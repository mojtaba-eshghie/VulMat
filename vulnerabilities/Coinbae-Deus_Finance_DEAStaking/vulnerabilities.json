{
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/exchange-libs/contracts/test/TestLibMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ROUNDING_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            numerator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            denominator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_15"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (TestLibMath.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (TestLibMath.sol#38-42)\n\t- TestLibMath.sol#39-41\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in TestLibMath.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- TestLibMath.sol#21 declares pragma solidity^0.5.9\n\t- TestLibMath.sol#47 declares pragma solidity^0.5.9\n\t- TestLibMath.sol#80 declares pragma solidity^0.5.9\n\t- TestLibMath.sol#145 declares pragma solidity^0.5.9\n\t- TestLibMath.sol#205 declares pragma solidity^0.5.9\n\t- TestLibMath.sol#433 declares pragma solidity^0.5.9\n\t- TestLibMath.sol#434 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 444,
                    "vulnerability_to_line": 454,
                    "vulnerability_code": "    function safeGetPartialAmountFloor(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        public\n\n        pure\n\n        returns (uint256 partialAmount)\n\n    {\n\n        return LibMath.safeGetPartialAmountFloor(numerator, denominator, target);\n",
                    "message": "TestLibMath.safeGetPartialAmountFloor (TestLibMath.sol#444-454) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": 472,
                    "vulnerability_code": "    function safeGetPartialAmountCeil(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        public\n\n        pure\n\n        returns (uint256 partialAmount)\n\n    {\n\n        return LibMath.safeGetPartialAmountCeil(numerator, denominator, target);\n",
                    "message": "TestLibMath.safeGetPartialAmountCeil (TestLibMath.sol#462-472) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 479,
                    "vulnerability_to_line": 489,
                    "vulnerability_code": "    function getPartialAmountFloor(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        public\n\n        pure\n\n        returns (uint256 partialAmount)\n\n    {\n\n        return LibMath.getPartialAmountFloor(numerator, denominator, target);\n",
                    "message": "TestLibMath.getPartialAmountFloor (TestLibMath.sol#479-489) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": 506,
                    "vulnerability_code": "    function getPartialAmountCeil(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        public\n\n        pure\n\n        returns (uint256 partialAmount)\n\n    {\n\n        return LibMath.getPartialAmountCeil(numerator, denominator, target);\n",
                    "message": "TestLibMath.getPartialAmountCeil (TestLibMath.sol#496-506) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 513,
                    "vulnerability_to_line": 523,
                    "vulnerability_code": "    function isRoundingErrorFloor(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        public\n\n        pure\n\n        returns (bool isError)\n\n    {\n\n        return LibMath.isRoundingErrorFloor(numerator, denominator, target);\n",
                    "message": "TestLibMath.isRoundingErrorFloor (TestLibMath.sol#513-523) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": 540,
                    "vulnerability_code": "    function isRoundingErrorCeil(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        public\n\n        pure\n\n        returns (bool isError)\n\n    {\n\n        return LibMath.isRoundingErrorCeil(numerator, denominator, target);\n",
                    "message": "TestLibMath.isRoundingErrorCeil (TestLibMath.sol#530-540) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestLibMath.sol:\n\t- pragma solidity^0.5.9 (TestLibMath.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibMath.sol#47): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibMath.sol#80): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibMath.sol#145): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibMath.sol#205): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibMath.sol#433): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (TestLibMath.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "    function Uint256BinOpError(BinOpErrorCodes errorCode, uint256 a, uint256 b) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (TestLibMath.sol#69-71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": 75,
                    "vulnerability_code": "    function Uint256DowncastError(DowncastErrorCodes errorCode, uint256 a) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (TestLibMath.sol#73-75) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": 165,
                    "vulnerability_code": "    function DivisionByZeroError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return DIVISION_BY_ZERO_ERROR;\n",
                    "message": "Function 'LibMathRichErrors.DivisionByZeroError' (TestLibMath.sol#159-165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": 182,
                    "vulnerability_code": "    function RoundingError(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ROUNDING_ERROR_SELECTOR,\n\n            numerator,\n\n            denominator,\n\n            target\n\n        );\n",
                    "message": "Function 'LibMathRichErrors.RoundingError' (TestLibMath.sol#167-182) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x339f3de2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/exchange-libs/contracts/src/LibMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ROUNDING_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            numerator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            denominator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibMath.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibMath.sol#38-42)\n\t- LibMath.sol#39-41\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibMath.sol:\n\t- pragma solidity^0.5.9 (LibMath.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibMath.sol#47): it allows old versions\n\t- pragma solidity^0.5.9 (LibMath.sol#80): it allows old versions\n\t- pragma solidity^0.5.9 (LibMath.sol#145): it allows old versions\n\t- pragma solidity^0.5.9 (LibMath.sol#205): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibMath.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "    function Uint256BinOpError(BinOpErrorCodes errorCode, uint256 a, uint256 b) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (LibMath.sol#69-71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": 75,
                    "vulnerability_code": "    function Uint256DowncastError(DowncastErrorCodes errorCode, uint256 a) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (LibMath.sol#73-75) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": 165,
                    "vulnerability_code": "    function DivisionByZeroError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return DIVISION_BY_ZERO_ERROR;\n",
                    "message": "Function 'LibMathRichErrors.DivisionByZeroError' (LibMath.sol#159-165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": 182,
                    "vulnerability_code": "    function RoundingError(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ROUNDING_ERROR_SELECTOR,\n\n            numerator,\n\n            denominator,\n\n            target\n\n        );\n",
                    "message": "Function 'LibMathRichErrors.RoundingError' (LibMath.sol#167-182) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x339f3de2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/exchange-libs/contracts/src/LibMathRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ROUNDING_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            numerator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            denominator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibMathRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibMathRichErrors.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": 23,
                    "vulnerability_code": "    function DivisionByZeroError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return DIVISION_BY_ZERO_ERROR;\n",
                    "message": "Function 'LibMathRichErrors.DivisionByZeroError' (LibMathRichErrors.sol#17-23) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 40,
                    "vulnerability_code": "    function RoundingError(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ROUNDING_ERROR_SELECTOR,\n\n            numerator,\n\n            denominator,\n\n            target\n\n        );\n",
                    "message": "Function 'LibMathRichErrors.RoundingError' (LibMathRichErrors.sol#25-40) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x339f3de2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/exchange/contracts/src/interfaces/IAssetProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IAssetProxy.sol:\n\t- pragma solidity^0.5.9 (IAssetProxy.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/exchange/contracts/src/interfaces/IProtocolFees.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IProtocolFees.sol:\n\t- pragma solidity^0.5.9 (IProtocolFees.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/exchange/contracts/src/interfaces/ITransferSimulator.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in ITransferSimulator.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- ITransferSimulator.sol#21 declares pragma solidity^0.5.9\n\t- ITransferSimulator.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function simulateDispatchTransferFromCalls(\n\n        bytes[] memory assetData,\n\n        address[] memory fromAddresses,\n\n        address[] memory toAddresses,\n\n        uint256[] memory amounts\n\n    )\n",
                    "message": "ITransferSimulator.simulateDispatchTransferFromCalls (ITransferSimulator.sol#38-44) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in ITransferSimulator.sol:\n\t- pragma solidity^0.5.9 (ITransferSimulator.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/exchange/contracts/src/interfaces/IAssetProxyDispatcher.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IAssetProxyDispatcher.sol:\n\t- pragma solidity^0.5.9 (IAssetProxyDispatcher.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/coordinator/contracts/src/MixinSignatureValidator.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 615,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            signature.length > 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"LENGTH_GREATER_THAN_0_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 617,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 624,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            signatureTypeRaw < uint8(SignatureType.NSignatureTypes),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 625,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SIGNATURE_UNSUPPORTED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 636,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"SIGNATURE_ILLEGAL\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 643,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                signature.length == 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_0_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"SIGNATURE_INVALID\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 651,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                signature.length == 65,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 653,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_65_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 668,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 669,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                signature.length == 65,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 670,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_65_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 692,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        revert(\"SIGNATURE_UNSUPPORTED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_29"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 88,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (MixinSignatureValidator.sol#84-88) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (MixinSignatureValidator.sol#122-127) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (MixinSignatureValidator.sol#132-137) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (MixinSignatureValidator.sol#143-243) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (MixinSignatureValidator.sol#284-312) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (MixinSignatureValidator.sol#317-337) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (MixinSignatureValidator.sol#354-378) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": 422,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (MixinSignatureValidator.sol#384-422) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (MixinSignatureValidator.sol#428-447) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (MixinSignatureValidator.sol#453-471) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 516,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (MixinSignatureValidator.sol#494-516) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength (MixinSignatureValidator.sol#523-527) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 88,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (MixinSignatureValidator.sol#84-88)\n\t- MixinSignatureValidator.sol#85-87\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (MixinSignatureValidator.sol#122-127)\n\t- MixinSignatureValidator.sol#123-125\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (MixinSignatureValidator.sol#132-137)\n\t- MixinSignatureValidator.sol#133-135\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (MixinSignatureValidator.sol#143-243)\n\t- MixinSignatureValidator.sol#148-153\n\t- MixinSignatureValidator.sol#176-206\n\t- MixinSignatureValidator.sol#208-240\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (MixinSignatureValidator.sol#284-312)\n\t- MixinSignatureValidator.sol#307-310\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (MixinSignatureValidator.sol#317-337)\n\t- MixinSignatureValidator.sol#331-335\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (MixinSignatureValidator.sol#354-378)\n\t- MixinSignatureValidator.sol#371-376\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": 422,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (MixinSignatureValidator.sol#384-422)\n\t- MixinSignatureValidator.sol#401-421\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (MixinSignatureValidator.sol#428-447)\n\t- MixinSignatureValidator.sol#443-445\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (MixinSignatureValidator.sol#453-471)\n\t- MixinSignatureValidator.sol#468-470\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 516,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (MixinSignatureValidator.sol#494-516)\n\t- MixinSignatureValidator.sol#509-514\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength uses assembly (MixinSignatureValidator.sol#523-527)\n\t- MixinSignatureValidator.sol#524-526\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": 575,
                    "vulnerability_code": "    function getSignerAddress(bytes32 hash, bytes memory signature)\n\n        public\n\n        pure\n",
                    "message": "ISignatureValidator.getSignerAddress (MixinSignatureValidator.sol#572-575) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 609,
                    "vulnerability_to_line": 693,
                    "vulnerability_code": "    function getSignerAddress(bytes32 hash, bytes memory signature)\n\n        public\n\n        pure\n\n        returns (address signerAddress)\n\n    {\n\n        require(\n\n            signature.length > 0,\n\n            \"LENGTH_GREATER_THAN_0_REQUIRED\"\n\n        );\n\n\n\n        // Pop last byte off of signature byte array.\n\n        uint8 signatureTypeRaw = uint8(signature.popLastByte());\n\n\n\n        // Ensure signature is supported\n\n        require(\n\n            signatureTypeRaw < uint8(SignatureType.NSignatureTypes),\n\n            \"SIGNATURE_UNSUPPORTED\"\n\n        );\n\n\n\n        SignatureType signatureType = SignatureType(signatureTypeRaw);\n\n\n\n        // Always illegal signature.\n\n        // This is always an implicit option since a signer can create a\n\n        // signature array with invalid type or length. We may as well make\n\n        // it an explicit option. This aids testing and analysis. It is\n\n        // also the initialization value for the enum type.\n\n        if (signatureType == SignatureType.Illegal) {\n\n            revert(\"SIGNATURE_ILLEGAL\");\n\n\n\n        // Always invalid signature.\n\n        // Like Illegal, this is always implicitly available and therefore\n\n        // offered explicitly. It can be implicitly created by providing\n\n        // a correctly formatted but incorrect signature.\n\n        } else if (signatureType == SignatureType.Invalid) {\n\n            require(\n\n                signature.length == 0,\n\n                \"LENGTH_0_REQUIRED\"\n\n            );\n\n            revert(\"SIGNATURE_INVALID\");\n\n\n\n        // Signature using EIP712\n\n        } else if (signatureType == SignatureType.EIP712) {\n\n            require(\n\n                signature.length == 65,\n\n                \"LENGTH_65_REQUIRED\"\n\n            );\n\n            uint8 v = uint8(signature[0]);\n\n            bytes32 r = signature.readBytes32(1);\n\n            bytes32 s = signature.readBytes32(33);\n\n            signerAddress = ecrecover(\n\n                hash,\n\n                v,\n\n                r,\n\n                s\n\n            );\n\n            return signerAddress;\n\n\n\n        // Signed using web3.eth_sign\n\n        } else if (signatureType == SignatureType.EthSign) {\n\n            require(\n\n                signature.length == 65,\n\n                \"LENGTH_65_REQUIRED\"\n\n            );\n\n            uint8 v = uint8(signature[0]);\n\n            bytes32 r = signature.readBytes32(1);\n\n            bytes32 s = signature.readBytes32(33);\n\n            signerAddress = ecrecover(\n\n                keccak256(abi.encodePacked(\n\n                    \"\\x19Ethereum Signed Message:\\n32\",\n\n                    hash\n\n                )),\n\n                v,\n\n                r,\n\n                s\n\n            );\n\n            return signerAddress;\n\n        }\n\n\n\n        // Anything else is illegal (We do not return false because\n\n        // the signature may actually be valid, just not in a format\n\n        // that we currently support. In this case returning false\n\n        // may lead the caller to incorrectly believe that the\n\n        // signature was invalid.)\n\n        revert(\"SIGNATURE_UNSUPPORTED\");\n",
                    "message": "MixinSignatureValidator.getSignerAddress (MixinSignatureValidator.sol#609-693) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MixinSignatureValidator.sol:\n\t- pragma solidity^0.5.9 (MixinSignatureValidator.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (MixinSignatureValidator.sol#67): it allows old versions\n\t- pragma solidity^0.5.9 (MixinSignatureValidator.sol#111): it allows old versions\n\t- pragma solidity^0.5.9 (MixinSignatureValidator.sol#550): it allows old versions\n\t- pragma solidity^0.5.9 (MixinSignatureValidator.sol#598): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    ) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (MixinSignatureValidator.sol#38-44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 80,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (MixinSignatureValidator.sol#78-80) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant INVALID_BYTE_OPERATION_ERROR_SELECTOR = 0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 635,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (signatureType == SignatureType.Illegal) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 642,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (signatureType == SignatureType.Invalid) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/coordinator/contracts/src/registry/CoordinatorRegistry.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        MixinCoordinatorRegistryCore()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {}\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in CoordinatorRegistry.sol:\n\t- pragma solidity^0.5.9 (CoordinatorRegistry.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (CoordinatorRegistry.sol#65): it allows old versions\n\t- pragma solidity^0.5.9 (CoordinatorRegistry.sol#113): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/coordinator/contracts/src/registry/MixinCoordinatorRegistryCore.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MixinCoordinatorRegistryCore.sol:\n\t- pragma solidity^0.5.9 (MixinCoordinatorRegistryCore.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (MixinCoordinatorRegistryCore.sol#65): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/coordinator/contracts/src/registry/interfaces/ICoordinatorRegistryCore.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in ICoordinatorRegistryCore.sol:\n\t- pragma solidity^0.5.9 (ICoordinatorRegistryCore.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/coordinator/contracts/src/interfaces/ISignatureValidator.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": 46,
                    "vulnerability_code": "    function getSignerAddress(bytes32 hash, bytes memory signature)\n\n        public\n\n        pure\n",
                    "message": "ISignatureValidator.getSignerAddress (ISignatureValidator.sol#43-46) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in ISignatureValidator.sol:\n\t- pragma solidity^0.5.9 (ISignatureValidator.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/erc20/contracts/src/WETH9.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(allowance[src][msg.sender] >= wad);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance[src][msg.sender] -= wad;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8  public decimals = 18;\n",
                    "message": "WETH9.decimals should be constant (WETH9.sol#25)\nWETH9.name should be constant (WETH9.sol#23)\nWETH9.symbol should be constant (WETH9.sol#24)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": 37,
                    "vulnerability_code": "    function() public payable {\n\n        deposit();\n",
                    "message": "WETH9.fallback (WETH9.sol#35-37) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function withdraw(uint wad) public {\n\n        require(balanceOf[msg.sender] >= wad);\n\n        balanceOf[msg.sender] -= wad;\n\n        msg.sender.transfer(wad);\n\n        Withdrawal(msg.sender, wad);\n",
                    "message": "WETH9.withdraw (WETH9.sol#42-47) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": 51,
                    "vulnerability_code": "    function totalSupply() public view returns (uint) {\n\n        return this.balance;\n",
                    "message": "WETH9.totalSupply (WETH9.sol#49-51) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": 57,
                    "vulnerability_code": "    function approve(address guy, uint wad) public returns (bool) {\n\n        allowance[msg.sender][guy] = wad;\n\n        Approval(msg.sender, guy, wad);\n\n        return true;\n",
                    "message": "WETH9.approve (WETH9.sol#53-57) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": 61,
                    "vulnerability_code": "    function transfer(address dst, uint wad) public returns (bool) {\n\n        return transferFrom(msg.sender, dst, wad);\n",
                    "message": "WETH9.transfer (WETH9.sol#59-61) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.18;\n",
                    "message": "Detected issues with version pragma in WETH9.sol:\n\t- pragma solidity^0.4.18 (WETH9.sol#19): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function() public payable {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/erc20/contracts/src/UnlimitedAllowanceERC20Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowed[_from][msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 285,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_18"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _totalSupply;\n",
                    "message": "ERC20Token._totalSupply (UnlimitedAllowanceERC20Token.sol#119) is never initialized. It is used in:\n\t- totalSupply (UnlimitedAllowanceERC20Token.sol#208-214)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 allowance = allowed[_from][msg.sender];\n",
                    "message": "UnlimitedAllowanceERC20Token.transferFrom.allowance (local variable @ UnlimitedAllowanceERC20Token.sol#279) shadows:\n\t- ERC20Token.allowance (function @ UnlimitedAllowanceERC20Token.sol#230-236)\n\t- IERC20Token.allowance (function @ UnlimitedAllowanceERC20Token.sol#85-88)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _totalSupply;\n",
                    "message": "ERC20Token._totalSupply should be constant (UnlimitedAllowanceERC20Token.sol#119)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in UnlimitedAllowanceERC20Token.sol:\n\t- pragma solidity^0.5.9 (UnlimitedAllowanceERC20Token.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (UnlimitedAllowanceERC20Token.sol#111): it allows old versions\n\t- pragma solidity^0.5.9 (UnlimitedAllowanceERC20Token.sol#259): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of ERC20Token.transfer (UnlimitedAllowanceERC20Token.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.transfer (UnlimitedAllowanceERC20Token.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of ERC20Token.transferFrom (UnlimitedAllowanceERC20Token.sol#156) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of ERC20Token.transferFrom (UnlimitedAllowanceERC20Token.sol#157) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _value\n",
                    "message": "Parameter '_value' of ERC20Token.transferFrom (UnlimitedAllowanceERC20Token.sol#158) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_spender' of ERC20Token.approve (UnlimitedAllowanceERC20Token.sol#193) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.approve (UnlimitedAllowanceERC20Token.sol#193) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner)\n",
                    "message": "Parameter '_owner' of ERC20Token.balanceOf (UnlimitedAllowanceERC20Token.sol#219) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_owner' of ERC20Token.allowance (UnlimitedAllowanceERC20Token.sol#230) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_spender' of ERC20Token.allowance (UnlimitedAllowanceERC20Token.sol#230) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _totalSupply;\n",
                    "message": "Variable 'ERC20Token._totalSupply' (UnlimitedAllowanceERC20Token.sol#119) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of UnlimitedAllowanceERC20Token.transferFrom (UnlimitedAllowanceERC20Token.sol#272) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of UnlimitedAllowanceERC20Token.transferFrom (UnlimitedAllowanceERC20Token.sol#273) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _value\n",
                    "message": "Parameter '_value' of UnlimitedAllowanceERC20Token.transferFrom (UnlimitedAllowanceERC20Token.sol#274) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/erc20/contracts/src/ERC20Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowed[_from][msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_14"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _totalSupply;\n",
                    "message": "ERC20Token._totalSupply (ERC20Token.sol#119) is never initialized. It is used in:\n\t- totalSupply (ERC20Token.sol#208-214)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _totalSupply;\n",
                    "message": "ERC20Token._totalSupply should be constant (ERC20Token.sol#119)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in ERC20Token.sol:\n\t- pragma solidity^0.5.9 (ERC20Token.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (ERC20Token.sol#111): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of ERC20Token.transfer (ERC20Token.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.transfer (ERC20Token.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of ERC20Token.transferFrom (ERC20Token.sol#156) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of ERC20Token.transferFrom (ERC20Token.sol#157) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _value\n",
                    "message": "Parameter '_value' of ERC20Token.transferFrom (ERC20Token.sol#158) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_spender' of ERC20Token.approve (ERC20Token.sol#193) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.approve (ERC20Token.sol#193) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner)\n",
                    "message": "Parameter '_owner' of ERC20Token.balanceOf (ERC20Token.sol#219) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_owner' of ERC20Token.allowance (ERC20Token.sol#230) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_spender' of ERC20Token.allowance (ERC20Token.sol#230) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _totalSupply;\n",
                    "message": "Variable 'ERC20Token._totalSupply' (ERC20Token.sol#119) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/erc20/contracts/src/ZRXToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[msg.sender] -= _value;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] += _value;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            Transfer(msg.sender, _to, _value);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else { return false; }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] += _value;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] -= _value;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowed[_from][msg.sender] -= _value;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            Transfer(_from, _to, _value);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else { return false; }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (balances[_from] >= _value\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && allowance >= _value\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && balances[_to] + _value >= balances[_to]\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] += _value;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] -= _value;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (allowance < MAX_UINT) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                allowed[_from][msg.sender] -= _value;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            Transfer(_from, _to, _value);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint _value) returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint) balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint)) allowed;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant MAX_UINT = 2**256 - 1;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/erc20/contracts/src/interfaces/IERC20Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IERC20Token.sol:\n\t- pragma solidity^0.5.9 (IERC20Token.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/erc20/contracts/src/interfaces/IEtherToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function deposit()\n\n        public\n",
                    "message": "IEtherToken.deposit (IEtherToken.sol#116-118) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": 121,
                    "vulnerability_code": "    function withdraw(uint256 amount)\n",
                    "message": "IEtherToken.withdraw (IEtherToken.sol#120-121) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IEtherToken.sol:\n\t- pragma solidity^0.5.9 (IEtherToken.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (IEtherToken.sol#111): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract IEtherToken is\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/multisig/contracts/test/TestRejectEther.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/multisig/contracts/test/TestAssetProxyOwner.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _assetProxyContracts.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        transactionCount += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] _owners,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _required,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _secondsTimeLocked\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 465,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 466,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        MultiSigWallet(_owners, _required)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        secondsTimeLocked = _secondsTimeLocked;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _owners,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _assetProxyContracts,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _required,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _secondsTimeLocked\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        MultiSigWalletWithTimeLock(_owners, _required, _secondsTimeLocked)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _assetProxyContracts.length; i++) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _owners,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _assetProxyContracts,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _required,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _secondsTimeLocked\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        AssetProxyOwner(_owners, _assetProxyContracts, _required, _secondsTimeLocked)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != 0);\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isOwner[_owners[i]] = true;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]])\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]])\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (count == required)\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isAssetProxyRegistered[assetProxy] = true;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _assetProxyContracts.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !isConfirmed(transactionId),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_FULLY_CONFIRMED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 436,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isConfirmed(transactionId),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_NOT_FULLY_CONFIRMED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 449,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            block.timestamp >= confirmationTimes[transactionId] + secondsTimeLocked,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TIME_LOCK_INCOMPLETE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1093,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1094,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isAssetProxyRegistered[txn.destination],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UNREGISTERED_ASSET_PROXY\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1096,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1097,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1098,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            txn.data.readBytes4(0) == REMOVE_AUTHORIZED_ADDRESS_AT_INDEX_SELECTOR,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1099,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_FUNCTION_SELECTOR\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assetProxy != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"INVALID_ASSET_PROXY\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(ownerCount <= MAX_OWNER_COUNT\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required <= ownerCount\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required != 0\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && ownerCount != 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (   pending && !transactions[i].executed\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                || executed && transactions[i].executed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (   pending && !transactions[i].executed\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                || executed && transactions[i].executed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                transactionIdsTemp[count] = i;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length - 1; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<transactionCount; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<count; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<transactionCount; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 392,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=from; i<to; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _assetProxyContracts.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 559,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant INVALID_BYTE_OPERATION_ERROR_SELECTOR = 0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owners.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isConfirmed(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getOwners()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmations(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length - 1; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<transactionCount; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<transactionCount; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _assetProxyContracts.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _assetProxyContracts.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract MultiSigWallet {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 4,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 544,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 590,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 634,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 655,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 807,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 877,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 907,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 951,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 976,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1017,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1046,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function submitTransaction(address destination, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _externalCall(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addTransaction(address destination, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address[])\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address[] _confirmations)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint[] _transactionIds)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] _owners,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 699,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 731,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 830,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 924,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 966,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 991,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1032,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1047,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function()\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/multisig/contracts/src/MultiSigWallet.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        transactionCount += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != 0);\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isOwner[_owners[i]] = true;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]])\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]])\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (count == required)\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(ownerCount <= MAX_OWNER_COUNT\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required <= ownerCount\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required != 0\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && ownerCount != 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (   pending && !transactions[i].executed\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                || executed && transactions[i].executed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (   pending && !transactions[i].executed\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                || executed && transactions[i].executed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                transactionIdsTemp[count] = i;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length - 1; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<transactionCount; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<count; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<transactionCount; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 392,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=from; i<to; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_20"
            ],
            "vulnerability_findings": [
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": 103,
                    "vulnerability_code": "    function()\n\n        payable\n\n    {\n\n        if (msg.value > 0)\n\n            Deposit(msg.sender, msg.value);\n",
                    "message": "Contract locking ether found in MultiSigWallet.sol:\n\tContract MultiSigWallet has payable functions:\n\t - fallback (MultiSigWallet.sol#98-103)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": 265,
                    "vulnerability_code": "    function _externalCall(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n\n        bool result;\n\n        assembly {\n\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n\n            result := call(\n\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\n\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n\n                destination,\n\n                value,\n\n                d,\n\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n\n                x,\n\n                0                  // Output is ignored, therefore the output size is zero\n\n            )\n\n        }\n\n        return result;\n",
                    "message": "MultiSigWallet._externalCall uses assembly (MultiSigWallet.sol#247-265)\n\t- MultiSigWallet.sol#249-264\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": 103,
                    "vulnerability_code": "    function()\n\n        payable\n\n    {\n\n        if (msg.value > 0)\n\n            Deposit(msg.sender, msg.value);\n",
                    "message": "MultiSigWallet.fallback (MultiSigWallet.sol#98-103) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": 135,
                    "vulnerability_code": "    function addOwner(address owner)\n\n        public\n\n        onlyWallet\n\n        ownerDoesNotExist(owner)\n\n        notNull(owner)\n\n        validRequirement(owners.length + 1, required)\n\n    {\n\n        isOwner[owner] = true;\n\n        owners.push(owner);\n\n        OwnerAddition(owner);\n",
                    "message": "MultiSigWallet.addOwner (MultiSigWallet.sol#125-135) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": 154,
                    "vulnerability_code": "    function removeOwner(address owner)\n\n        public\n\n        onlyWallet\n\n        ownerExists(owner)\n\n    {\n\n        isOwner[owner] = false;\n\n        for (uint i=0; i<owners.length - 1; i++)\n\n            if (owners[i] == owner) {\n\n                owners[i] = owners[owners.length - 1];\n\n                break;\n\n            }\n\n        owners.length -= 1;\n\n        if (required > owners.length)\n\n            changeRequirement(owners.length);\n\n        OwnerRemoval(owner);\n",
                    "message": "MultiSigWallet.removeOwner (MultiSigWallet.sol#139-154) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": 174,
                    "vulnerability_code": "    function replaceOwner(address owner, address newOwner)\n\n        public\n\n        onlyWallet\n\n        ownerExists(owner)\n\n        ownerDoesNotExist(newOwner)\n\n    {\n\n        for (uint i=0; i<owners.length; i++)\n\n            if (owners[i] == owner) {\n\n                owners[i] = newOwner;\n\n                break;\n\n            }\n\n        isOwner[owner] = false;\n\n        isOwner[newOwner] = true;\n\n        OwnerRemoval(owner);\n\n        OwnerAddition(newOwner);\n",
                    "message": "MultiSigWallet.replaceOwner (MultiSigWallet.sol#159-174) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": 198,
                    "vulnerability_code": "    function submitTransaction(address destination, uint value, bytes data)\n\n        public\n\n        returns (uint transactionId)\n\n    {\n\n        transactionId = _addTransaction(destination, value, data);\n\n        confirmTransaction(transactionId);\n",
                    "message": "MultiSigWallet.submitTransaction (MultiSigWallet.sol#192-198) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": 223,
                    "vulnerability_code": "    function revokeConfirmation(uint transactionId)\n\n        public\n\n        ownerExists(msg.sender)\n\n        confirmed(transactionId, msg.sender)\n\n        notExecuted(transactionId)\n\n    {\n\n        confirmations[transactionId][msg.sender] = false;\n\n        Revocation(msg.sender, transactionId);\n",
                    "message": "MultiSigWallet.revokeConfirmation (MultiSigWallet.sol#215-223) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": 322,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n\n        public\n\n        constant\n\n        returns (uint count)\n\n    {\n\n        for (uint i=0; i<owners.length; i++)\n\n            if (confirmations[transactionId][owners[i]])\n\n                count += 1;\n",
                    "message": "MultiSigWallet.getConfirmationCount (MultiSigWallet.sol#314-322) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n\n        public\n\n        constant\n\n        returns (uint count)\n\n    {\n\n        for (uint i=0; i<transactionCount; i++)\n\n            if (   pending && !transactions[i].executed\n\n                || executed && transactions[i].executed)\n\n                count += 1;\n",
                    "message": "MultiSigWallet.getTransactionCount (MultiSigWallet.sol#328-337) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": 347,
                    "vulnerability_code": "    function getOwners()\n\n        public\n\n        constant\n\n        returns (address[])\n\n    {\n\n        return owners;\n",
                    "message": "MultiSigWallet.getOwners (MultiSigWallet.sol#341-347) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": 368,
                    "vulnerability_code": "    function getConfirmations(uint transactionId)\n\n        public\n\n        constant\n\n        returns (address[] _confirmations)\n\n    {\n\n        address[] memory confirmationsTemp = new address[](owners.length);\n\n        uint count = 0;\n\n        uint i;\n\n        for (i=0; i<owners.length; i++)\n\n            if (confirmations[transactionId][owners[i]]) {\n\n                confirmationsTemp[count] = owners[i];\n\n                count += 1;\n\n            }\n\n        _confirmations = new address[](count);\n\n        for (i=0; i<count; i++)\n\n            _confirmations[i] = confirmationsTemp[i];\n",
                    "message": "MultiSigWallet.getConfirmations (MultiSigWallet.sol#352-368) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": 394,
                    "vulnerability_code": "    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n\n        public\n\n        constant\n\n        returns (uint[] _transactionIds)\n\n    {\n\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n\n        uint count = 0;\n\n        uint i;\n\n        for (i=0; i<transactionCount; i++)\n\n            if (   pending && !transactions[i].executed\n\n                || executed && transactions[i].executed)\n\n            {\n\n                transactionIdsTemp[count] = i;\n\n                count += 1;\n\n            }\n\n        _transactionIds = new uint[](to - from);\n\n        for (i=from; i<to; i++)\n\n            _transactionIds[i - from] = transactionIdsTemp[i];\n",
                    "message": "MultiSigWallet.getTransactionIds (MultiSigWallet.sol#376-394) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 4,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": "Detected issues with version pragma in MultiSigWallet.sol:\n\t- pragma solidity^0.4.15 (MultiSigWallet.sol#4): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": 121,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n\n        public\n\n        validRequirement(_owners.length, _required)\n\n    {\n\n        for (uint i=0; i<_owners.length; i++) {\n\n            require(!isOwner[_owners[i]] && _owners[i] != 0);\n\n            isOwner[_owners[i]] = true;\n\n        }\n\n        owners = _owners;\n\n        required = _required;\n",
                    "message": "Function 'MultiSigWallet.MultiSigWallet' (MultiSigWallet.sol#111-121) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n",
                    "message": "Parameter '_owners' of MultiSigWallet.MultiSigWallet (MultiSigWallet.sol#111) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n",
                    "message": "Parameter '_required' of MultiSigWallet.MultiSigWallet (MultiSigWallet.sol#111) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function changeRequirement(uint _required)\n",
                    "message": "Parameter '_required' of MultiSigWallet.changeRequirement (MultiSigWallet.sol#178) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": 265,
                    "vulnerability_code": "    function _externalCall(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n\n        bool result;\n\n        assembly {\n\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n\n            result := call(\n\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\n\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n\n                destination,\n\n                value,\n\n                d,\n\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n\n                x,\n\n                0                  // Output is ignored, therefore the output size is zero\n\n            )\n\n        }\n\n        return result;\n",
                    "message": "Function 'MultiSigWallet._externalCall' (MultiSigWallet.sol#247-265) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": 306,
                    "vulnerability_code": "    function _addTransaction(address destination, uint value, bytes data)\n\n        internal\n\n        notNull(destination)\n\n        returns (uint transactionId)\n\n    {\n\n        transactionId = transactionCount;\n\n        transactions[transactionId] = Transaction({\n\n            destination: destination,\n\n            value: value,\n\n            data: data,\n\n            executed: false\n\n        });\n\n        transactionCount += 1;\n\n        Submission(transactionId);\n",
                    "message": "Function 'MultiSigWallet._addTransaction' (MultiSigWallet.sol#292-306) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owners.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isConfirmed(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getOwners()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmations(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length - 1; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<transactionCount; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<transactionCount; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract MultiSigWallet {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 4,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function submitTransaction(address destination, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _externalCall(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addTransaction(address destination, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address[])\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address[] _confirmations)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint[] _transactionIds)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function()\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/multisig/contracts/src/AssetProxyOwner.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _assetProxyContracts.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        transactionCount += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] _owners,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _required,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _secondsTimeLocked\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 465,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 466,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        MultiSigWallet(_owners, _required)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        secondsTimeLocked = _secondsTimeLocked;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _owners,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _assetProxyContracts,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _required,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _secondsTimeLocked\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        MultiSigWalletWithTimeLock(_owners, _required, _secondsTimeLocked)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _assetProxyContracts.length; i++) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != 0);\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isOwner[_owners[i]] = true;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]])\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]])\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (count == required)\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isAssetProxyRegistered[assetProxy] = true;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _assetProxyContracts.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !isConfirmed(transactionId),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_FULLY_CONFIRMED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 436,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isConfirmed(transactionId),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_NOT_FULLY_CONFIRMED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 449,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            block.timestamp >= confirmationTimes[transactionId] + secondsTimeLocked,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TIME_LOCK_INCOMPLETE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1093,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1094,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isAssetProxyRegistered[txn.destination],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UNREGISTERED_ASSET_PROXY\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1096,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1097,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1098,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            txn.data.readBytes4(0) == REMOVE_AUTHORIZED_ADDRESS_AT_INDEX_SELECTOR,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1099,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_FUNCTION_SELECTOR\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assetProxy != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"INVALID_ASSET_PROXY\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(ownerCount <= MAX_OWNER_COUNT\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required <= ownerCount\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required != 0\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && ownerCount != 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (   pending && !transactions[i].executed\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                || executed && transactions[i].executed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (   pending && !transactions[i].executed\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                || executed && transactions[i].executed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                transactionIdsTemp[count] = i;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length - 1; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<transactionCount; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<count; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<transactionCount; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 392,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=from; i<to; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _assetProxyContracts.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 559,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant INVALID_BYTE_OPERATION_ERROR_SELECTOR = 0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owners.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isConfirmed(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getOwners()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmations(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length - 1; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<transactionCount; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<transactionCount; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _assetProxyContracts.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _assetProxyContracts.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract MultiSigWallet {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 4,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 544,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 590,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 634,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 655,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 807,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 877,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 907,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 951,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 976,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1017,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1046,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function submitTransaction(address destination, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _externalCall(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addTransaction(address destination, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address[])\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address[] _confirmations)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint[] _transactionIds)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] _owners,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 699,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 731,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 830,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 924,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 966,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 991,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1032,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1047,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function()\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/multisig/contracts/src/MultiSigWalletWithTimeLock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        transactionCount += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] _owners,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _required,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _secondsTimeLocked\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 465,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 466,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        MultiSigWallet(_owners, _required)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        secondsTimeLocked = _secondsTimeLocked;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != 0);\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isOwner[_owners[i]] = true;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]])\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]])\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (count == required)\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !isConfirmed(transactionId),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_FULLY_CONFIRMED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 436,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isConfirmed(transactionId),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_NOT_FULLY_CONFIRMED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 449,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            block.timestamp >= confirmationTimes[transactionId] + secondsTimeLocked,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TIME_LOCK_INCOMPLETE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(ownerCount <= MAX_OWNER_COUNT\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required <= ownerCount\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required != 0\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && ownerCount != 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (   pending && !transactions[i].executed\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                || executed && transactions[i].executed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (   pending && !transactions[i].executed\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                || executed && transactions[i].executed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                transactionIdsTemp[count] = i;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length - 1; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<transactionCount; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<count; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<transactionCount; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 392,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=from; i<to; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owners.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isConfirmed(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getOwners()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmations(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length - 1; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<transactionCount; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<transactionCount; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract MultiSigWallet {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 4,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function submitTransaction(address destination, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _externalCall(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addTransaction(address destination, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address[])\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address[] _confirmations)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint[] _transactionIds)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] _owners,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function()\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/test/TestLibAddressArray.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MISMANAGED_MEMORY_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            freeMemPtr,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            addressArrayEndPtr\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            required\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_45"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 164,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (TestLibAddressArray.sol#157-164) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (TestLibAddressArray.sol#199-208) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": 222,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (TestLibAddressArray.sol#213-222) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": 329,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (TestLibAddressArray.sol#228-329) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": 410,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (TestLibAddressArray.sol#378-410) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": 437,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (TestLibAddressArray.sol#415-437) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": 464,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes (TestLibAddressArray.sol#442-464) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (TestLibAddressArray.sol#488-517) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 566,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (TestLibAddressArray.sol#523-566) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": 596,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (TestLibAddressArray.sol#572-596) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": 625,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (TestLibAddressArray.sol#602-625) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": 689,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (TestLibAddressArray.sol#662-689) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 697,
                    "vulnerability_to_line": 725,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        if (b.length < index + nestedBytesLength) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors\n\n                    .InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsNestedBytesLengthRequired,\n\n                b.length,\n\n                index + nestedBytesLength\n\n            ));\n\n        }\n\n\n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength (TestLibAddressArray.sol#697-725) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 790,
                    "vulnerability_to_line": 797,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength (TestLibAddressArray.sol#790-797) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 833,
                    "vulnerability_to_line": 887,
                    "vulnerability_code": "    function append(address[] memory addressArray, address addressToAppend)\n\n        internal\n\n        pure\n\n        returns (address[] memory)\n\n    {\n\n        // Get stats on address array and free memory\n\n        uint256 freeMemPtr = 0;\n\n        uint256 addressArrayBeginPtr = 0;\n\n        uint256 addressArrayEndPtr = 0;\n\n        uint256 addressArrayLength = addressArray.length;\n\n        uint256 addressArrayMemSizeInBytes = 32 + (32 * addressArrayLength);\n\n        assembly {\n\n            freeMemPtr := mload(0x40)\n\n            addressArrayBeginPtr := addressArray\n\n            addressArrayEndPtr := add(addressArray, addressArrayMemSizeInBytes)\n\n        }\n\n\n\n        // Cases for `freeMemPtr`:\n\n        //  `freeMemPtr` == `addressArrayEndPtr`: Nothing occupies memory after `addressArray`\n\n        //  `freeMemPtr` > `addressArrayEndPtr`: Some value occupies memory after `addressArray`\n\n        //  `freeMemPtr` < `addressArrayEndPtr`: Memory has not been managed properly.\n\n        if (freeMemPtr < addressArrayEndPtr) {\n\n            LibRichErrors.rrevert(LibAddressArrayRichErrors.MismanagedMemoryError(\n\n                freeMemPtr,\n\n                addressArrayEndPtr\n\n            ));\n\n        }\n\n\n\n        // If free memory begins at the end of `addressArray`\n\n        // then we can append `addressToAppend` directly.\n\n        // Otherwise, we must copy the array to free memory\n\n        // before appending new values to it.\n\n        if (freeMemPtr > addressArrayEndPtr) {\n\n            LibBytes.memCopy(freeMemPtr, addressArrayBeginPtr, addressArrayMemSizeInBytes);\n\n            assembly {\n\n                addressArray := freeMemPtr\n\n                addressArrayBeginPtr := addressArray\n\n            }\n\n        }\n\n\n\n        // Append `addressToAppend`\n\n        addressArrayLength += 1;\n\n        addressArrayMemSizeInBytes += 32;\n\n        addressArrayEndPtr = addressArrayBeginPtr + addressArrayMemSizeInBytes;\n\n        freeMemPtr = addressArrayEndPtr;\n\n        assembly {\n\n            // Store new array length\n\n            mstore(addressArray, addressArrayLength)\n\n\n\n            // Update `freeMemPtr`\n\n            mstore(0x40, freeMemPtr)\n\n        }\n\n        addressArray[addressArrayLength - 1] = addressToAppend;\n\n        return addressArray;\n",
                    "message": "LibAddressArray.append (TestLibAddressArray.sol#833-887) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 893,
                    "vulnerability_to_line": 923,
                    "vulnerability_code": "    function contains(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success to true\n\n                    success := 1\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return success;\n",
                    "message": "LibAddressArray.contains (TestLibAddressArray.sol#893-923) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": 960,
                    "vulnerability_code": "    function indexOf(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success, uint256 index)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success and index\n\n                    success := 1\n\n                    index := div(sub(i, arrayContentsStart), 32)\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return (success, index);\n",
                    "message": "LibAddressArray.indexOf (TestLibAddressArray.sol#929-960) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1014,
                    "vulnerability_to_line": 1041,
                    "vulnerability_code": "    function testAppendRealloc(\n\n        address[] memory addressArray,\n\n        int256 freeMemOffset,\n\n        address addressToAppend\n\n    )\n\n        public\n\n        pure\n\n        returns (\n\n            address[] memory result,\n\n            uint256 oldArrayMemStart,\n\n            uint256 newArrayMemStart\n\n        )\n\n    {\n\n        assembly {\n\n            // Remember the original memory address of the array.\n\n            oldArrayMemStart := addressArray\n\n            // Move the free memory pointer.\n\n            mstore(0x40, add(mload(0x40), freeMemOffset))\n\n        }\n\n\n\n        // Call append.\n\n        result = addressArray.append(addressToAppend);\n\n\n\n        // Get the new array memory address.\n\n        assembly {\n\n            newArrayMemStart := result\n\n        }\n",
                    "message": "TestLibAddressArray.testAppendRealloc (TestLibAddressArray.sol#1014-1041) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 164,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (TestLibAddressArray.sol#157-164)\n\t- TestLibAddressArray.sol#161-163\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (TestLibAddressArray.sol#199-208)\n\t- TestLibAddressArray.sol#204-206\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": 222,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (TestLibAddressArray.sol#213-222)\n\t- TestLibAddressArray.sol#218-220\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": 329,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (TestLibAddressArray.sol#228-329)\n\t- TestLibAddressArray.sol#240-245\n\t- TestLibAddressArray.sol#268-295\n\t- TestLibAddressArray.sol#297-326\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": 410,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (TestLibAddressArray.sol#378-410)\n\t- TestLibAddressArray.sol#405-408\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": 437,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (TestLibAddressArray.sol#415-437)\n\t- TestLibAddressArray.sol#431-435\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": 464,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes uses assembly (TestLibAddressArray.sol#442-464)\n\t- TestLibAddressArray.sol#458-462\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (TestLibAddressArray.sol#488-517)\n\t- TestLibAddressArray.sol#510-515\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 566,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (TestLibAddressArray.sol#523-566)\n\t- TestLibAddressArray.sol#545-565\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": 596,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (TestLibAddressArray.sol#572-596)\n\t- TestLibAddressArray.sol#592-594\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": 625,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (TestLibAddressArray.sol#602-625)\n\t- TestLibAddressArray.sol#622-624\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": 689,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (TestLibAddressArray.sol#662-689)\n\t- TestLibAddressArray.sol#682-687\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 697,
                    "vulnerability_to_line": 725,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        if (b.length < index + nestedBytesLength) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors\n\n                    .InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsNestedBytesLengthRequired,\n\n                b.length,\n\n                index + nestedBytesLength\n\n            ));\n\n        }\n\n\n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength uses assembly (TestLibAddressArray.sol#697-725)\n\t- TestLibAddressArray.sol#721-723\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 790,
                    "vulnerability_to_line": 797,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength uses assembly (TestLibAddressArray.sol#790-797)\n\t- TestLibAddressArray.sol#794-796\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 833,
                    "vulnerability_to_line": 887,
                    "vulnerability_code": "    function append(address[] memory addressArray, address addressToAppend)\n\n        internal\n\n        pure\n\n        returns (address[] memory)\n\n    {\n\n        // Get stats on address array and free memory\n\n        uint256 freeMemPtr = 0;\n\n        uint256 addressArrayBeginPtr = 0;\n\n        uint256 addressArrayEndPtr = 0;\n\n        uint256 addressArrayLength = addressArray.length;\n\n        uint256 addressArrayMemSizeInBytes = 32 + (32 * addressArrayLength);\n\n        assembly {\n\n            freeMemPtr := mload(0x40)\n\n            addressArrayBeginPtr := addressArray\n\n            addressArrayEndPtr := add(addressArray, addressArrayMemSizeInBytes)\n\n        }\n\n\n\n        // Cases for `freeMemPtr`:\n\n        //  `freeMemPtr` == `addressArrayEndPtr`: Nothing occupies memory after `addressArray`\n\n        //  `freeMemPtr` > `addressArrayEndPtr`: Some value occupies memory after `addressArray`\n\n        //  `freeMemPtr` < `addressArrayEndPtr`: Memory has not been managed properly.\n\n        if (freeMemPtr < addressArrayEndPtr) {\n\n            LibRichErrors.rrevert(LibAddressArrayRichErrors.MismanagedMemoryError(\n\n                freeMemPtr,\n\n                addressArrayEndPtr\n\n            ));\n\n        }\n\n\n\n        // If free memory begins at the end of `addressArray`\n\n        // then we can append `addressToAppend` directly.\n\n        // Otherwise, we must copy the array to free memory\n\n        // before appending new values to it.\n\n        if (freeMemPtr > addressArrayEndPtr) {\n\n            LibBytes.memCopy(freeMemPtr, addressArrayBeginPtr, addressArrayMemSizeInBytes);\n\n            assembly {\n\n                addressArray := freeMemPtr\n\n                addressArrayBeginPtr := addressArray\n\n            }\n\n        }\n\n\n\n        // Append `addressToAppend`\n\n        addressArrayLength += 1;\n\n        addressArrayMemSizeInBytes += 32;\n\n        addressArrayEndPtr = addressArrayBeginPtr + addressArrayMemSizeInBytes;\n\n        freeMemPtr = addressArrayEndPtr;\n\n        assembly {\n\n            // Store new array length\n\n            mstore(addressArray, addressArrayLength)\n\n\n\n            // Update `freeMemPtr`\n\n            mstore(0x40, freeMemPtr)\n\n        }\n\n        addressArray[addressArrayLength - 1] = addressToAppend;\n\n        return addressArray;\n",
                    "message": "LibAddressArray.append uses assembly (TestLibAddressArray.sol#833-887)\n\t- TestLibAddressArray.sol#844-848\n\t- TestLibAddressArray.sol#867-870\n\t- TestLibAddressArray.sol#878-884\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 893,
                    "vulnerability_to_line": 923,
                    "vulnerability_code": "    function contains(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success to true\n\n                    success := 1\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return success;\n",
                    "message": "LibAddressArray.contains uses assembly (TestLibAddressArray.sol#893-923)\n\t- TestLibAddressArray.sol#898-921\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": 960,
                    "vulnerability_code": "    function indexOf(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success, uint256 index)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success and index\n\n                    success := 1\n\n                    index := div(sub(i, arrayContentsStart), 32)\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return (success, index);\n",
                    "message": "LibAddressArray.indexOf uses assembly (TestLibAddressArray.sol#929-960)\n\t- TestLibAddressArray.sol#934-958\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1014,
                    "vulnerability_to_line": 1041,
                    "vulnerability_code": "    function testAppendRealloc(\n\n        address[] memory addressArray,\n\n        int256 freeMemOffset,\n\n        address addressToAppend\n\n    )\n\n        public\n\n        pure\n\n        returns (\n\n            address[] memory result,\n\n            uint256 oldArrayMemStart,\n\n            uint256 newArrayMemStart\n\n        )\n\n    {\n\n        assembly {\n\n            // Remember the original memory address of the array.\n\n            oldArrayMemStart := addressArray\n\n            // Move the free memory pointer.\n\n            mstore(0x40, add(mload(0x40), freeMemOffset))\n\n        }\n\n\n\n        // Call append.\n\n        result = addressArray.append(addressToAppend);\n\n\n\n        // Get the new array memory address.\n\n        assembly {\n\n            newArrayMemStart := result\n\n        }\n",
                    "message": "TestLibAddressArray.testAppendRealloc uses assembly (TestLibAddressArray.sol#1014-1041)\n\t- TestLibAddressArray.sol#1027-1032\n\t- TestLibAddressArray.sol#1038-1040\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in TestLibAddressArray.sol:\n\t- Version used: ['^0.5.5', '^0.5.9']\n\t- TestLibAddressArray.sol#21 declares pragma solidity^0.5.9\n\t- TestLibAddressArray.sol#67 declares pragma solidity^0.5.9\n\t- TestLibAddressArray.sol#126 declares pragma solidity^0.5.9\n\t- TestLibAddressArray.sol#187 declares pragma solidity^0.5.9\n\t- TestLibAddressArray.sol#820 declares pragma solidity^0.5.9\n\t- TestLibAddressArray.sol#983 declares pragma solidity^0.5.5\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 996,
                    "vulnerability_to_line": 1002,
                    "vulnerability_code": "    function publicAppend(address[] memory addressArray, address addressToAppend)\n\n        public\n\n        pure\n\n        returns (address[] memory)\n\n    {\n\n        return addressArray.append(addressToAppend);\n",
                    "message": "TestLibAddressArray.publicAppend (TestLibAddressArray.sol#996-1002) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1014,
                    "vulnerability_to_line": 1041,
                    "vulnerability_code": "    function testAppendRealloc(\n\n        address[] memory addressArray,\n\n        int256 freeMemOffset,\n\n        address addressToAppend\n\n    )\n\n        public\n\n        pure\n\n        returns (\n\n            address[] memory result,\n\n            uint256 oldArrayMemStart,\n\n            uint256 newArrayMemStart\n\n        )\n\n    {\n\n        assembly {\n\n            // Remember the original memory address of the array.\n\n            oldArrayMemStart := addressArray\n\n            // Move the free memory pointer.\n\n            mstore(0x40, add(mload(0x40), freeMemOffset))\n\n        }\n\n\n\n        // Call append.\n\n        result = addressArray.append(addressToAppend);\n\n\n\n        // Get the new array memory address.\n\n        assembly {\n\n            newArrayMemStart := result\n\n        }\n",
                    "message": "TestLibAddressArray.testAppendRealloc (TestLibAddressArray.sol#1014-1041) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1047,
                    "vulnerability_to_line": 1053,
                    "vulnerability_code": "    function publicContains(address[] memory addressArray, address target)\n\n        public\n\n        pure\n\n        returns (bool success)\n\n    {\n\n        return addressArray.contains(target);\n",
                    "message": "TestLibAddressArray.publicContains (TestLibAddressArray.sol#1047-1053) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": 1065,
                    "vulnerability_code": "    function publicIndexOf(address[] memory addressArray, address target)\n\n        public\n\n        pure\n\n        returns (bool success, uint256 index)\n\n    {\n\n        (success, index) = addressArray.indexOf(target);\n",
                    "message": "TestLibAddressArray.publicIndexOf (TestLibAddressArray.sol#1059-1065) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestLibAddressArray.sol:\n\t- pragma solidity^0.5.9 (TestLibAddressArray.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibAddressArray.sol#67): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibAddressArray.sol#126): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibAddressArray.sol#187): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibAddressArray.sol#820): it allows old versions\n\t- pragma solidity^0.5.5 (TestLibAddressArray.sol#983): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function MismanagedMemoryError(\n\n        uint256 freeMemPtr,\n\n        uint256 addressArrayEndPtr\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            MISMANAGED_MEMORY_ERROR_SELECTOR,\n\n            freeMemPtr,\n\n            addressArrayEndPtr\n\n        );\n",
                    "message": "Function 'LibAddressArrayRichErrors.MismanagedMemoryError' (TestLibAddressArray.sol#31-44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": 103,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n\n            errorCode,\n\n            offset,\n\n            required\n\n        );\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (TestLibAddressArray.sol#88-103) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (TestLibAddressArray.sol#141-152) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x5fc83722;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1014,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function testAppendRealloc(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 983,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 697,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytesWithLength(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 790,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 833,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function append(address[] memory addressArray, address addressToAppend)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 893,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contains(address[] memory addressArray, address target)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function indexOf(address[] memory addressArray, address target)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1014,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function testAppendRealloc(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 932,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bool success, uint256 index)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1021,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1062,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bool success, uint256 index)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 405,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 592,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 622,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 682,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 721,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 794,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 867,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 878,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 898,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1027,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1038,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/test/TestLibRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (TestLibRichErrors.sol#52-59) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (TestLibRichErrors.sol#52-59)\n\t- TestLibRichErrors.sol#56-58\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestLibRichErrors.sol:\n\t- pragma solidity^0.5.9 (TestLibRichErrors.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibRichErrors.sol#82): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (TestLibRichErrors.sol#36-47) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/test/TestRefundable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_10"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function _refundNonZeroBalance()\n\n        internal\n\n    {\n\n        uint256 balance = address(this).balance;\n\n        if (balance > 0) {\n\n            msg.sender.transfer(balance);\n\n        }\n",
                    "message": "Refundable._refundNonZeroBalance (TestRefundable.sol#52-59) sends eth to arbitrary user\n\tDangerous calls:\n\t- msg.sender.transfer(balance) (TestRefundable.sol#57)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": 149,
                    "vulnerability_code": "    function nestedDisableRefundUntilEndFunction()\n\n        public\n\n        payable\n\n        disableRefundUntilEnd\n\n        returns (uint256)\n\n    {\n\n        disableRefundUntilEndFunction();\n\n        return address(this).balance;\n",
                    "message": "TestRefundable.nestedDisableRefundUntilEndFunction (TestRefundable.sol#141-149) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": 159,
                    "vulnerability_code": "    function mixedRefundModifierFunction()\n\n        public\n\n        payable\n\n        disableRefundUntilEnd\n\n        returns (uint256)\n\n    {\n\n        refundFinalBalanceFunction();\n\n        return address(this).balance;\n",
                    "message": "TestRefundable.mixedRefundModifierFunction (TestRefundable.sol#151-159) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestRefundable.sol:\n\t- pragma solidity^0.5.9 (TestRefundable.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestRefundable.sol#103): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": 50,
                    "vulnerability_code": "    function _refundNonZeroBalanceIfEnabled()\n\n        internal\n\n    {\n\n        if (!_areRefundsDisabled()) {\n\n            _refundNonZeroBalance();\n\n        }\n",
                    "message": "Function 'Refundable._refundNonZeroBalanceIfEnabled' (TestRefundable.sol#44-50) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function _refundNonZeroBalance()\n\n        internal\n\n    {\n\n        uint256 balance = address(this).balance;\n\n        if (balance > 0) {\n\n            msg.sender.transfer(balance);\n\n        }\n",
                    "message": "Function 'Refundable._refundNonZeroBalance' (TestRefundable.sol#52-59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": 65,
                    "vulnerability_code": "    function _disableRefund()\n\n        internal\n\n    {\n\n        _shouldNotRefund = true;\n",
                    "message": "Function 'Refundable._disableRefund' (TestRefundable.sol#61-65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function _enableAndRefundNonZeroBalance()\n\n        internal\n\n    {\n\n        _shouldNotRefund = false;\n\n        _refundNonZeroBalance();\n",
                    "message": "Function 'Refundable._enableAndRefundNonZeroBalance' (TestRefundable.sol#67-72) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 80,
                    "vulnerability_code": "    function _areRefundsDisabled()\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        return _shouldNotRefund;\n",
                    "message": "Function 'Refundable._areRefundsDisabled' (TestRefundable.sol#74-80) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool internal _shouldNotRefund;\n",
                    "message": "Variable 'Refundable._shouldNotRefund' (TestRefundable.sol#27) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract TestRefundable is\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/test/TestSafeMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT96_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT64_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_DOWNCAST_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_14"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (TestSafeMath.sol#52-59) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (TestSafeMath.sol#52-59)\n\t- TestSafeMath.sol#56-58\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestSafeMath.sol:\n\t- pragma solidity^0.5.9 (TestSafeMath.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestSafeMath.sol#64): it allows old versions\n\t- pragma solidity^0.5.9 (TestSafeMath.sol#167): it allows old versions\n\t- pragma solidity^0.5.9 (TestSafeMath.sol#275): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (TestSafeMath.sol#36-47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": 113,
                    "vulnerability_code": "    function Uint256BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint256 a,\n\n        uint256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (TestSafeMath.sol#98-113) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": 130,
                    "vulnerability_code": "    function Uint96BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint96 a,\n\n        uint96 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT96_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint96BinOpError' (TestSafeMath.sol#115-130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 147,
                    "vulnerability_code": "    function Uint64BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint64 a,\n\n        uint64 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT64_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint64BinOpError' (TestSafeMath.sol#132-147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": 162,
                    "vulnerability_code": "    function Uint256DowncastError(\n\n        DowncastErrorCodes errorCode,\n\n        uint256 a\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_DOWNCAST_ERROR_SELECTOR,\n\n            errorCode,\n\n            a\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (TestSafeMath.sol#149-162) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": 189,
                    "vulnerability_code": "    function _safeMul(uint256 a, uint256 b)\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n        uint256 c = a * b;\n\n        if (c / a != b) {\n\n            LibRichErrors.rrevert(LibSafeMathRichErrors.Uint256BinOpError(\n\n                LibSafeMathRichErrors.BinOpErrorCodes.MULTIPLICATION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        return c;\n",
                    "message": "Function 'SafeMath._safeMul' (TestSafeMath.sol#172-189) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": 205,
                    "vulnerability_code": "    function _safeDiv(uint256 a, uint256 b)\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        if (b == 0) {\n\n            LibRichErrors.rrevert(LibSafeMathRichErrors.Uint256BinOpError(\n\n                LibSafeMathRichErrors.BinOpErrorCodes.DIVISION_BY_ZERO,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        uint256 c = a / b;\n\n        return c;\n",
                    "message": "Function 'SafeMath._safeDiv' (TestSafeMath.sol#191-205) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 207,
                    "vulnerability_to_line": 220,
                    "vulnerability_code": "    function _safeSub(uint256 a, uint256 b)\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        if (b > a) {\n\n            LibRichErrors.rrevert(LibSafeMathRichErrors.Uint256BinOpError(\n\n                LibSafeMathRichErrors.BinOpErrorCodes.SUBTRACTION_UNDERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        return a - b;\n",
                    "message": "Function 'SafeMath._safeSub' (TestSafeMath.sol#207-220) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": 236,
                    "vulnerability_code": "    function _safeAdd(uint256 a, uint256 b)\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        uint256 c = a + b;\n\n        if (c < a) {\n\n            LibRichErrors.rrevert(LibSafeMathRichErrors.Uint256BinOpError(\n\n                LibSafeMathRichErrors.BinOpErrorCodes.ADDITION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        return c;\n",
                    "message": "Function 'SafeMath._safeAdd' (TestSafeMath.sol#222-236) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": 244,
                    "vulnerability_code": "    function _max256(uint256 a, uint256 b)\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        return a >= b ? a : b;\n",
                    "message": "Function 'SafeMath._max256' (TestSafeMath.sol#238-244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": 252,
                    "vulnerability_code": "    function _min256(uint256 a, uint256 b)\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        return a < b ? a : b;\n",
                    "message": "Function 'SafeMath._min256' (TestSafeMath.sol#246-252) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe486a353;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x67e71b32;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/test/TestLibAddress.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
                    "message": "LibAddress.isContract (TestLibAddress.sol#36-47) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
                    "message": "LibAddress.isContract uses assembly (TestLibAddress.sol#36-47)\n\t- TestLibAddress.sol#45\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestLibAddress.sol:\n\t- pragma solidity^0.5.9 (TestLibAddress.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibAddress.sol#71): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/test/TestLogDecodingDownstream.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": "Detected issues with version pragma in TestLogDecodingDownstream.sol:\n\t- pragma solidity^0.5.5 (TestLogDecodingDownstream.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/test/TestOwnable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_OWNER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/test/TestLibEIP712.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 82,
                    "vulnerability_code": "    function hashEIP712Domain(\n\n        string memory name,\n\n        string memory version,\n\n        uint256 chainId,\n\n        address verifyingContractAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n\n        //     keccak256(bytes(name)),\n\n        //     keccak256(bytes(version)),\n\n        //     chainId,\n\n        //     uint256(verifyingContractAddress)\n\n        // ))\n\n\n\n        assembly {\n\n            // Calculate hashes of dynamic data\n\n            let nameHash := keccak256(add(name, 32), mload(name))\n\n            let versionHash := keccak256(add(version, 32), mload(version))\n\n\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            // Store params in memory\n\n            mstore(memPtr, schemaHash)\n\n            mstore(add(memPtr, 32), nameHash)\n\n            mstore(add(memPtr, 64), versionHash)\n\n            mstore(add(memPtr, 96), chainId)\n\n            mstore(add(memPtr, 128), verifyingContractAddress)\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 160)\n\n        }\n\n        return result;\n",
                    "message": "LibEIP712.hashEIP712Domain (TestLibEIP712.sol#42-82) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": 113,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 66)\n\n        }\n\n        return result;\n",
                    "message": "LibEIP712.hashEIP712Message (TestLibEIP712.sol#89-113) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 82,
                    "vulnerability_code": "    function hashEIP712Domain(\n\n        string memory name,\n\n        string memory version,\n\n        uint256 chainId,\n\n        address verifyingContractAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n\n        //     keccak256(bytes(name)),\n\n        //     keccak256(bytes(version)),\n\n        //     chainId,\n\n        //     uint256(verifyingContractAddress)\n\n        // ))\n\n\n\n        assembly {\n\n            // Calculate hashes of dynamic data\n\n            let nameHash := keccak256(add(name, 32), mload(name))\n\n            let versionHash := keccak256(add(version, 32), mload(version))\n\n\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            // Store params in memory\n\n            mstore(memPtr, schemaHash)\n\n            mstore(add(memPtr, 32), nameHash)\n\n            mstore(add(memPtr, 64), versionHash)\n\n            mstore(add(memPtr, 96), chainId)\n\n            mstore(add(memPtr, 128), verifyingContractAddress)\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 160)\n\n        }\n\n        return result;\n",
                    "message": "LibEIP712.hashEIP712Domain uses assembly (TestLibEIP712.sol#42-82)\n\t- TestLibEIP712.sol#63-80\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": 113,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 66)\n\n        }\n\n        return result;\n",
                    "message": "LibEIP712.hashEIP712Message uses assembly (TestLibEIP712.sol#89-113)\n\t- TestLibEIP712.sol#101-111\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestLibEIP712.sol:\n\t- pragma solidity^0.5.9 (TestLibEIP712.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibEIP712.sol#136): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Domain(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function externalHashEIP712DomainSeperator(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string calldata version,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 chainid,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address verifyingcontractaddress\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bytes32)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return LibEIP712.hashEIP712Domain(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            version,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            verifyingcontractaddress\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/test/TestRefundableReceiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value != 0, \"Zero value should not be sent to this contract.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(this).balance == msg.value, \"A full refund was not provided by `refundNonzeroBalance`\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(balanceWithinCall == msg.value, \"Incorrect inner balance\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(balanceWithinCall == msg.value, \"Incorrect inner balance\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(this).balance == 0, \"Incorrect balance for TestRefundableReceiver\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(testRefundable).balance == msg.value, \"Incorrect balance for TestRefundable\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 338,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(this).balance == msg.value, \"Incorrect balance for TestRefundableReceiver\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(testRefundable).balance == 0, \"Incorrect balance for TestRefundable\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 346,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(testRefundable.getShouldNotRefund() == shouldNotRefund, \"Incorrect shouldNotRefund value\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value != 0, \"Zero value should not be sent to this contract.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(this).balance == msg.value, \"A full refund was not provided by `refundNonzeroBalance`\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(this).balance == 0, \"Incorrect balance for TestRefundableReceiver\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(testRefundable).balance == msg.value, \"Incorrect balance for TestRefundable\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 338,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(this).balance == msg.value, \"Incorrect balance for TestRefundableReceiver\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(testRefundable).balance == 0, \"Incorrect balance for TestRefundable\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_13"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function _refundNonZeroBalance()\n\n        internal\n\n    {\n\n        uint256 balance = address(this).balance;\n\n        if (balance > 0) {\n\n            msg.sender.transfer(balance);\n\n        }\n",
                    "message": "Refundable._refundNonZeroBalance (TestRefundableReceiver.sol#52-59) sends eth to arbitrary user\n\tDangerous calls:\n\t- msg.sender.transfer(balance) (TestRefundableReceiver.sol#57)\n"
                },
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": 350,
                    "vulnerability_code": "    function requireCorrectFinalBalancesAndState(\n\n        TestRefundable testRefundable,\n\n        bool shouldNotRefund\n\n    )\n\n        internal\n\n    {\n\n        // If `shouldNotRefund` was true, then this contract should have a balance of zero,\n\n        // and `testRefundable` should have a balance of `msg.value`. Otherwise, the opposite\n\n        // should be true.\n\n        if (shouldNotRefund) {\n\n            // Ensure that this contract's balance is zero.\n\n            require(address(this).balance == 0, \"Incorrect balance for TestRefundableReceiver\");\n\n\n\n            // Ensure that the other contract's balance is equal to `msg.value`.\n\n            require(address(testRefundable).balance == msg.value, \"Incorrect balance for TestRefundable\");\n\n        } else {\n\n            // Ensure that this contract's balance is `msg.value`.\n\n            require(address(this).balance == msg.value, \"Incorrect balance for TestRefundableReceiver\");\n\n\n\n            // Ensure that the other contract's balance is equal to zero.\n\n            require(address(testRefundable).balance == 0, \"Incorrect balance for TestRefundable\");\n\n        }\n\n\n\n        // Ensure that `shouldNotRefund` in TestRefundable is set to the parameter `shouldNotRefund`\n\n        // after the call (i.e. the value didn't change during the function call).\n\n        require(testRefundable.getShouldNotRefund() == shouldNotRefund, \"Incorrect shouldNotRefund value\");\n\n\n\n        // Drain the contract of funds so that subsequent tests don't have to account for leftover ether.\n\n        msg.sender.transfer(address(this).balance);\n",
                    "message": "TestRefundableReceiver.requireCorrectFinalBalancesAndState (TestRefundableReceiver.sol#321-350) sends eth to arbitrary user\n\tDangerous calls:\n\t- msg.sender.transfer(address(this).balance) (TestRefundableReceiver.sol#349)\n"
                },
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": 350,
                    "vulnerability_code": "    function requireCorrectFinalBalancesAndState(\n\n        TestRefundable testRefundable,\n\n        bool shouldNotRefund\n\n    )\n\n        internal\n\n    {\n\n        // If `shouldNotRefund` was true, then this contract should have a balance of zero,\n\n        // and `testRefundable` should have a balance of `msg.value`. Otherwise, the opposite\n\n        // should be true.\n\n        if (shouldNotRefund) {\n\n            // Ensure that this contract's balance is zero.\n\n            require(address(this).balance == 0, \"Incorrect balance for TestRefundableReceiver\");\n\n\n\n            // Ensure that the other contract's balance is equal to `msg.value`.\n\n            require(address(testRefundable).balance == msg.value, \"Incorrect balance for TestRefundable\");\n\n        } else {\n\n            // Ensure that this contract's balance is `msg.value`.\n\n            require(address(this).balance == msg.value, \"Incorrect balance for TestRefundableReceiver\");\n\n\n\n            // Ensure that the other contract's balance is equal to zero.\n\n            require(address(testRefundable).balance == 0, \"Incorrect balance for TestRefundable\");\n\n        }\n\n\n\n        // Ensure that `shouldNotRefund` in TestRefundable is set to the parameter `shouldNotRefund`\n\n        // after the call (i.e. the value didn't change during the function call).\n\n        require(testRefundable.getShouldNotRefund() == shouldNotRefund, \"Incorrect shouldNotRefund value\");\n\n\n\n        // Drain the contract of funds so that subsequent tests don't have to account for leftover ether.\n\n        msg.sender.transfer(address(this).balance);\n",
                    "message": "TestRefundableReceiver.requireCorrectFinalBalancesAndState (TestRefundableReceiver.sol#321-350) uses a dangerous strict equality:\n\t- require(bool,string)(address(this).balance == 0,Incorrect balance for TestRefundableReceiver)\n\t- require(bool,string)(address(testRefundable).balance == msg.value,Incorrect balance for TestRefundable)\n\t- require(bool,string)(address(this).balance == msg.value,Incorrect balance for TestRefundableReceiver)\n\t- require(bool,string)(address(testRefundable).balance == 0,Incorrect balance for TestRefundable)\n"
                },
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": 350,
                    "vulnerability_code": "    function requireCorrectFinalBalancesAndState(\n\n        TestRefundable testRefundable,\n\n        bool shouldNotRefund\n\n    )\n\n        internal\n\n    {\n\n        // If `shouldNotRefund` was true, then this contract should have a balance of zero,\n\n        // and `testRefundable` should have a balance of `msg.value`. Otherwise, the opposite\n\n        // should be true.\n\n        if (shouldNotRefund) {\n\n            // Ensure that this contract's balance is zero.\n\n            require(address(this).balance == 0, \"Incorrect balance for TestRefundableReceiver\");\n\n\n\n            // Ensure that the other contract's balance is equal to `msg.value`.\n\n            require(address(testRefundable).balance == msg.value, \"Incorrect balance for TestRefundable\");\n\n        } else {\n\n            // Ensure that this contract's balance is `msg.value`.\n\n            require(address(this).balance == msg.value, \"Incorrect balance for TestRefundableReceiver\");\n\n\n\n            // Ensure that the other contract's balance is equal to zero.\n\n            require(address(testRefundable).balance == 0, \"Incorrect balance for TestRefundable\");\n\n        }\n\n\n\n        // Ensure that `shouldNotRefund` in TestRefundable is set to the parameter `shouldNotRefund`\n\n        // after the call (i.e. the value didn't change during the function call).\n\n        require(testRefundable.getShouldNotRefund() == shouldNotRefund, \"Incorrect shouldNotRefund value\");\n\n\n\n        // Drain the contract of funds so that subsequent tests don't have to account for leftover ether.\n\n        msg.sender.transfer(address(this).balance);\n",
                    "message": "TestRefundableReceiver.requireCorrectFinalBalancesAndState (TestRefundableReceiver.sol#321-350) uses a dangerous strict equality:\n\t- require(bool,string)(address(this).balance == 0,Incorrect balance for TestRefundableReceiver)\n\t- require(bool,string)(address(testRefundable).balance == msg.value,Incorrect balance for TestRefundable)\n\t- require(bool,string)(address(this).balance == msg.value,Incorrect balance for TestRefundableReceiver)\n\t- require(bool,string)(address(testRefundable).balance == 0,Incorrect balance for TestRefundable)\nTestRefundableReceiver.testRefundNonZeroBalance (TestRefundableReceiver.sol#200-213) uses a dangerous strict equality:\n\t- require(bool,string)(address(this).balance == msg.value,A full refund was not provided by `refundNonzeroBalance`)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": 149,
                    "vulnerability_code": "    function nestedDisableRefundUntilEndFunction()\n\n        public\n\n        payable\n\n        disableRefundUntilEnd\n\n        returns (uint256)\n\n    {\n\n        disableRefundUntilEndFunction();\n\n        return address(this).balance;\n",
                    "message": "TestRefundable.nestedDisableRefundUntilEndFunction (TestRefundableReceiver.sol#141-149) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": 159,
                    "vulnerability_code": "    function mixedRefundModifierFunction()\n\n        public\n\n        payable\n\n        disableRefundUntilEnd\n\n        returns (uint256)\n\n    {\n\n        refundFinalBalanceFunction();\n\n        return address(this).balance;\n",
                    "message": "TestRefundable.mixedRefundModifierFunction (TestRefundableReceiver.sol#151-159) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestRefundableReceiver.sol:\n\t- pragma solidity^0.5.9 (TestRefundableReceiver.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestRefundableReceiver.sol#103): it allows old versions\n\t- pragma solidity^0.5.9 (TestRefundableReceiver.sol#182): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": 50,
                    "vulnerability_code": "    function _refundNonZeroBalanceIfEnabled()\n\n        internal\n\n    {\n\n        if (!_areRefundsDisabled()) {\n\n            _refundNonZeroBalance();\n\n        }\n",
                    "message": "Function 'Refundable._refundNonZeroBalanceIfEnabled' (TestRefundableReceiver.sol#44-50) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function _refundNonZeroBalance()\n\n        internal\n\n    {\n\n        uint256 balance = address(this).balance;\n\n        if (balance > 0) {\n\n            msg.sender.transfer(balance);\n\n        }\n",
                    "message": "Function 'Refundable._refundNonZeroBalance' (TestRefundableReceiver.sol#52-59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": 65,
                    "vulnerability_code": "    function _disableRefund()\n\n        internal\n\n    {\n\n        _shouldNotRefund = true;\n",
                    "message": "Function 'Refundable._disableRefund' (TestRefundableReceiver.sol#61-65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function _enableAndRefundNonZeroBalance()\n\n        internal\n\n    {\n\n        _shouldNotRefund = false;\n\n        _refundNonZeroBalance();\n",
                    "message": "Function 'Refundable._enableAndRefundNonZeroBalance' (TestRefundableReceiver.sol#67-72) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 80,
                    "vulnerability_code": "    function _areRefundsDisabled()\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        return _shouldNotRefund;\n",
                    "message": "Function 'Refundable._areRefundsDisabled' (TestRefundableReceiver.sol#74-80) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool internal _shouldNotRefund;\n",
                    "message": "Variable 'Refundable._shouldNotRefund' (TestRefundableReceiver.sol#27) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_BALANCE_EQUALITY",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(this).balance == msg.value, \"A full refund was not provided by `refundNonzeroBalance`\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_BALANCE_EQUALITY",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(this).balance == 0, \"Incorrect balance for TestRefundableReceiver\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_BALANCE_EQUALITY",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(testRefundable).balance == msg.value, \"Incorrect balance for TestRefundable\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_BALANCE_EQUALITY",
                    "vulnerability_from_line": 338,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(this).balance == msg.value, \"Incorrect balance for TestRefundableReceiver\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_BALANCE_EQUALITY",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(testRefundable).balance == 0, \"Incorrect balance for TestRefundable\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract TestRefundable is\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/test/TestReentrancyGuard.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _locked = false;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _locked = false;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/test/TestLibBytes.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            required\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_51"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (TestLibBytes.sol#111-118) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": 162,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (TestLibBytes.sol#153-162) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": 176,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (TestLibBytes.sol#167-176) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": 283,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (TestLibBytes.sol#182-283) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": 364,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (TestLibBytes.sol#332-364) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 391,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (TestLibBytes.sol#369-391) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": 418,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes (TestLibBytes.sol#396-418) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (TestLibBytes.sol#442-471) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": 520,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (TestLibBytes.sol#477-520) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": 550,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (TestLibBytes.sol#526-550) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 556,
                    "vulnerability_to_line": 579,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (TestLibBytes.sol#556-579) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": 643,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (TestLibBytes.sol#616-643) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 651,
                    "vulnerability_to_line": 679,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        if (b.length < index + nestedBytesLength) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors\n\n                    .InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsNestedBytesLengthRequired,\n\n                b.length,\n\n                index + nestedBytesLength\n\n            ));\n\n        }\n\n\n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength (TestLibBytes.sol#651-679) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 744,
                    "vulnerability_to_line": 751,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength (TestLibBytes.sol#744-751) is declared view but contains assembly code\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 817,
                    "vulnerability_to_line": 826,
                    "vulnerability_code": "    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n\n        public\n\n        pure\n\n        returns (bool equal)\n\n    {\n\n        lhs.popLastByte();\n\n        rhs.popLastByte();\n\n        equal = lhs.equals(rhs);\n\n        return equal;\n",
                    "message": "TestLibBytes.publicEqualsPop1 (TestLibBytes.sol#817-826) does not use the value returned by external calls:\n\t-lhs.popLastByte() (TestLibBytes.sol#822)\n\t-rhs.popLastByte() (TestLibBytes.sol#823)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (TestLibBytes.sol#111-118)\n\t- TestLibBytes.sol#115-117\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": 162,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (TestLibBytes.sol#153-162)\n\t- TestLibBytes.sol#158-160\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": 176,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (TestLibBytes.sol#167-176)\n\t- TestLibBytes.sol#172-174\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": 283,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (TestLibBytes.sol#182-283)\n\t- TestLibBytes.sol#194-199\n\t- TestLibBytes.sol#222-249\n\t- TestLibBytes.sol#251-280\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": 364,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (TestLibBytes.sol#332-364)\n\t- TestLibBytes.sol#359-362\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 391,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (TestLibBytes.sol#369-391)\n\t- TestLibBytes.sol#385-389\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": 418,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes uses assembly (TestLibBytes.sol#396-418)\n\t- TestLibBytes.sol#412-416\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (TestLibBytes.sol#442-471)\n\t- TestLibBytes.sol#464-469\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": 520,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (TestLibBytes.sol#477-520)\n\t- TestLibBytes.sol#499-519\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": 550,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (TestLibBytes.sol#526-550)\n\t- TestLibBytes.sol#546-548\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 556,
                    "vulnerability_to_line": 579,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (TestLibBytes.sol#556-579)\n\t- TestLibBytes.sol#576-578\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": 643,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (TestLibBytes.sol#616-643)\n\t- TestLibBytes.sol#636-641\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 651,
                    "vulnerability_to_line": 679,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        if (b.length < index + nestedBytesLength) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors\n\n                    .InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsNestedBytesLengthRequired,\n\n                b.length,\n\n                index + nestedBytesLength\n\n            ));\n\n        }\n\n\n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength uses assembly (TestLibBytes.sol#651-679)\n\t- TestLibBytes.sol#675-677\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 744,
                    "vulnerability_to_line": 751,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength uses assembly (TestLibBytes.sol#744-751)\n\t- TestLibBytes.sol#748-750\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 783,
                    "vulnerability_to_line": 790,
                    "vulnerability_code": "    function publicPopLastByte(bytes memory b)\n\n        public\n\n        pure\n\n        returns (bytes memory, bytes1 result)\n\n    {\n\n        result = b.popLastByte();\n\n        return (b, result);\n",
                    "message": "TestLibBytes.publicPopLastByte (TestLibBytes.sol#783-790) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": 802,
                    "vulnerability_code": "    function publicPopLast20Bytes(bytes memory b)\n\n        public\n\n        pure\n\n        returns (bytes memory, address result)\n\n    {\n\n        result = b.popLast20Bytes();\n\n        return (b, result);\n",
                    "message": "TestLibBytes.publicPopLast20Bytes (TestLibBytes.sol#795-802) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 808,
                    "vulnerability_to_line": 815,
                    "vulnerability_code": "    function publicEquals(bytes memory lhs, bytes memory rhs)\n\n        public\n\n        pure\n\n        returns (bool equal)\n\n    {\n\n        equal = lhs.equals(rhs);\n\n        return equal;\n",
                    "message": "TestLibBytes.publicEquals (TestLibBytes.sol#808-815) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 817,
                    "vulnerability_to_line": 826,
                    "vulnerability_code": "    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n\n        public\n\n        pure\n\n        returns (bool equal)\n\n    {\n\n        lhs.popLastByte();\n\n        rhs.popLastByte();\n\n        equal = lhs.equals(rhs);\n\n        return equal;\n",
                    "message": "TestLibBytes.publicEqualsPop1 (TestLibBytes.sol#817-826) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 831,
                    "vulnerability_to_line": 841,
                    "vulnerability_code": "    function publicDeepCopyBytes(\n\n        bytes memory dest,\n\n        bytes memory source\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        LibBytes.deepCopyBytes(dest, source);\n\n        return dest;\n",
                    "message": "TestLibBytes.publicDeepCopyBytes (TestLibBytes.sol#831-841) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 847,
                    "vulnerability_to_line": 857,
                    "vulnerability_code": "    function publicReadAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        public\n\n        pure\n\n        returns (address result)\n\n    {\n\n        result = b.readAddress(index);\n\n        return result;\n",
                    "message": "TestLibBytes.publicReadAddress (TestLibBytes.sol#847-857) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 863,
                    "vulnerability_to_line": 874,
                    "vulnerability_code": "    function publicWriteAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        b.writeAddress(index, input);\n\n        return b;\n",
                    "message": "TestLibBytes.publicWriteAddress (TestLibBytes.sol#863-874) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 880,
                    "vulnerability_to_line": 890,
                    "vulnerability_code": "    function publicReadBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        result = b.readBytes32(index);\n\n        return result;\n",
                    "message": "TestLibBytes.publicReadBytes32 (TestLibBytes.sol#880-890) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 896,
                    "vulnerability_to_line": 907,
                    "vulnerability_code": "    function publicWriteBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        b.writeBytes32(index, input);\n\n        return b;\n",
                    "message": "TestLibBytes.publicWriteBytes32 (TestLibBytes.sol#896-907) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 913,
                    "vulnerability_to_line": 923,
                    "vulnerability_code": "    function publicReadUint256(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        public\n\n        pure\n\n        returns (uint256 result)\n\n    {\n\n        result = b.readUint256(index);\n\n        return result;\n",
                    "message": "TestLibBytes.publicReadUint256 (TestLibBytes.sol#913-923) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": 940,
                    "vulnerability_code": "    function publicWriteUint256(\n\n        bytes memory b,\n\n        uint256 index,\n\n        uint256 input\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        b.writeUint256(index, input);\n\n        return b;\n",
                    "message": "TestLibBytes.publicWriteUint256 (TestLibBytes.sol#929-940) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 946,
                    "vulnerability_to_line": 956,
                    "vulnerability_code": "    function publicReadBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        result = b.readBytes4(index);\n\n        return result;\n",
                    "message": "TestLibBytes.publicReadBytes4 (TestLibBytes.sol#946-956) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": 972,
                    "vulnerability_code": "    function publicReadBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        result = b.readBytesWithLength(index);\n\n        return result;\n",
                    "message": "TestLibBytes.publicReadBytesWithLength (TestLibBytes.sol#962-972) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 979,
                    "vulnerability_to_line": 990,
                    "vulnerability_code": "    function publicWriteBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes memory input\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        b.writeBytesWithLength(index, input);\n\n        return b;\n",
                    "message": "TestLibBytes.publicWriteBytesWithLength (TestLibBytes.sol#979-990) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 998,
                    "vulnerability_to_line": 1020,
                    "vulnerability_code": "    function testMemcpy(\n\n        bytes memory mem,\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        public // not external, we need input in memory\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        // Sanity check. Overflows are not checked.\n\n        require(source + length <= mem.length);\n\n        require(dest + length <= mem.length);\n\n\n\n        // Get pointer to memory contents\n\n        uint256 offset = mem.contentAddress();\n\n\n\n        // Execute memCopy adjusted for memory array location\n\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n\n\n        // Return modified memory contents\n\n        return mem;\n",
                    "message": "TestLibBytes.testMemcpy (TestLibBytes.sol#998-1020) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1027,
                    "vulnerability_to_line": 1038,
                    "vulnerability_code": "    function publicSlice(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory result, bytes memory original)\n\n    {\n\n        result = LibBytes.slice(b, from, to);\n\n        return (result, b);\n",
                    "message": "TestLibBytes.publicSlice (TestLibBytes.sol#1027-1038) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1046,
                    "vulnerability_to_line": 1057,
                    "vulnerability_code": "    function publicSliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory result, bytes memory original)\n\n    {\n\n        result = LibBytes.sliceDestructive(b, from, to);\n\n        return (result, b);\n",
                    "message": "TestLibBytes.publicSliceDestructive (TestLibBytes.sol#1046-1057) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1066,
                    "vulnerability_to_line": 1079,
                    "vulnerability_code": "    function publicWriteLength(\n\n        bytes memory b,\n\n        uint256 length,\n\n        bytes memory extraBytes\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        uint256 bEnd = b.contentAddress() + b.length;\n\n        LibBytes.memCopy(bEnd, extraBytes.contentAddress(), extraBytes.length);\n\n        b.writeLength(length);\n\n        return b;\n",
                    "message": "TestLibBytes.publicWriteLength (TestLibBytes.sol#1066-1079) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1081,
                    "vulnerability_to_line": 1093,
                    "vulnerability_code": "    function assertBytesUnchangedAfterLengthReset(\n\n        bytes memory b,\n\n        uint256 tempLength\n\n    )\n\n        public\n\n        pure\n\n    {\n\n        uint256 length = b.length;\n\n        bytes memory bCopy = b.slice(0, length);\n\n        b.writeLength(tempLength);\n\n        b.writeLength(length);\n\n        assert(b.equals(bCopy));\n",
                    "message": "TestLibBytes.assertBytesUnchangedAfterLengthReset (TestLibBytes.sol#1081-1093) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestLibBytes.sol:\n\t- pragma solidity^0.5.9 (TestLibBytes.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibBytes.sol#80): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibBytes.sol#141): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibBytes.sol#774): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 57,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n\n            errorCode,\n\n            offset,\n\n            required\n\n        );\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (TestLibBytes.sol#42-57) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": 106,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (TestLibBytes.sol#95-106) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 556,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 651,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytesWithLength(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 744,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bytes memory, bytes1 result)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bytes memory, address result)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1034,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bytes memory result, bytes memory original)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bytes memory result, bytes memory original)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 546,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 636,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 675,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 748,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/test/TestLogDecoding.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": 104,
                    "vulnerability_code": "    function emitEventsLocalAndDownstream()\n\n        public\n\n    {\n\n        emitEvent();\n\n        emitEventDownstream();\n",
                    "message": "TestLogDecoding.emitEventsLocalAndDownstream (TestLogDecoding.sol#99-104) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": "Detected issues with version pragma in TestLogDecoding.sol:\n\t- pragma solidity^0.5.5 (TestLogDecoding.sol#21): it allows old versions\n\t- pragma solidity^0.5.5 (TestLogDecoding.sol#72): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/LibEIP1271.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibEIP1271.sol:\n\t- pragma solidity^0.5.9 (LibEIP1271.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant public EIP1271_MAGIC_VALUE = 0x20c13b0b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/ReentrancyGuard.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _locked = false;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 98,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (ReentrancyGuard.sol#91-98) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 98,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (ReentrancyGuard.sol#91-98)\n\t- ReentrancyGuard.sol#95-97\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in ReentrancyGuard.sol:\n\t- pragma solidity^0.5.9 (ReentrancyGuard.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (ReentrancyGuard.sol#60): it allows old versions\n\t- pragma solidity^0.5.9 (ReentrancyGuard.sol#121): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 37,
                    "vulnerability_code": "    function IllegalReentrancyError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ILLEGAL_REENTRANCY_ERROR_SELECTOR_BYTES;\n",
                    "message": "Function 'LibReentrancyGuardRichErrors.IllegalReentrancyError' (ReentrancyGuard.sol#31-37) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": 86,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (ReentrancyGuard.sol#75-86) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": 148,
                    "vulnerability_code": "    function _lockMutexOrThrowIfAlreadyLocked()\n\n        internal\n\n    {\n\n        // Ensure mutex is unlocked.\n\n        if (_locked) {\n\n            LibRichErrors.rrevert(\n\n                LibReentrancyGuardRichErrors.IllegalReentrancyError()\n\n            );\n\n        }\n\n        // Lock mutex.\n\n        _locked = true;\n",
                    "message": "Function 'ReentrancyGuard._lockMutexOrThrowIfAlreadyLocked' (ReentrancyGuard.sol#137-148) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": 155,
                    "vulnerability_code": "    function _unlockMutex()\n\n        internal\n\n    {\n\n        // Unlock mutex.\n\n        _locked = false;\n",
                    "message": "Function 'ReentrancyGuard._unlockMutex' (ReentrancyGuard.sol#150-155) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _locked = false;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/Authorizable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            AUTHORIZED_ADDRESS_MISMATCH_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INDEX_OUT_OF_BOUNDS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            length\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            SENDER_NOT_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            TARGET_ALREADY_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            TARGET_NOT_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_OWNER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 285,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (authorities[i] == target) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x140a84db;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe9f83771;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb65a25b9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xde16f1a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xeb5108a2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/LibSafeMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT96_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT64_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_DOWNCAST_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibSafeMath.sol#52-59) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibSafeMath.sol#52-59)\n\t- LibSafeMath.sol#56-58\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibSafeMath.sol:\n\t- pragma solidity^0.5.9 (LibSafeMath.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibSafeMath.sol#64): it allows old versions\n\t- pragma solidity^0.5.9 (LibSafeMath.sol#167): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibSafeMath.sol#36-47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": 113,
                    "vulnerability_code": "    function Uint256BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint256 a,\n\n        uint256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (LibSafeMath.sol#98-113) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": 130,
                    "vulnerability_code": "    function Uint96BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint96 a,\n\n        uint96 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT96_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint96BinOpError' (LibSafeMath.sol#115-130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 147,
                    "vulnerability_code": "    function Uint64BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint64 a,\n\n        uint64 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT64_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint64BinOpError' (LibSafeMath.sol#132-147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": 162,
                    "vulnerability_code": "    function Uint256DowncastError(\n\n        DowncastErrorCodes errorCode,\n\n        uint256 a\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_DOWNCAST_ERROR_SELECTOR,\n\n            errorCode,\n\n            a\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (LibSafeMath.sol#149-162) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe486a353;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x67e71b32;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/LibFractions.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT96_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT64_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_DOWNCAST_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibFractions.sol#52-59) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibFractions.sol#52-59)\n\t- LibFractions.sol#56-58\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibFractions.sol:\n\t- pragma solidity^0.5.9 (LibFractions.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibFractions.sol#64): it allows old versions\n\t- pragma solidity^0.5.9 (LibFractions.sol#167): it allows old versions\n\t- pragma solidity^0.5.9 (LibFractions.sol#257): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibFractions.sol#36-47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": 113,
                    "vulnerability_code": "    function Uint256BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint256 a,\n\n        uint256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (LibFractions.sol#98-113) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": 130,
                    "vulnerability_code": "    function Uint96BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint96 a,\n\n        uint96 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT96_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint96BinOpError' (LibFractions.sol#115-130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 147,
                    "vulnerability_code": "    function Uint64BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint64 a,\n\n        uint64 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT64_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint64BinOpError' (LibFractions.sol#132-147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": 162,
                    "vulnerability_code": "    function Uint256DowncastError(\n\n        DowncastErrorCodes errorCode,\n\n        uint256 a\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_DOWNCAST_ERROR_SELECTOR,\n\n            errorCode,\n\n            a\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (LibFractions.sol#149-162) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe486a353;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x67e71b32;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/Ownable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_OWNER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/SafeMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT96_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT64_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_DOWNCAST_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_14"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (SafeMath.sol#52-59) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (SafeMath.sol#52-59)\n\t- SafeMath.sol#56-58\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in SafeMath.sol:\n\t- pragma solidity^0.5.9 (SafeMath.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (SafeMath.sol#64): it allows old versions\n\t- pragma solidity^0.5.9 (SafeMath.sol#167): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (SafeMath.sol#36-47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": 113,
                    "vulnerability_code": "    function Uint256BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint256 a,\n\n        uint256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (SafeMath.sol#98-113) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": 130,
                    "vulnerability_code": "    function Uint96BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint96 a,\n\n        uint96 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT96_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint96BinOpError' (SafeMath.sol#115-130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 147,
                    "vulnerability_code": "    function Uint64BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint64 a,\n\n        uint64 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT64_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint64BinOpError' (SafeMath.sol#132-147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": 162,
                    "vulnerability_code": "    function Uint256DowncastError(\n\n        DowncastErrorCodes errorCode,\n\n        uint256 a\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_DOWNCAST_ERROR_SELECTOR,\n\n            errorCode,\n\n            a\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (SafeMath.sol#149-162) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": 189,
                    "vulnerability_code": "    function _safeMul(uint256 a, uint256 b)\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n        uint256 c = a * b;\n\n        if (c / a != b) {\n\n            LibRichErrors.rrevert(LibSafeMathRichErrors.Uint256BinOpError(\n\n                LibSafeMathRichErrors.BinOpErrorCodes.MULTIPLICATION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        return c;\n",
                    "message": "Function 'SafeMath._safeMul' (SafeMath.sol#172-189) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": 205,
                    "vulnerability_code": "    function _safeDiv(uint256 a, uint256 b)\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        if (b == 0) {\n\n            LibRichErrors.rrevert(LibSafeMathRichErrors.Uint256BinOpError(\n\n                LibSafeMathRichErrors.BinOpErrorCodes.DIVISION_BY_ZERO,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        uint256 c = a / b;\n\n        return c;\n",
                    "message": "Function 'SafeMath._safeDiv' (SafeMath.sol#191-205) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 207,
                    "vulnerability_to_line": 220,
                    "vulnerability_code": "    function _safeSub(uint256 a, uint256 b)\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        if (b > a) {\n\n            LibRichErrors.rrevert(LibSafeMathRichErrors.Uint256BinOpError(\n\n                LibSafeMathRichErrors.BinOpErrorCodes.SUBTRACTION_UNDERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        return a - b;\n",
                    "message": "Function 'SafeMath._safeSub' (SafeMath.sol#207-220) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": 236,
                    "vulnerability_code": "    function _safeAdd(uint256 a, uint256 b)\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        uint256 c = a + b;\n\n        if (c < a) {\n\n            LibRichErrors.rrevert(LibSafeMathRichErrors.Uint256BinOpError(\n\n                LibSafeMathRichErrors.BinOpErrorCodes.ADDITION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        return c;\n",
                    "message": "Function 'SafeMath._safeAdd' (SafeMath.sol#222-236) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": 244,
                    "vulnerability_code": "    function _max256(uint256 a, uint256 b)\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        return a >= b ? a : b;\n",
                    "message": "Function 'SafeMath._max256' (SafeMath.sol#238-244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": 252,
                    "vulnerability_code": "    function _min256(uint256 a, uint256 b)\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        return a < b ? a : b;\n",
                    "message": "Function 'SafeMath._min256' (SafeMath.sol#246-252) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe486a353;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x67e71b32;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/LibEIP712.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 82,
                    "vulnerability_code": "    function hashEIP712Domain(\n\n        string memory name,\n\n        string memory version,\n\n        uint256 chainId,\n\n        address verifyingContractAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n\n        //     keccak256(bytes(name)),\n\n        //     keccak256(bytes(version)),\n\n        //     chainId,\n\n        //     uint256(verifyingContractAddress)\n\n        // ))\n\n\n\n        assembly {\n\n            // Calculate hashes of dynamic data\n\n            let nameHash := keccak256(add(name, 32), mload(name))\n\n            let versionHash := keccak256(add(version, 32), mload(version))\n\n\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            // Store params in memory\n\n            mstore(memPtr, schemaHash)\n\n            mstore(add(memPtr, 32), nameHash)\n\n            mstore(add(memPtr, 64), versionHash)\n\n            mstore(add(memPtr, 96), chainId)\n\n            mstore(add(memPtr, 128), verifyingContractAddress)\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 160)\n\n        }\n\n        return result;\n",
                    "message": "LibEIP712.hashEIP712Domain (LibEIP712.sol#42-82) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": 113,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 66)\n\n        }\n\n        return result;\n",
                    "message": "LibEIP712.hashEIP712Message (LibEIP712.sol#89-113) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 82,
                    "vulnerability_code": "    function hashEIP712Domain(\n\n        string memory name,\n\n        string memory version,\n\n        uint256 chainId,\n\n        address verifyingContractAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n\n        //     keccak256(bytes(name)),\n\n        //     keccak256(bytes(version)),\n\n        //     chainId,\n\n        //     uint256(verifyingContractAddress)\n\n        // ))\n\n\n\n        assembly {\n\n            // Calculate hashes of dynamic data\n\n            let nameHash := keccak256(add(name, 32), mload(name))\n\n            let versionHash := keccak256(add(version, 32), mload(version))\n\n\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            // Store params in memory\n\n            mstore(memPtr, schemaHash)\n\n            mstore(add(memPtr, 32), nameHash)\n\n            mstore(add(memPtr, 64), versionHash)\n\n            mstore(add(memPtr, 96), chainId)\n\n            mstore(add(memPtr, 128), verifyingContractAddress)\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 160)\n\n        }\n\n        return result;\n",
                    "message": "LibEIP712.hashEIP712Domain uses assembly (LibEIP712.sol#42-82)\n\t- LibEIP712.sol#63-80\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": 113,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 66)\n\n        }\n\n        return result;\n",
                    "message": "LibEIP712.hashEIP712Message uses assembly (LibEIP712.sol#89-113)\n\t- LibEIP712.sol#101-111\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibEIP712.sol:\n\t- pragma solidity^0.5.9 (LibEIP712.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Domain(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/LibSafeMathRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT96_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT64_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_DOWNCAST_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibSafeMathRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibSafeMathRichErrors.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 52,
                    "vulnerability_code": "    function Uint256BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint256 a,\n\n        uint256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (LibSafeMathRichErrors.sol#37-52) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": 69,
                    "vulnerability_code": "    function Uint96BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint96 a,\n\n        uint96 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT96_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint96BinOpError' (LibSafeMathRichErrors.sol#54-69) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": 86,
                    "vulnerability_code": "    function Uint64BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint64 a,\n\n        uint64 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT64_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint64BinOpError' (LibSafeMathRichErrors.sol#71-86) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": 101,
                    "vulnerability_code": "    function Uint256DowncastError(\n\n        DowncastErrorCodes errorCode,\n\n        uint256 a\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_DOWNCAST_ERROR_SELECTOR,\n\n            errorCode,\n\n            a\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (LibSafeMathRichErrors.sol#88-101) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe486a353;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x67e71b32;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/LibAddress.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
                    "message": "LibAddress.isContract (LibAddress.sol#36-47) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
                    "message": "LibAddress.isContract uses assembly (LibAddress.sol#36-47)\n\t- LibAddress.sol#45\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibAddress.sol:\n\t- pragma solidity^0.5.9 (LibAddress.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/LibAddressArray.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MISMANAGED_MEMORY_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            freeMemPtr,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            addressArrayEndPtr\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            required\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_38"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 164,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibAddressArray.sol#157-164) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (LibAddressArray.sol#199-208) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": 222,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (LibAddressArray.sol#213-222) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": 329,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (LibAddressArray.sol#228-329) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": 410,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (LibAddressArray.sol#378-410) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": 437,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (LibAddressArray.sol#415-437) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": 464,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes (LibAddressArray.sol#442-464) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (LibAddressArray.sol#488-517) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 566,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (LibAddressArray.sol#523-566) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": 596,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (LibAddressArray.sol#572-596) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": 625,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (LibAddressArray.sol#602-625) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": 689,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (LibAddressArray.sol#662-689) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 697,
                    "vulnerability_to_line": 725,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        if (b.length < index + nestedBytesLength) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors\n\n                    .InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsNestedBytesLengthRequired,\n\n                b.length,\n\n                index + nestedBytesLength\n\n            ));\n\n        }\n\n\n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength (LibAddressArray.sol#697-725) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 790,
                    "vulnerability_to_line": 797,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength (LibAddressArray.sol#790-797) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 833,
                    "vulnerability_to_line": 887,
                    "vulnerability_code": "    function append(address[] memory addressArray, address addressToAppend)\n\n        internal\n\n        pure\n\n        returns (address[] memory)\n\n    {\n\n        // Get stats on address array and free memory\n\n        uint256 freeMemPtr = 0;\n\n        uint256 addressArrayBeginPtr = 0;\n\n        uint256 addressArrayEndPtr = 0;\n\n        uint256 addressArrayLength = addressArray.length;\n\n        uint256 addressArrayMemSizeInBytes = 32 + (32 * addressArrayLength);\n\n        assembly {\n\n            freeMemPtr := mload(0x40)\n\n            addressArrayBeginPtr := addressArray\n\n            addressArrayEndPtr := add(addressArray, addressArrayMemSizeInBytes)\n\n        }\n\n\n\n        // Cases for `freeMemPtr`:\n\n        //  `freeMemPtr` == `addressArrayEndPtr`: Nothing occupies memory after `addressArray`\n\n        //  `freeMemPtr` > `addressArrayEndPtr`: Some value occupies memory after `addressArray`\n\n        //  `freeMemPtr` < `addressArrayEndPtr`: Memory has not been managed properly.\n\n        if (freeMemPtr < addressArrayEndPtr) {\n\n            LibRichErrors.rrevert(LibAddressArrayRichErrors.MismanagedMemoryError(\n\n                freeMemPtr,\n\n                addressArrayEndPtr\n\n            ));\n\n        }\n\n\n\n        // If free memory begins at the end of `addressArray`\n\n        // then we can append `addressToAppend` directly.\n\n        // Otherwise, we must copy the array to free memory\n\n        // before appending new values to it.\n\n        if (freeMemPtr > addressArrayEndPtr) {\n\n            LibBytes.memCopy(freeMemPtr, addressArrayBeginPtr, addressArrayMemSizeInBytes);\n\n            assembly {\n\n                addressArray := freeMemPtr\n\n                addressArrayBeginPtr := addressArray\n\n            }\n\n        }\n\n\n\n        // Append `addressToAppend`\n\n        addressArrayLength += 1;\n\n        addressArrayMemSizeInBytes += 32;\n\n        addressArrayEndPtr = addressArrayBeginPtr + addressArrayMemSizeInBytes;\n\n        freeMemPtr = addressArrayEndPtr;\n\n        assembly {\n\n            // Store new array length\n\n            mstore(addressArray, addressArrayLength)\n\n\n\n            // Update `freeMemPtr`\n\n            mstore(0x40, freeMemPtr)\n\n        }\n\n        addressArray[addressArrayLength - 1] = addressToAppend;\n\n        return addressArray;\n",
                    "message": "LibAddressArray.append (LibAddressArray.sol#833-887) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 893,
                    "vulnerability_to_line": 923,
                    "vulnerability_code": "    function contains(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success to true\n\n                    success := 1\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return success;\n",
                    "message": "LibAddressArray.contains (LibAddressArray.sol#893-923) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": 960,
                    "vulnerability_code": "    function indexOf(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success, uint256 index)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success and index\n\n                    success := 1\n\n                    index := div(sub(i, arrayContentsStart), 32)\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return (success, index);\n",
                    "message": "LibAddressArray.indexOf (LibAddressArray.sol#929-960) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 164,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibAddressArray.sol#157-164)\n\t- LibAddressArray.sol#161-163\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (LibAddressArray.sol#199-208)\n\t- LibAddressArray.sol#204-206\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": 222,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (LibAddressArray.sol#213-222)\n\t- LibAddressArray.sol#218-220\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": 329,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (LibAddressArray.sol#228-329)\n\t- LibAddressArray.sol#240-245\n\t- LibAddressArray.sol#268-295\n\t- LibAddressArray.sol#297-326\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": 410,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (LibAddressArray.sol#378-410)\n\t- LibAddressArray.sol#405-408\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": 437,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (LibAddressArray.sol#415-437)\n\t- LibAddressArray.sol#431-435\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": 464,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes uses assembly (LibAddressArray.sol#442-464)\n\t- LibAddressArray.sol#458-462\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (LibAddressArray.sol#488-517)\n\t- LibAddressArray.sol#510-515\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 566,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (LibAddressArray.sol#523-566)\n\t- LibAddressArray.sol#545-565\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": 596,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (LibAddressArray.sol#572-596)\n\t- LibAddressArray.sol#592-594\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": 625,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (LibAddressArray.sol#602-625)\n\t- LibAddressArray.sol#622-624\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": 689,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (LibAddressArray.sol#662-689)\n\t- LibAddressArray.sol#682-687\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 697,
                    "vulnerability_to_line": 725,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        if (b.length < index + nestedBytesLength) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors\n\n                    .InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsNestedBytesLengthRequired,\n\n                b.length,\n\n                index + nestedBytesLength\n\n            ));\n\n        }\n\n\n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength uses assembly (LibAddressArray.sol#697-725)\n\t- LibAddressArray.sol#721-723\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 790,
                    "vulnerability_to_line": 797,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength uses assembly (LibAddressArray.sol#790-797)\n\t- LibAddressArray.sol#794-796\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 833,
                    "vulnerability_to_line": 887,
                    "vulnerability_code": "    function append(address[] memory addressArray, address addressToAppend)\n\n        internal\n\n        pure\n\n        returns (address[] memory)\n\n    {\n\n        // Get stats on address array and free memory\n\n        uint256 freeMemPtr = 0;\n\n        uint256 addressArrayBeginPtr = 0;\n\n        uint256 addressArrayEndPtr = 0;\n\n        uint256 addressArrayLength = addressArray.length;\n\n        uint256 addressArrayMemSizeInBytes = 32 + (32 * addressArrayLength);\n\n        assembly {\n\n            freeMemPtr := mload(0x40)\n\n            addressArrayBeginPtr := addressArray\n\n            addressArrayEndPtr := add(addressArray, addressArrayMemSizeInBytes)\n\n        }\n\n\n\n        // Cases for `freeMemPtr`:\n\n        //  `freeMemPtr` == `addressArrayEndPtr`: Nothing occupies memory after `addressArray`\n\n        //  `freeMemPtr` > `addressArrayEndPtr`: Some value occupies memory after `addressArray`\n\n        //  `freeMemPtr` < `addressArrayEndPtr`: Memory has not been managed properly.\n\n        if (freeMemPtr < addressArrayEndPtr) {\n\n            LibRichErrors.rrevert(LibAddressArrayRichErrors.MismanagedMemoryError(\n\n                freeMemPtr,\n\n                addressArrayEndPtr\n\n            ));\n\n        }\n\n\n\n        // If free memory begins at the end of `addressArray`\n\n        // then we can append `addressToAppend` directly.\n\n        // Otherwise, we must copy the array to free memory\n\n        // before appending new values to it.\n\n        if (freeMemPtr > addressArrayEndPtr) {\n\n            LibBytes.memCopy(freeMemPtr, addressArrayBeginPtr, addressArrayMemSizeInBytes);\n\n            assembly {\n\n                addressArray := freeMemPtr\n\n                addressArrayBeginPtr := addressArray\n\n            }\n\n        }\n\n\n\n        // Append `addressToAppend`\n\n        addressArrayLength += 1;\n\n        addressArrayMemSizeInBytes += 32;\n\n        addressArrayEndPtr = addressArrayBeginPtr + addressArrayMemSizeInBytes;\n\n        freeMemPtr = addressArrayEndPtr;\n\n        assembly {\n\n            // Store new array length\n\n            mstore(addressArray, addressArrayLength)\n\n\n\n            // Update `freeMemPtr`\n\n            mstore(0x40, freeMemPtr)\n\n        }\n\n        addressArray[addressArrayLength - 1] = addressToAppend;\n\n        return addressArray;\n",
                    "message": "LibAddressArray.append uses assembly (LibAddressArray.sol#833-887)\n\t- LibAddressArray.sol#844-848\n\t- LibAddressArray.sol#867-870\n\t- LibAddressArray.sol#878-884\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 893,
                    "vulnerability_to_line": 923,
                    "vulnerability_code": "    function contains(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success to true\n\n                    success := 1\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return success;\n",
                    "message": "LibAddressArray.contains uses assembly (LibAddressArray.sol#893-923)\n\t- LibAddressArray.sol#898-921\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": 960,
                    "vulnerability_code": "    function indexOf(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success, uint256 index)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success and index\n\n                    success := 1\n\n                    index := div(sub(i, arrayContentsStart), 32)\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return (success, index);\n",
                    "message": "LibAddressArray.indexOf uses assembly (LibAddressArray.sol#929-960)\n\t- LibAddressArray.sol#934-958\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibAddressArray.sol:\n\t- pragma solidity^0.5.9 (LibAddressArray.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibAddressArray.sol#67): it allows old versions\n\t- pragma solidity^0.5.9 (LibAddressArray.sol#126): it allows old versions\n\t- pragma solidity^0.5.9 (LibAddressArray.sol#187): it allows old versions\n\t- pragma solidity^0.5.9 (LibAddressArray.sol#820): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function MismanagedMemoryError(\n\n        uint256 freeMemPtr,\n\n        uint256 addressArrayEndPtr\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            MISMANAGED_MEMORY_ERROR_SELECTOR,\n\n            freeMemPtr,\n\n            addressArrayEndPtr\n\n        );\n",
                    "message": "Function 'LibAddressArrayRichErrors.MismanagedMemoryError' (LibAddressArray.sol#31-44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": 103,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n\n            errorCode,\n\n            offset,\n\n            required\n\n        );\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (LibAddressArray.sol#88-103) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibAddressArray.sol#141-152) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x5fc83722;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 697,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytesWithLength(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 790,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 833,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function append(address[] memory addressArray, address addressToAppend)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 893,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contains(address[] memory addressArray, address target)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function indexOf(address[] memory addressArray, address target)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 932,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bool success, uint256 index)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 405,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 592,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 622,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 682,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 721,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 794,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 867,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 878,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 898,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/Refundable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function _refundNonZeroBalance()\n\n        internal\n\n    {\n\n        uint256 balance = address(this).balance;\n\n        if (balance > 0) {\n\n            msg.sender.transfer(balance);\n\n        }\n",
                    "message": "Refundable._refundNonZeroBalance (Refundable.sol#52-59) sends eth to arbitrary user\n\tDangerous calls:\n\t- msg.sender.transfer(balance) (Refundable.sol#57)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in Refundable.sol:\n\t- pragma solidity^0.5.9 (Refundable.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": 50,
                    "vulnerability_code": "    function _refundNonZeroBalanceIfEnabled()\n\n        internal\n\n    {\n\n        if (!_areRefundsDisabled()) {\n\n            _refundNonZeroBalance();\n\n        }\n",
                    "message": "Function 'Refundable._refundNonZeroBalanceIfEnabled' (Refundable.sol#44-50) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function _refundNonZeroBalance()\n\n        internal\n\n    {\n\n        uint256 balance = address(this).balance;\n\n        if (balance > 0) {\n\n            msg.sender.transfer(balance);\n\n        }\n",
                    "message": "Function 'Refundable._refundNonZeroBalance' (Refundable.sol#52-59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": 65,
                    "vulnerability_code": "    function _disableRefund()\n\n        internal\n\n    {\n\n        _shouldNotRefund = true;\n",
                    "message": "Function 'Refundable._disableRefund' (Refundable.sol#61-65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function _enableAndRefundNonZeroBalance()\n\n        internal\n\n    {\n\n        _shouldNotRefund = false;\n\n        _refundNonZeroBalance();\n",
                    "message": "Function 'Refundable._enableAndRefundNonZeroBalance' (Refundable.sol#67-72) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 80,
                    "vulnerability_code": "    function _areRefundsDisabled()\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        return _shouldNotRefund;\n",
                    "message": "Function 'Refundable._areRefundsDisabled' (Refundable.sol#74-80) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool internal _shouldNotRefund;\n",
                    "message": "Variable 'Refundable._shouldNotRefund' (Refundable.sol#27) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/LibBytes.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            required\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_31"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibBytes.sol#111-118) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": 162,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (LibBytes.sol#153-162) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": 176,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (LibBytes.sol#167-176) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": 283,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (LibBytes.sol#182-283) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": 364,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (LibBytes.sol#332-364) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 391,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (LibBytes.sol#369-391) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": 418,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes (LibBytes.sol#396-418) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (LibBytes.sol#442-471) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": 520,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (LibBytes.sol#477-520) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": 550,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (LibBytes.sol#526-550) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 556,
                    "vulnerability_to_line": 579,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (LibBytes.sol#556-579) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": 643,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (LibBytes.sol#616-643) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 651,
                    "vulnerability_to_line": 679,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        if (b.length < index + nestedBytesLength) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors\n\n                    .InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsNestedBytesLengthRequired,\n\n                b.length,\n\n                index + nestedBytesLength\n\n            ));\n\n        }\n\n\n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength (LibBytes.sol#651-679) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 744,
                    "vulnerability_to_line": 751,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength (LibBytes.sol#744-751) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibBytes.sol#111-118)\n\t- LibBytes.sol#115-117\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": 162,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (LibBytes.sol#153-162)\n\t- LibBytes.sol#158-160\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": 176,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (LibBytes.sol#167-176)\n\t- LibBytes.sol#172-174\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": 283,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (LibBytes.sol#182-283)\n\t- LibBytes.sol#194-199\n\t- LibBytes.sol#222-249\n\t- LibBytes.sol#251-280\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": 364,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (LibBytes.sol#332-364)\n\t- LibBytes.sol#359-362\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 391,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (LibBytes.sol#369-391)\n\t- LibBytes.sol#385-389\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": 418,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes uses assembly (LibBytes.sol#396-418)\n\t- LibBytes.sol#412-416\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (LibBytes.sol#442-471)\n\t- LibBytes.sol#464-469\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": 520,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (LibBytes.sol#477-520)\n\t- LibBytes.sol#499-519\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": 550,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (LibBytes.sol#526-550)\n\t- LibBytes.sol#546-548\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 556,
                    "vulnerability_to_line": 579,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (LibBytes.sol#556-579)\n\t- LibBytes.sol#576-578\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": 643,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (LibBytes.sol#616-643)\n\t- LibBytes.sol#636-641\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 651,
                    "vulnerability_to_line": 679,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        if (b.length < index + nestedBytesLength) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors\n\n                    .InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsNestedBytesLengthRequired,\n\n                b.length,\n\n                index + nestedBytesLength\n\n            ));\n\n        }\n\n\n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength uses assembly (LibBytes.sol#651-679)\n\t- LibBytes.sol#675-677\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 744,
                    "vulnerability_to_line": 751,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength uses assembly (LibBytes.sol#744-751)\n\t- LibBytes.sol#748-750\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibBytes.sol:\n\t- pragma solidity^0.5.9 (LibBytes.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibBytes.sol#80): it allows old versions\n\t- pragma solidity^0.5.9 (LibBytes.sol#141): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 57,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n\n            errorCode,\n\n            offset,\n\n            required\n\n        );\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (LibBytes.sol#42-57) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": 106,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibBytes.sol#95-106) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 556,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 651,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytesWithLength(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 744,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 546,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 636,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 675,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 748,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/LibAuthorizableRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            AUTHORIZED_ADDRESS_MISMATCH_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INDEX_OUT_OF_BOUNDS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            length\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            SENDER_NOT_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            TARGET_ALREADY_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            TARGET_NOT_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibAuthorizableRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibAuthorizableRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function AuthorizedAddressMismatchError(\n\n        address authorized,\n\n        address target\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            AUTHORIZED_ADDRESS_MISMATCH_ERROR_SELECTOR,\n\n            authorized,\n\n            target\n\n        );\n",
                    "message": "Function 'LibAuthorizableRichErrors.AuthorizedAddressMismatchError' (LibAuthorizableRichErrors.sol#51-64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": 79,
                    "vulnerability_code": "    function IndexOutOfBoundsError(\n\n        uint256 index,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INDEX_OUT_OF_BOUNDS_ERROR_SELECTOR,\n\n            index,\n\n            length\n\n        );\n",
                    "message": "Function 'LibAuthorizableRichErrors.IndexOutOfBoundsError' (LibAuthorizableRichErrors.sol#66-79) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": 90,
                    "vulnerability_code": "    function SenderNotAuthorizedError(address sender)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            SENDER_NOT_AUTHORIZED_ERROR_SELECTOR,\n\n            sender\n\n        );\n",
                    "message": "Function 'LibAuthorizableRichErrors.SenderNotAuthorizedError' (LibAuthorizableRichErrors.sol#81-90) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": 101,
                    "vulnerability_code": "    function TargetAlreadyAuthorizedError(address target)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            TARGET_ALREADY_AUTHORIZED_ERROR_SELECTOR,\n\n            target\n\n        );\n",
                    "message": "Function 'LibAuthorizableRichErrors.TargetAlreadyAuthorizedError' (LibAuthorizableRichErrors.sol#92-101) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": 112,
                    "vulnerability_code": "    function TargetNotAuthorizedError(address target)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            TARGET_NOT_AUTHORIZED_ERROR_SELECTOR,\n\n            target\n\n        );\n",
                    "message": "Function 'LibAuthorizableRichErrors.TargetNotAuthorizedError' (LibAuthorizableRichErrors.sol#103-112) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": 120,
                    "vulnerability_code": "    function ZeroCantBeAuthorizedError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ZERO_CANT_BE_AUTHORIZED_ERROR_BYTES;\n",
                    "message": "Function 'LibAuthorizableRichErrors.ZeroCantBeAuthorizedError' (LibAuthorizableRichErrors.sol#114-120) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x140a84db;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe9f83771;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb65a25b9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xde16f1a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xeb5108a2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/LibAddressArrayRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MISMANAGED_MEMORY_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            freeMemPtr,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            addressArrayEndPtr\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibAddressArrayRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibAddressArrayRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function MismanagedMemoryError(\n\n        uint256 freeMemPtr,\n\n        uint256 addressArrayEndPtr\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            MISMANAGED_MEMORY_ERROR_SELECTOR,\n\n            freeMemPtr,\n\n            addressArrayEndPtr\n\n        );\n",
                    "message": "Function 'LibAddressArrayRichErrors.MismanagedMemoryError' (LibAddressArrayRichErrors.sol#31-44) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x5fc83722;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/LibBytesRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            required\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibBytesRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibBytesRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 57,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n\n            errorCode,\n\n            offset,\n\n            required\n\n        );\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (LibBytesRichErrors.sol#42-57) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/LibReentrancyGuardRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibReentrancyGuardRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibReentrancyGuardRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 37,
                    "vulnerability_code": "    function IllegalReentrancyError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ILLEGAL_REENTRANCY_ERROR_SELECTOR_BYTES;\n",
                    "message": "Function 'LibReentrancyGuardRichErrors.IllegalReentrancyError' (LibReentrancyGuardRichErrors.sol#31-37) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/LibOwnableRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_OWNER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibOwnableRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibOwnableRichErrors.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": 30,
                    "vulnerability_code": "    function OnlyOwnerError(\n\n        address sender,\n\n        address owner\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_OWNER_ERROR_SELECTOR,\n\n            sender,\n\n            owner\n\n        );\n",
                    "message": "Function 'LibOwnableRichErrors.OnlyOwnerError' (LibOwnableRichErrors.sol#17-30) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 38,
                    "vulnerability_code": "    function TransferOwnerToZeroError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return TRANSFER_OWNER_TO_ZERO_ERROR_BYTES;\n",
                    "message": "Function 'LibOwnableRichErrors.TransferOwnerToZeroError' (LibOwnableRichErrors.sol#32-38) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/LibRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibRichErrors.sol#52-59) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibRichErrors.sol#52-59)\n\t- LibRichErrors.sol#56-58\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibRichErrors.sol#36-47) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/interfaces/IOwnable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": 9,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n",
                    "message": "IOwnable.transferOwnership (IOwnable.sol#8-9) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IOwnable.sol:\n\t- pragma solidity^0.5.9 (IOwnable.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/utils/contracts/src/interfaces/IAuthorizable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": 9,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n",
                    "message": "IOwnable.transferOwnership (IAuthorizable.sol#8-9) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IAuthorizable.sol:\n\t- pragma solidity^0.5.9 (IAuthorizable.sol#3): it allows old versions\n\t- pragma solidity^0.5.9 (IAuthorizable.sol#32): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/extensions/contracts/src/OrderMatcher/interfaces/IAssets.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IAssets.sol:\n\t- pragma solidity^0.5.9 (IAssets.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/extensions/contracts/src/BalanceThresholdFilter/interfaces/IThresholdAsset.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IThresholdAsset.sol:\n\t- pragma solidity^0.5.9 (IThresholdAsset.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/extensions/contracts/src/BalanceThresholdFilter/interfaces/IBalanceThresholdFilterCore.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IBalanceThresholdFilterCore.sol:\n\t- pragma solidity^0.5.9 (IBalanceThresholdFilterCore.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function executeTransaction(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata signedExchangeTransaction,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata signature\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/test/TestLibFixedMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            SIGNED_VALUE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            n\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UNSIGNED_VALUE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            n\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            BIN_OP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (c > 0 && a < 0 && b < 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                LibFixedMathRichErrors.BinOpErrorCodes.SUBTRACTION_OVERFLOW,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                a,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                b\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 507,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 508,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (c < 0 && a > 0 && b > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                LibFixedMathRichErrors.BinOpErrorCodes.ADDITION_OVERFLOW,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                a,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                b\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_28"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (TestLibFixedMath.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        int256 y;\n",
                    "message": "y in LibFixedMath._exp (TestLibFixedMath.sol#397) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        int256 y;\n",
                    "message": "y in LibFixedMath._ln (TestLibFixedMath.sol#307) is a local variable never initialiazed\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (TestLibFixedMath.sol#38-42)\n\t- TestLibFixedMath.sol#39-41\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestLibFixedMath.sol:\n\t- pragma solidity^0.5.9 (TestLibFixedMath.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibFixedMath.sol#65): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibFixedMath.sol#162): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibFixedMath.sol#537): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (TestLibFixedMath.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 107,
                    "vulnerability_code": "    function SignedValueError(\n\n        ValueErrorCodes error,\n\n        int256 n\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            SIGNED_VALUE_ERROR_SELECTOR,\n\n            uint8(error),\n\n            n\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.SignedValueError' (TestLibFixedMath.sol#94-107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": 122,
                    "vulnerability_code": "    function UnsignedValueError(\n\n        ValueErrorCodes error,\n\n        uint256 n\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UNSIGNED_VALUE_ERROR_SELECTOR,\n\n            uint8(error),\n\n            n\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.UnsignedValueError' (TestLibFixedMath.sol#109-122) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": 139,
                    "vulnerability_code": "    function BinOpError(\n\n        BinOpErrorCodes error,\n\n        int256 a,\n\n        int256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            BIN_OP_ERROR_SELECTOR,\n\n            uint8(error),\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.BinOpError' (TestLibFixedMath.sol#124-139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": 183,
                    "vulnerability_code": "    function _one() internal pure returns (int256 f) {\n\n        f = FIXED_1;\n",
                    "message": "Function 'LibFixedMath._one' (TestLibFixedMath.sol#181-183) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": 188,
                    "vulnerability_code": "    function _add(int256 a, int256 b) internal pure returns (int256 c) {\n\n        c = __add(a, b);\n",
                    "message": "Function 'LibFixedMath._add' (TestLibFixedMath.sol#186-188) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": 193,
                    "vulnerability_code": "    function _sub(int256 a, int256 b) internal pure returns (int256 c) {\n\n        c = __add(a, -b);\n",
                    "message": "Function 'LibFixedMath._sub' (TestLibFixedMath.sol#191-193) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 198,
                    "vulnerability_code": "    function _mul(int256 a, int256 b) internal pure returns (int256 c) {\n\n        c = __mul(a, b) / FIXED_1;\n",
                    "message": "Function 'LibFixedMath._mul' (TestLibFixedMath.sol#196-198) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": 203,
                    "vulnerability_code": "    function _div(int256 a, int256 b) internal pure returns (int256 c) {\n\n        c = __div(__mul(a, FIXED_1), b);\n",
                    "message": "Function 'LibFixedMath._div' (TestLibFixedMath.sol#201-203) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 206,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function _mulDiv(int256 a, int256 n, int256 d) internal pure returns (int256 c) {\n\n        c = __div(__mul(a, n), d);\n",
                    "message": "Function 'LibFixedMath._mulDiv' (TestLibFixedMath.sol#206-208) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": 225,
                    "vulnerability_code": "    function _uintMul(int256 f, uint256 u) internal pure returns (uint256) {\n\n        if (int256(u) < int256(0)) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.UnsignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_LARGE,\n\n                u\n\n            ));\n\n        }\n\n        int256 c = __mul(f, int256(u));\n\n        if (c <= 0) {\n\n            return 0;\n\n        }\n\n        return uint256(uint256(c) >> 127);\n",
                    "message": "Function 'LibFixedMath._uintMul' (TestLibFixedMath.sol#213-225) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": 234,
                    "vulnerability_code": "    function _abs(int256 f) internal pure returns (int256 c) {\n\n        if (f >= 0) {\n\n            c = f;\n\n        } else {\n\n            c = -f;\n\n        }\n",
                    "message": "Function 'LibFixedMath._abs' (TestLibFixedMath.sol#228-234) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": 239,
                    "vulnerability_code": "    function _invert(int256 f) internal pure returns (int256 c) {\n\n        c = __div(FIXED_1_SQUARED, f);\n",
                    "message": "Function 'LibFixedMath._invert' (TestLibFixedMath.sol#237-239) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": 244,
                    "vulnerability_code": "    function _toFixed(int256 n) internal pure returns (int256 f) {\n\n        f = __mul(n, FIXED_1);\n",
                    "message": "Function 'LibFixedMath._toFixed' (TestLibFixedMath.sol#242-244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": 249,
                    "vulnerability_code": "    function _toFixed(int256 n, int256 d) internal pure returns (int256 f) {\n\n        f = __div(__mul(n, FIXED_1), d);\n",
                    "message": "Function 'LibFixedMath._toFixed' (TestLibFixedMath.sol#247-249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": 261,
                    "vulnerability_code": "    function _toFixed(uint256 n) internal pure returns (int256 f) {\n\n        if (int256(n) < int256(0)) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.UnsignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_LARGE,\n\n                n\n\n            ));\n\n        }\n\n        f = __mul(int256(n), FIXED_1);\n",
                    "message": "Function 'LibFixedMath._toFixed' (TestLibFixedMath.sol#253-261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": 279,
                    "vulnerability_code": "    function _toFixed(uint256 n, uint256 d) internal pure returns (int256 f) {\n\n        if (int256(n) < int256(0)) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.UnsignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_LARGE,\n\n                n\n\n            ));\n\n        }\n\n        if (int256(d) < int256(0)) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.UnsignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_LARGE,\n\n                d\n\n            ));\n\n        }\n\n        f = __div(__mul(int256(n), FIXED_1), int256(d));\n",
                    "message": "Function 'LibFixedMath._toFixed' (TestLibFixedMath.sol#265-279) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": 284,
                    "vulnerability_code": "    function _toInteger(int256 f) internal pure returns (int256 n) {\n\n        return f / FIXED_1;\n",
                    "message": "Function 'LibFixedMath._toInteger' (TestLibFixedMath.sol#282-284) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": 372,
                    "vulnerability_code": "    function _ln(int256 x) internal pure returns (int256 r) {\n\n        if (x > LN_MAX_VAL) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.SignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_LARGE,\n\n                x\n\n            ));\n\n        }\n\n        if (x <= 0) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.SignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_SMALL,\n\n                x\n\n            ));\n\n        }\n\n        if (x == FIXED_1) {\n\n            return 0;\n\n        }\n\n        if (x <= LN_MIN_VAL) {\n\n            return EXP_MIN_VAL;\n\n        }\n\n\n\n        int256 y;\n\n        int256 z;\n\n        int256 w;\n\n\n\n        // Rewrite the input as a quotient of negative natural exponents and a single residual q, such that 1 < q < 2\n\n        // For example: log(0.3) = log(e^-1 * e^-0.25 * 1.0471028872385522)\n\n        //              = 1 - 0.25 - log(1 + 0.0471028872385522)\n\n        // e ^ -32\n\n        if (x <= int256(0x00000000000000000000000000000000000000000001c8464f76164760000000)) {\n\n            r -= int256(0x0000000000000000000000000000001000000000000000000000000000000000); // - 32\n\n            x = x * FIXED_1 / int256(0x00000000000000000000000000000000000000000001c8464f76164760000000); // / e ^ -32\n\n        }\n\n        // e ^ -16\n\n        if (x <= int256(0x00000000000000000000000000000000000000f1aaddd7742e90000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000800000000000000000000000000000000); // - 16\n\n            x = x * FIXED_1 / int256(0x00000000000000000000000000000000000000f1aaddd7742e90000000000000); // / e ^ -16\n\n        }\n\n        // e ^ -8\n\n        if (x <= int256(0x00000000000000000000000000000000000afe10820813d78000000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000400000000000000000000000000000000); // - 8\n\n            x = x * FIXED_1 / int256(0x00000000000000000000000000000000000afe10820813d78000000000000000); // / e ^ -8\n\n        }\n\n        // e ^ -4\n\n        if (x <= int256(0x0000000000000000000000000000000002582ab704279ec00000000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000200000000000000000000000000000000); // - 4\n\n            x = x * FIXED_1 / int256(0x0000000000000000000000000000000002582ab704279ec00000000000000000); // / e ^ -4\n\n        }\n\n        // e ^ -2\n\n        if (x <= int256(0x000000000000000000000000000000001152aaa3bf81cc000000000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000100000000000000000000000000000000); // - 2\n\n            x = x * FIXED_1 / int256(0x000000000000000000000000000000001152aaa3bf81cc000000000000000000); // / e ^ -2\n\n        }\n\n        // e ^ -1\n\n        if (x <= int256(0x000000000000000000000000000000002f16ac6c59de70000000000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000080000000000000000000000000000000); // - 1\n\n            x = x * FIXED_1 / int256(0x000000000000000000000000000000002f16ac6c59de70000000000000000000); // / e ^ -1\n\n        }\n\n        // e ^ -0.5\n\n        if (x <= int256(0x000000000000000000000000000000004da2cbf1be5828000000000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000040000000000000000000000000000000); // - 0.5\n\n            x = x * FIXED_1 / int256(0x000000000000000000000000000000004da2cbf1be5828000000000000000000); // / e ^ -0.5\n\n        }\n\n        // e ^ -0.25\n\n        if (x <= int256(0x0000000000000000000000000000000063afbe7ab2082c000000000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000020000000000000000000000000000000); // - 0.25\n\n            x = x * FIXED_1 / int256(0x0000000000000000000000000000000063afbe7ab2082c000000000000000000); // / e ^ -0.25\n\n        }\n\n        // e ^ -0.125\n\n        if (x <= int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d)) {\n\n            r -= int256(0x0000000000000000000000000000000010000000000000000000000000000000); // - 0.125\n\n            x = x * FIXED_1 / int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d); // / e ^ -0.125\n\n        }\n\n        // `x` is now our residual in the range of 1 <= x <= 2 (or close enough).\n\n\n\n        // Add the taylor series for log(1 + z), where z = x - 1\n\n        z = y = x - FIXED_1;\n\n        w = y * y / FIXED_1;\n\n        r += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02\n\n        r += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04\n\n        r += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06\n\n        r += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08\n\n        r += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10\n\n        r += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12\n\n        r += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14\n\n        r += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16\n",
                    "message": "Function 'LibFixedMath._ln' (TestLibFixedMath.sol#287-372) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": 469,
                    "vulnerability_code": "    function _exp(int256 x) internal pure returns (int256 r) {\n\n        if (x < EXP_MIN_VAL) {\n\n            // Saturate to zero below EXP_MIN_VAL.\n\n            return 0;\n\n        }\n\n        if (x == 0) {\n\n            return FIXED_1;\n\n        }\n\n        if (x > EXP_MAX_VAL) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.SignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_LARGE,\n\n                x\n\n            ));\n\n        }\n\n\n\n        // Rewrite the input as a product of natural exponents and a\n\n        // single residual q, where q is a number of small magnitude.\n\n        // For example: e^-34.419 = e^(-32 - 2 - 0.25 - 0.125 - 0.044)\n\n        //              = e^-32 * e^-2 * e^-0.25 * e^-0.125 * e^-0.044\n\n        //              -> q = -0.044\n\n\n\n        // Multiply with the taylor series for e^q\n\n        int256 y;\n\n        int256 z;\n\n        // q = x % 0.125 (the residual)\n\n        z = y = x % 0x0000000000000000000000000000000010000000000000000000000000000000;\n\n        z = z * y / FIXED_1; r += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n\n        z = z * y / FIXED_1; r += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n\n        z = z * y / FIXED_1; r += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n\n        z = z * y / FIXED_1; r += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n\n        z = z * y / FIXED_1; r += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n\n        z = z * y / FIXED_1; r += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n\n        z = z * y / FIXED_1; r += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n\n        z = z * y / FIXED_1; r += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n\n        z = z * y / FIXED_1; r += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n\n        z = z * y / FIXED_1; r += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n\n        z = z * y / FIXED_1; r += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n\n        z = z * y / FIXED_1; r += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n\n        z = z * y / FIXED_1; r += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n\n        z = z * y / FIXED_1; r += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n\n        z = z * y / FIXED_1; r += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n\n        z = z * y / FIXED_1; r += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n\n        z = z * y / FIXED_1; r += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n\n        z = z * y / FIXED_1; r += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n\n        z = z * y / FIXED_1; r += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n\n        r = r / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n\n\n        // Multiply with the non-residual terms.\n\n        x = -x;\n\n        // e ^ -32\n\n        if ((x & int256(0x0000000000000000000000000000001000000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x00000000000000000000000000000000000000f1aaddd7742e56d32fb9f99744)\n\n                / int256(0x0000000000000000000000000043cbaf42a000812488fc5c220ad7b97bf6e99e); // * e ^ -32\n\n        }\n\n        // e ^ -16\n\n        if ((x & int256(0x0000000000000000000000000000000800000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x00000000000000000000000000000000000afe10820813d65dfe6a33c07f738f)\n\n                / int256(0x000000000000000000000000000005d27a9f51c31b7c2f8038212a0574779991); // * e ^ -16\n\n        }\n\n        // e ^ -8\n\n        if ((x & int256(0x0000000000000000000000000000000400000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x0000000000000000000000000000000002582ab704279e8efd15e0265855c47a)\n\n                / int256(0x0000000000000000000000000000001b4c902e273a58678d6d3bfdb93db96d02); // * e ^ -8\n\n        }\n\n        // e ^ -4\n\n        if ((x & int256(0x0000000000000000000000000000000200000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x000000000000000000000000000000001152aaa3bf81cb9fdb76eae12d029571)\n\n                / int256(0x00000000000000000000000000000003b1cc971a9bb5b9867477440d6d157750); // * e ^ -4\n\n        }\n\n        // e ^ -2\n\n        if ((x & int256(0x0000000000000000000000000000000100000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x000000000000000000000000000000002f16ac6c59de6f8d5d6f63c1482a7c86)\n\n                / int256(0x000000000000000000000000000000015bf0a8b1457695355fb8ac404e7a79e3); // * e ^ -2\n\n        }\n\n        // e ^ -1\n\n        if ((x & int256(0x0000000000000000000000000000000080000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x000000000000000000000000000000004da2cbf1be5827f9eb3ad1aa9866ebb3)\n\n                / int256(0x00000000000000000000000000000000d3094c70f034de4b96ff7d5b6f99fcd8); // * e ^ -1\n\n        }\n\n        // e ^ -0.5\n\n        if ((x & int256(0x0000000000000000000000000000000040000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x0000000000000000000000000000000063afbe7ab2082ba1a0ae5e4eb1b479dc)\n\n                / int256(0x00000000000000000000000000000000a45af1e1f40c333b3de1db4dd55f29a7); // * e ^ -0.5\n\n        }\n\n        // e ^ -0.25\n\n        if ((x & int256(0x0000000000000000000000000000000020000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d)\n\n                / int256(0x00000000000000000000000000000000910b022db7ae67ce76b441c27035c6a1); // * e ^ -0.25\n\n        }\n\n        // e ^ -0.125\n\n        if ((x & int256(0x0000000000000000000000000000000010000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x00000000000000000000000000000000783eafef1c0a8f3978c7f81824d62ebf)\n\n                / int256(0x0000000000000000000000000000000088415abbe9a76bead8d00cf112e4d4a8); // * e ^ -0.125\n\n        }\n",
                    "message": "Function 'LibFixedMath._exp' (TestLibFixedMath.sol#375-469) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": 484,
                    "vulnerability_code": "    function __mul(int256 a, int256 b) private pure returns (int256 c) {\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n        c = a * b;\n\n        if (c / a != b) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.MULTIPLICATION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n",
                    "message": "Function 'LibFixedMath.__mul' (TestLibFixedMath.sol#472-484) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 496,
                    "vulnerability_code": "    function __div(int256 a, int256 b) private pure returns (int256 c) {\n\n        if (b == 0) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.DIVISION_BY_ZERO,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        c = a / b;\n",
                    "message": "Function 'LibFixedMath.__div' (TestLibFixedMath.sol#487-496) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": 515,
                    "vulnerability_code": "    function __add(int256 a, int256 b) private pure returns (int256 c) {\n\n        c = a + b;\n\n        if (c > 0 && a < 0 && b < 0) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.SUBTRACTION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        if (c < 0 && a > 0 && b > 0) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.ADDITION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n",
                    "message": "Function 'LibFixedMath.__add' (TestLibFixedMath.sol#499-515) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xed2f26a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xbd79545f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x8c12dfe7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 402,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 403,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 405,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 408,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r = r / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 537,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant FIXED_1 = int256(0x0000000000000000000000000000000080000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant FIXED_1_SQUARED = int256(0x4000000000000000000000000000000000000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant LN_MAX_VAL = FIXED_1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant LN_MIN_VAL = int256(0x0000000000000000000000000000000000000000000000000000000733048c5a);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant EXP_MAX_VAL = 0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant EXP_MIN_VAL = -int256(0x0000000000000000000000000000001ff0000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/test/TestStorageLayout.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(ONLY_OWNER_ERROR_SELECTOR, sender, owner);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 730,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 731,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 732,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Ownable()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {}\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant internal NIL_ADDRESS = 0x0000000000000000000000000000000000000000;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ONLY_OWNER_ERROR_SELECTOR = 0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 429,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 843,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function assertExpectedStorageLayout()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 519,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/ReadOnlyProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(ONLY_OWNER_ERROR_SELECTOR, sender, owner);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 940,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 941,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MISCALCULATED_REWARDS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 942,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            totalRewardsPaid,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            initialContractBalance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 944,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 955,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_EXCHANGE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 956,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 967,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 968,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_ADDRESS_ALREADY_REGISTERED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 969,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 970,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 980,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 981,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_ADDRESS_NOT_REGISTERED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 982,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 983,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 994,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 995,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INSUFFICIENT_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 996,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 997,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 998,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1009,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1010,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1011,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1012,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1013,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1025,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1026,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_OR_MAKER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1027,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1028,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1029,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1030,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1042,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1043,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MAKER_POOL_ASSIGNMENT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1045,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1046,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1047,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            WITHDRAW_AMOUNT_EXCEEDS_MEMBER_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            withdrawAmount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1062,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1073,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            BLOCK_TIMESTAMP_TOO_LOW_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            epochEndTime,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1076,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentBlockTimestamp\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1077,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1087,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1088,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_STAKING_CONTRACT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1089,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1090,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            AMOUNT_EXCEEDS_BALANCE_OF_POOL_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolBalance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_POOL_OPERATOR_SHARE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorShare\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            POOL_ALREADY_EXISTS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_COBB_DOUGLAS_ALPHA_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            numerator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            denominator\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ETH_VAULT_NOT_SET_ERROR_SELECTOR\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            REWARD_VAULT_NOT_SET_ERROR_SELECTOR\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_STAKE_STATUS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            status\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 730,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 731,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 732,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Ownable()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {}\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant internal NIL_ADDRESS = 0x0000000000000000000000000000000000000000;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ONLY_OWNER_ERROR_SELECTOR = 0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 842,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xf7806c4e;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 846,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb56d2df0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc87a78b7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7dc025b0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 858,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x84c8b7c9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x6cfa0c22;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 866,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7d9e1c10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 870,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x69945e3f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 874,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xfc9c065f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 878,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa6bcde47;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 882,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xca1d07a2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x4c5c09dd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 898,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x70f55b5a;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x2a5e4dcf;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 906,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x8f8e73de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 910,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa067f596;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 914,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe6976d70;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 918,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb7161acd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 429,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 519,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/StakingProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MISCALCULATED_REWARDS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            totalRewardsPaid,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            initialContractBalance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_EXCHANGE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_ADDRESS_ALREADY_REGISTERED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_ADDRESS_NOT_REGISTERED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INSUFFICIENT_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_OR_MAKER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MAKER_POOL_ASSIGNMENT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            WITHDRAW_AMOUNT_EXCEEDS_MEMBER_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            withdrawAmount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            BLOCK_TIMESTAMP_TOO_LOW_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            epochEndTime,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentBlockTimestamp\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 315,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_STAKING_CONTRACT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 346,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            AMOUNT_EXCEEDS_BALANCE_OF_POOL_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolBalance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_POOL_OPERATOR_SHARE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 363,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorShare\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            POOL_ALREADY_EXISTS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_COBB_DOUGLAS_ALPHA_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            numerator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 391,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            denominator\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 392,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ETH_VAULT_NOT_SET_ERROR_SELECTOR\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 402,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            REWARD_VAULT_NOT_SET_ERROR_SELECTOR\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_STAKE_STATUS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            status\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(ONLY_OWNER_ERROR_SELECTOR, sender, owner);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 1230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 630,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 631,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Ownable()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _stakingContract, address _readOnlyProxy)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        MixinStorage()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        stakingContract = _stakingContract;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        readOnlyProxyCallee = _stakingContract;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        readOnlyProxy = _readOnlyProxy;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 731,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant internal NIL_ADDRESS = 0x0000000000000000000000000000000000000000;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xf7806c4e;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb56d2df0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc87a78b7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7dc025b0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x84c8b7c9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x6cfa0c22;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7d9e1c10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x69945e3f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xfc9c065f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa6bcde47;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xca1d07a2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x4c5c09dd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x70f55b5a;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x2a5e4dcf;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x8f8e73de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa067f596;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe6976d70;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb7161acd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 587,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ONLY_OWNER_ERROR_SELECTOR = 0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 1402,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract StakingProxy is\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 1456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setReadOnlyMode(bool readOnlyMode)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 583,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 677,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 716,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 858,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 932,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1022,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 486,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/immutable/MixinDeploymentConstants.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MixinDeploymentConstants.sol:\n\t- pragma solidity^0.5.9 (MixinDeploymentConstants.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/immutable/MixinStorage.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(ONLY_OWNER_ERROR_SELECTOR, sender, owner);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 730,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 731,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 732,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Ownable()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {}\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant internal NIL_ADDRESS = 0x0000000000000000000000000000000000000000;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ONLY_OWNER_ERROR_SELECTOR = 0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 429,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 519,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/immutable/MixinConstants.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MixinConstants.sol:\n\t- pragma solidity^0.5.9 (MixinConstants.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (MixinConstants.sol#60): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant internal NIL_ADDRESS = 0x0000000000000000000000000000000000000000;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/stake/MixinStakeStorage.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(ONLY_OWNER_ERROR_SELECTOR, sender, owner);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1098,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1099,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MISCALCULATED_REWARDS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            totalRewardsPaid,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            initialContractBalance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_EXCHANGE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_ADDRESS_ALREADY_REGISTERED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_ADDRESS_NOT_REGISTERED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INSUFFICIENT_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_OR_MAKER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MAKER_POOL_ASSIGNMENT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            WITHDRAW_AMOUNT_EXCEEDS_MEMBER_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            withdrawAmount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            BLOCK_TIMESTAMP_TOO_LOW_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            epochEndTime,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentBlockTimestamp\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_STAKING_CONTRACT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            AMOUNT_EXCEEDS_BALANCE_OF_POOL_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolBalance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_POOL_OPERATOR_SHARE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorShare\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            POOL_ALREADY_EXISTS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_COBB_DOUGLAS_ALPHA_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            numerator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            denominator\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ETH_VAULT_NOT_SET_ERROR_SELECTOR\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            REWARD_VAULT_NOT_SET_ERROR_SELECTOR\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_STAKE_STATUS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            status\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 885,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 479,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 888,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 890,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Ownable()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 891,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1672,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(_zrxVault) != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_ZRX_VAULT\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1675,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1687,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(_zrxVault) != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1688,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_ZRX_VAULT\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1689,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1702,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(_zrxVault) != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1703,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_ZRX_VAULT\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1704,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant internal NIL_ADDRESS = 0x0000000000000000000000000000000000000000;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 436,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ONLY_OWNER_ERROR_SELECTOR = 0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1000,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xf7806c4e;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1004,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb56d2df0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1008,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc87a78b7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1012,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7dc025b0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1016,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x84c8b7c9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1020,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x6cfa0c22;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1024,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7d9e1c10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1028,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x69945e3f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1032,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xfc9c065f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1036,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa6bcde47;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1040,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xca1d07a2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x4c5c09dd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1056,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x70f55b5a;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x2a5e4dcf;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1064,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x8f8e73de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1068,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa067f596;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1072,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe6976d70;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1076,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb7161acd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 1648,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setZrxVault(address zrxVaultAddress)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 622,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 696,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 875,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 995,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1729,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _arePointersEqual(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1912,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/stake/MixinStakeBalances.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(ONLY_OWNER_ERROR_SELECTOR, sender, owner);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1038,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1039,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MISCALCULATED_REWARDS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1040,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            totalRewardsPaid,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1041,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            initialContractBalance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1042,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_EXCHANGE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1066,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_ADDRESS_ALREADY_REGISTERED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1068,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1078,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1079,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_ADDRESS_NOT_REGISTERED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1080,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1081,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1092,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1093,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INSUFFICIENT_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1094,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1096,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_OR_MAKER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MAKER_POOL_ASSIGNMENT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            WITHDRAW_AMOUNT_EXCEEDS_MEMBER_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            withdrawAmount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            BLOCK_TIMESTAMP_TOO_LOW_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            epochEndTime,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentBlockTimestamp\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_STAKING_CONTRACT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            AMOUNT_EXCEEDS_BALANCE_OF_POOL_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolBalance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_POOL_OPERATOR_SHARE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorShare\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            POOL_ALREADY_EXISTS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_COBB_DOUGLAS_ALPHA_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            numerator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            denominator\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ETH_VAULT_NOT_SET_ERROR_SELECTOR\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            REWARD_VAULT_NOT_SET_ERROR_SELECTOR\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_STAKE_STATUS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            status\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 825,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 828,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 829,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 830,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Ownable()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 831,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1612,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1613,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(_zrxVault) != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_ZRX_VAULT\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1615,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1627,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(_zrxVault) != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_ZRX_VAULT\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1629,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1641,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1642,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(_zrxVault) != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1643,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_ZRX_VAULT\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_77"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => IStructs.StoredBalance) internal activeStakeByOwner;\n",
                    "message": "MixinStorage.activeStakeByOwner (MixinStakeBalances.sol#844) is never initialized. It is used in:\n\t- getActiveStake (MixinStakeBalances.sol#1977-1987)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => IStructs.StoredBalance) internal inactiveStakeByOwner;\n",
                    "message": "MixinStorage.inactiveStakeByOwner (MixinStakeBalances.sol#848) is never initialized. It is used in:\n\t- getInactiveStake (MixinStakeBalances.sol#1992-2002)\n\t- _computeWithdrawableStake (MixinStakeBalances.sol#2065-2080)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => IStructs.StoredBalance) internal delegatedStakeByOwner;\n",
                    "message": "MixinStorage.delegatedStakeByOwner (MixinStakeBalances.sol#852) is never initialized. It is used in:\n\t- getStakeDelegatedByOwner (MixinStakeBalances.sol#2018-2028)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 856,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (bytes32 => IStructs.StoredBalance)) internal delegatedStakeToPoolByOwner;\n",
                    "message": "MixinStorage.delegatedStakeToPoolByOwner (MixinStakeBalances.sol#856) is never initialized. It is used in:\n\t- getStakeDelegatedToPoolByOwner (MixinStakeBalances.sol#2034-2044)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 860,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (bytes32 => IStructs.StoredBalance) internal delegatedStakeByPoolId;\n",
                    "message": "MixinStorage.delegatedStakeByPoolId (MixinStakeBalances.sol#860) is never initialized. It is used in:\n\t- getTotalStakeDelegatedToPool (MixinStakeBalances.sol#2049-2059)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 863,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) internal withdrawableStakeByOwner;\n",
                    "message": "MixinStorage.withdrawableStakeByOwner (MixinStakeBalances.sol#863) is never initialized. It is used in:\n\t- getWithdrawableStake (MixinStakeBalances.sol#2007-2013)\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (MixinStakeBalances.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1902,
                    "vulnerability_to_line": 1919,
                    "vulnerability_code": "    function _arePointersEqual(\n\n        // solhint-disable-next-line no-unused-vars\n\n        IStructs.StoredBalance storage balancePtrA,\n\n        // solhint-disable-next-line no-unused-vars\n\n        IStructs.StoredBalance storage balancePtrB\n\n    )\n\n        private\n\n        pure\n\n        returns (bool areEqual)\n\n    {\n\n        assembly {\n\n            areEqual := and(\n\n                eq(balancePtrA_slot, balancePtrB_slot),\n\n                eq(balancePtrA_offset, balancePtrB_offset)\n\n            )\n\n        }\n\n        return areEqual;\n",
                    "message": "MixinStakeStorage._arePointersEqual (MixinStakeBalances.sol#1902-1919) is declared view but contains assembly code\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 1608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _depositFromOwnerIntoZrxVault(address owner, uint256 amount)\n",
                    "message": "MixinZrxVault._depositFromOwnerIntoZrxVault.owner (local variable @ MixinStakeBalances.sol#1608) shadows:\n\t- Ownable.owner (state variable @ MixinStakeBalances.sol#417)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 1622,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdrawToOwnerFromZrxVault(address owner, uint256 amount)\n",
                    "message": "MixinZrxVault._withdrawToOwnerFromZrxVault.owner (local variable @ MixinStakeBalances.sol#1622) shadows:\n\t- Ownable.owner (state variable @ MixinStakeBalances.sol#417)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 1635,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _balanceOfOwnerInZrxVault(address owner)\n",
                    "message": "MixinZrxVault._balanceOfOwnerInZrxVault.owner (local variable @ MixinStakeBalances.sol#1635) shadows:\n\t- Ownable.owner (state variable @ MixinStakeBalances.sol#417)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 1801,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 currentEpoch = getCurrentEpoch();\n",
                    "message": "MixinStakeStorage._loadAndSyncBalance.currentEpoch (local variable @ MixinStakeBalances.sol#1801) shadows:\n\t- MixinStorage.currentEpoch (state variable @ MixinStakeBalances.sol#879)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 1966,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTotalStake(address owner)\n",
                    "message": "MixinStakeBalances.getTotalStake.owner (local variable @ MixinStakeBalances.sol#1966) shadows:\n\t- Ownable.owner (state variable @ MixinStakeBalances.sol#417)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 1977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getActiveStake(address owner)\n",
                    "message": "MixinStakeBalances.getActiveStake.owner (local variable @ MixinStakeBalances.sol#1977) shadows:\n\t- Ownable.owner (state variable @ MixinStakeBalances.sol#417)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 1992,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getInactiveStake(address owner)\n",
                    "message": "MixinStakeBalances.getInactiveStake.owner (local variable @ MixinStakeBalances.sol#1992) shadows:\n\t- Ownable.owner (state variable @ MixinStakeBalances.sol#417)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 2007,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getWithdrawableStake(address owner)\n",
                    "message": "MixinStakeBalances.getWithdrawableStake.owner (local variable @ MixinStakeBalances.sol#2007) shadows:\n\t- Ownable.owner (state variable @ MixinStakeBalances.sol#417)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 2018,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getStakeDelegatedByOwner(address owner)\n",
                    "message": "MixinStakeBalances.getStakeDelegatedByOwner.owner (local variable @ MixinStakeBalances.sol#2018) shadows:\n\t- Ownable.owner (state variable @ MixinStakeBalances.sol#417)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 2034,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getStakeDelegatedToPoolByOwner(address owner, bytes32 poolId)\n",
                    "message": "MixinStakeBalances.getStakeDelegatedToPoolByOwner.owner (local variable @ MixinStakeBalances.sol#2034) shadows:\n\t- Ownable.owner (state variable @ MixinStakeBalances.sol#417)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 2065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _computeWithdrawableStake(address owner, uint256 lastStoredWithdrawableStake)\n",
                    "message": "MixinStakeBalances._computeWithdrawableStake.owner (local variable @ MixinStakeBalances.sol#2065) shadows:\n\t- Ownable.owner (state variable @ MixinStakeBalances.sol#417)\n"
                },
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 1526,
                    "vulnerability_to_line": 1554,
                    "vulnerability_code": "    function _goToNextEpoch()\n\n        internal\n\n    {\n\n        // get current timestamp\n\n        // solhint-disable-next-line not-rely-on-time\n\n        uint256 currentBlockTimestamp = block.timestamp;\n\n\n\n        // validate that we can increment the current epoch\n\n        uint256 epochEndTime = getCurrentEpochEarliestEndTimeInSeconds();\n\n        if (epochEndTime > currentBlockTimestamp) {\n\n            LibRichErrors.rrevert(LibStakingRichErrors.BlockTimestampTooLowError(\n\n                epochEndTime,\n\n                currentBlockTimestamp\n\n            ));\n\n        }\n\n\n\n        // incremment epoch\n\n        uint256 nextEpoch = currentEpoch.safeAdd(1);\n\n        currentEpoch = nextEpoch;\n\n        currentEpochStartTimeInSeconds = currentBlockTimestamp;\n\n        uint256 earliestEndTimeInSeconds = currentEpochStartTimeInSeconds.safeAdd(getEpochDurationInSeconds());\n\n\n\n        // notify of epoch change\n\n        emit EpochChanged(\n\n            currentEpoch,\n\n            currentEpochStartTimeInSeconds,\n\n            earliestEndTimeInSeconds\n\n        );\n",
                    "message": "MixinScheduler._goToNextEpoch (MixinStakeBalances.sol#1526-1554) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- epochEndTime > currentBlockTimestamp (MixinStakeBalances.sol#1535-1540)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (MixinStakeBalances.sol#38-42)\n\t- MixinStakeBalances.sol#39-41\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1902,
                    "vulnerability_to_line": 1919,
                    "vulnerability_code": "    function _arePointersEqual(\n\n        // solhint-disable-next-line no-unused-vars\n\n        IStructs.StoredBalance storage balancePtrA,\n\n        // solhint-disable-next-line no-unused-vars\n\n        IStructs.StoredBalance storage balancePtrB\n\n    )\n\n        private\n\n        pure\n\n        returns (bool areEqual)\n\n    {\n\n        assembly {\n\n            areEqual := and(\n\n                eq(balancePtrA_slot, balancePtrB_slot),\n\n                eq(balancePtrA_offset, balancePtrB_offset)\n\n            )\n\n        }\n\n        return areEqual;\n",
                    "message": "MixinStakeStorage._arePointersEqual uses assembly (MixinStakeBalances.sol#1902-1919)\n\t- MixinStakeBalances.sol#1912-1917\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 912,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal cobbDouglasAlphaDenomintor = 6;\n",
                    "message": "MixinStorage.cobbDouglasAlphaDenomintor should be constant (MixinStakeBalances.sol#912)\nMixinStorage.cobbDouglasAlphaNumerator should be constant (MixinStakeBalances.sol#909)\nMixinStorage.nextPoolId should be constant (MixinStakeBalances.sol#866)\nMixinStorage.readOnlyProxy should be constant (MixinStakeBalances.sol#837)\nMixinStorage.readOnlyProxyCallee should be constant (MixinStakeBalances.sol#840)\nMixinStorage.stakingContract should be constant (MixinStakeBalances.sol#834)\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in MixinStakeBalances.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- MixinStakeBalances.sol#21 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#47 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#80 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#163 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#272 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#311 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#357 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#372 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#410 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#466 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#562 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#636 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#815 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#935 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#1308 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#1458 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#1577 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#1669 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#1729 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#1942 declares pragma solidity^0.5.9\n\t- MixinStakeBalances.sol#1943 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public;\n",
                    "message": "IOwnable.transferOwnership (MixinStakeBalances.sol#367) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": 437,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        if (newOwner == address(0)) {\n\n            LibRichErrors.rrevert(LibOwnableRichErrors.TransferOwnerToZeroError());\n\n        } else {\n\n            owner = newOwner;\n\n            emit OwnershipTransferred(msg.sender, newOwner);\n\n        }\n",
                    "message": "Ownable.transferOwnership (MixinStakeBalances.sol#430-437) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1597,
                    "vulnerability_to_line": 1603,
                    "vulnerability_code": "    function getZrxVault()\n\n        public\n\n        view\n\n        returns (address)\n\n    {\n\n        return address(zrxVault);\n",
                    "message": "MixinZrxVault.getZrxVault (MixinStakeBalances.sol#1597-1603) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1966,
                    "vulnerability_to_line": 1972,
                    "vulnerability_code": "    function getTotalStake(address owner)\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        return _balanceOfOwnerInZrxVault(owner);\n",
                    "message": "MixinStakeBalances.getTotalStake (MixinStakeBalances.sol#1966-1972) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1977,
                    "vulnerability_to_line": 1987,
                    "vulnerability_code": "    function getActiveStake(address owner)\n\n        public\n\n        view\n\n        returns (IStructs.StakeBalance memory balance)\n\n    {\n\n        IStructs.StoredBalance memory storedBalance = _loadAndSyncBalance(activeStakeByOwner[owner]);\n\n        return IStructs.StakeBalance({\n\n            currentEpochBalance: storedBalance.currentEpochBalance,\n\n            nextEpochBalance: storedBalance.nextEpochBalance\n\n        });\n",
                    "message": "MixinStakeBalances.getActiveStake (MixinStakeBalances.sol#1977-1987) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1992,
                    "vulnerability_to_line": 2002,
                    "vulnerability_code": "    function getInactiveStake(address owner)\n\n        public\n\n        view\n\n        returns (IStructs.StakeBalance memory balance)\n\n    {\n\n        IStructs.StoredBalance memory storedBalance = _loadAndSyncBalance(inactiveStakeByOwner[owner]);\n\n        return IStructs.StakeBalance({\n\n            currentEpochBalance: storedBalance.currentEpochBalance,\n\n            nextEpochBalance: storedBalance.nextEpochBalance\n\n        });\n",
                    "message": "MixinStakeBalances.getInactiveStake (MixinStakeBalances.sol#1992-2002) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2007,
                    "vulnerability_to_line": 2013,
                    "vulnerability_code": "    function getWithdrawableStake(address owner)\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        return _computeWithdrawableStake(owner, withdrawableStakeByOwner[owner]);\n",
                    "message": "MixinStakeBalances.getWithdrawableStake (MixinStakeBalances.sol#2007-2013) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2018,
                    "vulnerability_to_line": 2028,
                    "vulnerability_code": "    function getStakeDelegatedByOwner(address owner)\n\n        public\n\n        view\n\n        returns (IStructs.StakeBalance memory balance)\n\n    {\n\n        IStructs.StoredBalance memory storedBalance = _loadAndSyncBalance(delegatedStakeByOwner[owner]);\n\n        return IStructs.StakeBalance({\n\n            currentEpochBalance: storedBalance.currentEpochBalance,\n\n            nextEpochBalance: storedBalance.nextEpochBalance\n\n        });\n",
                    "message": "MixinStakeBalances.getStakeDelegatedByOwner (MixinStakeBalances.sol#2018-2028) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2034,
                    "vulnerability_to_line": 2044,
                    "vulnerability_code": "    function getStakeDelegatedToPoolByOwner(address owner, bytes32 poolId)\n\n        public\n\n        view\n\n        returns (IStructs.StakeBalance memory balance)\n\n    {\n\n        IStructs.StoredBalance memory storedBalance = _loadAndSyncBalance(delegatedStakeToPoolByOwner[owner][poolId]);\n\n        return IStructs.StakeBalance({\n\n            currentEpochBalance: storedBalance.currentEpochBalance,\n\n            nextEpochBalance: storedBalance.nextEpochBalance\n\n        });\n",
                    "message": "MixinStakeBalances.getStakeDelegatedToPoolByOwner (MixinStakeBalances.sol#2034-2044) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2049,
                    "vulnerability_to_line": 2059,
                    "vulnerability_code": "    function getTotalStakeDelegatedToPool(bytes32 poolId)\n\n        public\n\n        view\n\n        returns (IStructs.StakeBalance memory balance)\n\n    {\n\n        IStructs.StoredBalance memory storedBalance = _loadAndSyncBalance(delegatedStakeByPoolId[poolId]);\n\n        return IStructs.StakeBalance({\n\n            currentEpochBalance: storedBalance.currentEpochBalance,\n\n            nextEpochBalance: storedBalance.nextEpochBalance\n\n        });\n",
                    "message": "MixinStakeBalances.getTotalStakeDelegatedToPool (MixinStakeBalances.sol#2049-2059) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MixinStakeBalances.sol:\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#47): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#80): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#163): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#272): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#311): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#357): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#372): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#410): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#466): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#562): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#636): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#815): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#935): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#1308): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#1458): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#1577): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#1669): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#1729): it allows old versions\n\t- pragma solidity^0.5.9 (MixinStakeBalances.sol#1942): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (MixinStakeBalances.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "    function Uint256BinOpError(BinOpErrorCodes errorCode, uint256 a, uint256 b) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (MixinStakeBalances.sol#69-71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": 75,
                    "vulnerability_code": "    function Uint256DowncastError(DowncastErrorCodes errorCode, uint256 a) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (MixinStakeBalances.sol#73-75) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": 383,
                    "vulnerability_code": "    function OnlyOwnerError(address sender, address owner) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(ONLY_OWNER_ERROR_SELECTOR, sender, owner);\n",
                    "message": "Function 'LibOwnableRichErrors.OnlyOwnerError' (MixinStakeBalances.sol#381-383) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": 387,
                    "vulnerability_code": "    function TransferOwnerToZeroError() internal pure returns (bytes memory) {\n\n        return TRANSFER_OWNER_TO_ZERO_ERROR_BYTES;\n",
                    "message": "Function 'LibOwnableRichErrors.TransferOwnerToZeroError' (MixinStakeBalances.sol#385-387) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 439,
                    "vulnerability_to_line": 443,
                    "vulnerability_code": "    function _assertSenderIsOwner() internal view {\n\n        if (msg.sender != owner) {\n\n            LibRichErrors.rrevert(LibOwnableRichErrors.OnlyOwnerError(msg.sender, owner));\n\n        }\n",
                    "message": "Function 'Ownable._assertSenderIsOwner' (MixinStakeBalances.sol#439-443) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1030,
                    "vulnerability_to_line": 1043,
                    "vulnerability_code": "    function MiscalculatedRewardsError(\n\n        uint256 totalRewardsPaid,\n\n        uint256 initialContractBalance\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            MISCALCULATED_REWARDS_ERROR_SELECTOR,\n\n            totalRewardsPaid,\n\n            initialContractBalance\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.MiscalculatedRewardsError' (MixinStakeBalances.sol#1030-1043) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1045,
                    "vulnerability_to_line": 1056,
                    "vulnerability_code": "    function OnlyCallableByExchangeError(\n\n        address senderAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_CALLABLE_BY_EXCHANGE_ERROR_SELECTOR,\n\n            senderAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableByExchangeError' (MixinStakeBalances.sol#1045-1056) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": 1069,
                    "vulnerability_code": "    function ExchangeAddressAlreadyRegisteredError(\n\n        address exchangeAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            EXCHANGE_ADDRESS_ALREADY_REGISTERED_ERROR_SELECTOR,\n\n            exchangeAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.ExchangeAddressAlreadyRegisteredError' (MixinStakeBalances.sol#1058-1069) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1071,
                    "vulnerability_to_line": 1082,
                    "vulnerability_code": "    function ExchangeAddressNotRegisteredError(\n\n        address exchangeAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            EXCHANGE_ADDRESS_NOT_REGISTERED_ERROR_SELECTOR,\n\n            exchangeAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.ExchangeAddressNotRegisteredError' (MixinStakeBalances.sol#1071-1082) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1084,
                    "vulnerability_to_line": 1097,
                    "vulnerability_code": "    function InsufficientBalanceError(\n\n        uint256 amount,\n\n        uint256 balance\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INSUFFICIENT_BALANCE_ERROR_SELECTOR,\n\n            amount,\n\n            balance\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.InsufficientBalanceError' (MixinStakeBalances.sol#1084-1097) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1099,
                    "vulnerability_to_line": 1112,
                    "vulnerability_code": "    function OnlyCallableByPoolOperatorError(\n\n        address senderAddress,\n\n        address poolOperatorAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_CALLABLE_BY_POOL_OPERATOR_ERROR_SELECTOR,\n\n            senderAddress,\n\n            poolOperatorAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableByPoolOperatorError' (MixinStakeBalances.sol#1099-1112) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1114,
                    "vulnerability_to_line": 1129,
                    "vulnerability_code": "    function OnlyCallableByPoolOperatorOrMakerError(\n\n        address senderAddress,\n\n        address poolOperatorAddress,\n\n        address makerAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_CALLABLE_BY_POOL_OPERATOR_OR_MAKER_ERROR_SELECTOR,\n\n            senderAddress,\n\n            poolOperatorAddress,\n\n            makerAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableByPoolOperatorOrMakerError' (MixinStakeBalances.sol#1114-1129) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1131,
                    "vulnerability_to_line": 1146,
                    "vulnerability_code": "    function MakerPoolAssignmentError(\n\n        MakerPoolAssignmentErrorCodes errorCode,\n\n        address makerAddress,\n\n        bytes32 poolId\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            MAKER_POOL_ASSIGNMENT_ERROR_SELECTOR,\n\n            errorCode,\n\n            makerAddress,\n\n            poolId\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.MakerPoolAssignmentError' (MixinStakeBalances.sol#1131-1146) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1148,
                    "vulnerability_to_line": 1161,
                    "vulnerability_code": "    function WithdrawAmountExceedsMemberBalanceError(\n\n        uint256 withdrawAmount,\n\n        uint256 balance\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            WITHDRAW_AMOUNT_EXCEEDS_MEMBER_BALANCE_ERROR_SELECTOR,\n\n            withdrawAmount,\n\n            balance\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.WithdrawAmountExceedsMemberBalanceError' (MixinStakeBalances.sol#1148-1161) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1163,
                    "vulnerability_to_line": 1176,
                    "vulnerability_code": "    function BlockTimestampTooLowError(\n\n        uint256 epochEndTime,\n\n        uint256 currentBlockTimestamp\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            BLOCK_TIMESTAMP_TOO_LOW_ERROR_SELECTOR,\n\n            epochEndTime,\n\n            currentBlockTimestamp\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.BlockTimestampTooLowError' (MixinStakeBalances.sol#1163-1176) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1178,
                    "vulnerability_to_line": 1189,
                    "vulnerability_code": "    function OnlyCallableByStakingContractError(\n\n        address senderAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_CALLABLE_BY_STAKING_CONTRACT_ERROR_SELECTOR,\n\n            senderAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableByStakingContractError' (MixinStakeBalances.sol#1178-1189) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1191,
                    "vulnerability_to_line": 1197,
                    "vulnerability_code": "    function OnlyCallableIfInCatastrophicFailureError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ONLY_CALLABLE_IF_IN_CATASTROPHIC_FAILURE_ERROR;\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableIfInCatastrophicFailureError' (MixinStakeBalances.sol#1191-1197) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1199,
                    "vulnerability_to_line": 1205,
                    "vulnerability_code": "    function OnlyCallableIfNotInCatastrophicFailureError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ONLY_CALLABLE_IF_NOT_IN_CATASTROPHIC_FAILURE_ERROR;\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableIfNotInCatastrophicFailureError' (MixinStakeBalances.sol#1199-1205) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1207,
                    "vulnerability_to_line": 1220,
                    "vulnerability_code": "    function AmountExceedsBalanceOfPoolError(\n\n        uint256 amount,\n\n        uint96 poolBalance\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            AMOUNT_EXCEEDS_BALANCE_OF_POOL_ERROR_SELECTOR,\n\n            amount,\n\n            poolBalance\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.AmountExceedsBalanceOfPoolError' (MixinStakeBalances.sol#1207-1220) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1222,
                    "vulnerability_to_line": 1235,
                    "vulnerability_code": "    function InvalidPoolOperatorShareError(\n\n        bytes32 poolId,\n\n        uint32 poolOperatorShare\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_POOL_OPERATOR_SHARE_ERROR_SELECTOR,\n\n            poolId,\n\n            poolOperatorShare\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.InvalidPoolOperatorShareError' (MixinStakeBalances.sol#1222-1235) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1237,
                    "vulnerability_to_line": 1248,
                    "vulnerability_code": "    function PoolAlreadyExistsError(\n\n        bytes32 poolId\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            POOL_ALREADY_EXISTS_ERROR_SELECTOR,\n\n            poolId\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.PoolAlreadyExistsError' (MixinStakeBalances.sol#1237-1248) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1250,
                    "vulnerability_to_line": 1263,
                    "vulnerability_code": "    function InvalidCobbDouglasAlphaError(\n\n        uint256 numerator,\n\n        uint256 denominator\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_COBB_DOUGLAS_ALPHA_ERROR_SELECTOR,\n\n            numerator,\n\n            denominator\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.InvalidCobbDouglasAlphaError' (MixinStakeBalances.sol#1250-1263) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1265,
                    "vulnerability_to_line": 1273,
                    "vulnerability_code": "    function EthVaultNotSetError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ETH_VAULT_NOT_SET_ERROR_SELECTOR\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.EthVaultNotSetError' (MixinStakeBalances.sol#1265-1273) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1275,
                    "vulnerability_to_line": 1283,
                    "vulnerability_code": "    function RewardVaultNotSetError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            REWARD_VAULT_NOT_SET_ERROR_SELECTOR\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.RewardVaultNotSetError' (MixinStakeBalances.sol#1275-1283) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1285,
                    "vulnerability_to_line": 1294,
                    "vulnerability_code": "    function InvalidStakeStatusError(uint256 status)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_STAKE_STATUS_ERROR_SELECTOR,\n\n            status\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.InvalidStakeStatusError' (MixinStakeBalances.sol#1285-1294) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": 1302,
                    "vulnerability_code": "    function ProxyDestinationCannotBeNil()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return PROXY_DESTINATION_CANNOT_BE_NIL;\n",
                    "message": "Function 'LibStakingRichErrors.ProxyDestinationCannotBeNil' (MixinStakeBalances.sol#1296-1302) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1526,
                    "vulnerability_to_line": 1554,
                    "vulnerability_code": "    function _goToNextEpoch()\n\n        internal\n\n    {\n\n        // get current timestamp\n\n        // solhint-disable-next-line not-rely-on-time\n\n        uint256 currentBlockTimestamp = block.timestamp;\n\n\n\n        // validate that we can increment the current epoch\n\n        uint256 epochEndTime = getCurrentEpochEarliestEndTimeInSeconds();\n\n        if (epochEndTime > currentBlockTimestamp) {\n\n            LibRichErrors.rrevert(LibStakingRichErrors.BlockTimestampTooLowError(\n\n                epochEndTime,\n\n                currentBlockTimestamp\n\n            ));\n\n        }\n\n\n\n        // incremment epoch\n\n        uint256 nextEpoch = currentEpoch.safeAdd(1);\n\n        currentEpoch = nextEpoch;\n\n        currentEpochStartTimeInSeconds = currentBlockTimestamp;\n\n        uint256 earliestEndTimeInSeconds = currentEpochStartTimeInSeconds.safeAdd(getEpochDurationInSeconds());\n\n\n\n        // notify of epoch change\n\n        emit EpochChanged(\n\n            currentEpoch,\n\n            currentEpochStartTimeInSeconds,\n\n            earliestEndTimeInSeconds\n\n        );\n",
                    "message": "Function 'MixinScheduler._goToNextEpoch' (MixinStakeBalances.sol#1526-1554) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1608,
                    "vulnerability_to_line": 1617,
                    "vulnerability_code": "    function _depositFromOwnerIntoZrxVault(address owner, uint256 amount)\n\n        internal\n\n    {\n\n        IZrxVault _zrxVault = zrxVault;\n\n        require(\n\n            address(_zrxVault) != address(0),\n\n            \"INVALID_ZRX_VAULT\"\n\n        );\n\n        _zrxVault.depositFrom(owner, amount);\n",
                    "message": "Function 'MixinZrxVault._depositFromOwnerIntoZrxVault' (MixinStakeBalances.sol#1608-1617) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1622,
                    "vulnerability_to_line": 1631,
                    "vulnerability_code": "    function _withdrawToOwnerFromZrxVault(address owner, uint256 amount)\n\n        internal\n\n    {\n\n        IZrxVault _zrxVault = zrxVault;\n\n        require(\n\n            address(_zrxVault) != address(0),\n\n            \"INVALID_ZRX_VAULT\"\n\n        );\n\n        _zrxVault.withdrawFrom(owner, amount);\n",
                    "message": "Function 'MixinZrxVault._withdrawToOwnerFromZrxVault' (MixinStakeBalances.sol#1622-1631) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1635,
                    "vulnerability_to_line": 1646,
                    "vulnerability_code": "    function _balanceOfOwnerInZrxVault(address owner)\n\n        internal\n\n        view\n\n        returns (uint256)\n\n    {\n\n        IZrxVault _zrxVault = zrxVault;\n\n        require(\n\n            address(_zrxVault) != address(0),\n\n            \"INVALID_ZRX_VAULT\"\n\n        );\n\n        return _zrxVault.balanceOf(owner);\n",
                    "message": "Function 'MixinZrxVault._balanceOfOwnerInZrxVault' (MixinStakeBalances.sol#1635-1646) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1752,
                    "vulnerability_to_line": 1785,
                    "vulnerability_code": "    function _moveStake(\n\n        IStructs.StoredBalance storage fromPtr,\n\n        IStructs.StoredBalance storage toPtr,\n\n        uint256 amount\n\n    )\n\n        internal\n\n    {\n\n        // do nothing if pointers are equal\n\n        if (_arePointersEqual(fromPtr, toPtr)) {\n\n            return;\n\n        }\n\n\n\n        // load balance from storage and synchronize it\n\n        IStructs.StoredBalance memory from = _loadAndSyncBalance(fromPtr);\n\n        IStructs.StoredBalance memory to = _loadAndSyncBalance(toPtr);\n\n\n\n        // sanity check on balance\n\n        if (amount > from.nextEpochBalance) {\n\n            LibRichErrors.rrevert(\n\n                LibStakingRichErrors.InsufficientBalanceError(\n\n                    amount,\n\n                    from.nextEpochBalance\n\n                )\n\n            );\n\n        }\n\n\n\n        // move stake for next epoch\n\n        from.nextEpochBalance = uint256(from.nextEpochBalance).safeSub(amount).downcastToUint96();\n\n        to.nextEpochBalance = uint256(to.nextEpochBalance).safeAdd(amount).downcastToUint96();\n\n\n\n        // update state in storage\n\n        _storeBalance(fromPtr, from);\n\n        _storeBalance(toPtr, to);\n",
                    "message": "Function 'MixinStakeStorage._moveStake' (MixinStakeBalances.sol#1752-1785) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1793,
                    "vulnerability_to_line": 1807,
                    "vulnerability_code": "    function _loadAndSyncBalance(IStructs.StoredBalance storage balancePtr)\n\n        internal\n\n        view\n\n        returns (IStructs.StoredBalance memory balance)\n\n    {\n\n        // load from storage\n\n        balance = balancePtr;\n\n        // sync\n\n        uint256 currentEpoch = getCurrentEpoch();\n\n        if (currentEpoch > balance.currentEpoch) {\n\n            balance.currentEpoch = currentEpoch.downcastToUint64();\n\n            balance.currentEpochBalance = balance.nextEpochBalance;\n\n        }\n\n        return balance;\n",
                    "message": "Function 'MixinStakeStorage._loadAndSyncBalance' (MixinStakeBalances.sol#1793-1807) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1815,
                    "vulnerability_to_line": 1822,
                    "vulnerability_code": "    function _loadUnsyncedBalance(IStructs.StoredBalance storage balancePtr)\n\n        internal\n\n        view\n\n        returns (IStructs.StoredBalance memory balance)\n\n    {\n\n        balance = balancePtr;\n\n        return balance;\n",
                    "message": "Function 'MixinStakeStorage._loadUnsyncedBalance' (MixinStakeBalances.sol#1815-1822) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1827,
                    "vulnerability_to_line": 1837,
                    "vulnerability_code": "    function _incrementCurrentAndNextBalance(IStructs.StoredBalance storage balancePtr, uint256 amount)\n\n        internal\n\n    {\n\n        // Remove stake from balance\n\n        IStructs.StoredBalance memory balance = _loadAndSyncBalance(balancePtr);\n\n        balance.nextEpochBalance = uint256(balance.nextEpochBalance).safeAdd(amount).downcastToUint96();\n\n        balance.currentEpochBalance = uint256(balance.currentEpochBalance).safeAdd(amount).downcastToUint96();\n\n\n\n        // update state\n\n        _storeBalance(balancePtr, balance);\n",
                    "message": "Function 'MixinStakeStorage._incrementCurrentAndNextBalance' (MixinStakeBalances.sol#1827-1837) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1842,
                    "vulnerability_to_line": 1852,
                    "vulnerability_code": "    function _decrementCurrentAndNextBalance(IStructs.StoredBalance storage balancePtr, uint256 amount)\n\n        internal\n\n    {\n\n        // Remove stake from balance\n\n        IStructs.StoredBalance memory balance = _loadAndSyncBalance(balancePtr);\n\n        balance.nextEpochBalance = uint256(balance.nextEpochBalance).safeSub(amount).downcastToUint96();\n\n        balance.currentEpochBalance = uint256(balance.currentEpochBalance).safeSub(amount).downcastToUint96();\n\n\n\n        // update state\n\n        _storeBalance(balancePtr, balance);\n",
                    "message": "Function 'MixinStakeStorage._decrementCurrentAndNextBalance' (MixinStakeBalances.sol#1842-1852) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1857,
                    "vulnerability_to_line": 1866,
                    "vulnerability_code": "    function _incrementNextBalance(IStructs.StoredBalance storage balancePtr, uint256 amount)\n\n        internal\n\n    {\n\n        // Add stake to balance\n\n        IStructs.StoredBalance memory balance = _loadAndSyncBalance(balancePtr);\n\n        balance.nextEpochBalance = uint256(balance.nextEpochBalance).safeAdd(amount).downcastToUint96();\n\n\n\n        // update state\n\n        _storeBalance(balancePtr, balance);\n",
                    "message": "Function 'MixinStakeStorage._incrementNextBalance' (MixinStakeBalances.sol#1857-1866) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1871,
                    "vulnerability_to_line": 1880,
                    "vulnerability_code": "    function _decrementNextBalance(IStructs.StoredBalance storage balancePtr, uint256 amount)\n\n        internal\n\n    {\n\n        // Remove stake from balance\n\n        IStructs.StoredBalance memory balance = _loadAndSyncBalance(balancePtr);\n\n        balance.nextEpochBalance = uint256(balance.nextEpochBalance).safeSub(amount).downcastToUint96();\n\n\n\n        // update state\n\n        _storeBalance(balancePtr, balance);\n",
                    "message": "Function 'MixinStakeStorage._decrementNextBalance' (MixinStakeBalances.sol#1871-1880) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1885,
                    "vulnerability_to_line": 1896,
                    "vulnerability_code": "    function _storeBalance(\n\n        IStructs.StoredBalance storage balancePtr,\n\n        IStructs.StoredBalance memory balance\n\n    )\n\n        private\n\n    {\n\n        // note - this compresses into a single `sstore` when optimizations are enabled,\n\n        // since the StakeBalance struct occupies a single word of storage.\n\n        balancePtr.currentEpoch = balance.currentEpoch;\n\n        balancePtr.nextEpochBalance = balance.nextEpochBalance;\n\n        balancePtr.currentEpochBalance = balance.currentEpochBalance;\n",
                    "message": "Function 'MixinStakeStorage._storeBalance' (MixinStakeBalances.sol#1885-1896) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1902,
                    "vulnerability_to_line": 1919,
                    "vulnerability_code": "    function _arePointersEqual(\n\n        // solhint-disable-next-line no-unused-vars\n\n        IStructs.StoredBalance storage balancePtrA,\n\n        // solhint-disable-next-line no-unused-vars\n\n        IStructs.StoredBalance storage balancePtrB\n\n    )\n\n        private\n\n        pure\n\n        returns (bool areEqual)\n\n    {\n\n        assembly {\n\n            areEqual := and(\n\n                eq(balancePtrA_slot, balancePtrB_slot),\n\n                eq(balancePtrA_offset, balancePtrB_offset)\n\n            )\n\n        }\n\n        return areEqual;\n",
                    "message": "Function 'MixinStakeStorage._arePointersEqual' (MixinStakeBalances.sol#1902-1919) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2065,
                    "vulnerability_to_line": 2080,
                    "vulnerability_code": "    function _computeWithdrawableStake(address owner, uint256 lastStoredWithdrawableStake)\n\n        internal\n\n        view\n\n        returns (uint256)\n\n    {\n\n        // stake cannot be withdrawn if it has been reallocated for the `next` epoch;\n\n        // so the upper bound of withdrawable stake is always limited by the value of `next`.\n\n        IStructs.StoredBalance memory storedBalance = _loadUnsyncedBalance(inactiveStakeByOwner[owner]);\n\n        if (storedBalance.currentEpoch == currentEpoch) {\n\n            return LibSafeMath.min256(storedBalance.nextEpochBalance, lastStoredWithdrawableStake);\n\n        } else if (uint256(storedBalance.currentEpoch).safeAdd(1) == currentEpoch) {\n\n            return LibSafeMath.min256(storedBalance.nextEpochBalance, storedBalance.currentEpochBalance);\n\n        } else {\n\n            return storedBalance.nextEpochBalance;\n\n        }\n",
                    "message": "Function 'MixinStakeBalances._computeWithdrawableStake' (MixinStakeBalances.sol#2065-2080) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant internal TIMELOCK_DURATION_IN_EPOCHS = 3;\n",
                    "message": "MixinDeploymentConstants.TIMELOCK_DURATION_IN_EPOCHS (MixinStakeBalances.sol#281) is never used in MixinStakeBalances\nMixinDeploymentConstants.REWARD_DELEGATED_STAKE_WEIGHT (MixinStakeBalances.sol#284) is never used in MixinStakeBalances\nMixinDeploymentConstants.CHAIN_ID (MixinStakeBalances.sol#286) is never used in MixinStakeBalances\nMixinDeploymentConstants.MAX_MAKERS_IN_POOL (MixinStakeBalances.sol#288) is never used in MixinStakeBalances\nMixinConstants.PPM_DENOMINATOR (MixinStakeBalances.sol#316) is never used in MixinStakeBalances\nMixinConstants.INITIAL_POOL_ID (MixinStakeBalances.sol#319) is never used in MixinStakeBalances\nMixinConstants.POOL_ID_INCREMENT_AMOUNT (MixinStakeBalances.sol#322) is never used in MixinStakeBalances\nMixinConstants.NIL_POOL_ID (MixinStakeBalances.sol#324) is never used in MixinStakeBalances\nMixinConstants.NIL_ADDRESS (MixinStakeBalances.sol#326) is never used in MixinStakeBalances\nMixinConstants.UNKNOWN_STAKING_POOL_ID (MixinStakeBalances.sol#328) is never used in MixinStakeBalances\nMixinConstants.INITIAL_EPOCH (MixinStakeBalances.sol#330) is never used in MixinStakeBalances\nMixinConstants.INITIAL_TIMELOCK_PERIOD (MixinStakeBalances.sol#332) is never used in MixinStakeBalances\nMixinConstants.MIN_TOKEN_VALUE (MixinStakeBalances.sol#334) is never used in MixinStakeBalances\nMixinStorage.stakingContract (MixinStakeBalances.sol#834) is never used in MixinStakeBalances\nMixinStorage.readOnlyProxy (MixinStakeBalances.sol#837) is never used in MixinStakeBalances\nMixinStorage.readOnlyProxyCallee (MixinStakeBalances.sol#840) is never used in MixinStakeBalances\nMixinStorage.nextPoolId (MixinStakeBalances.sol#866) is never used in MixinStakeBalances\nMixinStorage.poolById (MixinStakeBalances.sol#869) is never used in MixinStakeBalances\nMixinStorage.poolJoinedByMakerAddress (MixinStakeBalances.sol#873) is never used in MixinStakeBalances\nMixinStorage.numMakersByPoolId (MixinStakeBalances.sol#876) is never used in MixinStakeBalances\nMixinStorage.protocolFeesThisEpochByPool (MixinStakeBalances.sol#885) is never used in MixinStakeBalances\nMixinStorage.activePoolsThisEpoch (MixinStakeBalances.sol#888) is never used in MixinStakeBalances\nMixinStorage.cumulativeRewardsByPool (MixinStakeBalances.sol#891) is never used in MixinStakeBalances\nMixinStorage.cumulativeRewardsByPoolLastStored (MixinStakeBalances.sol#894) is never used in MixinStakeBalances\nMixinStorage.validExchanges (MixinStakeBalances.sol#897) is never used in MixinStakeBalances\nMixinStorage.ethVault (MixinStakeBalances.sol#903) is never used in MixinStakeBalances\nMixinStorage.rewardVault (MixinStakeBalances.sol#906) is never used in MixinStakeBalances\nMixinStorage.cobbDouglasAlphaNumerator (MixinStakeBalances.sol#909) is never used in MixinStakeBalances\nMixinStorage.cobbDouglasAlphaDenomintor (MixinStakeBalances.sol#912) is never used in MixinStakeBalances\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 326,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant internal NIL_ADDRESS = 0x0000000000000000000000000000000000000000;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ONLY_OWNER_ERROR_SELECTOR = 0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 940,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xf7806c4e;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 944,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb56d2df0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 948,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc87a78b7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 952,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7dc025b0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 956,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x84c8b7c9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 960,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x6cfa0c22;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 964,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7d9e1c10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 968,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x69945e3f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 972,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xfc9c065f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 976,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa6bcde47;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 980,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xca1d07a2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 992,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x4c5c09dd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 996,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x70f55b5a;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1000,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x2a5e4dcf;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1004,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x8f8e73de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1008,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa067f596;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1012,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe6976d70;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1016,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb7161acd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 1588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setZrxVault(address zrxVaultAddress)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 357,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 372,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 466,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 562,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 636,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 815,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1577,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1669,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1729,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1942,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _arePointersEqual(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1912,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/stake/MixinZrxVault.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(ONLY_OWNER_ERROR_SELECTOR, sender, owner);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 730,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 731,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 732,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Ownable()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 872,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 873,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(_zrxVault) != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 874,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_ZRX_VAULT\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 875,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 886,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 887,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(_zrxVault) != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 888,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_ZRX_VAULT\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 901,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(_zrxVault) != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 903,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_ZRX_VAULT\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 904,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant internal NIL_ADDRESS = 0x0000000000000000000000000000000000000000;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ONLY_OWNER_ERROR_SELECTOR = 0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setZrxVault(address zrxVaultAddress)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 429,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 519,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/fees/MixinExchangeManager.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MISCALCULATED_REWARDS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            totalRewardsPaid,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            initialContractBalance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_EXCHANGE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_ADDRESS_ALREADY_REGISTERED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_ADDRESS_NOT_REGISTERED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INSUFFICIENT_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_OR_MAKER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MAKER_POOL_ASSIGNMENT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            WITHDRAW_AMOUNT_EXCEEDS_MEMBER_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            withdrawAmount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            BLOCK_TIMESTAMP_TOO_LOW_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            epochEndTime,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentBlockTimestamp\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 315,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_STAKING_CONTRACT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 346,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            AMOUNT_EXCEEDS_BALANCE_OF_POOL_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolBalance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_POOL_OPERATOR_SHARE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 363,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorShare\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            POOL_ALREADY_EXISTS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_COBB_DOUGLAS_ALPHA_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            numerator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 391,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            denominator\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 392,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ETH_VAULT_NOT_SET_ERROR_SELECTOR\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 402,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            REWARD_VAULT_NOT_SET_ERROR_SELECTOR\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_STAKE_STATUS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            status\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 698,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(ONLY_OWNER_ERROR_SELECTOR, sender, owner);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 1250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 735,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 737,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Ownable()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {}\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 642,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant internal NIL_ADDRESS = 0x0000000000000000000000000000000000000000;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xf7806c4e;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb56d2df0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc87a78b7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7dc025b0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x84c8b7c9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x6cfa0c22;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7d9e1c10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x69945e3f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xfc9c065f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa6bcde47;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xca1d07a2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x4c5c09dd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x70f55b5a;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x2a5e4dcf;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x8f8e73de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa067f596;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe6976d70;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb7161acd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 692,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ONLY_OWNER_ERROR_SELECTOR = 0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 438,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 627,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 688,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 782,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 878,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 952,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1042,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/staking_pools/MixinEthVault.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(ONLY_OWNER_ERROR_SELECTOR, sender, owner);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 859,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 863,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 864,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Ownable()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 865,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {}\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant internal NIL_ADDRESS = 0x0000000000000000000000000000000000000000;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ONLY_OWNER_ERROR_SELECTOR = 0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 983,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setEthVault(address ethVaultAddress)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 465,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 740,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 969,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 651,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/staking_pools/MixinStakingPoolRewardVault.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 357,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(ONLY_OWNER_ERROR_SELECTOR, sender, owner);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1072,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1073,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MISCALCULATED_REWARDS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            totalRewardsPaid,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            initialContractBalance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1076,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1086,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1087,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_EXCHANGE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1088,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1089,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1099,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_ADDRESS_ALREADY_REGISTERED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_ADDRESS_NOT_REGISTERED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INSUFFICIENT_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_OR_MAKER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MAKER_POOL_ASSIGNMENT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            WITHDRAW_AMOUNT_EXCEEDS_MEMBER_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            withdrawAmount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            BLOCK_TIMESTAMP_TOO_LOW_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1207,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            epochEndTime,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentBlockTimestamp\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_STAKING_CONTRACT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            AMOUNT_EXCEEDS_BALANCE_OF_POOL_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolBalance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_POOL_OPERATOR_SHARE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorShare\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            POOL_ALREADY_EXISTS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_COBB_DOUGLAS_ALPHA_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            numerator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            denominator\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ETH_VAULT_NOT_SET_ERROR_SELECTOR\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1314,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1315,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            REWARD_VAULT_NOT_SET_ERROR_SELECTOR\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_STAKE_STATUS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1326,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            status\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1327,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 859,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 438,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 863,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 864,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Ownable()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 865,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {}\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant internal NIL_ADDRESS = 0x0000000000000000000000000000000000000000;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ONLY_OWNER_ERROR_SELECTOR = 0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xf7806c4e;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 978,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb56d2df0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 982,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc87a78b7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 986,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7dc025b0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 990,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x84c8b7c9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 994,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x6cfa0c22;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 998,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7d9e1c10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1002,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x69945e3f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1006,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xfc9c065f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1010,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa6bcde47;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1014,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xca1d07a2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1026,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x4c5c09dd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1030,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x70f55b5a;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1034,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x2a5e4dcf;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1038,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x8f8e73de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1042,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa067f596;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1046,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe6976d70;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1050,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb7161acd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 1368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract MixinStakingPoolRewardVault is\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 429,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 485,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 570,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 740,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 969,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 402,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 403,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingPoolRewardVault(address payable rewardVaultAddress)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        rewardVault = IStakingPoolRewardVault(rewardVaultAddress);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        rewardVault = IStakingPoolRewardVault(rewardVaultAddress);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit StakingPoolRewardVaultChanged(rewardVaultAddress);\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/libs/LibSafeDowncast.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibSafeDowncast.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibSafeDowncast.sol#38-42)\n\t- LibSafeDowncast.sol#39-41\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibSafeDowncast.sol:\n\t- pragma solidity^0.5.9 (LibSafeDowncast.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibSafeDowncast.sol#47): it allows old versions\n\t- pragma solidity^0.5.9 (LibSafeDowncast.sol#98): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibSafeDowncast.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "    function Uint256BinOpError(BinOpErrorCodes errorCode, uint256 a, uint256 b) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (LibSafeDowncast.sol#69-71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": 75,
                    "vulnerability_code": "    function Uint256DowncastError(DowncastErrorCodes errorCode, uint256 a) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (LibSafeDowncast.sol#73-75) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/libs/LibFixedMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            SIGNED_VALUE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            n\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UNSIGNED_VALUE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            n\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            BIN_OP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (c > 0 && a < 0 && b < 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                LibFixedMathRichErrors.BinOpErrorCodes.SUBTRACTION_OVERFLOW,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                a,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                b\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 507,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 508,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (c < 0 && a > 0 && b > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                LibFixedMathRichErrors.BinOpErrorCodes.ADDITION_OVERFLOW,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                a,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                b\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_28"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibFixedMath.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        int256 y;\n",
                    "message": "y in LibFixedMath._exp (LibFixedMath.sol#397) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        int256 y;\n",
                    "message": "y in LibFixedMath._ln (LibFixedMath.sol#307) is a local variable never initialiazed\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibFixedMath.sol#38-42)\n\t- LibFixedMath.sol#39-41\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibFixedMath.sol:\n\t- pragma solidity^0.5.9 (LibFixedMath.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibFixedMath.sol#65): it allows old versions\n\t- pragma solidity^0.5.9 (LibFixedMath.sol#162): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibFixedMath.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 107,
                    "vulnerability_code": "    function SignedValueError(\n\n        ValueErrorCodes error,\n\n        int256 n\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            SIGNED_VALUE_ERROR_SELECTOR,\n\n            uint8(error),\n\n            n\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.SignedValueError' (LibFixedMath.sol#94-107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": 122,
                    "vulnerability_code": "    function UnsignedValueError(\n\n        ValueErrorCodes error,\n\n        uint256 n\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UNSIGNED_VALUE_ERROR_SELECTOR,\n\n            uint8(error),\n\n            n\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.UnsignedValueError' (LibFixedMath.sol#109-122) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": 139,
                    "vulnerability_code": "    function BinOpError(\n\n        BinOpErrorCodes error,\n\n        int256 a,\n\n        int256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            BIN_OP_ERROR_SELECTOR,\n\n            uint8(error),\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.BinOpError' (LibFixedMath.sol#124-139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": 183,
                    "vulnerability_code": "    function _one() internal pure returns (int256 f) {\n\n        f = FIXED_1;\n",
                    "message": "Function 'LibFixedMath._one' (LibFixedMath.sol#181-183) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": 188,
                    "vulnerability_code": "    function _add(int256 a, int256 b) internal pure returns (int256 c) {\n\n        c = __add(a, b);\n",
                    "message": "Function 'LibFixedMath._add' (LibFixedMath.sol#186-188) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": 193,
                    "vulnerability_code": "    function _sub(int256 a, int256 b) internal pure returns (int256 c) {\n\n        c = __add(a, -b);\n",
                    "message": "Function 'LibFixedMath._sub' (LibFixedMath.sol#191-193) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 198,
                    "vulnerability_code": "    function _mul(int256 a, int256 b) internal pure returns (int256 c) {\n\n        c = __mul(a, b) / FIXED_1;\n",
                    "message": "Function 'LibFixedMath._mul' (LibFixedMath.sol#196-198) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": 203,
                    "vulnerability_code": "    function _div(int256 a, int256 b) internal pure returns (int256 c) {\n\n        c = __div(__mul(a, FIXED_1), b);\n",
                    "message": "Function 'LibFixedMath._div' (LibFixedMath.sol#201-203) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 206,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function _mulDiv(int256 a, int256 n, int256 d) internal pure returns (int256 c) {\n\n        c = __div(__mul(a, n), d);\n",
                    "message": "Function 'LibFixedMath._mulDiv' (LibFixedMath.sol#206-208) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": 225,
                    "vulnerability_code": "    function _uintMul(int256 f, uint256 u) internal pure returns (uint256) {\n\n        if (int256(u) < int256(0)) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.UnsignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_LARGE,\n\n                u\n\n            ));\n\n        }\n\n        int256 c = __mul(f, int256(u));\n\n        if (c <= 0) {\n\n            return 0;\n\n        }\n\n        return uint256(uint256(c) >> 127);\n",
                    "message": "Function 'LibFixedMath._uintMul' (LibFixedMath.sol#213-225) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": 234,
                    "vulnerability_code": "    function _abs(int256 f) internal pure returns (int256 c) {\n\n        if (f >= 0) {\n\n            c = f;\n\n        } else {\n\n            c = -f;\n\n        }\n",
                    "message": "Function 'LibFixedMath._abs' (LibFixedMath.sol#228-234) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": 239,
                    "vulnerability_code": "    function _invert(int256 f) internal pure returns (int256 c) {\n\n        c = __div(FIXED_1_SQUARED, f);\n",
                    "message": "Function 'LibFixedMath._invert' (LibFixedMath.sol#237-239) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": 244,
                    "vulnerability_code": "    function _toFixed(int256 n) internal pure returns (int256 f) {\n\n        f = __mul(n, FIXED_1);\n",
                    "message": "Function 'LibFixedMath._toFixed' (LibFixedMath.sol#242-244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": 249,
                    "vulnerability_code": "    function _toFixed(int256 n, int256 d) internal pure returns (int256 f) {\n\n        f = __div(__mul(n, FIXED_1), d);\n",
                    "message": "Function 'LibFixedMath._toFixed' (LibFixedMath.sol#247-249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": 261,
                    "vulnerability_code": "    function _toFixed(uint256 n) internal pure returns (int256 f) {\n\n        if (int256(n) < int256(0)) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.UnsignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_LARGE,\n\n                n\n\n            ));\n\n        }\n\n        f = __mul(int256(n), FIXED_1);\n",
                    "message": "Function 'LibFixedMath._toFixed' (LibFixedMath.sol#253-261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": 279,
                    "vulnerability_code": "    function _toFixed(uint256 n, uint256 d) internal pure returns (int256 f) {\n\n        if (int256(n) < int256(0)) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.UnsignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_LARGE,\n\n                n\n\n            ));\n\n        }\n\n        if (int256(d) < int256(0)) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.UnsignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_LARGE,\n\n                d\n\n            ));\n\n        }\n\n        f = __div(__mul(int256(n), FIXED_1), int256(d));\n",
                    "message": "Function 'LibFixedMath._toFixed' (LibFixedMath.sol#265-279) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": 284,
                    "vulnerability_code": "    function _toInteger(int256 f) internal pure returns (int256 n) {\n\n        return f / FIXED_1;\n",
                    "message": "Function 'LibFixedMath._toInteger' (LibFixedMath.sol#282-284) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": 372,
                    "vulnerability_code": "    function _ln(int256 x) internal pure returns (int256 r) {\n\n        if (x > LN_MAX_VAL) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.SignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_LARGE,\n\n                x\n\n            ));\n\n        }\n\n        if (x <= 0) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.SignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_SMALL,\n\n                x\n\n            ));\n\n        }\n\n        if (x == FIXED_1) {\n\n            return 0;\n\n        }\n\n        if (x <= LN_MIN_VAL) {\n\n            return EXP_MIN_VAL;\n\n        }\n\n\n\n        int256 y;\n\n        int256 z;\n\n        int256 w;\n\n\n\n        // Rewrite the input as a quotient of negative natural exponents and a single residual q, such that 1 < q < 2\n\n        // For example: log(0.3) = log(e^-1 * e^-0.25 * 1.0471028872385522)\n\n        //              = 1 - 0.25 - log(1 + 0.0471028872385522)\n\n        // e ^ -32\n\n        if (x <= int256(0x00000000000000000000000000000000000000000001c8464f76164760000000)) {\n\n            r -= int256(0x0000000000000000000000000000001000000000000000000000000000000000); // - 32\n\n            x = x * FIXED_1 / int256(0x00000000000000000000000000000000000000000001c8464f76164760000000); // / e ^ -32\n\n        }\n\n        // e ^ -16\n\n        if (x <= int256(0x00000000000000000000000000000000000000f1aaddd7742e90000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000800000000000000000000000000000000); // - 16\n\n            x = x * FIXED_1 / int256(0x00000000000000000000000000000000000000f1aaddd7742e90000000000000); // / e ^ -16\n\n        }\n\n        // e ^ -8\n\n        if (x <= int256(0x00000000000000000000000000000000000afe10820813d78000000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000400000000000000000000000000000000); // - 8\n\n            x = x * FIXED_1 / int256(0x00000000000000000000000000000000000afe10820813d78000000000000000); // / e ^ -8\n\n        }\n\n        // e ^ -4\n\n        if (x <= int256(0x0000000000000000000000000000000002582ab704279ec00000000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000200000000000000000000000000000000); // - 4\n\n            x = x * FIXED_1 / int256(0x0000000000000000000000000000000002582ab704279ec00000000000000000); // / e ^ -4\n\n        }\n\n        // e ^ -2\n\n        if (x <= int256(0x000000000000000000000000000000001152aaa3bf81cc000000000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000100000000000000000000000000000000); // - 2\n\n            x = x * FIXED_1 / int256(0x000000000000000000000000000000001152aaa3bf81cc000000000000000000); // / e ^ -2\n\n        }\n\n        // e ^ -1\n\n        if (x <= int256(0x000000000000000000000000000000002f16ac6c59de70000000000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000080000000000000000000000000000000); // - 1\n\n            x = x * FIXED_1 / int256(0x000000000000000000000000000000002f16ac6c59de70000000000000000000); // / e ^ -1\n\n        }\n\n        // e ^ -0.5\n\n        if (x <= int256(0x000000000000000000000000000000004da2cbf1be5828000000000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000040000000000000000000000000000000); // - 0.5\n\n            x = x * FIXED_1 / int256(0x000000000000000000000000000000004da2cbf1be5828000000000000000000); // / e ^ -0.5\n\n        }\n\n        // e ^ -0.25\n\n        if (x <= int256(0x0000000000000000000000000000000063afbe7ab2082c000000000000000000)) {\n\n            r -= int256(0x0000000000000000000000000000000020000000000000000000000000000000); // - 0.25\n\n            x = x * FIXED_1 / int256(0x0000000000000000000000000000000063afbe7ab2082c000000000000000000); // / e ^ -0.25\n\n        }\n\n        // e ^ -0.125\n\n        if (x <= int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d)) {\n\n            r -= int256(0x0000000000000000000000000000000010000000000000000000000000000000); // - 0.125\n\n            x = x * FIXED_1 / int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d); // / e ^ -0.125\n\n        }\n\n        // `x` is now our residual in the range of 1 <= x <= 2 (or close enough).\n\n\n\n        // Add the taylor series for log(1 + z), where z = x - 1\n\n        z = y = x - FIXED_1;\n\n        w = y * y / FIXED_1;\n\n        r += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02\n\n        r += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04\n\n        r += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06\n\n        r += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08\n\n        r += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10\n\n        r += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12\n\n        r += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14\n\n        r += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16\n",
                    "message": "Function 'LibFixedMath._ln' (LibFixedMath.sol#287-372) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": 469,
                    "vulnerability_code": "    function _exp(int256 x) internal pure returns (int256 r) {\n\n        if (x < EXP_MIN_VAL) {\n\n            // Saturate to zero below EXP_MIN_VAL.\n\n            return 0;\n\n        }\n\n        if (x == 0) {\n\n            return FIXED_1;\n\n        }\n\n        if (x > EXP_MAX_VAL) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.SignedValueError(\n\n                LibFixedMathRichErrors.ValueErrorCodes.TOO_LARGE,\n\n                x\n\n            ));\n\n        }\n\n\n\n        // Rewrite the input as a product of natural exponents and a\n\n        // single residual q, where q is a number of small magnitude.\n\n        // For example: e^-34.419 = e^(-32 - 2 - 0.25 - 0.125 - 0.044)\n\n        //              = e^-32 * e^-2 * e^-0.25 * e^-0.125 * e^-0.044\n\n        //              -> q = -0.044\n\n\n\n        // Multiply with the taylor series for e^q\n\n        int256 y;\n\n        int256 z;\n\n        // q = x % 0.125 (the residual)\n\n        z = y = x % 0x0000000000000000000000000000000010000000000000000000000000000000;\n\n        z = z * y / FIXED_1; r += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n\n        z = z * y / FIXED_1; r += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n\n        z = z * y / FIXED_1; r += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n\n        z = z * y / FIXED_1; r += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n\n        z = z * y / FIXED_1; r += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n\n        z = z * y / FIXED_1; r += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n\n        z = z * y / FIXED_1; r += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n\n        z = z * y / FIXED_1; r += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n\n        z = z * y / FIXED_1; r += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n\n        z = z * y / FIXED_1; r += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n\n        z = z * y / FIXED_1; r += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n\n        z = z * y / FIXED_1; r += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n\n        z = z * y / FIXED_1; r += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n\n        z = z * y / FIXED_1; r += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n\n        z = z * y / FIXED_1; r += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n\n        z = z * y / FIXED_1; r += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n\n        z = z * y / FIXED_1; r += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n\n        z = z * y / FIXED_1; r += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n\n        z = z * y / FIXED_1; r += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n\n        r = r / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n\n\n        // Multiply with the non-residual terms.\n\n        x = -x;\n\n        // e ^ -32\n\n        if ((x & int256(0x0000000000000000000000000000001000000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x00000000000000000000000000000000000000f1aaddd7742e56d32fb9f99744)\n\n                / int256(0x0000000000000000000000000043cbaf42a000812488fc5c220ad7b97bf6e99e); // * e ^ -32\n\n        }\n\n        // e ^ -16\n\n        if ((x & int256(0x0000000000000000000000000000000800000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x00000000000000000000000000000000000afe10820813d65dfe6a33c07f738f)\n\n                / int256(0x000000000000000000000000000005d27a9f51c31b7c2f8038212a0574779991); // * e ^ -16\n\n        }\n\n        // e ^ -8\n\n        if ((x & int256(0x0000000000000000000000000000000400000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x0000000000000000000000000000000002582ab704279e8efd15e0265855c47a)\n\n                / int256(0x0000000000000000000000000000001b4c902e273a58678d6d3bfdb93db96d02); // * e ^ -8\n\n        }\n\n        // e ^ -4\n\n        if ((x & int256(0x0000000000000000000000000000000200000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x000000000000000000000000000000001152aaa3bf81cb9fdb76eae12d029571)\n\n                / int256(0x00000000000000000000000000000003b1cc971a9bb5b9867477440d6d157750); // * e ^ -4\n\n        }\n\n        // e ^ -2\n\n        if ((x & int256(0x0000000000000000000000000000000100000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x000000000000000000000000000000002f16ac6c59de6f8d5d6f63c1482a7c86)\n\n                / int256(0x000000000000000000000000000000015bf0a8b1457695355fb8ac404e7a79e3); // * e ^ -2\n\n        }\n\n        // e ^ -1\n\n        if ((x & int256(0x0000000000000000000000000000000080000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x000000000000000000000000000000004da2cbf1be5827f9eb3ad1aa9866ebb3)\n\n                / int256(0x00000000000000000000000000000000d3094c70f034de4b96ff7d5b6f99fcd8); // * e ^ -1\n\n        }\n\n        // e ^ -0.5\n\n        if ((x & int256(0x0000000000000000000000000000000040000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x0000000000000000000000000000000063afbe7ab2082ba1a0ae5e4eb1b479dc)\n\n                / int256(0x00000000000000000000000000000000a45af1e1f40c333b3de1db4dd55f29a7); // * e ^ -0.5\n\n        }\n\n        // e ^ -0.25\n\n        if ((x & int256(0x0000000000000000000000000000000020000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d)\n\n                / int256(0x00000000000000000000000000000000910b022db7ae67ce76b441c27035c6a1); // * e ^ -0.25\n\n        }\n\n        // e ^ -0.125\n\n        if ((x & int256(0x0000000000000000000000000000000010000000000000000000000000000000)) != 0) {\n\n            r = r * int256(0x00000000000000000000000000000000783eafef1c0a8f3978c7f81824d62ebf)\n\n                / int256(0x0000000000000000000000000000000088415abbe9a76bead8d00cf112e4d4a8); // * e ^ -0.125\n\n        }\n",
                    "message": "Function 'LibFixedMath._exp' (LibFixedMath.sol#375-469) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": 484,
                    "vulnerability_code": "    function __mul(int256 a, int256 b) private pure returns (int256 c) {\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n        c = a * b;\n\n        if (c / a != b) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.MULTIPLICATION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n",
                    "message": "Function 'LibFixedMath.__mul' (LibFixedMath.sol#472-484) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 496,
                    "vulnerability_code": "    function __div(int256 a, int256 b) private pure returns (int256 c) {\n\n        if (b == 0) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.DIVISION_BY_ZERO,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        c = a / b;\n",
                    "message": "Function 'LibFixedMath.__div' (LibFixedMath.sol#487-496) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": 515,
                    "vulnerability_code": "    function __add(int256 a, int256 b) private pure returns (int256 c) {\n\n        c = a + b;\n\n        if (c > 0 && a < 0 && b < 0) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.SUBTRACTION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        if (c < 0 && a > 0 && b > 0) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.ADDITION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n",
                    "message": "Function 'LibFixedMath.__add' (LibFixedMath.sol#499-515) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xed2f26a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xbd79545f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x8c12dfe7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 402,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 403,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 405,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 408,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r = r / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant FIXED_1 = int256(0x0000000000000000000000000000000080000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant FIXED_1_SQUARED = int256(0x4000000000000000000000000000000000000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant LN_MAX_VAL = FIXED_1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant LN_MIN_VAL = int256(0x0000000000000000000000000000000000000000000000000000000733048c5a);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant EXP_MAX_VAL = 0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant EXP_MIN_VAL = -int256(0x0000000000000000000000000000001ff0000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/libs/LibStakingRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MISCALCULATED_REWARDS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            totalRewardsPaid,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            initialContractBalance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_EXCHANGE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_ADDRESS_ALREADY_REGISTERED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_ADDRESS_NOT_REGISTERED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INSUFFICIENT_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_OR_MAKER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MAKER_POOL_ASSIGNMENT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            WITHDRAW_AMOUNT_EXCEEDS_MEMBER_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            withdrawAmount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            BLOCK_TIMESTAMP_TOO_LOW_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            epochEndTime,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentBlockTimestamp\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 315,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_STAKING_CONTRACT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 346,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            AMOUNT_EXCEEDS_BALANCE_OF_POOL_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolBalance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_POOL_OPERATOR_SHARE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 363,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorShare\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            POOL_ALREADY_EXISTS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_COBB_DOUGLAS_ALPHA_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            numerator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 391,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            denominator\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 392,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ETH_VAULT_NOT_SET_ERROR_SELECTOR\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 402,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            REWARD_VAULT_NOT_SET_ERROR_SELECTOR\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_STAKE_STATUS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            status\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_25"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibStakingRichErrors.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibStakingRichErrors.sol#38-42)\n\t- LibStakingRichErrors.sol#39-41\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibStakingRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibStakingRichErrors.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibStakingRichErrors.sol#65): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibStakingRichErrors.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": 173,
                    "vulnerability_code": "    function MiscalculatedRewardsError(\n\n        uint256 totalRewardsPaid,\n\n        uint256 initialContractBalance\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            MISCALCULATED_REWARDS_ERROR_SELECTOR,\n\n            totalRewardsPaid,\n\n            initialContractBalance\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.MiscalculatedRewardsError' (LibStakingRichErrors.sol#160-173) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": 186,
                    "vulnerability_code": "    function OnlyCallableByExchangeError(\n\n        address senderAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_CALLABLE_BY_EXCHANGE_ERROR_SELECTOR,\n\n            senderAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableByExchangeError' (LibStakingRichErrors.sol#175-186) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": 199,
                    "vulnerability_code": "    function ExchangeAddressAlreadyRegisteredError(\n\n        address exchangeAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            EXCHANGE_ADDRESS_ALREADY_REGISTERED_ERROR_SELECTOR,\n\n            exchangeAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.ExchangeAddressAlreadyRegisteredError' (LibStakingRichErrors.sol#188-199) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": 212,
                    "vulnerability_code": "    function ExchangeAddressNotRegisteredError(\n\n        address exchangeAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            EXCHANGE_ADDRESS_NOT_REGISTERED_ERROR_SELECTOR,\n\n            exchangeAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.ExchangeAddressNotRegisteredError' (LibStakingRichErrors.sol#201-212) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function InsufficientBalanceError(\n\n        uint256 amount,\n\n        uint256 balance\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INSUFFICIENT_BALANCE_ERROR_SELECTOR,\n\n            amount,\n\n            balance\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.InsufficientBalanceError' (LibStakingRichErrors.sol#214-227) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": 242,
                    "vulnerability_code": "    function OnlyCallableByPoolOperatorError(\n\n        address senderAddress,\n\n        address poolOperatorAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_CALLABLE_BY_POOL_OPERATOR_ERROR_SELECTOR,\n\n            senderAddress,\n\n            poolOperatorAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableByPoolOperatorError' (LibStakingRichErrors.sol#229-242) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": 259,
                    "vulnerability_code": "    function OnlyCallableByPoolOperatorOrMakerError(\n\n        address senderAddress,\n\n        address poolOperatorAddress,\n\n        address makerAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_CALLABLE_BY_POOL_OPERATOR_OR_MAKER_ERROR_SELECTOR,\n\n            senderAddress,\n\n            poolOperatorAddress,\n\n            makerAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableByPoolOperatorOrMakerError' (LibStakingRichErrors.sol#244-259) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": 276,
                    "vulnerability_code": "    function MakerPoolAssignmentError(\n\n        MakerPoolAssignmentErrorCodes errorCode,\n\n        address makerAddress,\n\n        bytes32 poolId\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            MAKER_POOL_ASSIGNMENT_ERROR_SELECTOR,\n\n            errorCode,\n\n            makerAddress,\n\n            poolId\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.MakerPoolAssignmentError' (LibStakingRichErrors.sol#261-276) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": 291,
                    "vulnerability_code": "    function WithdrawAmountExceedsMemberBalanceError(\n\n        uint256 withdrawAmount,\n\n        uint256 balance\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            WITHDRAW_AMOUNT_EXCEEDS_MEMBER_BALANCE_ERROR_SELECTOR,\n\n            withdrawAmount,\n\n            balance\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.WithdrawAmountExceedsMemberBalanceError' (LibStakingRichErrors.sol#278-291) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": 306,
                    "vulnerability_code": "    function BlockTimestampTooLowError(\n\n        uint256 epochEndTime,\n\n        uint256 currentBlockTimestamp\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            BLOCK_TIMESTAMP_TOO_LOW_ERROR_SELECTOR,\n\n            epochEndTime,\n\n            currentBlockTimestamp\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.BlockTimestampTooLowError' (LibStakingRichErrors.sol#293-306) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": 319,
                    "vulnerability_code": "    function OnlyCallableByStakingContractError(\n\n        address senderAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_CALLABLE_BY_STAKING_CONTRACT_ERROR_SELECTOR,\n\n            senderAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableByStakingContractError' (LibStakingRichErrors.sol#308-319) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": 327,
                    "vulnerability_code": "    function OnlyCallableIfInCatastrophicFailureError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ONLY_CALLABLE_IF_IN_CATASTROPHIC_FAILURE_ERROR;\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableIfInCatastrophicFailureError' (LibStakingRichErrors.sol#321-327) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": 335,
                    "vulnerability_code": "    function OnlyCallableIfNotInCatastrophicFailureError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ONLY_CALLABLE_IF_NOT_IN_CATASTROPHIC_FAILURE_ERROR;\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableIfNotInCatastrophicFailureError' (LibStakingRichErrors.sol#329-335) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": 350,
                    "vulnerability_code": "    function AmountExceedsBalanceOfPoolError(\n\n        uint256 amount,\n\n        uint96 poolBalance\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            AMOUNT_EXCEEDS_BALANCE_OF_POOL_ERROR_SELECTOR,\n\n            amount,\n\n            poolBalance\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.AmountExceedsBalanceOfPoolError' (LibStakingRichErrors.sol#337-350) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": 365,
                    "vulnerability_code": "    function InvalidPoolOperatorShareError(\n\n        bytes32 poolId,\n\n        uint32 poolOperatorShare\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_POOL_OPERATOR_SHARE_ERROR_SELECTOR,\n\n            poolId,\n\n            poolOperatorShare\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.InvalidPoolOperatorShareError' (LibStakingRichErrors.sol#352-365) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function PoolAlreadyExistsError(\n\n        bytes32 poolId\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            POOL_ALREADY_EXISTS_ERROR_SELECTOR,\n\n            poolId\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.PoolAlreadyExistsError' (LibStakingRichErrors.sol#367-378) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": 393,
                    "vulnerability_code": "    function InvalidCobbDouglasAlphaError(\n\n        uint256 numerator,\n\n        uint256 denominator\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_COBB_DOUGLAS_ALPHA_ERROR_SELECTOR,\n\n            numerator,\n\n            denominator\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.InvalidCobbDouglasAlphaError' (LibStakingRichErrors.sol#380-393) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 395,
                    "vulnerability_to_line": 403,
                    "vulnerability_code": "    function EthVaultNotSetError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ETH_VAULT_NOT_SET_ERROR_SELECTOR\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.EthVaultNotSetError' (LibStakingRichErrors.sol#395-403) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 405,
                    "vulnerability_to_line": 413,
                    "vulnerability_code": "    function RewardVaultNotSetError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            REWARD_VAULT_NOT_SET_ERROR_SELECTOR\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.RewardVaultNotSetError' (LibStakingRichErrors.sol#405-413) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": 424,
                    "vulnerability_code": "    function InvalidStakeStatusError(uint256 status)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_STAKE_STATUS_ERROR_SELECTOR,\n\n            status\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.InvalidStakeStatusError' (LibStakingRichErrors.sol#415-424) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 426,
                    "vulnerability_to_line": 432,
                    "vulnerability_code": "    function ProxyDestinationCannotBeNil()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return PROXY_DESTINATION_CANNOT_BE_NIL;\n",
                    "message": "Function 'LibStakingRichErrors.ProxyDestinationCannotBeNil' (LibStakingRichErrors.sol#426-432) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xf7806c4e;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb56d2df0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc87a78b7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7dc025b0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x84c8b7c9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x6cfa0c22;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7d9e1c10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x69945e3f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xfc9c065f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa6bcde47;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xca1d07a2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x4c5c09dd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x70f55b5a;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x2a5e4dcf;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x8f8e73de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa067f596;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe6976d70;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb7161acd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/libs/LibProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MISCALCULATED_REWARDS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            totalRewardsPaid,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            initialContractBalance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_EXCHANGE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_ADDRESS_ALREADY_REGISTERED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_ADDRESS_NOT_REGISTERED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INSUFFICIENT_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_OR_MAKER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MAKER_POOL_ASSIGNMENT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            WITHDRAW_AMOUNT_EXCEEDS_MEMBER_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            withdrawAmount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            BLOCK_TIMESTAMP_TOO_LOW_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            epochEndTime,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentBlockTimestamp\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 315,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_STAKING_CONTRACT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 346,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            AMOUNT_EXCEEDS_BALANCE_OF_POOL_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolBalance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_POOL_OPERATOR_SHARE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 363,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorShare\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            POOL_ALREADY_EXISTS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_COBB_DOUGLAS_ALPHA_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            numerator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 391,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            denominator\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 392,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ETH_VAULT_NOT_SET_ERROR_SELECTOR\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 402,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            REWARD_VAULT_NOT_SET_ERROR_SELECTOR\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_STAKE_STATUS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            status\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_26"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibProxy.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibProxy.sol#38-42)\n\t- LibProxy.sol#39-41\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": 545,
                    "vulnerability_code": "    function proxyCall(\n\n        address destination,\n\n        RevertRule revertRule,\n\n        bytes4 customEgressSelector,\n\n        bool ignoreIngressSelector\n\n    )\n\n        internal\n\n    {\n\n        if (destination == address(0)) {\n\n            LibRichErrors.rrevert(\n\n                LibStakingRichErrors.ProxyDestinationCannotBeNil()\n\n            );\n\n        }\n\n\n\n        assembly {\n\n            // store selector of destination function\n\n            let freeMemPtr := 0\n\n            if gt(customEgressSelector, 0) {\n\n                mstore(0x0, customEgressSelector)\n\n                freeMemPtr := add(freeMemPtr, 4)\n\n            }\n\n\n\n            // adjust the calldata offset, if we should ignore the selector\n\n            let calldataOffset := 0\n\n            if gt(ignoreIngressSelector, 0) {\n\n                calldataOffset := 4\n\n            }\n\n\n\n            // copy calldata to memory\n\n            calldatacopy(\n\n                freeMemPtr,\n\n                calldataOffset,\n\n                calldatasize()\n\n            )\n\n            freeMemPtr := add(\n\n                freeMemPtr,\n\n                sub(calldatasize(), calldataOffset)\n\n            )\n\n\n\n            // delegate call into staking contract\n\n            let success := delegatecall(\n\n                gas,                        // forward all gas\n\n                destination,                // calling staking contract\n\n                0x0,                        // start of input (calldata)\n\n                freeMemPtr,                 // length of input (calldata)\n\n                0x0,                        // write output over input\n\n                0                           // length of output is unknown\n\n            )\n\n\n\n            // copy return data to memory and *return*\n\n            returndatacopy(\n\n                0x0,\n\n                0x0,\n\n                returndatasize()\n\n            )\n\n\n\n            switch revertRule\n\n            case 1 {    // ALWAYS_REVERT\n\n                revert(0, returndatasize())\n\n            }\n\n            case 2 {    // NEVER_REVERT\n\n                return(0, returndatasize())\n\n            }\n\n            // solhint-disable no-empty-blocks\n\n            default {} // REVERT_ON_ERROR (handled below)\n\n\n\n            // rethrow any exceptions\n\n            if iszero(success) {\n\n                revert(0, returndatasize())\n\n            }\n\n            // return call results\n\n            return(0, returndatasize())\n\n        }\n",
                    "message": "LibProxy.proxyCall uses assembly (LibProxy.sol#472-545)\n\t- LibProxy.sol#486-544\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibProxy.sol:\n\t- pragma solidity^0.5.9 (LibProxy.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibProxy.sol#65): it allows old versions\n\t- pragma solidity^0.5.9 (LibProxy.sol#456): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibProxy.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": 173,
                    "vulnerability_code": "    function MiscalculatedRewardsError(\n\n        uint256 totalRewardsPaid,\n\n        uint256 initialContractBalance\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            MISCALCULATED_REWARDS_ERROR_SELECTOR,\n\n            totalRewardsPaid,\n\n            initialContractBalance\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.MiscalculatedRewardsError' (LibProxy.sol#160-173) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": 186,
                    "vulnerability_code": "    function OnlyCallableByExchangeError(\n\n        address senderAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_CALLABLE_BY_EXCHANGE_ERROR_SELECTOR,\n\n            senderAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableByExchangeError' (LibProxy.sol#175-186) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": 199,
                    "vulnerability_code": "    function ExchangeAddressAlreadyRegisteredError(\n\n        address exchangeAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            EXCHANGE_ADDRESS_ALREADY_REGISTERED_ERROR_SELECTOR,\n\n            exchangeAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.ExchangeAddressAlreadyRegisteredError' (LibProxy.sol#188-199) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": 212,
                    "vulnerability_code": "    function ExchangeAddressNotRegisteredError(\n\n        address exchangeAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            EXCHANGE_ADDRESS_NOT_REGISTERED_ERROR_SELECTOR,\n\n            exchangeAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.ExchangeAddressNotRegisteredError' (LibProxy.sol#201-212) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function InsufficientBalanceError(\n\n        uint256 amount,\n\n        uint256 balance\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INSUFFICIENT_BALANCE_ERROR_SELECTOR,\n\n            amount,\n\n            balance\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.InsufficientBalanceError' (LibProxy.sol#214-227) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": 242,
                    "vulnerability_code": "    function OnlyCallableByPoolOperatorError(\n\n        address senderAddress,\n\n        address poolOperatorAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_CALLABLE_BY_POOL_OPERATOR_ERROR_SELECTOR,\n\n            senderAddress,\n\n            poolOperatorAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableByPoolOperatorError' (LibProxy.sol#229-242) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": 259,
                    "vulnerability_code": "    function OnlyCallableByPoolOperatorOrMakerError(\n\n        address senderAddress,\n\n        address poolOperatorAddress,\n\n        address makerAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_CALLABLE_BY_POOL_OPERATOR_OR_MAKER_ERROR_SELECTOR,\n\n            senderAddress,\n\n            poolOperatorAddress,\n\n            makerAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableByPoolOperatorOrMakerError' (LibProxy.sol#244-259) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": 276,
                    "vulnerability_code": "    function MakerPoolAssignmentError(\n\n        MakerPoolAssignmentErrorCodes errorCode,\n\n        address makerAddress,\n\n        bytes32 poolId\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            MAKER_POOL_ASSIGNMENT_ERROR_SELECTOR,\n\n            errorCode,\n\n            makerAddress,\n\n            poolId\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.MakerPoolAssignmentError' (LibProxy.sol#261-276) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": 291,
                    "vulnerability_code": "    function WithdrawAmountExceedsMemberBalanceError(\n\n        uint256 withdrawAmount,\n\n        uint256 balance\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            WITHDRAW_AMOUNT_EXCEEDS_MEMBER_BALANCE_ERROR_SELECTOR,\n\n            withdrawAmount,\n\n            balance\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.WithdrawAmountExceedsMemberBalanceError' (LibProxy.sol#278-291) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": 306,
                    "vulnerability_code": "    function BlockTimestampTooLowError(\n\n        uint256 epochEndTime,\n\n        uint256 currentBlockTimestamp\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            BLOCK_TIMESTAMP_TOO_LOW_ERROR_SELECTOR,\n\n            epochEndTime,\n\n            currentBlockTimestamp\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.BlockTimestampTooLowError' (LibProxy.sol#293-306) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": 319,
                    "vulnerability_code": "    function OnlyCallableByStakingContractError(\n\n        address senderAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_CALLABLE_BY_STAKING_CONTRACT_ERROR_SELECTOR,\n\n            senderAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableByStakingContractError' (LibProxy.sol#308-319) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": 327,
                    "vulnerability_code": "    function OnlyCallableIfInCatastrophicFailureError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ONLY_CALLABLE_IF_IN_CATASTROPHIC_FAILURE_ERROR;\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableIfInCatastrophicFailureError' (LibProxy.sol#321-327) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": 335,
                    "vulnerability_code": "    function OnlyCallableIfNotInCatastrophicFailureError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ONLY_CALLABLE_IF_NOT_IN_CATASTROPHIC_FAILURE_ERROR;\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableIfNotInCatastrophicFailureError' (LibProxy.sol#329-335) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": 350,
                    "vulnerability_code": "    function AmountExceedsBalanceOfPoolError(\n\n        uint256 amount,\n\n        uint96 poolBalance\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            AMOUNT_EXCEEDS_BALANCE_OF_POOL_ERROR_SELECTOR,\n\n            amount,\n\n            poolBalance\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.AmountExceedsBalanceOfPoolError' (LibProxy.sol#337-350) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": 365,
                    "vulnerability_code": "    function InvalidPoolOperatorShareError(\n\n        bytes32 poolId,\n\n        uint32 poolOperatorShare\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_POOL_OPERATOR_SHARE_ERROR_SELECTOR,\n\n            poolId,\n\n            poolOperatorShare\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.InvalidPoolOperatorShareError' (LibProxy.sol#352-365) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function PoolAlreadyExistsError(\n\n        bytes32 poolId\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            POOL_ALREADY_EXISTS_ERROR_SELECTOR,\n\n            poolId\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.PoolAlreadyExistsError' (LibProxy.sol#367-378) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": 393,
                    "vulnerability_code": "    function InvalidCobbDouglasAlphaError(\n\n        uint256 numerator,\n\n        uint256 denominator\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_COBB_DOUGLAS_ALPHA_ERROR_SELECTOR,\n\n            numerator,\n\n            denominator\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.InvalidCobbDouglasAlphaError' (LibProxy.sol#380-393) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 395,
                    "vulnerability_to_line": 403,
                    "vulnerability_code": "    function EthVaultNotSetError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ETH_VAULT_NOT_SET_ERROR_SELECTOR\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.EthVaultNotSetError' (LibProxy.sol#395-403) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 405,
                    "vulnerability_to_line": 413,
                    "vulnerability_code": "    function RewardVaultNotSetError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            REWARD_VAULT_NOT_SET_ERROR_SELECTOR\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.RewardVaultNotSetError' (LibProxy.sol#405-413) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": 424,
                    "vulnerability_code": "    function InvalidStakeStatusError(uint256 status)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_STAKE_STATUS_ERROR_SELECTOR,\n\n            status\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.InvalidStakeStatusError' (LibProxy.sol#415-424) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 426,
                    "vulnerability_to_line": 432,
                    "vulnerability_code": "    function ProxyDestinationCannotBeNil()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return PROXY_DESTINATION_CANNOT_BE_NIL;\n",
                    "message": "Function 'LibStakingRichErrors.ProxyDestinationCannotBeNil' (LibProxy.sol#426-432) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xf7806c4e;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb56d2df0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc87a78b7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7dc025b0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x84c8b7c9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x6cfa0c22;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7d9e1c10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x69945e3f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xfc9c065f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa6bcde47;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xca1d07a2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x4c5c09dd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x70f55b5a;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x2a5e4dcf;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x8f8e73de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa067f596;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe6976d70;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb7161acd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 486,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/libs/LibFixedMathRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            SIGNED_VALUE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            n\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UNSIGNED_VALUE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            n\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            BIN_OP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibFixedMathRichErrors.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibFixedMathRichErrors.sol#38-42)\n\t- LibFixedMathRichErrors.sol#39-41\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibFixedMathRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibFixedMathRichErrors.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibFixedMathRichErrors.sol#65): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibFixedMathRichErrors.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 107,
                    "vulnerability_code": "    function SignedValueError(\n\n        ValueErrorCodes error,\n\n        int256 n\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            SIGNED_VALUE_ERROR_SELECTOR,\n\n            uint8(error),\n\n            n\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.SignedValueError' (LibFixedMathRichErrors.sol#94-107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": 122,
                    "vulnerability_code": "    function UnsignedValueError(\n\n        ValueErrorCodes error,\n\n        uint256 n\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UNSIGNED_VALUE_ERROR_SELECTOR,\n\n            uint8(error),\n\n            n\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.UnsignedValueError' (LibFixedMathRichErrors.sol#109-122) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": 139,
                    "vulnerability_code": "    function BinOpError(\n\n        BinOpErrorCodes error,\n\n        int256 a,\n\n        int256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            BIN_OP_ERROR_SELECTOR,\n\n            uint8(error),\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.BinOpError' (LibFixedMathRichErrors.sol#124-139) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xed2f26a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xbd79545f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x8c12dfe7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/sys/MixinScheduler.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MISCALCULATED_REWARDS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            totalRewardsPaid,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            initialContractBalance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_EXCHANGE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_ADDRESS_ALREADY_REGISTERED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_ADDRESS_NOT_REGISTERED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INSUFFICIENT_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 323,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 338,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_OR_MAKER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MAKER_POOL_ASSIGNMENT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 372,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 373,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            WITHDRAW_AMOUNT_EXCEEDS_MEMBER_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            withdrawAmount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            BLOCK_TIMESTAMP_TOO_LOW_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            epochEndTime,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 402,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentBlockTimestamp\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 403,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_STAKING_CONTRACT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            AMOUNT_EXCEEDS_BALANCE_OF_POOL_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 445,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolBalance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 459,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_POOL_OPERATOR_SHARE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolOperatorShare\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 473,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            POOL_ALREADY_EXISTS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 474,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 475,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 486,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_COBB_DOUGLAS_ALPHA_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            numerator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 489,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            denominator\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 490,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ETH_VAULT_NOT_SET_ERROR_SELECTOR\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 500,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 508,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            REWARD_VAULT_NOT_SET_ERROR_SELECTOR\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 519,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_STAKE_STATUS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            status\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(ONLY_OWNER_ERROR_SELECTOR, sender, owner);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 1216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 702,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 703,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Ownable()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {}\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant internal NIL_ADDRESS = 0x0000000000000000000000000000000000000000;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xf7806c4e;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb56d2df0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc87a78b7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7dc025b0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x84c8b7c9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x6cfa0c22;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7d9e1c10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x69945e3f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xfc9c065f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa6bcde47;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xca1d07a2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x4c5c09dd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x70f55b5a;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x2a5e4dcf;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x8f8e73de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa067f596;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe6976d70;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb7161acd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ONLY_OWNER_ERROR_SELECTOR = 0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 692,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 748,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 918,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1097,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1008,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/interfaces/IStakingEvents.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IStakingEvents.sol:\n\t- pragma solidity^0.5.9 (IStakingEvents.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/interfaces/IStructs.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IStructs.sol:\n\t- pragma solidity^0.5.9 (IStructs.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/interfaces/IStakingProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IStakingProxy.sol:\n\t- pragma solidity^0.5.9 (IStakingProxy.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/interfaces/IVaultCore.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IVaultCore.sol:\n\t- pragma solidity^0.5.9 (IVaultCore.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingContract(address payable _stakingContractAddress)\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/interfaces/IStakingPoolRewardVault.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IStakingPoolRewardVault.sol:\n\t- pragma solidity^0.5.9 (IStakingPoolRewardVault.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/interfaces/IStaking.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IStaking.sol:\n\t- pragma solidity^0.5.9 (IStaking.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/interfaces/IEthVault.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IEthVault.sol:\n\t- pragma solidity^0.5.9 (IEthVault.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/staking/contracts/src/interfaces/IZrxVault.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IZrxVault.sol:\n\t- pragma solidity^0.5.9 (IZrxVault.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/dev-utils/contracts/src/EthBalanceChecker.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i != addresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i != addresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i != addresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": 39,
                    "vulnerability_code": "    function getEthBalances(address[] memory addresses)\n\n        public\n\n        view\n\n        returns (uint256[] memory)\n\n    {\n\n        uint256[] memory balances = new uint256[](addresses.length);\n\n        for (uint256 i = 0; i != addresses.length; i++) {\n\n            balances[i] = addresses[i].balance;\n\n        }\n\n        return balances;\n",
                    "message": "EthBalanceChecker.getEthBalances (EthBalanceChecker.sol#29-39) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": "Detected issues with version pragma in EthBalanceChecker.sol:\n\t- pragma solidity^0.5.5 (EthBalanceChecker.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i != addresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/asset-proxy/contracts/archive/Ownable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public;\n",
                    "message": "IOwnable.transferOwnership (Ownable.sol#31) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable.transferOwnership (Ownable.sol#57-64) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in Ownable.sol:\n\t- pragma solidity^0.5.9 (Ownable.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (Ownable.sol#36): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/asset-proxy/contracts/archive/MixinAssetProxyDispatcher.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentAssetProxy == address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ASSET_PROXY_ALREADY_EXISTS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assetData.length > 3,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assetProxy != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"ASSET_PROXY_DOES_NOT_EXIST\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (amount > 0 && from != to) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // Ensure assetData length is valid\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assetData.length > 3,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // Lookup assetProxy. We do not use `LibBytes.readBytes4` for gas efficiency reasons.\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4 assetProxyId;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": 211,
                    "vulnerability_code": "    function registerAssetProxy(address assetProxy)\n\n        external\n\n        onlyOwner\n\n    {\n\n        // Ensure that no asset proxy exists with current id.\n\n        bytes4 assetProxyId = IAssetProxy(assetProxy).getProxyId();\n\n        address currentAssetProxy = assetProxies[assetProxyId];\n\n        require(\n\n            currentAssetProxy == address(0),\n\n            \"ASSET_PROXY_ALREADY_EXISTS\"\n\n        );\n\n\n\n        // Add asset proxy and log registration.\n\n        assetProxies[assetProxyId] = assetProxy;\n\n        emit AssetProxyRegistered(\n\n            assetProxyId,\n\n            assetProxy\n\n        );\n",
                    "message": "Reentrancy in MixinAssetProxyDispatcher.registerAssetProxy (MixinAssetProxyDispatcher.sol#193-211):\n\tExternal calls:\n\t- assetProxyId = IAssetProxy(assetProxy).getProxyId() (MixinAssetProxyDispatcher.sol#198)\n\tState variables written after the call(s):\n\t- assetProxies (MixinAssetProxyDispatcher.sol#206)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": 328,
                    "vulnerability_code": "    function _dispatchTransferFrom(\n\n        bytes memory assetData,\n\n        address from,\n\n        address to,\n\n        uint256 amount\n\n    )\n\n        internal\n\n    {\n\n        // Do nothing if no amount should be transferred.\n\n        if (amount > 0 && from != to) {\n\n            // Ensure assetData length is valid\n\n            require(\n\n                assetData.length > 3,\n\n                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n\n            );\n\n\n\n            // Lookup assetProxy. We do not use `LibBytes.readBytes4` for gas efficiency reasons.\n\n            bytes4 assetProxyId;\n\n            assembly {\n\n                assetProxyId := and(mload(\n\n                    add(assetData, 32)),\n\n                    0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n\n                )\n\n            }\n\n            address assetProxy = assetProxies[assetProxyId];\n\n\n\n            // Ensure that assetProxy exists\n\n            require(\n\n                assetProxy != address(0),\n\n                \"ASSET_PROXY_DOES_NOT_EXIST\"\n\n            );\n\n\n\n            // We construct calldata for the `assetProxy.transferFrom` ABI.\n\n            // The layout of this calldata is in the table below.\n\n            //\n\n            // | Area     | Offset | Length  | Contents                                    |\n\n            // | -------- |--------|---------|-------------------------------------------- |\n\n            // | Header   | 0      | 4       | function selector                           |\n\n            // | Params   |        | 4 * 32  | function parameters:                        |\n\n            // |          | 4      |         |   1. offset to assetData (*)                |\n\n            // |          | 36     |         |   2. from                                   |\n\n            // |          | 68     |         |   3. to                                     |\n\n            // |          | 100    |         |   4. amount                                 |\n\n            // | Data     |        |         | assetData:                                  |\n\n            // |          | 132    | 32      | assetData Length                            |\n\n            // |          | 164    | **      | assetData Contents                          |\n\n\n\n            assembly {\n\n                /////// Setup State ///////\n\n                // `cdStart` is the start of the calldata for `assetProxy.transferFrom` (equal to free memory ptr).\n\n                let cdStart := mload(64)\n\n                // `dataAreaLength` is the total number of words needed to store `assetData`\n\n                //  As-per the ABI spec, this value is padded up to the nearest multiple of 32,\n\n                //  and includes 32-bytes for length.\n\n                let dataAreaLength := and(add(mload(assetData), 63), 0xFFFFFFFFFFFE0)\n\n                // `cdEnd` is the end of the calldata for `assetProxy.transferFrom`.\n\n                let cdEnd := add(cdStart, add(132, dataAreaLength))\n\n\n\n\n\n                /////// Setup Header Area ///////\n\n                // This area holds the 4-byte `transferFromSelector`.\n\n                // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n\n                mstore(cdStart, 0xa85e59e400000000000000000000000000000000000000000000000000000000)\n\n\n\n                /////// Setup Params Area ///////\n\n                // Each parameter is padded to 32-bytes. The entire Params Area is 128 bytes.\n\n                // Notes:\n\n                //   1. The offset to `assetData` is the length of the Params Area (128 bytes).\n\n                //   2. A 20-byte mask is applied to addresses to zero-out the unused bytes.\n\n                mstore(add(cdStart, 4), 128)\n\n                mstore(add(cdStart, 36), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(cdStart, 68), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(cdStart, 100), amount)\n\n\n\n                /////// Setup Data Area ///////\n\n                // This area holds `assetData`.\n\n                let dataArea := add(cdStart, 132)\n\n                // solhint-disable-next-line no-empty-blocks\n\n                for {} lt(dataArea, cdEnd) {} {\n\n                    mstore(dataArea, mload(assetData))\n\n                    dataArea := add(dataArea, 32)\n\n                    assetData := add(assetData, 32)\n\n                }\n\n\n\n                /////// Call `assetProxy.transferFrom` using the constructed calldata ///////\n\n                let success := call(\n\n                    gas,                    // forward all gas\n\n                    assetProxy,             // call address of asset proxy\n\n                    0,                      // don't send any ETH\n\n                    cdStart,                // pointer to start of input\n\n                    sub(cdEnd, cdStart),    // length of input\n\n                    cdStart,                // write output over input\n\n                    512                     // reserve 512 bytes for output\n\n                )\n\n                if iszero(success) {\n\n                    revert(cdStart, returndatasize())\n\n                }\n\n            }\n\n        }\n",
                    "message": "MixinAssetProxyDispatcher._dispatchTransferFrom uses assembly (MixinAssetProxyDispatcher.sol#229-328)\n\t- MixinAssetProxyDispatcher.sol#247-252\n\t- MixinAssetProxyDispatcher.sol#276-326\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public;\n",
                    "message": "IOwnable.transferOwnership (MixinAssetProxyDispatcher.sol#31) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable.transferOwnership (MixinAssetProxyDispatcher.sol#57-64) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MixinAssetProxyDispatcher.sol:\n\t- pragma solidity^0.5.9 (MixinAssetProxyDispatcher.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (MixinAssetProxyDispatcher.sol#36): it allows old versions\n\t- pragma solidity^0.5.9 (MixinAssetProxyDispatcher.sol#87): it allows old versions\n\t- pragma solidity^0.5.9 (MixinAssetProxyDispatcher.sol#133): it allows old versions\n\t- pragma solidity^0.5.9 (MixinAssetProxyDispatcher.sol#179): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": 328,
                    "vulnerability_code": "    function _dispatchTransferFrom(\n\n        bytes memory assetData,\n\n        address from,\n\n        address to,\n\n        uint256 amount\n\n    )\n\n        internal\n\n    {\n\n        // Do nothing if no amount should be transferred.\n\n        if (amount > 0 && from != to) {\n\n            // Ensure assetData length is valid\n\n            require(\n\n                assetData.length > 3,\n\n                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n\n            );\n\n\n\n            // Lookup assetProxy. We do not use `LibBytes.readBytes4` for gas efficiency reasons.\n\n            bytes4 assetProxyId;\n\n            assembly {\n\n                assetProxyId := and(mload(\n\n                    add(assetData, 32)),\n\n                    0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n\n                )\n\n            }\n\n            address assetProxy = assetProxies[assetProxyId];\n\n\n\n            // Ensure that assetProxy exists\n\n            require(\n\n                assetProxy != address(0),\n\n                \"ASSET_PROXY_DOES_NOT_EXIST\"\n\n            );\n\n\n\n            // We construct calldata for the `assetProxy.transferFrom` ABI.\n\n            // The layout of this calldata is in the table below.\n\n            //\n\n            // | Area     | Offset | Length  | Contents                                    |\n\n            // | -------- |--------|---------|-------------------------------------------- |\n\n            // | Header   | 0      | 4       | function selector                           |\n\n            // | Params   |        | 4 * 32  | function parameters:                        |\n\n            // |          | 4      |         |   1. offset to assetData (*)                |\n\n            // |          | 36     |         |   2. from                                   |\n\n            // |          | 68     |         |   3. to                                     |\n\n            // |          | 100    |         |   4. amount                                 |\n\n            // | Data     |        |         | assetData:                                  |\n\n            // |          | 132    | 32      | assetData Length                            |\n\n            // |          | 164    | **      | assetData Contents                          |\n\n\n\n            assembly {\n\n                /////// Setup State ///////\n\n                // `cdStart` is the start of the calldata for `assetProxy.transferFrom` (equal to free memory ptr).\n\n                let cdStart := mload(64)\n\n                // `dataAreaLength` is the total number of words needed to store `assetData`\n\n                //  As-per the ABI spec, this value is padded up to the nearest multiple of 32,\n\n                //  and includes 32-bytes for length.\n\n                let dataAreaLength := and(add(mload(assetData), 63), 0xFFFFFFFFFFFE0)\n\n                // `cdEnd` is the end of the calldata for `assetProxy.transferFrom`.\n\n                let cdEnd := add(cdStart, add(132, dataAreaLength))\n\n\n\n\n\n                /////// Setup Header Area ///////\n\n                // This area holds the 4-byte `transferFromSelector`.\n\n                // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n\n                mstore(cdStart, 0xa85e59e400000000000000000000000000000000000000000000000000000000)\n\n\n\n                /////// Setup Params Area ///////\n\n                // Each parameter is padded to 32-bytes. The entire Params Area is 128 bytes.\n\n                // Notes:\n\n                //   1. The offset to `assetData` is the length of the Params Area (128 bytes).\n\n                //   2. A 20-byte mask is applied to addresses to zero-out the unused bytes.\n\n                mstore(add(cdStart, 4), 128)\n\n                mstore(add(cdStart, 36), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(cdStart, 68), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(cdStart, 100), amount)\n\n\n\n                /////// Setup Data Area ///////\n\n                // This area holds `assetData`.\n\n                let dataArea := add(cdStart, 132)\n\n                // solhint-disable-next-line no-empty-blocks\n\n                for {} lt(dataArea, cdEnd) {} {\n\n                    mstore(dataArea, mload(assetData))\n\n                    dataArea := add(dataArea, 32)\n\n                    assetData := add(assetData, 32)\n\n                }\n\n\n\n                /////// Call `assetProxy.transferFrom` using the constructed calldata ///////\n\n                let success := call(\n\n                    gas,                    // forward all gas\n\n                    assetProxy,             // call address of asset proxy\n\n                    0,                      // don't send any ETH\n\n                    cdStart,                // pointer to start of input\n\n                    sub(cdEnd, cdStart),    // length of input\n\n                    cdStart,                // write output over input\n\n                    512                     // reserve 512 bytes for output\n\n                )\n\n                if iszero(success) {\n\n                    revert(cdStart, returndatasize())\n\n                }\n\n            }\n\n        }\n",
                    "message": "Function 'MixinAssetProxyDispatcher._dispatchTransferFrom' (MixinAssetProxyDispatcher.sol#229-328) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/asset-proxy/contracts/archive/MixinAuthorizable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (authorities[i] == target) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[msg.sender],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SENDER_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_ALREADY_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index < authorities.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INDEX_OUT_OF_BOUNDS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorities[index] == target,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"AUTHORIZED_ADDRESS_MISMATCH\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable.transferOwnership (MixinAuthorizable.sol#57-64) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public;\n",
                    "message": "IOwnable.transferOwnership (MixinAuthorizable.sol#31) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MixinAuthorizable.sol:\n\t- pragma solidity^0.5.9 (MixinAuthorizable.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (MixinAuthorizable.sol#36): it allows old versions\n\t- pragma solidity^0.5.9 (MixinAuthorizable.sol#87): it allows old versions\n\t- pragma solidity^0.5.9 (MixinAuthorizable.sol#151): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/asset-proxy/contracts/test/TestStaticCallTarget.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target % 2 == 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 570,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_EVEN\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _state++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_28"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 88,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (TestStaticCallTarget.sol#84-88) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (TestStaticCallTarget.sol#122-127) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (TestStaticCallTarget.sol#132-137) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (TestStaticCallTarget.sol#143-243) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (TestStaticCallTarget.sol#284-312) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (TestStaticCallTarget.sol#317-337) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (TestStaticCallTarget.sol#354-378) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": 422,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (TestStaticCallTarget.sol#384-422) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (TestStaticCallTarget.sol#428-447) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (TestStaticCallTarget.sol#453-471) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 516,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (TestStaticCallTarget.sol#494-516) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength (TestStaticCallTarget.sol#523-527) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 88,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (TestStaticCallTarget.sol#84-88)\n\t- TestStaticCallTarget.sol#85-87\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (TestStaticCallTarget.sol#122-127)\n\t- TestStaticCallTarget.sol#123-125\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (TestStaticCallTarget.sol#132-137)\n\t- TestStaticCallTarget.sol#133-135\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (TestStaticCallTarget.sol#143-243)\n\t- TestStaticCallTarget.sol#148-153\n\t- TestStaticCallTarget.sol#176-206\n\t- TestStaticCallTarget.sol#208-240\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (TestStaticCallTarget.sol#284-312)\n\t- TestStaticCallTarget.sol#307-310\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (TestStaticCallTarget.sol#317-337)\n\t- TestStaticCallTarget.sol#331-335\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (TestStaticCallTarget.sol#354-378)\n\t- TestStaticCallTarget.sol#371-376\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": 422,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (TestStaticCallTarget.sol#384-422)\n\t- TestStaticCallTarget.sol#401-421\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (TestStaticCallTarget.sol#428-447)\n\t- TestStaticCallTarget.sol#443-445\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (TestStaticCallTarget.sol#453-471)\n\t- TestStaticCallTarget.sol#468-470\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 516,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (TestStaticCallTarget.sol#494-516)\n\t- TestStaticCallTarget.sol#509-514\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength uses assembly (TestStaticCallTarget.sol#523-527)\n\t- TestStaticCallTarget.sol#524-526\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestStaticCallTarget.sol:\n\t- pragma solidity^0.5.9 (TestStaticCallTarget.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestStaticCallTarget.sol#67): it allows old versions\n\t- pragma solidity^0.5.9 (TestStaticCallTarget.sol#111): it allows old versions\n\t- pragma solidity^0.5.9 (TestStaticCallTarget.sol#550): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    ) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (TestStaticCallTarget.sol#38-44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 80,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (TestStaticCallTarget.sol#78-80) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 556,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _state;\n",
                    "message": "Variable 'TestStaticCallTarget._state' (TestStaticCallTarget.sol#556) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant INVALID_BYTE_OPERATION_ERROR_SELECTOR = 0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/asset-proxy/contracts/src/MultiAssetProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 465,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (authorities[i] == target) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 465,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentAssetProxy == address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ASSET_PROXY_ALREADY_EXISTS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assetData.length > 3,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assetProxy != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"ASSET_PROXY_DOES_NOT_EXIST\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[msg.sender],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 426,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SENDER_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_ALREADY_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 459,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 484,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 485,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 486,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index < authorities.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INDEX_OUT_OF_BOUNDS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 489,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 490,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 491,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorities[index] == target,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 492,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"AUTHORIZED_ADDRESS_MISMATCH\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (amount > 0 && from != to) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // Ensure assetData length is valid\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assetData.length > 3,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // Lookup assetProxy. We do not use `LibBytes.readBytes4` for gas efficiency reasons.\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4 assetProxyId;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 465,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 497,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 532,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/asset-proxy/contracts/src/ERC721Proxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (authorities[i] == target) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[msg.sender],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SENDER_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_ALREADY_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index < authorities.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INDEX_OUT_OF_BOUNDS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorities[index] == target,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"AUTHORIZED_ADDRESS_MISMATCH\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "assembly",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": 406,
                    "vulnerability_code": "    function ()\n\n        external\n\n    {\n\n        assembly {\n\n            // The first 4 bytes of calldata holds the function selector\n\n            let selector := and(calldataload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n\n\n            // `transferFrom` will be called with the following parameters:\n\n            // assetData Encoded byte array.\n\n            // from Address to transfer asset from.\n\n            // to Address to transfer asset to.\n\n            // amount Amount of asset to transfer.\n\n            // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n\n            if eq(selector, 0xa85e59e400000000000000000000000000000000000000000000000000000000) {\n\n\n\n                // To lookup a value in a mapping, we load from the storage location keccak256(k, p),\n\n                // where k is the key left padded to 32 bytes and p is the storage slot\n\n                let start := mload(64)\n\n                mstore(start, and(caller, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(start, 32), authorized_slot)\n\n\n\n                // Revert if authorized[msg.sender] == false\n\n                if iszero(sload(keccak256(start, 64))) {\n\n                    // Revert with `Error(\"SENDER_NOT_AUTHORIZED\")`\n\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\n                    mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\n\n                    mstore(64, 0x0000001553454e4445525f4e4f545f415554484f52495a454400000000000000)\n\n                    mstore(96, 0)\n\n                    revert(0, 100)\n\n                }\n\n\n\n                // `transferFrom`.\n\n                // The function is marked `external`, so no abi decodeding is done for\n\n                // us. Instead, we expect the `calldata` memory to contain the\n\n                // following:\n\n                //\n\n                // | Area     | Offset | Length  | Contents                            |\n\n                // |----------|--------|---------|-------------------------------------|\n\n                // | Header   | 0      | 4       | function selector                   |\n\n                // | Params   |        | 4 * 32  | function parameters:                |\n\n                // |          | 4      |         |   1. offset to assetData (*)        |\n\n                // |          | 36     |         |   2. from                           |\n\n                // |          | 68     |         |   3. to                             |\n\n                // |          | 100    |         |   4. amount                         |\n\n                // | Data     |        |         | assetData:                          |\n\n                // |          | 132    | 32      | assetData Length                    |\n\n                // |          | 164    | **      | assetData Contents                  |\n\n                //\n\n                // (*): offset is computed from start of function parameters, so offset\n\n                //      by an additional 4 bytes in the calldata.\n\n                //\n\n                // (**): see table below to compute length of assetData Contents\n\n                //\n\n                // WARNING: The ABIv2 specification allows additional padding between\n\n                //          the Params and Data section. This will result in a larger\n\n                //          offset to assetData.\n\n\n\n                // Asset data itself is encoded as follows:\n\n                //\n\n                // | Area     | Offset | Length  | Contents                            |\n\n                // |----------|--------|---------|-------------------------------------|\n\n                // | Header   | 0      | 4       | function selector                   |\n\n                // | Params   |        | 2 * 32  | function parameters:                |\n\n                // |          | 4      | 12 + 20 |   1. token address                  |\n\n                // |          | 36     |         |   2. tokenId                        |\n\n\n\n                // We construct calldata for the `token.transferFrom` ABI.\n\n                // The layout of this calldata is in the table below.\n\n                //\n\n                // | Area     | Offset | Length  | Contents                            |\n\n                // |----------|--------|---------|-------------------------------------|\n\n                // | Header   | 0      | 4       | function selector                   |\n\n                // | Params   |        | 3 * 32  | function parameters:                |\n\n                // |          | 4      |         |   1. from                           |\n\n                // |          | 36     |         |   2. to                             |\n\n                // |          | 68     |         |   3. tokenId                        |\n\n\n\n                // There exists only 1 of each token.\n\n                // require(amount == 1, \"INVALID_AMOUNT\")\n\n                if sub(calldataload(100), 1) {\n\n                    // Revert with `Error(\"INVALID_AMOUNT\")`\n\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\n                    mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\n\n                    mstore(64, 0x0000000e494e56414c49445f414d4f554e540000000000000000000000000000)\n\n                    mstore(96, 0)\n\n                    revert(0, 100)\n\n                }\n\n\n\n                /////// Setup Header Area ///////\n\n                // This area holds the 4-byte `transferFrom` selector.\n\n                // Any trailing data in transferFromSelector will be\n\n                // overwritten in the next `mstore` call.\n\n                mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n\n\n\n                /////// Setup Params Area ///////\n\n                // We copy the fields `from` and `to` in bulk\n\n                // from our own calldata to the new calldata.\n\n                calldatacopy(4, 36, 64)\n\n\n\n                // Copy `tokenId` field from our own calldata to the new calldata.\n\n                let assetDataOffset := calldataload(4)\n\n                calldatacopy(68, add(assetDataOffset, 72), 32)\n\n\n\n                /////// Call `token.transferFrom` using the calldata ///////\n\n                let token := calldataload(add(assetDataOffset, 40))\n\n                let success := call(\n\n                    gas,            // forward all gas\n\n                    token,          // call address of token contract\n\n                    0,              // don't send any ETH\n\n                    0,              // pointer to start of input\n\n                    100,            // length of input\n\n                    0,              // write output to null\n\n                    0               // output size is 0 bytes\n\n                )\n\n                if success {\n\n                    return(0, 0)\n\n                }\n\n\n\n                // Revert with `Error(\"TRANSFER_FAILED\")`\n\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\n                mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\n\n                mstore(64, 0x0000000f5452414e534645525f4641494c454400000000000000000000000000)\n\n                mstore(96, 0)\n\n                revert(0, 100)\n\n            }\n\n\n\n            // Revert if undefined function is called\n\n            revert(0, 0)\n\n        }\n",
                    "message": "ERC721Proxy.fallback uses assembly (ERC721Proxy.sol#277-406)\n\t- ERC721Proxy.sol#280-405\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public;\n",
                    "message": "IOwnable.transferOwnership (ERC721Proxy.sol#31) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable.transferOwnership (ERC721Proxy.sol#57-64) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in ERC721Proxy.sol:\n\t- pragma solidity^0.5.9 (ERC721Proxy.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (ERC721Proxy.sol#36): it allows old versions\n\t- pragma solidity^0.5.9 (ERC721Proxy.sol#87): it allows old versions\n\t- pragma solidity^0.5.9 (ERC721Proxy.sol#151): it allows old versions\n\t- pragma solidity^0.5.9 (ERC721Proxy.sol#268): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/asset-proxy/contracts/src/ERC20Proxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (authorities[i] == target) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[msg.sender],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SENDER_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_ALREADY_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index < authorities.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INDEX_OUT_OF_BOUNDS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorities[index] == target,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"AUTHORIZED_ADDRESS_MISMATCH\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "assembly",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": 419,
                    "vulnerability_code": "    function ()\n\n        external\n\n    {\n\n        assembly {\n\n            // The first 4 bytes of calldata holds the function selector\n\n            let selector := and(calldataload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n\n\n            // `transferFrom` will be called with the following parameters:\n\n            // assetData Encoded byte array.\n\n            // from Address to transfer asset from.\n\n            // to Address to transfer asset to.\n\n            // amount Amount of asset to transfer.\n\n            // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n\n            if eq(selector, 0xa85e59e400000000000000000000000000000000000000000000000000000000) {\n\n\n\n                // To lookup a value in a mapping, we load from the storage location keccak256(k, p),\n\n                // where k is the key left padded to 32 bytes and p is the storage slot\n\n                let start := mload(64)\n\n                mstore(start, and(caller, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(start, 32), authorized_slot)\n\n\n\n                // Revert if authorized[msg.sender] == false\n\n                if iszero(sload(keccak256(start, 64))) {\n\n                    // Revert with `Error(\"SENDER_NOT_AUTHORIZED\")`\n\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\n                    mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\n\n                    mstore(64, 0x0000001553454e4445525f4e4f545f415554484f52495a454400000000000000)\n\n                    mstore(96, 0)\n\n                    revert(0, 100)\n\n                }\n\n\n\n                // `transferFrom`.\n\n                // The function is marked `external`, so no abi decodeding is done for\n\n                // us. Instead, we expect the `calldata` memory to contain the\n\n                // following:\n\n                //\n\n                // | Area     | Offset | Length  | Contents                            |\n\n                // |----------|--------|---------|-------------------------------------|\n\n                // | Header   | 0      | 4       | function selector                   |\n\n                // | Params   |        | 4 * 32  | function parameters:                |\n\n                // |          | 4      |         |   1. offset to assetData (*)        |\n\n                // |          | 36     |         |   2. from                           |\n\n                // |          | 68     |         |   3. to                             |\n\n                // |          | 100    |         |   4. amount                         |\n\n                // | Data     |        |         | assetData:                          |\n\n                // |          | 132    | 32      | assetData Length                    |\n\n                // |          | 164    | **      | assetData Contents                  |\n\n                //\n\n                // (*): offset is computed from start of function parameters, so offset\n\n                //      by an additional 4 bytes in the calldata.\n\n                //\n\n                // (**): see table below to compute length of assetData Contents\n\n                //\n\n                // WARNING: The ABIv2 specification allows additional padding between\n\n                //          the Params and Data section. This will result in a larger\n\n                //          offset to assetData.\n\n\n\n                // Asset data itself is encoded as follows:\n\n                //\n\n                // | Area     | Offset | Length  | Contents                            |\n\n                // |----------|--------|---------|-------------------------------------|\n\n                // | Header   | 0      | 4       | function selector                   |\n\n                // | Params   |        | 1 * 32  | function parameters:                |\n\n                // |          | 4      | 12 + 20 |   1. token address                  |\n\n\n\n                // We construct calldata for the `token.transferFrom` ABI.\n\n                // The layout of this calldata is in the table below.\n\n                //\n\n                // | Area     | Offset | Length  | Contents                            |\n\n                // |----------|--------|---------|-------------------------------------|\n\n                // | Header   | 0      | 4       | function selector                   |\n\n                // | Params   |        | 3 * 32  | function parameters:                |\n\n                // |          | 4      |         |   1. from                           |\n\n                // |          | 36     |         |   2. to                             |\n\n                // |          | 68     |         |   3. amount                         |\n\n\n\n                /////// Read token address from calldata ///////\n\n                // * The token address is stored in `assetData`.\n\n                //\n\n                // * The \"offset to assetData\" is stored at offset 4 in the calldata (table 1).\n\n                //   [assetDataOffsetFromParams = calldataload(4)]\n\n                //\n\n                // * Notes that the \"offset to assetData\" is relative to the \"Params\" area of calldata;\n\n                //   add 4 bytes to account for the length of the \"Header\" area (table 1).\n\n                //   [assetDataOffsetFromHeader = assetDataOffsetFromParams + 4]\n\n                //\n\n                // * The \"token address\" is offset 32+4=36 bytes into \"assetData\" (tables 1 & 2).\n\n                //   [tokenOffset = assetDataOffsetFromHeader + 36 = calldataload(4) + 4 + 36]\n\n                let token := calldataload(add(calldataload(4), 40))\n\n\n\n                /////// Setup Header Area ///////\n\n                // This area holds the 4-byte `transferFrom` selector.\n\n                // Any trailing data in transferFromSelector will be\n\n                // overwritten in the next `mstore` call.\n\n                mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n\n\n\n                /////// Setup Params Area ///////\n\n                // We copy the fields `from`, `to` and `amount` in bulk\n\n                // from our own calldata to the new calldata.\n\n                calldatacopy(4, 36, 96)\n\n\n\n                /////// Call `token.transferFrom` using the calldata ///////\n\n                let success := call(\n\n                    gas,            // forward all gas\n\n                    token,          // call address of token contract\n\n                    0,              // don't send any ETH\n\n                    0,              // pointer to start of input\n\n                    100,            // length of input\n\n                    0,              // write output over input\n\n                    32              // output size should be 32 bytes\n\n                )\n\n\n\n                /////// Check return data. ///////\n\n                // If there is no return data, we assume the token incorrectly\n\n                // does not return a bool. In this case we expect it to revert\n\n                // on failure, which was handled above.\n\n                // If the token does return data, we require that it is a single\n\n                // nonzero 32 bytes value.\n\n                // So the transfer succeeded if the call succeeded and either\n\n                // returned nothing, or returned a non-zero 32 byte value.\n\n                success := and(success, or(\n\n                    iszero(returndatasize),\n\n                    and(\n\n                        eq(returndatasize, 32),\n\n                        gt(mload(0), 0)\n\n                    )\n\n                ))\n\n                if success {\n\n                    return(0, 0)\n\n                }\n\n\n\n                // Revert with `Error(\"TRANSFER_FAILED\")`\n\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\n                mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\n\n                mstore(64, 0x0000000f5452414e534645525f4641494c454400000000000000000000000000)\n\n                mstore(96, 0)\n\n                revert(0, 100)\n\n            }\n\n\n\n            // Revert if undefined function is called\n\n            revert(0, 0)\n\n        }\n",
                    "message": "ERC20Proxy.fallback uses assembly (ERC20Proxy.sol#277-419)\n\t- ERC20Proxy.sol#280-418\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public;\n",
                    "message": "IOwnable.transferOwnership (ERC20Proxy.sol#31) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable.transferOwnership (ERC20Proxy.sol#57-64) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in ERC20Proxy.sol:\n\t- pragma solidity^0.5.9 (ERC20Proxy.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (ERC20Proxy.sol#36): it allows old versions\n\t- pragma solidity^0.5.9 (ERC20Proxy.sol#87): it allows old versions\n\t- pragma solidity^0.5.9 (ERC20Proxy.sol#151): it allows old versions\n\t- pragma solidity^0.5.9 (ERC20Proxy.sol#268): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/asset-proxy/contracts/src/StaticCallProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            expectedReturnDataHash == returnDataHash,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UNEXPECTED_STATIC_CALL_RESULT\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 599,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_30"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 88,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (StaticCallProxy.sol#84-88) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (StaticCallProxy.sol#122-127) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (StaticCallProxy.sol#132-137) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (StaticCallProxy.sol#143-243) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (StaticCallProxy.sol#284-312) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (StaticCallProxy.sol#317-337) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (StaticCallProxy.sol#354-378) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": 422,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (StaticCallProxy.sol#384-422) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (StaticCallProxy.sol#428-447) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (StaticCallProxy.sol#453-471) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 516,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (StaticCallProxy.sol#494-516) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength (StaticCallProxy.sol#523-527) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": 600,
                    "vulnerability_code": "    function transferFrom(\n\n        bytes calldata assetData,\n\n        address from,\n\n        address to,\n\n        uint256 amount\n\n    )\n\n        external\n\n        view\n\n    {\n\n        // Decode params from `assetData`\n\n        (\n\n            address staticCallTarget,\n\n            bytes memory staticCallData,\n\n            bytes32 expectedReturnDataHash\n\n        ) = abi.decode(\n\n            assetData.sliceDestructive(4, assetData.length),\n\n            (address, bytes, bytes32)\n\n        );\n\n\n\n        // Execute staticcall\n\n        (bool success, bytes memory returnData) = staticCallTarget.staticcall(staticCallData);\n\n\n\n        // Revert with returned data if staticcall is unsuccessful\n\n        if (!success) {\n\n            assembly {\n\n                revert(add(returnData, 32), mload(returnData))\n\n            }\n\n        }\n\n\n\n        // Revert if hash of return data is not as expected\n\n        bytes32 returnDataHash = keccak256(returnData);\n\n        require(\n\n            expectedReturnDataHash == returnDataHash,\n\n            \"UNEXPECTED_STATIC_CALL_RESULT\"\n\n        );\n",
                    "message": "StaticCallProxy.transferFrom (StaticCallProxy.sol#565-600) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 88,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (StaticCallProxy.sol#84-88)\n\t- StaticCallProxy.sol#85-87\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (StaticCallProxy.sol#122-127)\n\t- StaticCallProxy.sol#123-125\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (StaticCallProxy.sol#132-137)\n\t- StaticCallProxy.sol#133-135\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (StaticCallProxy.sol#143-243)\n\t- StaticCallProxy.sol#148-153\n\t- StaticCallProxy.sol#176-206\n\t- StaticCallProxy.sol#208-240\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (StaticCallProxy.sol#284-312)\n\t- StaticCallProxy.sol#307-310\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (StaticCallProxy.sol#317-337)\n\t- StaticCallProxy.sol#331-335\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (StaticCallProxy.sol#354-378)\n\t- StaticCallProxy.sol#371-376\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": 422,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (StaticCallProxy.sol#384-422)\n\t- StaticCallProxy.sol#401-421\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (StaticCallProxy.sol#428-447)\n\t- StaticCallProxy.sol#443-445\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (StaticCallProxy.sol#453-471)\n\t- StaticCallProxy.sol#468-470\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 516,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (StaticCallProxy.sol#494-516)\n\t- StaticCallProxy.sol#509-514\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength uses assembly (StaticCallProxy.sol#523-527)\n\t- StaticCallProxy.sol#524-526\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": 600,
                    "vulnerability_code": "    function transferFrom(\n\n        bytes calldata assetData,\n\n        address from,\n\n        address to,\n\n        uint256 amount\n\n    )\n\n        external\n\n        view\n\n    {\n\n        // Decode params from `assetData`\n\n        (\n\n            address staticCallTarget,\n\n            bytes memory staticCallData,\n\n            bytes32 expectedReturnDataHash\n\n        ) = abi.decode(\n\n            assetData.sliceDestructive(4, assetData.length),\n\n            (address, bytes, bytes32)\n\n        );\n\n\n\n        // Execute staticcall\n\n        (bool success, bytes memory returnData) = staticCallTarget.staticcall(staticCallData);\n\n\n\n        // Revert with returned data if staticcall is unsuccessful\n\n        if (!success) {\n\n            assembly {\n\n                revert(add(returnData, 32), mload(returnData))\n\n            }\n\n        }\n\n\n\n        // Revert if hash of return data is not as expected\n\n        bytes32 returnDataHash = keccak256(returnData);\n\n        require(\n\n            expectedReturnDataHash == returnDataHash,\n\n            \"UNEXPECTED_STATIC_CALL_RESULT\"\n\n        );\n",
                    "message": "StaticCallProxy.transferFrom uses assembly (StaticCallProxy.sol#565-600)\n\t- StaticCallProxy.sol#589-591\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in StaticCallProxy.sol:\n\t- pragma solidity^0.5.9 (StaticCallProxy.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (StaticCallProxy.sol#67): it allows old versions\n\t- pragma solidity^0.5.9 (StaticCallProxy.sol#111): it allows old versions\n\t- pragma solidity^0.5.9 (StaticCallProxy.sol#550): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": 600,
                    "vulnerability_code": "    function transferFrom(\n\n        bytes calldata assetData,\n\n        address from,\n\n        address to,\n\n        uint256 amount\n\n    )\n\n        external\n\n        view\n\n    {\n\n        // Decode params from `assetData`\n\n        (\n\n            address staticCallTarget,\n\n            bytes memory staticCallData,\n\n            bytes32 expectedReturnDataHash\n\n        ) = abi.decode(\n\n            assetData.sliceDestructive(4, assetData.length),\n\n            (address, bytes, bytes32)\n\n        );\n\n\n\n        // Execute staticcall\n\n        (bool success, bytes memory returnData) = staticCallTarget.staticcall(staticCallData);\n\n\n\n        // Revert with returned data if staticcall is unsuccessful\n\n        if (!success) {\n\n            assembly {\n\n                revert(add(returnData, 32), mload(returnData))\n\n            }\n\n        }\n\n\n\n        // Revert if hash of return data is not as expected\n\n        bytes32 returnDataHash = keccak256(returnData);\n\n        require(\n\n            expectedReturnDataHash == returnDataHash,\n\n            \"UNEXPECTED_STATIC_CALL_RESULT\"\n\n        );\n",
                    "message": "Low level call in StaticCallProxy.transferFrom (StaticCallProxy.sol#565-600):\n\t-(success,returnData) = staticCallTarget.staticcall(staticCallData) StaticCallProxy.sol#585\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    ) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (StaticCallProxy.sol#38-44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 80,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (StaticCallProxy.sol#78-80) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant INVALID_BYTE_OPERATION_ERROR_SELECTOR = 0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 585,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, bytes memory returnData) = staticCallTarget.staticcall(staticCallData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 589,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/asset-proxy/contracts/src/interfaces/IAuthorizable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public;\n",
                    "message": "IOwnable.transferOwnership (IAuthorizable.sol#31) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IAuthorizable.sol:\n\t- pragma solidity^0.5.9 (IAuthorizable.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (IAuthorizable.sol#54): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/asset-proxy/contracts/src/interfaces/IAssetProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IAssetProxy.sol:\n\t- pragma solidity^0.5.9 (IAssetProxy.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/asset-proxy/contracts/src/interfaces/IAssetData.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in IAssetData.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- IAssetData.sol#22 declares pragma solidity^0.5.9\n\t- IAssetData.sol#23 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IAssetData.sol:\n\t- pragma solidity^0.5.9 (IAssetData.sol#22): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function ERC20Token(address tokenAddress)\n",
                    "message": "Function 'IAssetData.ERC20Token' (IAssetData.sol#33-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": 43,
                    "vulnerability_code": "    function ERC721Token(\n\n        address tokenAddress,\n\n        uint256 tokenId\n\n    )\n",
                    "message": "Function 'IAssetData.ERC721Token' (IAssetData.sol#39-43) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": 57,
                    "vulnerability_code": "    function ERC1155Assets(\n\n        address tokenAddress,\n\n        uint256[] calldata tokenIds,\n\n        uint256[] calldata values,\n\n        bytes calldata callbackData\n\n    )\n",
                    "message": "Function 'IAssetData.ERC1155Assets' (IAssetData.sol#51-57) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": 67,
                    "vulnerability_code": "    function MultiAsset(\n\n        uint256[] calldata values,\n\n        bytes[] calldata nestedAssetData\n\n    )\n",
                    "message": "Function 'IAssetData.MultiAsset' (IAssetData.sol#63-67) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": 78,
                    "vulnerability_code": "    function StaticCall(\n\n        address staticCallTargetAddress,\n\n        bytes calldata staticCallData,\n\n        bytes32 expectedReturnDataHash\n\n    )\n",
                    "message": "Function 'IAssetData.StaticCall' (IAssetData.sol#73-78) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ERC1155Assets(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function StaticCall(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata tokenIds,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata callbackData\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata staticCallData,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes32 expectedReturnDataHash\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/asset-proxy/contracts/src/interfaces/IAssetProxyDispatcher.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IAssetProxyDispatcher.sol:\n\t- pragma solidity^0.5.9 (IAssetProxyDispatcher.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/erc721/contracts/test/InvalidERC721Receiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in InvalidERC721Receiver.sol:\n\t- Version used: ['^0.5.5', '^0.5.9']\n\t- InvalidERC721Receiver.sol#21 declares pragma solidity^0.5.9\n\t- InvalidERC721Receiver.sol#68 declares pragma solidity^0.5.5\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in InvalidERC721Receiver.sol:\n\t- pragma solidity^0.5.9 (InvalidERC721Receiver.sol#21): it allows old versions\n\t- pragma solidity^0.5.5 (InvalidERC721Receiver.sol#68): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _operator,\n",
                    "message": "Parameter '_operator' of InvalidERC721Receiver.onERC721Received (InvalidERC721Receiver.sol#96) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of InvalidERC721Receiver.onERC721Received (InvalidERC721Receiver.sol#97) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId,\n",
                    "message": "Parameter '_tokenId' of InvalidERC721Receiver.onERC721Received (InvalidERC721Receiver.sol#98) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata _data\n",
                    "message": "Parameter '_data' of InvalidERC721Receiver.onERC721Received (InvalidERC721Receiver.sol#99) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/erc721/contracts/test/DummyERC721Receiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in DummyERC721Receiver.sol:\n\t- Version used: ['^0.5.5', '^0.5.9']\n\t- DummyERC721Receiver.sol#21 declares pragma solidity^0.5.9\n\t- DummyERC721Receiver.sol#68 declares pragma solidity^0.5.5\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in DummyERC721Receiver.sol:\n\t- pragma solidity^0.5.9 (DummyERC721Receiver.sol#21): it allows old versions\n\t- pragma solidity^0.5.5 (DummyERC721Receiver.sol#68): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _operator,\n",
                    "message": "Parameter '_operator' of DummyERC721Receiver.onERC721Received (DummyERC721Receiver.sol#97) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of DummyERC721Receiver.onERC721Received (DummyERC721Receiver.sol#98) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId,\n",
                    "message": "Parameter '_tokenId' of DummyERC721Receiver.onERC721Received (DummyERC721Receiver.sol#99) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata _data\n",
                    "message": "Parameter '_data' of DummyERC721Receiver.onERC721Received (DummyERC721Receiver.sol#100) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/erc721/contracts/src/interfaces/IERC721Receiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IERC721Receiver.sol:\n\t- pragma solidity^0.5.9 (IERC721Receiver.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/erc721/contracts/src/interfaces/IERC721Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": 160,
                    "vulnerability_code": "contract IERC721Token {\n\n\n\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n\n    ///      This event emits when NFTs are created (`from` == 0) and destroyed\n\n    ///      (`to` == 0). Exception: during contract creation, any number of NFTs\n\n    ///      may be created and assigned without emitting Transfer. At the time of\n\n    ///      any transfer, the approved address for that NFT (if any) is reset to none.\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /// @dev This emits when the approved address for an NFT is changed or\n\n    ///      reaffirmed. The zero address indicates there is no approved address.\n\n    ///      When a Transfer event emits, this also indicates that the approved\n\n    ///      address for that NFT (if any) is reset to none.\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n\n    ///      The operator can manage all NFTs of the owner.\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n\n    ///      perator, or the approved address for this NFT. Throws if `_from` is\n\n    ///      not the current owner. Throws if `_to` is the zero address. Throws if\n\n    ///      `_tokenId` is not a valid NFT. When transfer is complete, this function\n\n    ///      checks if `_to` is a smart contract (code size > 0). If so, it calls\n\n    ///      `onERC721Received` on `_to` and throws if the return value is not\n\n    ///      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    /// @param _data Additional data with no specified format, sent in call to `_to`\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    )\n\n        external;\n\n\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n\n    /// @dev This works identically to the other function with an extra data parameter,\n\n    ///      except this function just sets data to \"\".\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        external;\n\n\n\n    /// @notice Change or reaffirm the approved address for an NFT\n\n    /// @dev The zero address indicates there is no approved address.\n\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized\n\n    ///      operator of the current owner.\n\n    /// @param _approved The new approved NFT controller\n\n    /// @param _tokenId The NFT to approve\n\n    function approve(address _approved, uint256 _tokenId)\n\n        external;\n\n\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n\n    ///         all of `msg.sender`'s assets\n\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n\n    ///      multiple operators per owner.\n\n    /// @param _operator Address to add to the set of authorized operators\n\n    /// @param _approved True if the operator is approved, false to revoke approval\n\n    function setApprovalForAll(address _operator, bool _approved)\n\n        external;\n\n\n\n    /// @notice Count all NFTs assigned to an owner\n\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n\n    ///      function throws for queries about the zero address.\n\n    /// @param _owner An address for whom to query the balance\n\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n\n    function balanceOf(address _owner)\n\n        external\n\n        view\n\n        returns (uint256);\n\n\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n\n    ///         TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n\n    ///         THEY MAY BE PERMANENTLY LOST\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n\n    ///      operator, or the approved address for this NFT. Throws if `_from` is\n\n    ///      not the current owner. Throws if `_to` is the zero address. Throws if\n\n    ///      `_tokenId` is not a valid NFT.\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        public;\n\n\n\n    /// @notice Find the owner of an NFT\n\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n\n    ///      about them do throw.\n\n    /// @param _tokenId The identifier for an NFT\n\n    /// @return The address of the owner of the NFT\n\n    function ownerOf(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address);\n\n\n\n    /// @notice Get the approved address for a single NFT\n\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n\n    /// @param _tokenId The NFT to find the approved address for\n\n    /// @return The approved address for this NFT, or the zero address if there is none\n\n    function getApproved(uint256 _tokenId) \n\n        public\n\n        view\n\n        returns (address);\n\n    \n\n    /// @notice Query if an address is an authorized operator for another address\n\n    /// @param _owner The address that owns the NFTs\n\n    /// @param _operator The address that acts on behalf of the owner\n\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        public\n\n        view\n\n        returns (bool);\n",
                    "message": "IERC721Token (IERC721Token.sol#24-160) has incorrect ERC20 function interface(s):\n\t-approve (IERC721Token.sol#94-95)\n\t-transferFrom (IERC721Token.sol#126-131)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": 131,
                    "vulnerability_code": "    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n",
                    "message": "IERC721Token.transferFrom (IERC721Token.sol#126-131) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": 141,
                    "vulnerability_code": "    function ownerOf(uint256 _tokenId)\n\n        public\n\n        view\n",
                    "message": "IERC721Token.ownerOf (IERC721Token.sol#138-141) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 150,
                    "vulnerability_code": "    function getApproved(uint256 _tokenId) \n\n        public\n\n        view\n",
                    "message": "IERC721Token.getApproved (IERC721Token.sol#147-150) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": 159,
                    "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n\n        public\n\n        view\n",
                    "message": "IERC721Token.isApprovedForAll (IERC721Token.sol#156-159) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IERC721Token.sol:\n\t- pragma solidity^0.5.9 (IERC721Token.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/exchange-forwarder/contracts/src/libs/LibForwarderRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UNREGISTERED_ASSET_PROXY_ERROR_SELECTOR);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UNSUPPORTED_ASSET_PROXY_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            proxyId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            COMPLETE_BUY_FAILED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            expectedAssetBuyAmount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            actualAssetBuyAmount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MAKER_ASSET_MISMATCH_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            firstOrderMakerAssetData,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            mismatchedMakerAssetData\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UNSUPPORTED_FEE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            takerFeeAssetData\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            FEE_PERCENTAGE_TOO_LARGE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            feePercentage\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INSUFFICIENT_ETH_FOR_FEE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ethFeeRequired,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ethAvailable\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 207,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OVERSOLD_WETH_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            wethSold,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msgValue\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            TRANSFER_FAILED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorData\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            DEFAULT_FUNCTION_WETH_CONTRACT_ONLY_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(MSG_VALUE_CANT_EQUAL_ZERO_ERROR_SELECTOR);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ERC721_AMOUNT_MUST_EQUAL_ONE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_16"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibForwarderRichErrors.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibForwarderRichErrors.sol#38-42)\n\t- LibForwarderRichErrors.sol#39-41\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibForwarderRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibForwarderRichErrors.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibForwarderRichErrors.sol#65): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibForwarderRichErrors.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": 124,
                    "vulnerability_code": "    function UnregisteredAssetProxyError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(UNREGISTERED_ASSET_PROXY_ERROR_SELECTOR);\n",
                    "message": "Function 'LibForwarderRichErrors.UnregisteredAssetProxyError' (LibForwarderRichErrors.sol#118-124) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function UnsupportedAssetProxyError(\n\n        bytes4 proxyId\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UNSUPPORTED_ASSET_PROXY_ERROR_SELECTOR,\n\n            proxyId\n\n        );\n",
                    "message": "Function 'LibForwarderRichErrors.UnsupportedAssetProxyError' (LibForwarderRichErrors.sol#126-137) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "    function CompleteBuyFailedError(\n\n        uint256 expectedAssetBuyAmount,\n\n        uint256 actualAssetBuyAmount\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            COMPLETE_BUY_FAILED_ERROR_SELECTOR,\n\n            expectedAssetBuyAmount,\n\n            actualAssetBuyAmount\n\n        );\n",
                    "message": "Function 'LibForwarderRichErrors.CompleteBuyFailedError' (LibForwarderRichErrors.sol#139-152) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": 167,
                    "vulnerability_code": "    function MakerAssetMismatchError(\n\n        bytes memory firstOrderMakerAssetData,\n\n        bytes memory mismatchedMakerAssetData\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            MAKER_ASSET_MISMATCH_ERROR_SELECTOR,\n\n            firstOrderMakerAssetData,\n\n            mismatchedMakerAssetData\n\n        );\n",
                    "message": "Function 'LibForwarderRichErrors.MakerAssetMismatchError' (LibForwarderRichErrors.sol#154-167) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": 180,
                    "vulnerability_code": "    function UnsupportedFeeError(\n\n        bytes memory takerFeeAssetData\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UNSUPPORTED_FEE_ERROR_SELECTOR,\n\n            takerFeeAssetData\n\n        );\n",
                    "message": "Function 'LibForwarderRichErrors.UnsupportedFeeError' (LibForwarderRichErrors.sol#169-180) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": 193,
                    "vulnerability_code": "    function FeePercentageTooLargeError(\n\n        uint256 feePercentage\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            FEE_PERCENTAGE_TOO_LARGE_ERROR_SELECTOR,\n\n            feePercentage\n\n        );\n",
                    "message": "Function 'LibForwarderRichErrors.FeePercentageTooLargeError' (LibForwarderRichErrors.sol#182-193) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function InsufficientEthForFeeError(\n\n        uint256 ethFeeRequired,\n\n        uint256 ethAvailable\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INSUFFICIENT_ETH_FOR_FEE_ERROR_SELECTOR,\n\n            ethFeeRequired,\n\n            ethAvailable\n\n        );\n",
                    "message": "Function 'LibForwarderRichErrors.InsufficientEthForFeeError' (LibForwarderRichErrors.sol#195-208) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": 223,
                    "vulnerability_code": "    function OversoldWethError(\n\n        uint256 wethSold,\n\n        uint256 msgValue\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            OVERSOLD_WETH_ERROR_SELECTOR,\n\n            wethSold,\n\n            msgValue\n\n        );\n",
                    "message": "Function 'LibForwarderRichErrors.OversoldWethError' (LibForwarderRichErrors.sol#210-223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": 236,
                    "vulnerability_code": "    function TransferFailedError(\n\n        bytes memory errorData\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            TRANSFER_FAILED_ERROR_SELECTOR,\n\n            errorData\n\n        );\n",
                    "message": "Function 'LibForwarderRichErrors.TransferFailedError' (LibForwarderRichErrors.sol#225-236) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": 249,
                    "vulnerability_code": "    function DefaultFunctionWethContractOnlyError(\n\n        address senderAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            DEFAULT_FUNCTION_WETH_CONTRACT_ONLY_ERROR_SELECTOR,\n\n            senderAddress\n\n        );\n",
                    "message": "Function 'LibForwarderRichErrors.DefaultFunctionWethContractOnlyError' (LibForwarderRichErrors.sol#238-249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": 257,
                    "vulnerability_code": "    function MsgValueCantEqualZeroError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(MSG_VALUE_CANT_EQUAL_ZERO_ERROR_SELECTOR);\n",
                    "message": "Function 'LibForwarderRichErrors.MsgValueCantEqualZeroError' (LibForwarderRichErrors.sol#251-257) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": 270,
                    "vulnerability_code": "    function Erc721AmountMustEqualOneError(\n\n        uint256 amount\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ERC721_AMOUNT_MUST_EQUAL_ONE_ERROR_SELECTOR,\n\n            amount\n\n        );\n",
                    "message": "Function 'LibForwarderRichErrors.Erc721AmountMustEqualOneError' (LibForwarderRichErrors.sol#259-270) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xf3b96b8d;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7996a271;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x91353a0c;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x56677f2c;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x31360af1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x1174fb80;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xecf40fd9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x5cc555c8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x5e7eb60f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08b18698;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x1213e1d6;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xbaffa474;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/exchange-forwarder/contracts/src/interfaces/IAssets.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IAssets.sol:\n\t- pragma solidity^0.5.9 (IAssets.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/erc1155/contracts/test/DummyERC1155Receiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        shouldRejectTransfer = false;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"TRANSFER_REJECTED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"TRANSFER_REJECTED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in DummyERC1155Receiver.sol:\n\t- Version used: ['^0.5.5', '^0.5.9']\n\t- DummyERC1155Receiver.sol#21 declares pragma solidity^0.5.9\n\t- DummyERC1155Receiver.sol#91 declares pragma solidity^0.5.5\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in DummyERC1155Receiver.sol:\n\t- pragma solidity^0.5.9 (DummyERC1155Receiver.sol#21): it allows old versions\n\t- pragma solidity^0.5.5 (DummyERC1155Receiver.sol#91): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRejectTransferFlag(bool _shouldRejectTransfer) external {\n",
                    "message": "Parameter '_shouldRejectTransfer' of DummyERC1155Receiver.setRejectTransferFlag (DummyERC1155Receiver.sol#192) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant public ERC1155_RECEIVED       = 0xf23a6e61;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant public ERC1155_BATCH_RECEIVED = 0xbc197c81;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (shouldRejectTransfer) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onERC1155BatchReceived(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onERC1155BatchReceived(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata ids,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns(bytes4);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata ids,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bytes4)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (shouldRejectTransfer) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"TRANSFER_REJECTED\");\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/erc1155/contracts/src/MixinNonFungibleToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_9"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (uint256 => address) internal nfOwners;\n",
                    "message": "MixinNonFungibleToken.nfOwners (MixinNonFungibleToken.sol#36) is never initialized. It is used in:\n\t- ownerOf (MixinNonFungibleToken.sol#71-73)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function isNonFungible(uint256 id) public pure returns(bool) {\n\n        return id & TYPE_NF_BIT == TYPE_NF_BIT;\n",
                    "message": "MixinNonFungibleToken.isNonFungible (MixinNonFungibleToken.sol#39-41) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": 46,
                    "vulnerability_code": "    function isFungible(uint256 id) public pure returns(bool) {\n\n        return id & TYPE_NF_BIT == 0;\n",
                    "message": "MixinNonFungibleToken.isFungible (MixinNonFungibleToken.sol#44-46) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": 51,
                    "vulnerability_code": "    function getNonFungibleIndex(uint256 id) public pure returns(uint256) {\n\n        return id & NF_INDEX_MASK;\n",
                    "message": "MixinNonFungibleToken.getNonFungibleIndex (MixinNonFungibleToken.sol#49-51) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function getNonFungibleBaseType(uint256 id) public pure returns(uint256) {\n\n        return id & TYPE_MASK;\n",
                    "message": "MixinNonFungibleToken.getNonFungibleBaseType (MixinNonFungibleToken.sol#54-56) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": 62,
                    "vulnerability_code": "    function isNonFungibleBaseType(uint256 id) public pure returns(bool) {\n\n        // A base type has the NF bit but does not have an index.\n\n        return (id & TYPE_NF_BIT == TYPE_NF_BIT) && (id & NF_INDEX_MASK == 0);\n",
                    "message": "MixinNonFungibleToken.isNonFungibleBaseType (MixinNonFungibleToken.sol#59-62) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": 68,
                    "vulnerability_code": "    function isNonFungibleItem(uint256 id) public pure returns(bool) {\n\n        // A base type has the NF bit but does has an index.\n\n        return (id & TYPE_NF_BIT == TYPE_NF_BIT) && (id & NF_INDEX_MASK != 0);\n",
                    "message": "MixinNonFungibleToken.isNonFungibleItem (MixinNonFungibleToken.sol#65-68) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": 73,
                    "vulnerability_code": "    function ownerOf(uint256 id) public view returns (address) {\n\n        return nfOwners[id];\n",
                    "message": "MixinNonFungibleToken.ownerOf (MixinNonFungibleToken.sol#71-73) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MixinNonFungibleToken.sol:\n\t- pragma solidity^0.5.9 (MixinNonFungibleToken.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/erc1155/contracts/src/interfaces/IERC1155Mintable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IERC1155Mintable.sol:\n\t- pragma solidity^0.5.9 (IERC1155Mintable.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (IERC1155Mintable.sol#158): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safeBatchTransferFrom(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintFungible(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata ids,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata to,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata quantities\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/erc1155/contracts/src/interfaces/IERC1155Receiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IERC1155Receiver.sol:\n\t- pragma solidity^0.5.9 (IERC1155Receiver.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onERC1155BatchReceived(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata ids,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns(bytes4);\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/contracts/erc1155/contracts/src/interfaces/IERC1155.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IERC1155.sol:\n\t- pragma solidity^0.5.9 (IERC1155.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safeBatchTransferFrom(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata ids,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata data\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/packages/sol-doc/test/fixtures/contracts/StructParamAndReturn.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.24;\n",
                    "message": "Different versions of Solidity is used in StructParamAndReturn.sol:\n\t- Version used: ['0.4.24', 'ABIEncoderV2']\n\t- StructParamAndReturn.sol#3 declares pragma solidity0.4.24\n\t- StructParamAndReturn.sol#4 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": 19,
                    "vulnerability_code": "    function methodWithStructParamAndReturn(Stuff stuff) public pure returns(Stuff) {\n\n        return stuff;\n",
                    "message": "StructParamAndReturn.methodWithStructParamAndReturn (StructParamAndReturn.sol#17-19) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function methodWithStructParamAndReturn(Stuff stuff) public pure returns(Stuff) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function methodWithStructParamAndReturn(Stuff stuff) public pure returns(Stuff) {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/packages/sol-doc/test/fixtures/contracts/MultipleReturnValues.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": 8,
                    "vulnerability_code": "    function methodWithMultipleReturnValues() public pure returns(int, int) {\n\n        return (0, 0);\n",
                    "message": "MultipleReturnValues.methodWithMultipleReturnValues (MultipleReturnValues.sol#6-8) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/packages/sol-doc/test/fixtures/contracts/NatspecEverything.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(int p) public { d = p; }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function publicMethod(int p) public pure returns(int r) { return p; }\n",
                    "message": "NatspecEverything.publicMethod (NatspecEverything.sol#19) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function () public {}\n",
                    "message": "NatspecEverything.fallback (NatspecEverything.sol#22) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function methodWithLongDevdoc(int p) public pure returns(int) { return p; }\n",
                    "message": "NatspecEverything.methodWithLongDevdoc (NatspecEverything.sol#33) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function methodWithSolhintDirective() public pure {}\n",
                    "message": "NatspecEverything.methodWithSolhintDirective (NatspecEverything.sol#41) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function () public {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int d;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/packages/sol-compiler/test/fixtures/contracts/BadContractName.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": "Detected issues with version pragma in BadContractName.sol:\n\t- pragma solidity^0.4.14 (BadContractName.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/packages/sol-compiler/test/fixtures/contracts/EmptyContract.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": "Detected issues with version pragma in EmptyContract.sol:\n\t- pragma solidity^0.4.14 (EmptyContract.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/packages/sol-compiler/test/fixtures/contracts/base/Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
                    "message": "Token.totalSupply (Token.sol#8) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
                    "message": "Token.balanceOf (Token.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint _value) returns (bool success) {}\n",
                    "message": "Token.transfer (Token.sol#18) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n",
                    "message": "Token.transferFrom (Token.sol#25) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool success) {}\n",
                    "message": "Token.approve (Token.sol#31) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
                    "message": "Token.allowance (Token.sol#36) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": "Detected issues with version pragma in Token.sol:\n\t- pragma solidity^0.4.14 (Token.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/packages/sol-compiler/test/fixtures/contracts/base/SafeMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": "Detected issues with version pragma in SafeMath.sol:\n\t- pragma solidity^0.4.14 (SafeMath.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safeMul(uint a, uint b) internal constant returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safeDiv(uint a, uint b) internal constant returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safeSub(uint a, uint b) internal constant returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safeAdd(uint a, uint b) internal constant returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/packages/abi-gen/test-cli/fixtures/contracts/LibDummy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": "Detected issues with version pragma in LibDummy.sol:\n\t- pragma solidity^0.5.5 (LibDummy.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/packages/abi-gen/test-cli/fixtures/contracts/TestLibDummy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": 78,
                    "vulnerability_code": "    function publicAddOne (uint256 x)\n\n        public\n\n        pure\n\n        returns (uint256 result)\n\n    {\n\n        return x.addOne();\n",
                    "message": "TestLibDummy.publicAddOne (TestLibDummy.sol#72-78) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": 86,
                    "vulnerability_code": "    function publicAddConstant (uint256 x)\n\n        public\n\n        pure\n\n        returns (uint256 result)\n\n    {\n\n        return x.addConstant();\n",
                    "message": "TestLibDummy.publicAddConstant (TestLibDummy.sol#80-86) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": "Detected issues with version pragma in TestLibDummy.sol:\n\t- pragma solidity^0.5.5 (TestLibDummy.sol#21): it allows old versions\n\t- pragma solidity^0.5.5 (TestLibDummy.sol#66): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/packages/abi-gen/test-cli/fixtures/contracts/AbiGenDummy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function nonPureMethod() public returns(uint) { return someState += 1; }\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function nonPureMethodThatReturnsNothing() public { someState += 1; }\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        revert(\"SIMPLE_REVERT\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(0 > 1, \"SIMPLE_REQUIRE\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_36"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma experimental ABIEncoderV2;\n",
                    "message": "Different versions of Solidity is used in AbiGenDummy.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.5']\n\t- AbiGenDummy.sol#21 declares pragma experimentalABIEncoderV2\n\t- AbiGenDummy.sol#23 declares pragma solidity^0.5.5\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 39,
                    "vulnerability_code": "    function simplePureFunction ()\n\n        public\n\n        pure\n\n        returns (uint256 result)\n\n    {\n\n        return 1;\n",
                    "message": "AbiGenDummy.simplePureFunction (AbiGenDummy.sol#33-39) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function simplePureFunctionWithInput (uint256 x)\n\n        public\n\n        pure\n\n        returns (uint256 sum)\n\n    {\n\n        return 1 + x;\n",
                    "message": "AbiGenDummy.simplePureFunctionWithInput (AbiGenDummy.sol#41-47) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "    function pureFunctionWithConstant ()\n\n        public\n\n        pure\n\n        returns (uint256 someConstant)\n\n    {\n\n        return SOME_CONSTANT;\n",
                    "message": "AbiGenDummy.pureFunctionWithConstant (AbiGenDummy.sol#49-55) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 62,
                    "vulnerability_code": "    function simpleRevert ()\n\n        public\n\n        pure\n\n    {\n\n        revert(\"SIMPLE_REVERT\");\n",
                    "message": "AbiGenDummy.simpleRevert (AbiGenDummy.sol#57-62) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": 69,
                    "vulnerability_code": "    function revertWithConstant ()\n\n        public\n\n        pure\n\n    {\n\n        revert(REVERT_REASON);\n",
                    "message": "AbiGenDummy.revertWithConstant (AbiGenDummy.sol#64-69) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": 76,
                    "vulnerability_code": "    function simpleRequire ()\n\n        public\n\n        pure\n\n    {\n\n        require(0 > 1, \"SIMPLE_REQUIRE\");\n",
                    "message": "AbiGenDummy.simpleRequire (AbiGenDummy.sol#71-76) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 83,
                    "vulnerability_code": "    function requireWithConstant ()\n\n        public\n\n        pure\n\n    {\n\n        require(0 > 1, REQUIRE_REASON);\n",
                    "message": "AbiGenDummy.requireWithConstant (AbiGenDummy.sol#78-83) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": 100,
                    "vulnerability_code": "    function ecrecoverFn(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n\n        public\n\n        pure\n\n        returns (address signerAddress)\n\n    {\n\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\n\n        return ecrecover(prefixedHash, v, r, s);\n",
                    "message": "AbiGenDummy.ecrecoverFn (AbiGenDummy.sol#92-100) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": 106,
                    "vulnerability_code": "    function withdraw(uint wad) public {\n\n        emit Withdrawal(msg.sender, wad);\n",
                    "message": "AbiGenDummy.withdraw (AbiGenDummy.sol#104-106) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": 116,
                    "vulnerability_code": "    function withAddressInput(address x, uint256 a, uint256 b, address y, uint256 c)\n\n        public\n\n        pure\n\n        returns (address z)\n\n    {\n\n        return x;\n",
                    "message": "AbiGenDummy.withAddressInput (AbiGenDummy.sol#110-116) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function acceptsBytes(bytes memory a) public pure {}\n",
                    "message": "AbiGenDummy.acceptsBytes (AbiGenDummy.sol#120) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function acceptsAnArrayOfBytes(bytes[] memory a) public pure {}\n",
                    "message": "AbiGenDummy.acceptsAnArrayOfBytes (AbiGenDummy.sol#124) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function structInput(Struct memory s) public pure {}\n",
                    "message": "AbiGenDummy.structInput (AbiGenDummy.sol#133) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": 148,
                    "vulnerability_code": "    function structOutput() public pure returns(Struct memory s) {\n\n        bytes[] memory byteArray = new bytes[](2);\n\n        byteArray[0] = \"0x123\";\n\n        byteArray[1] = \"0x321\";\n\n\n\n        return Struct({\n\n            someBytes: \"0x123\",\n\n            anInteger: 5,\n\n            aDynamicArrayOfBytes: byteArray,\n\n            aString: \"abc\"\n\n        });\n",
                    "message": "AbiGenDummy.structOutput (AbiGenDummy.sol#137-148) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function methodReturningArrayOfStructs() public pure returns(Struct[] memory) {}\n",
                    "message": "AbiGenDummy.methodReturningArrayOfStructs (AbiGenDummy.sol#150) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function nestedStructInput(NestedStruct memory n) public pure {}\n",
                    "message": "AbiGenDummy.nestedStructInput (AbiGenDummy.sol#157) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function nestedStructOutput() public pure returns(NestedStruct memory) {}\n",
                    "message": "AbiGenDummy.nestedStructOutput (AbiGenDummy.sol#158) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": 170,
                    "vulnerability_code": "    function methodUsingNestedStructWithInnerStructNotUsedElsewhere()\n\n        public pure returns(NestedStructWithInnerStructNotUsedElsewhere  memory)\n",
                    "message": "AbiGenDummy.methodUsingNestedStructWithInnerStructNotUsedElsewhere (AbiGenDummy.sol#168-170) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function nonPureMethod() public returns(uint) { return someState += 1; }\n",
                    "message": "AbiGenDummy.nonPureMethod (AbiGenDummy.sol#173) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function nonPureMethodThatReturnsNothing() public { someState += 1; }\n",
                    "message": "AbiGenDummy.nonPureMethodThatReturnsNothing (AbiGenDummy.sol#174) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": 180,
                    "vulnerability_code": "    function methodReturningMultipleValues()\n\n        public pure returns (uint256, string memory)\n\n    {\n\n        return (1, \"hello\");\n",
                    "message": "AbiGenDummy.methodReturningMultipleValues (AbiGenDummy.sol#176-180) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function overloadedMethod(int a) public pure {}\n",
                    "message": "AbiGenDummy.overloadedMethod (AbiGenDummy.sol#182) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function overloadedMethod(string memory a) public pure {}\n",
                    "message": "AbiGenDummy.overloadedMethod (AbiGenDummy.sol#183) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function noInputNoOutput()\n\n        public\n\n        pure\n\n    {\n\n        // NOP\n\n        require(true == true);\n",
                    "message": "AbiGenDummy.noInputNoOutput (AbiGenDummy.sol#202-208) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": 217,
                    "vulnerability_code": "    function noInputSimpleOutput()\n\n        public\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        return 1991;\n",
                    "message": "AbiGenDummy.noInputSimpleOutput (AbiGenDummy.sol#211-217) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": 226,
                    "vulnerability_code": "    function simpleInputNoOutput(uint256)\n\n        public\n\n        pure\n\n    {\n\n        // NOP\n\n        require(true == true);\n",
                    "message": "AbiGenDummy.simpleInputNoOutput (AbiGenDummy.sol#220-226) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": 235,
                    "vulnerability_code": "    function simpleInputSimpleOutput(uint256)\n\n        public\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        return 1991;\n",
                    "message": "AbiGenDummy.simpleInputSimpleOutput (AbiGenDummy.sol#229-235) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": 249,
                    "vulnerability_code": "    function complexInputComplexOutput(ComplexInput memory complexInput)\n\n        public\n\n        pure\n\n        returns (ComplexOutput memory)\n\n    {\n\n        return ComplexOutput({\n\n            input: complexInput,\n\n            lorem: hex'12345678',\n\n            ipsum: hex'87654321',\n\n            dolor: \"amet\"\n\n        });\n",
                    "message": "AbiGenDummy.complexInputComplexOutput (AbiGenDummy.sol#238-249) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": 270,
                    "vulnerability_code": "    function multiInputMultiOutput(\n\n        uint256,\n\n        bytes memory,\n\n        string memory\n\n    )\n\n        public\n\n        pure\n\n        returns (\n\n            bytes memory,\n\n            bytes memory,\n\n            string memory\n\n        )\n\n    {\n\n        return (\n\n            hex'12345678',\n\n            hex'87654321',\n\n            \"amet\"\n\n        );\n",
                    "message": "AbiGenDummy.multiInputMultiOutput (AbiGenDummy.sol#252-270) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": "Detected issues with version pragma in AbiGenDummy.sol:\n\t- pragma solidity^0.5.5 (AbiGenDummy.sol#23): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function simpleInputNoOutput(uint256)\n",
                    "message": "Parameter '' of AbiGenDummy.simpleInputNoOutput (AbiGenDummy.sol#220) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function simpleInputSimpleOutput(uint256)\n",
                    "message": "Parameter '' of AbiGenDummy.simpleInputSimpleOutput (AbiGenDummy.sol#229) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '' of AbiGenDummy.multiInputMultiOutput (AbiGenDummy.sol#253) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory,\n",
                    "message": "Parameter '_scope_0' of AbiGenDummy.multiInputMultiOutput (AbiGenDummy.sol#254) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory\n",
                    "message": "Parameter '_scope_1' of AbiGenDummy.multiInputMultiOutput (AbiGenDummy.sol#255) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function methodReturningArrayOfStructs() public pure returns(Struct[] memory) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function nestedStructOutput() public pure returns(NestedStruct memory) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function methodUsingNestedStructWithInnerStructNotUsedElsewhere()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public pure returns (uint256, string memory)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint someState;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/packages/sol-tracing-utils/test/fixtures/contracts/SimpleStorage.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": 9,
                    "vulnerability_code": "    function set(uint x) {\n\n        storedData = x;\n",
                    "message": "SimpleStorage.set (SimpleStorage.sol#7-9) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 12,
                    "vulnerability_code": "    function get() constant returns (uint retVal) {\n\n        return storedData;\n",
                    "message": "SimpleStorage.get (SimpleStorage.sol#10-12) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.21;\n",
                    "message": "Detected issues with version pragma in SimpleStorage.sol:\n\t- pragma solidity^0.4.21 (SimpleStorage.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function get() constant returns (uint retVal) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.21;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function set(uint x) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function get() constant returns (uint retVal) {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-abd479dc68fa75719647db261130418725fd40d5/packages/sol-tracing-utils/test/fixtures/contracts/SolcovIgnore.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": 11,
                    "vulnerability_code": "    function set(uint x) public {\n\n        /* solcov ignore next */\n\n        storedData = x;\n",
                    "message": "SolcovIgnore.set (SolcovIgnore.sol#8-11) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": 16,
                    "vulnerability_code": "    function get() constant public returns (uint retVal) {\n\n        return storedData;\n",
                    "message": "SolcovIgnore.get (SolcovIgnore.sol#14-16) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": 23,
                    "vulnerability_code": "    function ignored() public returns (bool) {\n\n        return false;\n",
                    "message": "Ignore.ignored (SolcovIgnore.sol#21-23) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.21;\n",
                    "message": "Detected issues with version pragma in SolcovIgnore.sol:\n\t- pragma solidity^0.4.21 (SolcovIgnore.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function get() constant public returns (uint retVal) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.21;\n",
                    "message": null
                }
            ]
        }
    }
}