{
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/test/BadBeacon.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    revert(\"This is not a working upgrade beacon.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    revert(\"This is not a working upgrade beacon.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in BadBeacon.sol:\n\t- pragma solidity0.5.11 (BadBeacon.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_REDUNDANT_FALLBACK_REJECT",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function () external {\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/test/BadBeaconTwo.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      revert(\"This is not an upgradeable upgrade beacon.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      revert(\"This is not an upgradeable upgrade beacon.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "assembly",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 20,
                    "vulnerability_code": "  function () external {\n\n    if (msg.data.length > 0) {\n\n      revert(\"This is not an upgradeable upgrade beacon.\");\n\n    }\n\n\n\n    address implementation = address(0);\n\n    assembly {\n\n      mstore(0, implementation)\n\n      return(0, 32)  \n\n    }\n",
                    "message": "BadBeaconTwo.fallback uses assembly (BadBeaconTwo.sol#10-20)\n\t- BadBeaconTwo.sol#16-19\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in BadBeaconTwo.sol:\n\t- pragma solidity0.5.11 (BadBeaconTwo.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address implementation = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    if (msg.data.length > 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/test/UpgradeBeaconImplementationCheck.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(address beacon, address expectedImplementation) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (bool success, bytes memory returnData) = beacon.staticcall(\"\");\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(success, \"call to beacon failed.\");\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      abi.decode(returnData, (address)) == expectedImplementation,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"returned implementation does not match expected implementation.\"\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(success, \"call to beacon failed.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      abi.decode(returnData, (address)) == expectedImplementation,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"returned implementation does not match expected implementation.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      abi.decode(returnData, (address)) == expectedImplementation,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"returned implementation does not match expected implementation.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in UpgradeBeaconImplementationCheck.sol:\n\t- pragma solidity0.5.11 (UpgradeBeaconImplementationCheck.sol#3): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 17,
                    "vulnerability_code": "  constructor(address beacon, address expectedImplementation) public {\n\n    (bool success, bytes memory returnData) = beacon.staticcall(\"\");\n\n    require(success, \"call to beacon failed.\");\n\n    require(\n\n      abi.decode(returnData, (address)) == expectedImplementation,\n\n      \"returned implementation does not match expected implementation.\"\n\n    );\n",
                    "message": "Low level call in UpgradeBeaconImplementationCheck.constructor (UpgradeBeaconImplementationCheck.sol#10-17):\n\t-(success,returnData) = beacon.staticcall() UpgradeBeaconImplementationCheck.sol#11\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (bool success, bytes memory returnData) = beacon.staticcall(\"\");\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/mock/MockCodeCheck.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": 29,
                    "vulnerability_code": "  function code(address target) public view returns (bytes memory codeValue) {\n\n    /* solhint-disable no-inline-assembly */\n\n    assembly {\n\n      // retrieve the size of the external code\n\n      let size := extcodesize(target)\n\n      \n\n      // allocate output byte array\n\n      codeValue := mload(0x40)\n\n      \n\n      // new \"memory end\" including padding\n\n      mstore(0x40, add(codeValue, and(add(size, 0x3f), not(0x1f))))\n\n      \n\n      // store length in memory\n\n      mstore(codeValue, size)\n\n      \n\n      // get the code using extcodecopy\n\n      extcodecopy(target, add(codeValue, 0x20), 0, size)\n\n    } /* solhint-enable no-inline-assembly */\n",
                    "message": "MockCodeCheck.code (MockCodeCheck.sol#11-29) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 36,
                    "vulnerability_code": "  function hash(address target) public view returns (bytes32 hashValue) {\n\n  \t/* solhint-disable no-inline-assembly */\n\n  \tassembly {\n\n  \t  hashValue := extcodehash(target)\n\n  \t} /* solhint-enable no-inline-assembly */\n",
                    "message": "MockCodeCheck.hash (MockCodeCheck.sol#31-36) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": 29,
                    "vulnerability_code": "  function code(address target) public view returns (bytes memory codeValue) {\n\n    /* solhint-disable no-inline-assembly */\n\n    assembly {\n\n      // retrieve the size of the external code\n\n      let size := extcodesize(target)\n\n      \n\n      // allocate output byte array\n\n      codeValue := mload(0x40)\n\n      \n\n      // new \"memory end\" including padding\n\n      mstore(0x40, add(codeValue, and(add(size, 0x3f), not(0x1f))))\n\n      \n\n      // store length in memory\n\n      mstore(codeValue, size)\n\n      \n\n      // get the code using extcodecopy\n\n      extcodecopy(target, add(codeValue, 0x20), 0, size)\n\n    } /* solhint-enable no-inline-assembly */\n",
                    "message": "MockCodeCheck.code uses assembly (MockCodeCheck.sol#11-29)\n\t- MockCodeCheck.sol#13-28\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 36,
                    "vulnerability_code": "  function hash(address target) public view returns (bytes32 hashValue) {\n\n  \t/* solhint-disable no-inline-assembly */\n\n  \tassembly {\n\n  \t  hashValue := extcodehash(target)\n\n  \t} /* solhint-enable no-inline-assembly */\n",
                    "message": "MockCodeCheck.hash uses assembly (MockCodeCheck.sol#31-36)\n\t- MockCodeCheck.sol#33-35\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": 29,
                    "vulnerability_code": "  function code(address target) public view returns (bytes memory codeValue) {\n\n    /* solhint-disable no-inline-assembly */\n\n    assembly {\n\n      // retrieve the size of the external code\n\n      let size := extcodesize(target)\n\n      \n\n      // allocate output byte array\n\n      codeValue := mload(0x40)\n\n      \n\n      // new \"memory end\" including padding\n\n      mstore(0x40, add(codeValue, and(add(size, 0x3f), not(0x1f))))\n\n      \n\n      // store length in memory\n\n      mstore(codeValue, size)\n\n      \n\n      // get the code using extcodecopy\n\n      extcodecopy(target, add(codeValue, 0x20), 0, size)\n\n    } /* solhint-enable no-inline-assembly */\n",
                    "message": "MockCodeCheck.code (MockCodeCheck.sol#11-29) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 36,
                    "vulnerability_code": "  function hash(address target) public view returns (bytes32 hashValue) {\n\n  \t/* solhint-disable no-inline-assembly */\n\n  \tassembly {\n\n  \t  hashValue := extcodehash(target)\n\n  \t} /* solhint-enable no-inline-assembly */\n",
                    "message": "MockCodeCheck.hash (MockCodeCheck.sol#31-36) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function code(address target) public view returns (bytes memory codeValue) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function hash(address target) public view returns (bytes32 hashValue) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function code(address target) public view returns (bytes memory codeValue) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function hash(address target) public view returns (bytes32 hashValue) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  \tassembly {\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/mock/RelayContract.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function () external payable {}\n",
                    "message": "Contract locking ether found in RelayContract.sol:\n\tContract RelayContract has payable functions:\n\t - fallback (RelayContract.sol#74)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Different versions of Solidity is used in RelayContract.sol:\n\t- Version used: ['0.5.11', 'ABIEncoderV2']\n\t- RelayContract.sol#3 declares pragma solidity0.5.11\n\t- RelayContract.sol#4 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function setController(address candidate) public {\n\n        emit SetControllerAttempt(candidate);\n\n\n\n        if (msg.sender == controller) {\n\n            controller = candidate;\n\n\n\n            emit SetControllerSuccess(candidate);\n\n        } else {\n\n            emit SetControllerFailure(candidate);\n\n        }\n",
                    "message": "RelayContract.setController (RelayContract.sol#49-59) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function getController() public view returns (address) {\n\n        return controller;\n",
                    "message": "RelayContract.getController (RelayContract.sol#62-64) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "    function recoverSignerAddress(\n\n        bytes32 prefixedHash,\n\n        ECDSASignature memory signature\n\n    ) public view returns (address signer) {\n\n        return ecrecover(prefixedHash, signature.v, signature.r, signature.s);\n",
                    "message": "RelayContract.recoverSignerAddress (RelayContract.sol#66-71) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in RelayContract.sol:\n\t- pragma solidity0.5.11 (RelayContract.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": 28,
                    "vulnerability_code": "    struct transactionParameters {\n\n        address to;\n\n        bytes data;\n\n        uint value;\n\n        ECDSASignature signature;\n\n        address signer;\n\n        uint nonce;\n",
                    "message": "Struct 'RelayContract.transactionParameters' (RelayContract.sol#21-28) is not in CapWords\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes constant internal PREFIX = \"\\x19Ethereum Signed Message:\\n32\";\n",
                    "message": "RelayContract.PREFIX (RelayContract.sol#46) is never used in RelayContract\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RelayContract {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setController(address candidate) public {\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/factories/smart-wallet/DharmaSmartWalletFactoryV1.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes memory initializationCalldata = abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      _INITIALIZER.initialize.selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      userSigningKey\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes memory initializationCalldata = abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      _INITIALIZER.initialize.selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      userSigningKey\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      nonce++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": false,
            "errors": [
                "EXIT_CODE_255",
                "error parsing results: file could not be opened successfully:\n- method gz: ReadError('empty file')\n- method bz2: ReadError('not a bzip2 file')\n- method xz: ReadError('not an lzma file')\n- method tar: ReadError('empty file')"
            ],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    0x000000000026750c571ce882B17016557279ADaa\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                bytes1(0xff),      // pass in the control character.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function _deployUpgradeBeaconProxyInstance(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    while (true) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract UpgradeBeaconProxyV1 {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  address private constant _UPGRADE_BEACON = address(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  DharmaSmartWalletInitializer private _INITIALIZER;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function _getSaltAndTarget(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) private view returns (uint256 nonce, address target) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (bool ok, ) = _implementation().delegatecall(initializationCalldata);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (bool ok, bytes memory returnData) = _UPGRADE_BEACON.staticcall(\"\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/implementations/smart-wallet/AdharmaSmartWalletImplementation.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(msg.sender == _key, \"Caller prohibited.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "assembly",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 31,
                    "vulnerability_code": "  function initialize(address key) external {\n\n    // Ensure that this function is only callable during contract construction.\n\n    assembly { if extcodesize(address) { revert(0, 0) } }\n\n\n\n    // Set up the user's key.\n\n    _key = key;\n",
                    "message": "AdharmaSmartWalletImplementation.initialize uses assembly (AdharmaSmartWalletImplementation.sol#25-31)\n\t- AdharmaSmartWalletImplementation.sol#27\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in AdharmaSmartWalletImplementation.sol:\n\t- pragma solidity0.5.11 (AdharmaSmartWalletImplementation.sol#3): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": 45,
                    "vulnerability_code": "  function performCall(\n\n    address payable to,\n\n    uint256 amount,\n\n    bytes calldata data\n\n  ) external payable returns (\n\n    bool ok,\n\n    bytes memory returnData\n\n  ) {\n\n    require(msg.sender == _key, \"Caller prohibited.\");\n\n    (ok, returnData) = to.call.value(amount)(data);\n\n    require(ok, string(returnData));\n",
                    "message": "Low level call in AdharmaSmartWalletImplementation.performCall (AdharmaSmartWalletImplementation.sol#34-45):\n\t-(ok,returnData) = to.call.value(amount)(data) AdharmaSmartWalletImplementation.sol#43\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract AdharmaSmartWalletImplementation {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  address private _key;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (ok, returnData) = to.call.value(amount)(data);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly { if extcodesize(address) { revert(0, 0) } }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function performCall(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable to,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 amount,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external payable returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes memory returnData\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(msg.sender == _key, \"Caller prohibited.\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(msg.sender == _key, \"Caller prohibited.\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (ok, returnData) = to.call.value(amount)(data);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(ok, string(returnData));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(ok, string(returnData));\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/implementations/key-ring/AdharmaKeyRingImplementation.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(_keys[key] == KeyType.None, \"Cannot supply duplicate keys.\");\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      _keys[key] = keyType;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < keys.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(keys.length > 0, \"Must supply at least one key.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(adminThreshold > 0, \"Admin threshold cannot be zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(executorThreshold > 0, \"Executor threshold cannot be zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      keys.length == keyTypes.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Length of keys array and keyTypes arrays must be the same.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(key != uint160(0), \"Cannot supply the null address as a key.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(_keys[key] == KeyType.None, \"Cannot supply duplicate keys.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(adminKeys > 0, \"Must supply at least one admin key.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(executorKeys > 0, \"Must supply at least one executor key.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      adminThreshold >= adminKeys,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Admin threshold cannot be less than the total supplied admin keys.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      executorThreshold >= executorKeys,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Executor threshold cannot be less than the total supplied executor keys.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      _keys[uint160(msg.sender)] == KeyType.Admin ||\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      _keys[uint160(msg.sender)] == KeyType.Dual,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Only Admin or Dual key holders can call this function.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < keys.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        executorKeys++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        adminKeys++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(executorThreshold > 0, \"Executor threshold cannot be zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      keys.length == keyTypes.length,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Length of keys array and keyTypes arrays must be the same.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(key != uint160(0), \"Cannot supply the null address as a key.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(adminKeys > 0, \"Must supply at least one admin key.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(executorKeys > 0, \"Must supply at least one executor key.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      adminThreshold >= adminKeys,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Admin threshold cannot be less than the total supplied admin keys.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      executorThreshold >= executorKeys,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Executor threshold cannot be less than the total supplied executor keys.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      _keys[uint160(msg.sender)] == KeyType.Admin ||\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      _keys[uint160(msg.sender)] == KeyType.Dual,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Only Admin or Dual key holders can call this function.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "assembly",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 132,
                    "vulnerability_code": "  function initialize(\n\n    uint128 adminThreshold,\n\n    uint128 executorThreshold,\n\n    address[] calldata keys,\n\n    uint8[] calldata keyTypes // 1: standard, 2: admin, 3: dual\n\n  ) external {\n\n    // Ensure that this function is only callable during contract construction.\n\n    assembly { if extcodesize(address) { revert(0, 0) } }\n\n\n\n    uint128 adminKeys;\n\n    uint128 executorKeys;\n\n\n\n    require(keys.length > 0, \"Must supply at least one key.\");\n\n\n\n    require(adminThreshold > 0, \"Admin threshold cannot be zero.\");\n\n\n\n    require(executorThreshold > 0, \"Executor threshold cannot be zero.\");\n\n\n\n    require(\n\n      keys.length == keyTypes.length,\n\n      \"Length of keys array and keyTypes arrays must be the same.\"\n\n    );\n\n\n\n    for (uint256 i = 0; i < keys.length; i++) {\n\n      uint160 key = uint160(keys[i]);\n\n\n\n      require(key != uint160(0), \"Cannot supply the null address as a key.\");\n\n\n\n      require(_keys[key] == KeyType.None, \"Cannot supply duplicate keys.\");\n\n\n\n      KeyType keyType = KeyType(keyTypes[i]);\n\n\n\n      _keys[key] = keyType;\n\n\n\n      bool isStandard = (keyType == KeyType.Standard || keyType == KeyType.Dual);\n\n      bool isAdmin = (keyType == KeyType.Admin || keyType == KeyType.Dual);\n\n\n\n      emit KeyModified(keys[i], isStandard, isAdmin);\n\n\n\n      if (isStandard) {\n\n        executorKeys++;\n\n      }\n\n\n\n      if (isAdmin) {\n\n        adminKeys++;\n\n      }\n\n    }\n\n\n\n    require(adminKeys > 0, \"Must supply at least one admin key.\");\n\n\n\n    require(executorKeys > 0, \"Must supply at least one executor key.\");\n\n\n\n    require(\n\n      adminThreshold >= adminKeys,\n\n      \"Admin threshold cannot be less than the total supplied admin keys.\"\n\n    );\n\n\n\n    require(\n\n      executorThreshold >= executorKeys,\n\n      \"Executor threshold cannot be less than the total supplied executor keys.\"\n\n    );\n\n\n\n    if (adminKeys > 1 || executorKeys > 1) {\n\n      _additionalKeyCounts = AdditionalKeyCount({\n\n        standard: executorKeys - 1,\n\n        admin: adminKeys - 1\n\n      });\n\n    }\n\n\n\n    if (adminThreshold > 1 || executorThreshold > 1) {\n\n      _additionalThresholds = AdditionalThreshold({\n\n        standard: executorThreshold - 1,\n\n        admin: adminThreshold - 1\n\n      });\n\n    }\n",
                    "message": "AdharmaKeyRingImplementation.initialize uses assembly (AdharmaKeyRingImplementation.sol#57-132)\n\t- AdharmaKeyRingImplementation.sol#64\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  uint256 private _nonce;\n",
                    "message": "AdharmaKeyRingImplementation._nonce should be constant (AdharmaKeyRingImplementation.sol#45)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in AdharmaKeyRingImplementation.sol:\n\t- pragma solidity0.5.11 (AdharmaKeyRingImplementation.sol#3): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "  function takeAction(\n\n    address payable to, uint256 value, bytes calldata data, bytes calldata\n\n  ) external returns (bool ok, bytes memory returnData) {\n\n    require(\n\n      _keys[uint160(msg.sender)] == KeyType.Admin ||\n\n      _keys[uint160(msg.sender)] == KeyType.Dual,\n\n      \"Only Admin or Dual key holders can call this function.\"\n\n    );\n\n\n\n    (ok, returnData) = to.call.value(value)(data);\n",
                    "message": "Low level call in AdharmaKeyRingImplementation.takeAction (AdharmaKeyRingImplementation.sol#135-145):\n\t-(ok,returnData) = to.call.value(value)(data) AdharmaKeyRingImplementation.sol#144\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable to, uint256 value, bytes calldata data, bytes calldata\n",
                    "message": "Parameter '' of AdharmaKeyRingImplementation.takeAction (AdharmaKeyRingImplementation.sol#136) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  uint256 private _nonce;\n",
                    "message": "AdharmaKeyRingImplementation._nonce (AdharmaKeyRingImplementation.sol#45) is never used in AdharmaKeyRingImplementation\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  mapping (uint160 => KeyType) private _keys;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  uint256 private _nonce;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  AdditionalKeyCount private _additionalKeyCounts;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  AdditionalThreshold private _additionalThresholds;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function initialize(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address[] calldata keys,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8[] calldata keyTypes // 1: standard, 2: admin, 3: dual\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly { if extcodesize(address) { revert(0, 0) } }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly { if extcodesize(address) { revert(0, 0) } }\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/implementations/key-ring/DharmaKeyRingImplementationV1.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < signers.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 489,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < signers.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(_keys[key] == KeyType.None, \"Cannot supply duplicate keys.\");\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      _keys[key] = keyType;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 491,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      KeyType keyType = _keys[signer];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < signers.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < keys.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 489,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < signers.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(keys.length > 0, \"Must supply at least one key.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(adminThreshold > 0, \"Admin threshold cannot be zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(executorThreshold > 0, \"Executor threshold cannot be zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      keys.length == keyTypes.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Length of keys array and keyTypes arrays must be the same.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(key != uint160(0), \"Cannot supply the null address as a key.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(_keys[key] == KeyType.None, \"Cannot supply duplicate keys.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(adminKeys > 0, \"Must supply at least one admin key.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(executorKeys > 0, \"Must supply at least one executor key.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      adminThreshold >= adminKeys,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Admin threshold cannot be less than the total supplied admin keys.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      executorThreshold >= executorKeys,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Executor threshold cannot be less than the total supplied executor keys.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(argument != uint160(0), \"Cannot supply null address as a key.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(_keys[argument] == KeyType.None, \"Key already exists.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(_keys[argument] != KeyType.None, \"Key does not exist.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          _additionalThresholds.standard > _additionalKeyCounts.standard,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          \"Cannot reduce number of standard keys below required threshold.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          _additionalThresholds.admin > _additionalKeyCounts.admin,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          \"Cannot reduce number of admin keys below required threshold.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        revert(\"Supplied key type is not currently set.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(threshold > 0, \"Cannot reduce threshold to zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 346,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          threshold <= _additionalKeyCounts.standard,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          \"Cannot increase standard threshold above number of standard keys.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          threshold <= _additionalKeyCounts.admin,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          \"Cannot increase admin threshold above number of admin keys.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 484,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      signers.length >= threshold,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 485,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Supplied number of signatures does not meet the required threshold.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 486,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 492,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        keyType == KeyType.Dual || keyType == requiredKeyType,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        \"Supplied signature does not have a signer with the required key type.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 495,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(signer > lastSigner, \"Invalid signature ordering.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      if (v != 27 && v != 28) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        continue;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 343,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      threshold--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < signers.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < keys.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        executorKeys++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        adminKeys++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _nonce++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _nonce++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 489,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < signers.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(executorThreshold > 0, \"Executor threshold cannot be zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      keys.length == keyTypes.length,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Length of keys array and keyTypes arrays must be the same.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(key != uint160(0), \"Cannot supply the null address as a key.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(adminKeys > 0, \"Must supply at least one admin key.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(executorKeys > 0, \"Must supply at least one executor key.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      adminThreshold >= adminKeys,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Admin threshold cannot be less than the total supplied admin keys.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      executorThreshold >= executorKeys,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Executor threshold cannot be less than the total supplied executor keys.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(argument != uint160(0), \"Cannot supply null address as a key.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          _additionalThresholds.standard > _additionalKeyCounts.standard,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          \"Cannot reduce number of standard keys below required threshold.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          _additionalThresholds.admin > _additionalKeyCounts.admin,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          \"Cannot reduce number of admin keys below required threshold.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        revert(\"Supplied key type is not currently set.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 346,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          threshold <= _additionalKeyCounts.standard,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          \"Cannot increase standard threshold above number of standard keys.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          threshold <= _additionalKeyCounts.admin,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          \"Cannot increase admin threshold above number of admin keys.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 484,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      signers.length >= threshold,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 485,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Supplied number of signatures does not meet the required threshold.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 486,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 492,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        keyType == KeyType.Dual || keyType == requiredKeyType,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        \"Supplied signature does not have a signer with the required key type.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 495,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_9"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": 404,
                    "vulnerability_code": "  function takeAction(\n\n    address payable to, uint256 value, bytes calldata data, bytes calldata signatures\n\n  ) external returns (bool ok, bytes memory returnData) {\n\n    // admin-only: 0x44f62b3c => setUserSigningKey(address,uint256,bytes,bytes)\n\n    _verifyOrderedSignatures(\n\n      (\n\n        (\n\n          data.length >= 4 &&\n\n          data[0] == byte(0x44) &&\n\n          data[1] == byte(0xf6) &&\n\n          data[2] == byte(0x2b) &&\n\n          data[3] == byte(0x3c)\n\n        )\n\n        ? KeyType.Admin\n\n        : KeyType.Standard\n\n      ),\n\n      _getStandardActionHash(to, value, data),\n\n      signatures\n\n    );\n\n\n\n    _nonce++;\n\n\n\n    (ok, returnData) = to.call.value(value)(data);\n",
                    "message": "DharmaKeyRingImplementationV1.takeAction (DharmaKeyRingImplementationV1.sol#381-404) sends eth to arbitrary user\n\tDangerous calls:\n\t- (ok,returnData) = to.call.value(value)(data) (DharmaKeyRingImplementationV1.sol#403)\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": 62,
                    "vulnerability_code": "  function recoverGroup(\n\n    bytes32 hash,\n\n    bytes memory signatures\n\n  ) internal pure returns (uint160[] memory signers) {\n\n    // Ensure that the signatures length is a multiple of 65.\n\n    if (signatures.length % 65 != 0) {\n\n      return new uint160[](0);\n\n    }\n\n\n\n    // Create an appropriately-sized array of addresses for each signer.\n\n    signers = new uint160[](signatures.length / 65);\n\n\n\n    // Get each signature location and divide into r, s and v variables.\n\n    bytes32 signatureLocation;\n\n    bytes32 r;\n\n    bytes32 s;\n\n    uint8 v;\n\n\n\n    for (uint256 i = 0; i < signers.length; i++) {\n\n      assembly {\n\n        signatureLocation := add(signatures, mul(i, 65))\n\n        r := mload(add(signatureLocation, 0x20))\n\n        s := mload(add(signatureLocation, 0x40))\n\n        v := byte(0, mload(add(signatureLocation, 0x60)))\n\n      }\n\n\n\n      // EIP-2 still allows signature malleability for ecrecover(). Remove\n\n      // this possibility and make the signature unique. \n\n      if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n\n        continue;\n\n      }\n\n\n\n      if (v != 27 && v != 28) {\n\n        continue;\n\n      }\n\n\n\n      // If signature is valid & not malleable, add signer address as uint160.\n\n      signers[i] = uint160(ecrecover(hash, v, r, s));\n\n    }\n",
                    "message": "ECDSAGroup.recoverGroup (DharmaKeyRingImplementationV1.sol#23-62) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": 62,
                    "vulnerability_code": "  function recoverGroup(\n\n    bytes32 hash,\n\n    bytes memory signatures\n\n  ) internal pure returns (uint160[] memory signers) {\n\n    // Ensure that the signatures length is a multiple of 65.\n\n    if (signatures.length % 65 != 0) {\n\n      return new uint160[](0);\n\n    }\n\n\n\n    // Create an appropriately-sized array of addresses for each signer.\n\n    signers = new uint160[](signatures.length / 65);\n\n\n\n    // Get each signature location and divide into r, s and v variables.\n\n    bytes32 signatureLocation;\n\n    bytes32 r;\n\n    bytes32 s;\n\n    uint8 v;\n\n\n\n    for (uint256 i = 0; i < signers.length; i++) {\n\n      assembly {\n\n        signatureLocation := add(signatures, mul(i, 65))\n\n        r := mload(add(signatureLocation, 0x20))\n\n        s := mload(add(signatureLocation, 0x40))\n\n        v := byte(0, mload(add(signatureLocation, 0x60)))\n\n      }\n\n\n\n      // EIP-2 still allows signature malleability for ecrecover(). Remove\n\n      // this possibility and make the signature unique. \n\n      if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n\n        continue;\n\n      }\n\n\n\n      if (v != 27 && v != 28) {\n\n        continue;\n\n      }\n\n\n\n      // If signature is valid & not malleable, add signer address as uint160.\n\n      signers[i] = uint160(ecrecover(hash, v, r, s));\n\n    }\n",
                    "message": "ECDSAGroup.recoverGroup uses assembly (DharmaKeyRingImplementationV1.sol#23-62)\n\t- DharmaKeyRingImplementationV1.sol#42-47\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 206,
                    "vulnerability_to_line": 281,
                    "vulnerability_code": "  function initialize(\n\n    uint128 adminThreshold,\n\n    uint128 executorThreshold,\n\n    address[] calldata keys,\n\n    uint8[] calldata keyTypes // 1: standard, 2: admin, 3: dual\n\n  ) external {\n\n    // Ensure that this function is only callable during contract construction.\n\n    assembly { if extcodesize(address) { revert(0, 0) } }\n\n\n\n    uint128 adminKeys;\n\n    uint128 executorKeys;\n\n\n\n    require(keys.length > 0, \"Must supply at least one key.\");\n\n\n\n    require(adminThreshold > 0, \"Admin threshold cannot be zero.\");\n\n\n\n    require(executorThreshold > 0, \"Executor threshold cannot be zero.\");\n\n\n\n    require(\n\n      keys.length == keyTypes.length,\n\n      \"Length of keys array and keyTypes arrays must be the same.\"\n\n    );\n\n\n\n    for (uint256 i = 0; i < keys.length; i++) {\n\n      uint160 key = uint160(keys[i]);\n\n\n\n      require(key != uint160(0), \"Cannot supply the null address as a key.\");\n\n\n\n      require(_keys[key] == KeyType.None, \"Cannot supply duplicate keys.\");\n\n\n\n      KeyType keyType = KeyType(keyTypes[i]);\n\n\n\n      _keys[key] = keyType;\n\n\n\n      bool isStandard = (keyType == KeyType.Standard || keyType == KeyType.Dual);\n\n      bool isAdmin = (keyType == KeyType.Admin || keyType == KeyType.Dual);\n\n\n\n      emit KeyModified(keys[i], isStandard, isAdmin);\n\n\n\n      if (isStandard) {\n\n        executorKeys++;\n\n      }\n\n\n\n      if (isAdmin) {\n\n        adminKeys++;\n\n      }\n\n    }\n\n\n\n    require(adminKeys > 0, \"Must supply at least one admin key.\");\n\n\n\n    require(executorKeys > 0, \"Must supply at least one executor key.\");\n\n\n\n    require(\n\n      adminThreshold >= adminKeys,\n\n      \"Admin threshold cannot be less than the total supplied admin keys.\"\n\n    );\n\n\n\n    require(\n\n      executorThreshold >= executorKeys,\n\n      \"Executor threshold cannot be less than the total supplied executor keys.\"\n\n    );\n\n\n\n    if (adminKeys > 1 || executorKeys > 1) {\n\n      _additionalKeyCounts = AdditionalKeyCount({\n\n        standard: executorKeys - 1,\n\n        admin: adminKeys - 1\n\n      });\n\n    }\n\n\n\n    if (adminThreshold > 1 || executorThreshold > 1) {\n\n      _additionalThresholds = AdditionalThreshold({\n\n        standard: executorThreshold - 1,\n\n        admin: adminThreshold - 1\n\n      });\n\n    }\n",
                    "message": "DharmaKeyRingImplementationV1.initialize uses assembly (DharmaKeyRingImplementationV1.sol#206-281)\n\t- DharmaKeyRingImplementationV1.sol#213\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in DharmaKeyRingImplementationV1.sol:\n\t- pragma solidity0.5.11 (DharmaKeyRingImplementationV1.sol#3): it allows old versions\n\t- pragma solidity0.5.11 (DharmaKeyRingImplementationV1.sol#67): it allows old versions\n\t- pragma solidity0.5.11 (DharmaKeyRingImplementationV1.sol#110): it allows old versions\n\t- pragma solidity0.5.11 (DharmaKeyRingImplementationV1.sol#132): it allows old versions\n\t- pragma solidity0.5.11 (DharmaKeyRingImplementationV1.sol#153): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": 404,
                    "vulnerability_code": "  function takeAction(\n\n    address payable to, uint256 value, bytes calldata data, bytes calldata signatures\n\n  ) external returns (bool ok, bytes memory returnData) {\n\n    // admin-only: 0x44f62b3c => setUserSigningKey(address,uint256,bytes,bytes)\n\n    _verifyOrderedSignatures(\n\n      (\n\n        (\n\n          data.length >= 4 &&\n\n          data[0] == byte(0x44) &&\n\n          data[1] == byte(0xf6) &&\n\n          data[2] == byte(0x2b) &&\n\n          data[3] == byte(0x3c)\n\n        )\n\n        ? KeyType.Admin\n\n        : KeyType.Standard\n\n      ),\n\n      _getStandardActionHash(to, value, data),\n\n      signatures\n\n    );\n\n\n\n    _nonce++;\n\n\n\n    (ok, returnData) = to.call.value(value)(data);\n",
                    "message": "Low level call in DharmaKeyRingImplementationV1.takeAction (DharmaKeyRingImplementationV1.sol#381-404):\n\t-(ok,returnData) = to.call.value(value)(data) DharmaKeyRingImplementationV1.sol#403\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": 455,
                    "vulnerability_code": "  function _getStandardActionHash(\n\n    address payable to, uint256 value, bytes memory data\n\n  ) internal view returns (bytes32 hash) {\n\n    hash = keccak256(\n\n      abi.encodePacked(\n\n        address(this),\n\n        _DHARMA_KEY_RING_VERSION,\n\n        _nonce,\n\n        KeyType.Standard,\n\n        to,\n\n        value,\n\n        data\n\n      )\n\n    );\n",
                    "message": "Function 'DharmaKeyRingImplementationV1._getStandardActionHash' (DharmaKeyRingImplementationV1.sol#441-455) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 457,
                    "vulnerability_to_line": 470,
                    "vulnerability_code": "  function _getAdminActionHash(\n\n    AdminActionType adminActionType, uint160 argument\n\n  ) internal view returns (bytes32 hash) {\n\n    hash = keccak256(\n\n      abi.encodePacked(\n\n        address(this),\n\n        _DHARMA_KEY_RING_VERSION,\n\n        _nonce,\n\n        KeyType.Admin,\n\n        adminActionType,\n\n        argument\n\n      )\n\n    );\n",
                    "message": "Function 'DharmaKeyRingImplementationV1._getAdminActionHash' (DharmaKeyRingImplementationV1.sol#457-470) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": 499,
                    "vulnerability_code": "  function _verifyOrderedSignatures(\n\n    KeyType requiredKeyType, bytes32 hash, bytes memory signatures\n\n  ) internal view {\n\n    uint160[] memory signers = hash.recoverGroup(signatures);\n\n    \n\n    uint256 threshold = (\n\n      requiredKeyType == KeyType.Standard\n\n        ? uint256(_additionalThresholds.standard)\n\n        : uint256(_additionalThresholds.admin)\n\n    ) + 1;\n\n\n\n    require(\n\n      signers.length >= threshold,\n\n      \"Supplied number of signatures does not meet the required threshold.\"\n\n    );\n\n    \n\n    uint160 lastSigner = 0;\n\n    for (uint256 i = 0; i < signers.length; i++) {\n\n      uint160 signer = signers[i];\n\n      KeyType keyType = _keys[signer];\n\n      require(\n\n        keyType == KeyType.Dual || keyType == requiredKeyType,\n\n        \"Supplied signature does not have a signer with the required key type.\"\n\n      );\n\n      require(signer > lastSigner, \"Invalid signature ordering.\");\n\n      lastSigner = signer;\n\n    }\n",
                    "message": "Function 'DharmaKeyRingImplementationV1._verifyOrderedSignatures' (DharmaKeyRingImplementationV1.sol#472-499) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  bytes4 internal constant _ERC_1271_MAGIC_VALUE = bytes4(0x20c13b0b);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < signers.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < signers.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  mapping (uint160 => KeyType) private _keys;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  uint256 private _nonce;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  AdditionalKeyCount private _additionalKeyCounts;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  AdditionalThreshold private _additionalThresholds;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function recoverGroup(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function takeAction(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function getActionID(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function initialize(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable to, uint256 value, bytes calldata data, bytes calldata signatures\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable to, uint256 value, bytes calldata data, bytes calldata signatures\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable to, uint256 value, bytes calldata data, bytes calldata signatures\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable to, uint256 value, bytes calldata data, bytes calldata signatures\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable to, uint256 value, bytes calldata data, bytes calldata signatures\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external returns (bool ok, bytes memory returnData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external returns (bool ok, bytes memory returnData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable to, uint256 value, bytes calldata data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable to, uint256 value, bytes calldata data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable to, uint256 value, bytes calldata data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external view returns (bytes32 actionID);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address[] calldata keys,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8[] calldata keyTypes // 1: standard, 2: admin, 3: dual\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly { if extcodesize(address) { revert(0, 0) } }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly { if extcodesize(address) { revert(0, 0) } }\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/proxies/smart-wallet/UpgradeBeaconProxyV1.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "assembly",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": 40,
                    "vulnerability_code": "  constructor(bytes memory initializationCalldata) public payable {\n\n    // Delegatecall into the implementation, supplying initialization calldata.\n\n    (bool ok, ) = _implementation().delegatecall(initializationCalldata);\n\n    \n\n    // Revert and include revert data if delegatecall to implementation reverts.\n\n    if (!ok) {\n\n      assembly {\n\n        returndatacopy(0, 0, returndatasize)\n\n        revert(0, returndatasize)\n\n      }\n\n    }\n",
                    "message": "UpgradeBeaconProxyV1.constructor uses assembly (UpgradeBeaconProxyV1.sol#29-40)\n\t- UpgradeBeaconProxyV1.sol#35-38\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": 95,
                    "vulnerability_code": "  function _delegate(address implementation) private {\n\n    assembly {\n\n      // Copy msg.data. We take full control of memory in this inline assembly\n\n      // block because it will not return to Solidity code. We overwrite the\n\n      // Solidity scratch pad at memory position 0.\n\n      calldatacopy(0, 0, calldatasize)\n\n\n\n      // Delegatecall to the implementation, supplying calldata and gas.\n\n      // Out and outsize are set to zero - instead, use the return buffer.\n\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n\n\n      // Copy the returned data from the return buffer.\n\n      returndatacopy(0, 0, returndatasize)\n\n\n\n      switch result\n\n      // Delegatecall returns 0 on error.\n\n      case 0 { revert(0, returndatasize) }\n\n      default { return(0, returndatasize) }\n\n    }\n",
                    "message": "UpgradeBeaconProxyV1._delegate uses assembly (UpgradeBeaconProxyV1.sol#76-95)\n\t- UpgradeBeaconProxyV1.sol#77-94\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in UpgradeBeaconProxyV1.sol:\n\t- pragma solidity0.5.11 (UpgradeBeaconProxyV1.sol#3): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": 40,
                    "vulnerability_code": "  constructor(bytes memory initializationCalldata) public payable {\n\n    // Delegatecall into the implementation, supplying initialization calldata.\n\n    (bool ok, ) = _implementation().delegatecall(initializationCalldata);\n\n    \n\n    // Revert and include revert data if delegatecall to implementation reverts.\n\n    if (!ok) {\n\n      assembly {\n\n        returndatacopy(0, 0, returndatasize)\n\n        revert(0, returndatasize)\n\n      }\n\n    }\n",
                    "message": "Low level call in UpgradeBeaconProxyV1.constructor (UpgradeBeaconProxyV1.sol#29-40):\n\t-(ok) = _implementation().delegatecall(initializationCalldata) UpgradeBeaconProxyV1.sol#31\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 66,
                    "vulnerability_code": "  function _implementation() private view returns (address implementation) {\n\n    // Get the current implementation address from the upgrade beacon.\n\n    (bool ok, bytes memory returnData) = _UPGRADE_BEACON.staticcall(\"\");\n\n    \n\n    // Revert and pass along revert message if call to upgrade beacon reverts.\n\n    require(ok, string(returnData));\n\n\n\n    // Set the implementation to the address returned from the upgrade beacon.\n\n    implementation = abi.decode(returnData, (address));\n",
                    "message": "Low level call in UpgradeBeaconProxyV1._implementation (UpgradeBeaconProxyV1.sol#57-66):\n\t-(ok,returnData) = _UPGRADE_BEACON.staticcall() UpgradeBeaconProxyV1.sol#59\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 66,
                    "vulnerability_code": "  function _implementation() private view returns (address implementation) {\n\n    // Get the current implementation address from the upgrade beacon.\n\n    (bool ok, bytes memory returnData) = _UPGRADE_BEACON.staticcall(\"\");\n\n    \n\n    // Revert and pass along revert message if call to upgrade beacon reverts.\n\n    require(ok, string(returnData));\n\n\n\n    // Set the implementation to the address returned from the upgrade beacon.\n\n    implementation = abi.decode(returnData, (address));\n",
                    "message": "Function 'UpgradeBeaconProxyV1._implementation' (UpgradeBeaconProxyV1.sol#57-66) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": 95,
                    "vulnerability_code": "  function _delegate(address implementation) private {\n\n    assembly {\n\n      // Copy msg.data. We take full control of memory in this inline assembly\n\n      // block because it will not return to Solidity code. We overwrite the\n\n      // Solidity scratch pad at memory position 0.\n\n      calldatacopy(0, 0, calldatasize)\n\n\n\n      // Delegatecall to the implementation, supplying calldata and gas.\n\n      // Out and outsize are set to zero - instead, use the return buffer.\n\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n\n\n      // Copy the returned data from the return buffer.\n\n      returndatacopy(0, 0, returndatasize)\n\n\n\n      switch result\n\n      // Delegatecall returns 0 on error.\n\n      case 0 { revert(0, returndatasize) }\n\n      default { return(0, returndatasize) }\n\n    }\n",
                    "message": "Function 'UpgradeBeaconProxyV1._delegate' (UpgradeBeaconProxyV1.sol#76-95) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    0x000000000026750c571ce882B17016557279ADaa\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract UpgradeBeaconProxyV1 {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  address private constant _UPGRADE_BEACON = address(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (bool ok, ) = _implementation().delegatecall(initializationCalldata);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (bool ok, bytes memory returnData) = _UPGRADE_BEACON.staticcall(\"\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/helpers/ImmutableCreate2Factory.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      !_deployed[targetDeploymentAddress],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Invalid contract creation - contract has already been deployed.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      deploymentAddress == targetDeploymentAddress,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Failed to deploy contract using provided salt and initialization code.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      (address(bytes20(salt)) == msg.sender) ||\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      (bytes20(salt) == bytes20(0)),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Invalid salt - first 20 bytes of the salt must match calling address.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      !_deployed[targetDeploymentAddress],\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Invalid contract creation - contract has already been deployed.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      deploymentAddress == targetDeploymentAddress,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Failed to deploy contract using provided salt and initialization code.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      (address(bytes20(salt)) == msg.sender) ||\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      (bytes20(salt) == bytes20(0)),\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Invalid salt - first 20 bytes of the salt must match calling address.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 89,
                    "vulnerability_code": "  function safeCreate2(\n\n    bytes32 salt,\n\n    bytes calldata initializationCode\n\n  ) external payable containsCaller(salt) returns (address deploymentAddress) {\n\n    // move the initialization code from calldata to memory.\n\n    bytes memory initCode = initializationCode;\n\n\n\n    // determine the target address for contract deployment.\n\n    address targetDeploymentAddress = address(\n\n      uint160(                    // downcast to match the address type.\n\n        uint256(                  // convert to uint to truncate upper digits.\n\n          keccak256(              // compute the CREATE2 hash using 4 inputs.\n\n            abi.encodePacked(     // pack all inputs to the hash together.\n\n              hex\"ff\",            // start with 0xff to distinguish from RLP.\n\n              address(this),      // this contract will be the caller.\n\n              salt,               // pass in the supplied salt value.\n\n              keccak256(          // pass in the hash of initialization code.\n\n                abi.encodePacked(\n\n                  initCode\n\n                )\n\n              )\n\n            )\n\n          )\n\n        )\n\n      )\n\n    );\n\n\n\n    // ensure that a contract hasn't been previously deployed to target address.\n\n    require(\n\n      !_deployed[targetDeploymentAddress],\n\n      \"Invalid contract creation - contract has already been deployed.\"\n\n    );\n\n\n\n    // using inline assembly: load data and length of data, then call CREATE2.\n\n    assembly {                                // solhint-disable-line\n\n      let encoded_data := add(0x20, initCode) // load initialization code.\n\n      let encoded_size := mload(initCode)     // load the init code's length.\n\n      deploymentAddress := create2(           // call CREATE2 with 4 arguments.\n\n        callvalue,                            // forward any attached value.\n\n        encoded_data,                         // pass in initialization code.\n\n        encoded_size,                         // pass in init code's length.\n\n        salt                                  // pass in the salt value.\n\n      )\n\n    }\n\n\n\n    // check address against target to ensure that deployment was successful.\n\n    require(\n\n      deploymentAddress == targetDeploymentAddress,\n\n      \"Failed to deploy contract using provided salt and initialization code.\"\n\n    );\n\n\n\n    // record the deployment of the contract to prevent redeploys.\n\n    _deployed[deploymentAddress] = true;\n",
                    "message": "Contract locking ether found in ImmutableCreate2Factory.sol:\n\tContract ImmutableCreate2Factory has payable functions:\n\t - safeCreate2 (ImmutableCreate2Factory.sol#36-89)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 89,
                    "vulnerability_code": "  function safeCreate2(\n\n    bytes32 salt,\n\n    bytes calldata initializationCode\n\n  ) external payable containsCaller(salt) returns (address deploymentAddress) {\n\n    // move the initialization code from calldata to memory.\n\n    bytes memory initCode = initializationCode;\n\n\n\n    // determine the target address for contract deployment.\n\n    address targetDeploymentAddress = address(\n\n      uint160(                    // downcast to match the address type.\n\n        uint256(                  // convert to uint to truncate upper digits.\n\n          keccak256(              // compute the CREATE2 hash using 4 inputs.\n\n            abi.encodePacked(     // pack all inputs to the hash together.\n\n              hex\"ff\",            // start with 0xff to distinguish from RLP.\n\n              address(this),      // this contract will be the caller.\n\n              salt,               // pass in the supplied salt value.\n\n              keccak256(          // pass in the hash of initialization code.\n\n                abi.encodePacked(\n\n                  initCode\n\n                )\n\n              )\n\n            )\n\n          )\n\n        )\n\n      )\n\n    );\n\n\n\n    // ensure that a contract hasn't been previously deployed to target address.\n\n    require(\n\n      !_deployed[targetDeploymentAddress],\n\n      \"Invalid contract creation - contract has already been deployed.\"\n\n    );\n\n\n\n    // using inline assembly: load data and length of data, then call CREATE2.\n\n    assembly {                                // solhint-disable-line\n\n      let encoded_data := add(0x20, initCode) // load initialization code.\n\n      let encoded_size := mload(initCode)     // load the init code's length.\n\n      deploymentAddress := create2(           // call CREATE2 with 4 arguments.\n\n        callvalue,                            // forward any attached value.\n\n        encoded_data,                         // pass in initialization code.\n\n        encoded_size,                         // pass in init code's length.\n\n        salt                                  // pass in the salt value.\n\n      )\n\n    }\n\n\n\n    // check address against target to ensure that deployment was successful.\n\n    require(\n\n      deploymentAddress == targetDeploymentAddress,\n\n      \"Failed to deploy contract using provided salt and initialization code.\"\n\n    );\n\n\n\n    // record the deployment of the contract to prevent redeploys.\n\n    _deployed[deploymentAddress] = true;\n",
                    "message": "ImmutableCreate2Factory.safeCreate2 uses assembly (ImmutableCreate2Factory.sol#36-89)\n\t- ImmutableCreate2Factory.sol#70-79\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in ImmutableCreate2Factory.sol:\n\t- pragma solidity0.5.11 (ImmutableCreate2Factory.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      return address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      return address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract ImmutableCreate2Factory {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  mapping(address => bool) private _deployed;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly {                                // solhint-disable-line\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/helpers/IndestructibleRegistry.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = dataStart; i < dataEnd; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      !_isPotentiallyDestructible(target),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Supplied target is potentially destructible.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(size > 0, \"No code at target.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require (dataEnd > dataStart, \"SafeMath: addition overflow.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (op > 95 && op < 128) { // pushN\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          i += (op - 95);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          continue;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = dataStart; i < dataEnd; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      !_isPotentiallyDestructible(target),\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Supplied target is potentially destructible.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": 146,
                    "vulnerability_code": "  function _isPotentiallyDestructible(\n\n    address target\n\n  ) internal view returns (bool potentiallyDestructible) {\n\n    // Get the size of the target.\n\n    uint256 size;\n\n    assembly { size := extcodesize(target) }\n\n    require(size > 0, \"No code at target.\");\n\n    \n\n    // Get code at the target and the location data starts and ends in memory.\n\n    uint256 dataStart;\n\n    bytes memory extcode = new bytes(size);\n\n    assembly {\n\n      dataStart := add(extcode, 0x20)\n\n      extcodecopy(target, dataStart, 0, size)\n\n    }\n\n    uint256 dataEnd = dataStart + size;\n\n    require (dataEnd > dataStart, \"SafeMath: addition overflow.\");\n\n    \n\n    // Look for any reachable, impermissible opcodes.\n\n    bool reachable = true;\n\n    uint256 op;\n\n    for (uint256 i = dataStart; i < dataEnd; i++) {\n\n      // Get the opcode in question.\n\n      assembly { op := shr(0xf8, mload(i)) }\n\n      \n\n      // Check the opcode if it is reachable (i.e. not a constant or metadata).\n\n      if (reachable) {\n\n        // If execution is halted, mark opcodes that follow as unreachable.\n\n        if (\n\n          op == 254 || // invalid\n\n          op == 243 || // return\n\n          op == 253 || // revert\n\n          op == 86  || // jump\n\n          op == 0      // stop\n\n        ) {\n\n          reachable = false;\n\n          continue;\n\n        }\n\n\n\n        // If the opcode is a PUSH, skip over the push data.\n\n        if (op > 95 && op < 128) { // pushN\n\n          i += (op - 95);\n\n          continue;\n\n        }\n\n        \n\n        // If opcode is impermissible, return true - potential destructibility!\n\n        if (\n\n          op == 242 || // callcode\n\n          op == 244 || // delegatecall\n\n          op == 255    // selfdestruct\n\n        ) {\n\n          return true; // potentially destructible!\n\n        }\n\n      } else if (op == 91) { // jumpdest\n\n        // Whenever a JUMPDEST is found, mark opcodes that follow as reachable. \n\n        reachable = true;\n\n      }\n\n    }\n",
                    "message": "IndestructibleRegistry._isPotentiallyDestructible (IndestructibleRegistry.sol#88-146) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": 146,
                    "vulnerability_code": "  function _isPotentiallyDestructible(\n\n    address target\n\n  ) internal view returns (bool potentiallyDestructible) {\n\n    // Get the size of the target.\n\n    uint256 size;\n\n    assembly { size := extcodesize(target) }\n\n    require(size > 0, \"No code at target.\");\n\n    \n\n    // Get code at the target and the location data starts and ends in memory.\n\n    uint256 dataStart;\n\n    bytes memory extcode = new bytes(size);\n\n    assembly {\n\n      dataStart := add(extcode, 0x20)\n\n      extcodecopy(target, dataStart, 0, size)\n\n    }\n\n    uint256 dataEnd = dataStart + size;\n\n    require (dataEnd > dataStart, \"SafeMath: addition overflow.\");\n\n    \n\n    // Look for any reachable, impermissible opcodes.\n\n    bool reachable = true;\n\n    uint256 op;\n\n    for (uint256 i = dataStart; i < dataEnd; i++) {\n\n      // Get the opcode in question.\n\n      assembly { op := shr(0xf8, mload(i)) }\n\n      \n\n      // Check the opcode if it is reachable (i.e. not a constant or metadata).\n\n      if (reachable) {\n\n        // If execution is halted, mark opcodes that follow as unreachable.\n\n        if (\n\n          op == 254 || // invalid\n\n          op == 243 || // return\n\n          op == 253 || // revert\n\n          op == 86  || // jump\n\n          op == 0      // stop\n\n        ) {\n\n          reachable = false;\n\n          continue;\n\n        }\n\n\n\n        // If the opcode is a PUSH, skip over the push data.\n\n        if (op > 95 && op < 128) { // pushN\n\n          i += (op - 95);\n\n          continue;\n\n        }\n\n        \n\n        // If opcode is impermissible, return true - potential destructibility!\n\n        if (\n\n          op == 242 || // callcode\n\n          op == 244 || // delegatecall\n\n          op == 255    // selfdestruct\n\n        ) {\n\n          return true; // potentially destructible!\n\n        }\n\n      } else if (op == 91) { // jumpdest\n\n        // Whenever a JUMPDEST is found, mark opcodes that follow as reachable. \n\n        reachable = true;\n\n      }\n\n    }\n",
                    "message": "IndestructibleRegistry._isPotentiallyDestructible uses assembly (IndestructibleRegistry.sol#88-146)\n\t- IndestructibleRegistry.sol#93\n\t- IndestructibleRegistry.sol#99-102\n\t- IndestructibleRegistry.sol#111\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in IndestructibleRegistry.sol:\n\t- pragma solidity0.5.11 (IndestructibleRegistry.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": 146,
                    "vulnerability_code": "  function _isPotentiallyDestructible(\n\n    address target\n\n  ) internal view returns (bool potentiallyDestructible) {\n\n    // Get the size of the target.\n\n    uint256 size;\n\n    assembly { size := extcodesize(target) }\n\n    require(size > 0, \"No code at target.\");\n\n    \n\n    // Get code at the target and the location data starts and ends in memory.\n\n    uint256 dataStart;\n\n    bytes memory extcode = new bytes(size);\n\n    assembly {\n\n      dataStart := add(extcode, 0x20)\n\n      extcodecopy(target, dataStart, 0, size)\n\n    }\n\n    uint256 dataEnd = dataStart + size;\n\n    require (dataEnd > dataStart, \"SafeMath: addition overflow.\");\n\n    \n\n    // Look for any reachable, impermissible opcodes.\n\n    bool reachable = true;\n\n    uint256 op;\n\n    for (uint256 i = dataStart; i < dataEnd; i++) {\n\n      // Get the opcode in question.\n\n      assembly { op := shr(0xf8, mload(i)) }\n\n      \n\n      // Check the opcode if it is reachable (i.e. not a constant or metadata).\n\n      if (reachable) {\n\n        // If execution is halted, mark opcodes that follow as unreachable.\n\n        if (\n\n          op == 254 || // invalid\n\n          op == 243 || // return\n\n          op == 253 || // revert\n\n          op == 86  || // jump\n\n          op == 0      // stop\n\n        ) {\n\n          reachable = false;\n\n          continue;\n\n        }\n\n\n\n        // If the opcode is a PUSH, skip over the push data.\n\n        if (op > 95 && op < 128) { // pushN\n\n          i += (op - 95);\n\n          continue;\n\n        }\n\n        \n\n        // If opcode is impermissible, return true - potential destructibility!\n\n        if (\n\n          op == 242 || // callcode\n\n          op == 244 || // delegatecall\n\n          op == 255    // selfdestruct\n\n        ) {\n\n          return true; // potentially destructible!\n\n        }\n\n      } else if (op == 91) { // jumpdest\n\n        // Whenever a JUMPDEST is found, mark opcodes that follow as reachable. \n\n        reachable = true;\n\n      }\n\n    }\n",
                    "message": "Function 'IndestructibleRegistry._isPotentiallyDestructible' (IndestructibleRegistry.sol#88-146) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  mapping (address => bool) private _definitelyIndestructible;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function _isPotentiallyDestructible(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      assembly { op := shr(0xf8, mload(i)) }\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/helpers/CodeHashCache.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(_cachedHashes[target] == bytes32(0), \"Target already registered.\");    \n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(currentCodeSize > 0, \"Target currently has no runtime code.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(cachedCodeHash != bytes32(0), \"Target not yet registered.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(currentCodeSize > 0, \"Target currently has no runtime code.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "  function matchesRegisteredCodeHash(\n\n    address target\n\n  ) external view returns (bool codeHashMatchesRegisteredCodeHash) {\n\n    // Get the runtime code hash that is currently registered for the target.\n\n    bytes32 cachedCodeHash = _cachedHashes[target];\n\n\n\n    // Ensure that the target contract has already had a code hash registered.\n\n    require(cachedCodeHash != bytes32(0), \"Target not yet registered.\");\n\n\n\n    // Retrieve the current runtime code hash of the target contract.\n\n    bytes32 currentCodeHash;\n\n    assembly { currentCodeHash := extcodehash(target) }\n\n\n\n    // Compare current runtime code hash to registered runtime code hash.\n\n    codeHashMatchesRegisteredCodeHash = currentCodeHash == cachedCodeHash;\n",
                    "message": "CodeHashCache.matchesRegisteredCodeHash (CodeHashCache.sol#57-72) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "  function registerCodeHash(address target) external {\n\n    // Ensure that the target contract has not already had a hash registered.\n\n    require(_cachedHashes[target] == bytes32(0), \"Target already registered.\");    \n\n\n\n    // Ensure that the target contract currently has runtime code.\n\n    uint256 currentCodeSize;\n\n    assembly { currentCodeSize := extcodesize(target) }\n\n    require(currentCodeSize > 0, \"Target currently has no runtime code.\");\n\n\n\n    // Retrieve the current runtime code hash of the target contract.\n\n    bytes32 currentCodeHash;\n\n    assembly { currentCodeHash := extcodehash(target) }\n\n\n\n    // Register the runtime code hash for the target contract.\n\n    _cachedHashes[target] = currentCodeHash;\n",
                    "message": "CodeHashCache.registerCodeHash uses assembly (CodeHashCache.sol#29-44)\n\t- CodeHashCache.sol#35\n\t- CodeHashCache.sol#40\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "  function matchesRegisteredCodeHash(\n\n    address target\n\n  ) external view returns (bool codeHashMatchesRegisteredCodeHash) {\n\n    // Get the runtime code hash that is currently registered for the target.\n\n    bytes32 cachedCodeHash = _cachedHashes[target];\n\n\n\n    // Ensure that the target contract has already had a code hash registered.\n\n    require(cachedCodeHash != bytes32(0), \"Target not yet registered.\");\n\n\n\n    // Retrieve the current runtime code hash of the target contract.\n\n    bytes32 currentCodeHash;\n\n    assembly { currentCodeHash := extcodehash(target) }\n\n\n\n    // Compare current runtime code hash to registered runtime code hash.\n\n    codeHashMatchesRegisteredCodeHash = currentCodeHash == cachedCodeHash;\n",
                    "message": "CodeHashCache.matchesRegisteredCodeHash uses assembly (CodeHashCache.sol#57-72)\n\t- CodeHashCache.sol#68\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in CodeHashCache.sol:\n\t- pragma solidity0.5.11 (CodeHashCache.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  mapping (address => bytes32) private _cachedHashes;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function matchesRegisteredCodeHash(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly { currentCodeHash := extcodehash(target) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly { currentCodeHash := extcodehash(target) }\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/helpers/ECDSAGroup.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < signers.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < signers.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      if (v != 27 && v != 28) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        continue;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < signers.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": 62,
                    "vulnerability_code": "  function recoverGroup(\n\n    bytes32 hash,\n\n    bytes memory signatures\n\n  ) internal pure returns (uint160[] memory signers) {\n\n    // Ensure that the signatures length is a multiple of 65.\n\n    if (signatures.length % 65 != 0) {\n\n      return new uint160[](0);\n\n    }\n\n\n\n    // Create an appropriately-sized array of addresses for each signer.\n\n    signers = new uint160[](signatures.length / 65);\n\n\n\n    // Get each signature location and divide into r, s and v variables.\n\n    bytes32 signatureLocation;\n\n    bytes32 r;\n\n    bytes32 s;\n\n    uint8 v;\n\n\n\n    for (uint256 i = 0; i < signers.length; i++) {\n\n      assembly {\n\n        signatureLocation := add(signatures, mul(i, 65))\n\n        r := mload(add(signatureLocation, 0x20))\n\n        s := mload(add(signatureLocation, 0x40))\n\n        v := byte(0, mload(add(signatureLocation, 0x60)))\n\n      }\n\n\n\n      // EIP-2 still allows signature malleability for ecrecover(). Remove\n\n      // this possibility and make the signature unique. \n\n      if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n\n        continue;\n\n      }\n\n\n\n      if (v != 27 && v != 28) {\n\n        continue;\n\n      }\n\n\n\n      // If signature is valid & not malleable, add signer address as uint160.\n\n      signers[i] = uint160(ecrecover(hash, v, r, s));\n\n    }\n",
                    "message": "ECDSAGroup.recoverGroup (ECDSAGroup.sol#23-62) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": 62,
                    "vulnerability_code": "  function recoverGroup(\n\n    bytes32 hash,\n\n    bytes memory signatures\n\n  ) internal pure returns (uint160[] memory signers) {\n\n    // Ensure that the signatures length is a multiple of 65.\n\n    if (signatures.length % 65 != 0) {\n\n      return new uint160[](0);\n\n    }\n\n\n\n    // Create an appropriately-sized array of addresses for each signer.\n\n    signers = new uint160[](signatures.length / 65);\n\n\n\n    // Get each signature location and divide into r, s and v variables.\n\n    bytes32 signatureLocation;\n\n    bytes32 r;\n\n    bytes32 s;\n\n    uint8 v;\n\n\n\n    for (uint256 i = 0; i < signers.length; i++) {\n\n      assembly {\n\n        signatureLocation := add(signatures, mul(i, 65))\n\n        r := mload(add(signatureLocation, 0x20))\n\n        s := mload(add(signatureLocation, 0x40))\n\n        v := byte(0, mload(add(signatureLocation, 0x60)))\n\n      }\n\n\n\n      // EIP-2 still allows signature malleability for ecrecover(). Remove\n\n      // this possibility and make the signature unique. \n\n      if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n\n        continue;\n\n      }\n\n\n\n      if (v != 27 && v != 28) {\n\n        continue;\n\n      }\n\n\n\n      // If signature is valid & not malleable, add signer address as uint160.\n\n      signers[i] = uint160(ecrecover(hash, v, r, s));\n\n    }\n",
                    "message": "ECDSAGroup.recoverGroup uses assembly (ECDSAGroup.sol#23-62)\n\t- ECDSAGroup.sol#42-47\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in ECDSAGroup.sol:\n\t- pragma solidity0.5.11 (ECDSAGroup.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < signers.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < signers.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function recoverGroup(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/upgradeability/DharmaUpgradeBeaconEnvoy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(returnData.length == 32, \"Return data must be exactly 32 bytes.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(returnData.length == 32, \"Return data must be exactly 32 bytes.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in DharmaUpgradeBeaconEnvoy.sol:\n\t- pragma solidity0.5.11 (DharmaUpgradeBeaconEnvoy.sol#3): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": 35,
                    "vulnerability_code": "  function getImplementation(\n\n    address beacon\n\n  ) external view returns (address implementation) {\n\n    // Perform the staticcall into the supplied upgrade beacon.\n\n    (bool ok, bytes memory returnData) = beacon.staticcall(\"\");\n\n\n\n    // Revert if underlying staticcall reverts, passing along revert message.\n\n    require(ok, string(returnData));\n\n\n\n    // Ensure that the data returned from the beacon is the correct length.\n\n    require(returnData.length == 32, \"Return data must be exactly 32 bytes.\");\n\n\n\n    // Decode the address from the returned data and return it to the caller.\n\n    implementation = abi.decode(returnData, (address));\n",
                    "message": "Low level call in DharmaUpgradeBeaconEnvoy.getImplementation (DharmaUpgradeBeaconEnvoy.sol#21-35):\n\t-(ok,returnData) = beacon.staticcall() DharmaUpgradeBeaconEnvoy.sol#25\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (bool ok, bytes memory returnData) = beacon.staticcall(\"\");\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/upgradeability/DharmaUpgradeBeaconController.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    // Set the transaction submitter as the initial owner of this contract.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _owner = tx.origin;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    emit OwnershipTransferred(address(0), tx.origin);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    // Ensure the upgrade beacon envoy has the expected runtime code.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address envoy = address(_UPGRADE_BEACON_ENVOY);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 envoyCodeHash;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly { envoyCodeHash := extcodehash(envoy)}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      envoyCodeHash == bytes32(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7332d06692fd32b21bdd8b8b7a0a3f0de5cf549668cbc4498fc6cfaa453f1176\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      ),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Upgrade Beacon Envoy runtime code is incorrect.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(implementation != address(0), \"Must specify an implementation.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(implementationSize > 0, \"Implementation must have contract code.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(beacon != address(0), \"Must specify an upgrade beacon.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(beaconSize > 0, \"Upgrade beacon must have contract code.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(msg.sender == _owner, \"Ownable: caller is not the owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      envoyCodeHash == bytes32(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7332d06692fd32b21bdd8b8b7a0a3f0de5cf549668cbc4498fc6cfaa453f1176\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      ),\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      \"Upgrade Beacon Envoy runtime code is incorrect.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(implementationSize > 0, \"Implementation must have contract code.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(beaconSize > 0, \"Upgrade beacon must have contract code.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": 231,
                    "vulnerability_code": "  function _update(address beacon, address implementation) private {\n\n    // Get the address of the current implementation set on the upgrade beacon.\n\n    address oldImplementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon);\n\n\n\n    // Get the runtime code hash for the current implementation.\n\n    bytes32 oldImplementationCodeHash;\n\n    assembly { oldImplementationCodeHash := extcodehash(oldImplementation) }\n\n\n\n    // Call into beacon and supply address of new implementation to update it.\n\n    (bool success,) = beacon.call(abi.encode(implementation));\n\n\n\n    // Revert with message on failure (i.e. if the beacon is somehow incorrect).\n\n    if (!success) {\n\n      assembly {\n\n        returndatacopy(0, 0, returndatasize)\n\n        revert(0, returndatasize)\n\n      }\n\n    }\n\n\n\n    // Get address of the new implementation that was set on the upgrade beacon.\n\n    address newImplementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon);\n\n\n\n    // Get the runtime code hash for the new implementation.\n\n    bytes32 newImplementationCodeHash;\n\n    assembly { newImplementationCodeHash := extcodehash(newImplementation) }\n\n\n\n    // Set runtime code hash of the new implementation for the given beacon.\n\n    _codeHashAtLastUpgrade[beacon] = newImplementationCodeHash;\n\n\n\n    // Emit an event to signal that the upgrade beacon was updated.\n\n    emit Upgraded(\n\n      beacon,\n\n      oldImplementation,\n\n      oldImplementationCodeHash,\n\n      newImplementation,\n\n      newImplementationCodeHash\n\n    );\n",
                    "message": "Reentrancy in DharmaUpgradeBeaconController._update (DharmaUpgradeBeaconController.sol#194-231):\n\tExternal calls:\n\t- oldImplementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon) (DharmaUpgradeBeaconController.sol#196)\n\t- (success) = beacon.call(abi.encode(implementation)) (DharmaUpgradeBeaconController.sol#203)\n\t- newImplementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon) (DharmaUpgradeBeaconController.sol#214)\n\tState variables written after the call(s):\n\t- _codeHashAtLastUpgrade (DharmaUpgradeBeaconController.sol#221)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": 76,
                    "vulnerability_code": "  constructor() public {\n\n    // Set the transaction submitter as the initial owner of this contract.\n\n    _owner = tx.origin;\n\n    emit OwnershipTransferred(address(0), tx.origin);\n\n    \n\n    // Ensure the upgrade beacon envoy has the expected runtime code.\n\n    address envoy = address(_UPGRADE_BEACON_ENVOY);\n\n    bytes32 envoyCodeHash;\n\n    assembly { envoyCodeHash := extcodehash(envoy)}\n\n    require(\n\n      envoyCodeHash == bytes32(\n\n        0x7332d06692fd32b21bdd8b8b7a0a3f0de5cf549668cbc4498fc6cfaa453f1176\n\n      ),\n\n      \"Upgrade Beacon Envoy runtime code is incorrect.\"\n\n    );\n",
                    "message": "DharmaUpgradeBeaconController.constructor uses assembly (DharmaUpgradeBeaconController.sol#61-76)\n\t- DharmaUpgradeBeaconController.sol#69\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 103,
                    "vulnerability_code": "  function upgrade(address beacon, address implementation) external onlyOwner {\n\n    // Ensure that the implementaton contract is not the null address.\n\n    require(implementation != address(0), \"Must specify an implementation.\");\n\n\n\n    // Ensure that the implementation contract has code via extcodesize.\n\n    uint256 implementationSize;\n\n    assembly { implementationSize := extcodesize(implementation) }\n\n    require(implementationSize > 0, \"Implementation must have contract code.\");\n\n\n\n    // Ensure that the beacon contract is not the null address.\n\n    require(beacon != address(0), \"Must specify an upgrade beacon.\");\n\n\n\n    // Ensure that the upgrade beacon contract has code via extcodesize.\n\n    uint256 beaconSize;\n\n    assembly { beaconSize := extcodesize(beacon) }\n\n    require(beaconSize > 0, \"Upgrade beacon must have contract code.\");\n\n\n\n    // Update the upgrade beacon with the new implementation address.\n\n    _update(beacon, implementation);\n",
                    "message": "DharmaUpgradeBeaconController.upgrade uses assembly (DharmaUpgradeBeaconController.sol#84-103)\n\t- DharmaUpgradeBeaconController.sol#90\n\t- DharmaUpgradeBeaconController.sol#98\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": 231,
                    "vulnerability_code": "  function _update(address beacon, address implementation) private {\n\n    // Get the address of the current implementation set on the upgrade beacon.\n\n    address oldImplementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon);\n\n\n\n    // Get the runtime code hash for the current implementation.\n\n    bytes32 oldImplementationCodeHash;\n\n    assembly { oldImplementationCodeHash := extcodehash(oldImplementation) }\n\n\n\n    // Call into beacon and supply address of new implementation to update it.\n\n    (bool success,) = beacon.call(abi.encode(implementation));\n\n\n\n    // Revert with message on failure (i.e. if the beacon is somehow incorrect).\n\n    if (!success) {\n\n      assembly {\n\n        returndatacopy(0, 0, returndatasize)\n\n        revert(0, returndatasize)\n\n      }\n\n    }\n\n\n\n    // Get address of the new implementation that was set on the upgrade beacon.\n\n    address newImplementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon);\n\n\n\n    // Get the runtime code hash for the new implementation.\n\n    bytes32 newImplementationCodeHash;\n\n    assembly { newImplementationCodeHash := extcodehash(newImplementation) }\n\n\n\n    // Set runtime code hash of the new implementation for the given beacon.\n\n    _codeHashAtLastUpgrade[beacon] = newImplementationCodeHash;\n\n\n\n    // Emit an event to signal that the upgrade beacon was updated.\n\n    emit Upgraded(\n\n      beacon,\n\n      oldImplementation,\n\n      oldImplementationCodeHash,\n\n      newImplementation,\n\n      newImplementationCodeHash\n\n    );\n",
                    "message": "DharmaUpgradeBeaconController._update uses assembly (DharmaUpgradeBeaconController.sol#194-231)\n\t- DharmaUpgradeBeaconController.sol#200\n\t- DharmaUpgradeBeaconController.sol#207-210\n\t- DharmaUpgradeBeaconController.sol#218\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in DharmaUpgradeBeaconController.sol:\n\t- pragma solidity0.5.11 (DharmaUpgradeBeaconController.sol#3): it allows old versions\n\t- pragma solidity0.5.11 (DharmaUpgradeBeaconController.sol#12): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": 231,
                    "vulnerability_code": "  function _update(address beacon, address implementation) private {\n\n    // Get the address of the current implementation set on the upgrade beacon.\n\n    address oldImplementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon);\n\n\n\n    // Get the runtime code hash for the current implementation.\n\n    bytes32 oldImplementationCodeHash;\n\n    assembly { oldImplementationCodeHash := extcodehash(oldImplementation) }\n\n\n\n    // Call into beacon and supply address of new implementation to update it.\n\n    (bool success,) = beacon.call(abi.encode(implementation));\n\n\n\n    // Revert with message on failure (i.e. if the beacon is somehow incorrect).\n\n    if (!success) {\n\n      assembly {\n\n        returndatacopy(0, 0, returndatasize)\n\n        revert(0, returndatasize)\n\n      }\n\n    }\n\n\n\n    // Get address of the new implementation that was set on the upgrade beacon.\n\n    address newImplementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon);\n\n\n\n    // Get the runtime code hash for the new implementation.\n\n    bytes32 newImplementationCodeHash;\n\n    assembly { newImplementationCodeHash := extcodehash(newImplementation) }\n\n\n\n    // Set runtime code hash of the new implementation for the given beacon.\n\n    _codeHashAtLastUpgrade[beacon] = newImplementationCodeHash;\n\n\n\n    // Emit an event to signal that the upgrade beacon was updated.\n\n    emit Upgraded(\n\n      beacon,\n\n      oldImplementation,\n\n      oldImplementationCodeHash,\n\n      newImplementation,\n\n      newImplementationCodeHash\n\n    );\n",
                    "message": "Low level call in DharmaUpgradeBeaconController._update (DharmaUpgradeBeaconController.sol#194-231):\n\t-(success) = beacon.call(abi.encode(implementation)) DharmaUpgradeBeaconController.sol#203\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": 231,
                    "vulnerability_code": "  function _update(address beacon, address implementation) private {\n\n    // Get the address of the current implementation set on the upgrade beacon.\n\n    address oldImplementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon);\n\n\n\n    // Get the runtime code hash for the current implementation.\n\n    bytes32 oldImplementationCodeHash;\n\n    assembly { oldImplementationCodeHash := extcodehash(oldImplementation) }\n\n\n\n    // Call into beacon and supply address of new implementation to update it.\n\n    (bool success,) = beacon.call(abi.encode(implementation));\n\n\n\n    // Revert with message on failure (i.e. if the beacon is somehow incorrect).\n\n    if (!success) {\n\n      assembly {\n\n        returndatacopy(0, 0, returndatasize)\n\n        revert(0, returndatasize)\n\n      }\n\n    }\n\n\n\n    // Get address of the new implementation that was set on the upgrade beacon.\n\n    address newImplementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon);\n\n\n\n    // Get the runtime code hash for the new implementation.\n\n    bytes32 newImplementationCodeHash;\n\n    assembly { newImplementationCodeHash := extcodehash(newImplementation) }\n\n\n\n    // Set runtime code hash of the new implementation for the given beacon.\n\n    _codeHashAtLastUpgrade[beacon] = newImplementationCodeHash;\n\n\n\n    // Emit an event to signal that the upgrade beacon was updated.\n\n    emit Upgraded(\n\n      beacon,\n\n      oldImplementation,\n\n      oldImplementationCodeHash,\n\n      newImplementation,\n\n      newImplementationCodeHash\n\n    );\n",
                    "message": "Function 'DharmaUpgradeBeaconController._update' (DharmaUpgradeBeaconController.sol#194-231) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      0x000000000067503c398F4c9652530DBC4eA95C02\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  address private _owner;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  mapping(address => bytes32) private _codeHashAtLastUpgrade;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  DharmaUpgradeBeaconEnvoyInterface private constant _UPGRADE_BEACON_ENVOY = (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_TX_ORIGIN",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _owner = tx.origin;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_TX_ORIGIN",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    emit OwnershipTransferred(address(0), tx.origin);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (bool success,) = beacon.call(abi.encode(implementation));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly { envoyCodeHash := extcodehash(envoy)}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly { oldImplementationCodeHash := extcodehash(oldImplementation) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 207,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly { newImplementationCodeHash := extcodehash(newImplementation) }\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/upgradeability/smart-wallet/DharmaUpgradeBeacon.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "assembly",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": 39,
                    "vulnerability_code": "  function () external {\n\n    // Return implementation address for all callers other than the controller.\n\n    if (msg.sender != _CONTROLLER) {\n\n      // Load implementation from storage slot zero into memory and return it.\n\n      assembly {\n\n        mstore(0, sload(0))\n\n        return(0, 32)\n\n      }\n\n    } else {\n\n      // Set implementation - put first word in calldata in storage slot zero.\n\n      assembly { sstore(0, calldataload(0)) }\n\n    }\n",
                    "message": "DharmaUpgradeBeacon.fallback uses assembly (DharmaUpgradeBeacon.sol#27-39)\n\t- DharmaUpgradeBeacon.sol#31-34\n\t- DharmaUpgradeBeacon.sol#37\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  address private _implementation;\n",
                    "message": "DharmaUpgradeBeacon._implementation should be constant (DharmaUpgradeBeacon.sol#14)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in DharmaUpgradeBeacon.sol:\n\t- pragma solidity0.5.11 (DharmaUpgradeBeacon.sol#3): it allows old versions\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  address private _implementation;\n",
                    "message": "DharmaUpgradeBeacon._implementation (DharmaUpgradeBeacon.sol#14) is never used in DharmaUpgradeBeacon\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    0x00000000002226C940b74d674B85E4bE05539663\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  address private _implementation;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  address private constant _CONTROLLER = address(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      assembly { sstore(0, calldataload(0)) }\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/contracts/upgradeability/key-ring/DharmaKeyRingUpgradeBeacon.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "assembly",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": 39,
                    "vulnerability_code": "  function () external {\n\n    // Return implementation address for all callers other than the controller.\n\n    if (msg.sender != _CONTROLLER) {\n\n      // Load implementation from storage slot zero into memory and return it.\n\n      assembly {\n\n        mstore(0, sload(0))\n\n        return(0, 32)\n\n      }\n\n    } else {\n\n      // Set implementation - put first word in calldata in storage slot zero.\n\n      assembly { sstore(0, calldataload(0)) }\n\n    }\n",
                    "message": "DharmaKeyRingUpgradeBeacon.fallback uses assembly (DharmaKeyRingUpgradeBeacon.sol#27-39)\n\t- DharmaKeyRingUpgradeBeacon.sol#31-34\n\t- DharmaKeyRingUpgradeBeacon.sol#37\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  address private _implementation;\n",
                    "message": "DharmaKeyRingUpgradeBeacon._implementation should be constant (DharmaKeyRingUpgradeBeacon.sol#14)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in DharmaKeyRingUpgradeBeacon.sol:\n\t- pragma solidity0.5.11 (DharmaKeyRingUpgradeBeacon.sol#3): it allows old versions\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  address private _implementation;\n",
                    "message": "DharmaKeyRingUpgradeBeacon._implementation (DharmaKeyRingUpgradeBeacon.sol#14) is never used in DharmaKeyRingUpgradeBeacon\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    0x00000000011dF015e8aD00D7B2486a88C2Eb8210\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  address private _implementation;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  address private constant _CONTROLLER = address(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      assembly { sstore(0, calldataload(0)) }\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/interfaces/ComptrollerInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in ComptrollerInterface.sol:\n\t- pragma solidity0.5.11 (ComptrollerInterface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external view returns (uint256 err, uint256 liquidity, uint256 shortfall);\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/interfaces/UpgradeBeaconControllerInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in UpgradeBeaconControllerInterface.sol:\n\t- pragma solidity0.5.11 (UpgradeBeaconControllerInterface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/interfaces/DharmaKeyRingImplementationV0Interface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in DharmaKeyRingImplementationV0Interface.sol:\n\t- pragma solidity0.5.11 (DharmaKeyRingImplementationV0Interface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/interfaces/DharmaKeyRingImplementationV1Interface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in DharmaKeyRingImplementationV1Interface.sol:\n\t- pragma solidity0.5.11 (DharmaKeyRingImplementationV1Interface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function takeAction(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function getActionID(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable to, uint256 value, bytes calldata data, bytes calldata signatures\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable to, uint256 value, bytes calldata data, bytes calldata signatures\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable to, uint256 value, bytes calldata data, bytes calldata signatures\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable to, uint256 value, bytes calldata data, bytes calldata signatures\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable to, uint256 value, bytes calldata data, bytes calldata signatures\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external returns (bool ok, bytes memory returnData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external returns (bool ok, bytes memory returnData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable to, uint256 value, bytes calldata data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable to, uint256 value, bytes calldata data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable to, uint256 value, bytes calldata data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external view returns (bytes32 actionID);\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/interfaces/DharmaUpgradeBeaconEnvoyInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in DharmaUpgradeBeaconEnvoyInterface.sol:\n\t- pragma solidity0.5.11 (DharmaUpgradeBeaconEnvoyInterface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/interfaces/DharmaSmartWalletImplementationV3Interface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in DharmaSmartWalletImplementationV3Interface.sol:\n\t- pragma solidity0.5.11 (DharmaSmartWalletImplementationV3Interface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function borrowDai(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function borrowUSDC(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata userSignature,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata dharmaSignature\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external returns (bool ok);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata userSignature,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata dharmaSignature\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external returns (bool ok);\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/interfaces/CTokenInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in CTokenInterface.sol:\n\t- pragma solidity0.5.11 (CTokenInterface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function getAccountSnapshot(address account) external view returns (\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/interfaces/DharmaSmartWalletImplementationV0Interface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in DharmaSmartWalletImplementationV0Interface.sol:\n\t- pragma solidity0.5.11 (DharmaSmartWalletImplementationV0Interface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function getBalances() external returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function withdrawDai(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function withdrawUSDC(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function setUserSigningKey(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata userSignature,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata dharmaSignature\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external returns (bool ok);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata userSignature,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata dharmaSignature\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external returns (bool ok);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata userSignature,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata dharmaSignature\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/interfaces/ERC1271.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in ERC1271.sol:\n\t- pragma solidity0.5.11 (ERC1271.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/interfaces/DharmaSmartWalletImplementationV1Interface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Different versions of Solidity is used in DharmaSmartWalletImplementationV1Interface.sol:\n\t- Version used: ['0.5.11', 'ABIEncoderV2']\n\t- DharmaSmartWalletImplementationV1Interface.sol#3 declares pragma solidity0.5.11\n\t- DharmaSmartWalletImplementationV1Interface.sol#4 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in DharmaSmartWalletImplementationV1Interface.sol:\n\t- pragma solidity0.5.11 (DharmaSmartWalletImplementationV1Interface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function withdrawEther(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function executeAction(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function executeActionWithAtomicBatchCalls(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function getNextGenericActionID(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function getGenericActionID(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address payable recipient,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 minimumActionGas,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata userSignature,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata userSignature,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata dharmaSignature\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external returns (bool ok);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata data,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 minimumActionGas,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata userSignature,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata userSignature,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata dharmaSignature\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external returns (bool ok, bytes memory returnData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external returns (bool ok, bytes memory returnData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata userSignature,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata dharmaSignature\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external returns (bool[] memory ok, bytes[] memory returnData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external returns (bool[] memory ok, bytes[] memory returnData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata data,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 minimumActionGas\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external view returns (bytes32 actionID);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata data,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 nonce,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 minimumActionGas\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external view returns (bytes32 actionID);\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/interfaces/USDCV1Interface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in USDCV1Interface.sol:\n\t- pragma solidity0.5.11 (USDCV1Interface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/interfaces/CEtherInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in CEtherInterface.sol:\n\t- pragma solidity0.5.11 (CEtherInterface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/interfaces/RelayContractInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Different versions of Solidity is used in RelayContractInterface.sol:\n\t- Version used: ['0.5.11', 'ABIEncoderV2']\n\t- RelayContractInterface.sol#3 declares pragma solidity0.5.11\n\t- RelayContractInterface.sol#4 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 27,
                    "vulnerability_code": "  function executeTransactions(\n\n  \ttransactionParameters[] memory transactions\n",
                    "message": "RelayContractInterface.executeTransactions (RelayContractInterface.sol#25-27) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in RelayContractInterface.sol:\n\t- pragma solidity0.5.11 (RelayContractInterface.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": 23,
                    "vulnerability_code": "  struct transactionParameters {\n\n    address to;\n\n    bytes data;\n\n    uint value;\n\n    ECDSASignature signature;\n\n    address signer;\n\n    uint nonce;\n",
                    "message": "Struct 'RelayContractInterface.transactionParameters' (RelayContractInterface.sol#16-23) is not in CapWords\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function getHash(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address to, bytes calldata data, uint256 value, uint256 nonce\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address to, bytes calldata data, uint256 value, uint256 nonce\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address to, bytes calldata data, uint256 value, uint256 nonce\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external view returns (bytes32 prefixedHash);\n",
                    "message": null
                }
            ]
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/interfaces/DharmaSmartWalletFactoryV1Interface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in DharmaSmartWalletFactoryV1Interface.sol:\n\t- pragma solidity0.5.11 (DharmaSmartWalletFactoryV1Interface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/interfaces/DharmaKeyRegistryInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in DharmaKeyRegistryInterface.sol:\n\t- pragma solidity0.5.11 (DharmaKeyRegistryInterface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "dharma-smart-wallet-b1d510d03b97a9c8457b9c0b9c91568a09ccc95d/interfaces/DharmaSmartWalletInitializer.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in DharmaSmartWalletInitializer.sol:\n\t- pragma solidity0.5.11 (DharmaSmartWalletInitializer.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    }
}