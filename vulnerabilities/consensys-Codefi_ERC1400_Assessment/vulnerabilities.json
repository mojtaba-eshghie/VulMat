{
    "UniversalToken-f6de24d50c54471f85985e2303a04bb92c27ac71/contracts/Migrations.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": 21,
                    "vulnerability_code": "  function setCompleted(uint completed) public restricted {\n\n    last_completed_migration = completed;\n",
                    "message": "Migrations.setCompleted (Migrations.sol#19-21) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": 26,
                    "vulnerability_code": "  function upgrade(address new_address) public restricted {\n\n    Migrations upgraded = Migrations(new_address);\n\n    upgraded.setCompleted(last_completed_migration);\n",
                    "message": "Migrations.upgrade (Migrations.sol#23-26) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in Migrations.sol:\n\t- pragma solidity^0.5.0 (Migrations.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function upgrade(address new_address) public restricted {\n",
                    "message": "Parameter 'new_address' of Migrations.upgrade (Migrations.sol#23) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  uint public last_completed_migration;\n",
                    "message": "Variable 'Migrations.last_completed_migration' (Migrations.sol#9) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "UniversalToken-f6de24d50c54471f85985e2303a04bb92c27ac71/contracts/IERC1400.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in IERC1400.sol:\n\t- pragma solidity^0.5.0 (IERC1400.sol#7): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function getDocument(bytes32 name) external view returns (string memory, bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32);\n",
                    "message": null
                }
            ]
        }
    },
    "UniversalToken-f6de24d50c54471f85985e2303a04bb92c27ac71/contracts/mocks/ERC1400TokensSenderMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ERC1820Implementer._setInterface(ERC1400_TOKENS_SENDER);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(_canTransfer(from, to, value, data), \"56\"); // 0x56\tinvalid sender\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_18"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 136,
                    "vulnerability_code": "  function _canTransfer(\n\n    address /*from*/,\n\n    address /*to*/,\n\n    uint /*value*/,\n\n    bytes memory data\n\n  ) // Comments to avoid compilation warnings for unused variables.\n\n    internal\n\n    pure\n\n    returns(bool)\n\n  {\n\n    bytes32 transferRevert = 0x1100000000000000000000000000000000000000000000000000000000000000; // Default sender hook failure data for the mock only\n\n    bytes32 data32;\n\n    assembly {\n\n        data32 := mload(add(data, 32))\n\n    }\n\n    if (data32 == transferRevert) {\n\n      return false;\n\n    } else {\n\n      return true;\n\n    }\n",
                    "message": "ERC1400TokensSenderMock._canTransfer (ERC1400TokensSenderMock.sol#116-136) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 136,
                    "vulnerability_code": "  function _canTransfer(\n\n    address /*from*/,\n\n    address /*to*/,\n\n    uint /*value*/,\n\n    bytes memory data\n\n  ) // Comments to avoid compilation warnings for unused variables.\n\n    internal\n\n    pure\n\n    returns(bool)\n\n  {\n\n    bytes32 transferRevert = 0x1100000000000000000000000000000000000000000000000000000000000000; // Default sender hook failure data for the mock only\n\n    bytes32 data32;\n\n    assembly {\n\n        data32 := mload(add(data, 32))\n\n    }\n\n    if (data32 == transferRevert) {\n\n      return false;\n\n    } else {\n\n      return true;\n\n    }\n",
                    "message": "ERC1400TokensSenderMock._canTransfer uses assembly (ERC1400TokensSenderMock.sol#116-136)\n\t- ERC1400TokensSenderMock.sol#128-130\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in ERC1400TokensSenderMock.sol:\n\t- pragma solidity^0.5.0 (ERC1400TokensSenderMock.sol#7): it allows old versions\n\t- pragma solidity^0.5.0 (ERC1400TokensSenderMock.sol#45): it allows old versions\n\t- pragma solidity^0.5.0 (ERC1400TokensSenderMock.sol#73): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function canImplementInterfaceForAddress(bytes32 interfaceHash, address /*addr*/) // Comments to avoid compilation warnings for unused variables.\n",
                    "message": "Parameter '' of ERC1820Implementer.canImplementInterfaceForAddress (ERC1400TokensSenderMock.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": 67,
                    "vulnerability_code": "  function _setInterface(string memory interfaceLabel) internal {\n\n    _interfaceHashes[keccak256(abi.encodePacked(interfaceLabel))] = true;\n",
                    "message": "Function 'ERC1820Implementer._setInterface' (ERC1400TokensSenderMock.sol#65-67) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  mapping(bytes32 => bool) internal _interfaceHashes;\n",
                    "message": "Variable 'ERC1820Implementer._interfaceHashes' (ERC1400TokensSenderMock.sol#51) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 /*functionSig*/,\n",
                    "message": "Parameter '' of ERC1400TokensSenderMock.canTransfer (ERC1400TokensSenderMock.sol#85) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 /*partition*/,\n",
                    "message": "Parameter '_scope_0' of ERC1400TokensSenderMock.canTransfer (ERC1400TokensSenderMock.sol#86) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address /*operator*/,\n",
                    "message": "Parameter '_scope_1' of ERC1400TokensSenderMock.canTransfer (ERC1400TokensSenderMock.sol#87) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata /*operatorData*/\n",
                    "message": "Parameter '_scope_2' of ERC1400TokensSenderMock.canTransfer (ERC1400TokensSenderMock.sol#92) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 /*functionSig*/,\n",
                    "message": "Parameter '' of ERC1400TokensSenderMock.tokensToTransfer (ERC1400TokensSenderMock.sol#102) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 /*partition*/,\n",
                    "message": "Parameter '_scope_0' of ERC1400TokensSenderMock.tokensToTransfer (ERC1400TokensSenderMock.sol#103) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address /*operator*/,\n",
                    "message": "Parameter '_scope_1' of ERC1400TokensSenderMock.tokensToTransfer (ERC1400TokensSenderMock.sol#104) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata /*operatorData*/\n",
                    "message": "Parameter '_scope_2' of ERC1400TokensSenderMock.tokensToTransfer (ERC1400TokensSenderMock.sol#109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 136,
                    "vulnerability_code": "  function _canTransfer(\n\n    address /*from*/,\n\n    address /*to*/,\n\n    uint /*value*/,\n\n    bytes memory data\n\n  ) // Comments to avoid compilation warnings for unused variables.\n\n    internal\n\n    pure\n\n    returns(bool)\n\n  {\n\n    bytes32 transferRevert = 0x1100000000000000000000000000000000000000000000000000000000000000; // Default sender hook failure data for the mock only\n\n    bytes32 data32;\n\n    assembly {\n\n        data32 := mload(add(data, 32))\n\n    }\n\n    if (data32 == transferRevert) {\n\n      return false;\n\n    } else {\n\n      return true;\n\n    }\n",
                    "message": "Function 'ERC1400TokensSenderMock._canTransfer' (ERC1400TokensSenderMock.sol#116-136) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address /*from*/,\n",
                    "message": "Parameter '' of ERC1400TokensSenderMock._canTransfer (ERC1400TokensSenderMock.sol#117) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address /*to*/,\n",
                    "message": "Parameter '_scope_0' of ERC1400TokensSenderMock._canTransfer (ERC1400TokensSenderMock.sol#118) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint /*value*/,\n",
                    "message": "Parameter '_scope_1' of ERC1400TokensSenderMock._canTransfer (ERC1400TokensSenderMock.sol#119) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function canTransfer(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function tokensToTransfer(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function canTransfer(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata data,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata operatorData\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external view returns(bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata data,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata operatorData\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  bytes32 constant ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata data,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata /*operatorData*/\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    returns(bool)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    return(_canTransfer(from, to, value, data));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    return(_canTransfer(from, to, value, data));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    return(_canTransfer(from, to, value, data));\n",
                    "message": null
                }
            ]
        }
    },
    "UniversalToken-f6de24d50c54471f85985e2303a04bb92c27ac71/contracts/mocks/ERC1400TokensRecipientMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ERC1820Implementer._setInterface(ERC1400_TOKENS_RECIPIENT);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(_canReceive(from, to, value, data), \"57\"); // 0x57\tinvalid receiver\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_18"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 136,
                    "vulnerability_code": "  function _canReceive(\n\n    address /*from*/,\n\n    address /*to*/,\n\n    uint /*value*/,\n\n    bytes memory data\n\n  ) // Comments to avoid compilation warnings for unused variables.\n\n    internal\n\n    pure\n\n    returns(bool)\n\n  {\n\n    bytes32 receiveRevert = 0x2200000000000000000000000000000000000000000000000000000000000000; // Default recipient hook failure data for the mock only\n\n    bytes32 data32;\n\n    assembly {\n\n        data32 := mload(add(data, 32))\n\n    }\n\n    if (data32 == receiveRevert) {\n\n      return false;\n\n    } else {\n\n      return true;\n\n    }\n",
                    "message": "ERC1400TokensRecipientMock._canReceive (ERC1400TokensRecipientMock.sol#116-136) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 136,
                    "vulnerability_code": "  function _canReceive(\n\n    address /*from*/,\n\n    address /*to*/,\n\n    uint /*value*/,\n\n    bytes memory data\n\n  ) // Comments to avoid compilation warnings for unused variables.\n\n    internal\n\n    pure\n\n    returns(bool)\n\n  {\n\n    bytes32 receiveRevert = 0x2200000000000000000000000000000000000000000000000000000000000000; // Default recipient hook failure data for the mock only\n\n    bytes32 data32;\n\n    assembly {\n\n        data32 := mload(add(data, 32))\n\n    }\n\n    if (data32 == receiveRevert) {\n\n      return false;\n\n    } else {\n\n      return true;\n\n    }\n",
                    "message": "ERC1400TokensRecipientMock._canReceive uses assembly (ERC1400TokensRecipientMock.sol#116-136)\n\t- ERC1400TokensRecipientMock.sol#128-130\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in ERC1400TokensRecipientMock.sol:\n\t- pragma solidity^0.5.0 (ERC1400TokensRecipientMock.sol#7): it allows old versions\n\t- pragma solidity^0.5.0 (ERC1400TokensRecipientMock.sol#45): it allows old versions\n\t- pragma solidity^0.5.0 (ERC1400TokensRecipientMock.sol#73): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function canImplementInterfaceForAddress(bytes32 interfaceHash, address /*addr*/) // Comments to avoid compilation warnings for unused variables.\n",
                    "message": "Parameter '' of ERC1820Implementer.canImplementInterfaceForAddress (ERC1400TokensRecipientMock.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": 67,
                    "vulnerability_code": "  function _setInterface(string memory interfaceLabel) internal {\n\n    _interfaceHashes[keccak256(abi.encodePacked(interfaceLabel))] = true;\n",
                    "message": "Function 'ERC1820Implementer._setInterface' (ERC1400TokensRecipientMock.sol#65-67) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  mapping(bytes32 => bool) internal _interfaceHashes;\n",
                    "message": "Variable 'ERC1820Implementer._interfaceHashes' (ERC1400TokensRecipientMock.sol#51) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 /*functionSig*/,\n",
                    "message": "Parameter '' of ERC1400TokensRecipientMock.canReceive (ERC1400TokensRecipientMock.sol#85) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 /*partition*/,\n",
                    "message": "Parameter '_scope_0' of ERC1400TokensRecipientMock.canReceive (ERC1400TokensRecipientMock.sol#86) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address /*operator*/,\n",
                    "message": "Parameter '_scope_1' of ERC1400TokensRecipientMock.canReceive (ERC1400TokensRecipientMock.sol#87) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata /*operatorData*/\n",
                    "message": "Parameter '_scope_2' of ERC1400TokensRecipientMock.canReceive (ERC1400TokensRecipientMock.sol#92) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 /*functionSig*/,\n",
                    "message": "Parameter '' of ERC1400TokensRecipientMock.tokensReceived (ERC1400TokensRecipientMock.sol#102) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 /*partition*/,\n",
                    "message": "Parameter '_scope_0' of ERC1400TokensRecipientMock.tokensReceived (ERC1400TokensRecipientMock.sol#103) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address /*operator*/,\n",
                    "message": "Parameter '_scope_1' of ERC1400TokensRecipientMock.tokensReceived (ERC1400TokensRecipientMock.sol#104) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata /*operatorData*/\n",
                    "message": "Parameter '_scope_2' of ERC1400TokensRecipientMock.tokensReceived (ERC1400TokensRecipientMock.sol#109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 136,
                    "vulnerability_code": "  function _canReceive(\n\n    address /*from*/,\n\n    address /*to*/,\n\n    uint /*value*/,\n\n    bytes memory data\n\n  ) // Comments to avoid compilation warnings for unused variables.\n\n    internal\n\n    pure\n\n    returns(bool)\n\n  {\n\n    bytes32 receiveRevert = 0x2200000000000000000000000000000000000000000000000000000000000000; // Default recipient hook failure data for the mock only\n\n    bytes32 data32;\n\n    assembly {\n\n        data32 := mload(add(data, 32))\n\n    }\n\n    if (data32 == receiveRevert) {\n\n      return false;\n\n    } else {\n\n      return true;\n\n    }\n",
                    "message": "Function 'ERC1400TokensRecipientMock._canReceive' (ERC1400TokensRecipientMock.sol#116-136) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address /*from*/,\n",
                    "message": "Parameter '' of ERC1400TokensRecipientMock._canReceive (ERC1400TokensRecipientMock.sol#117) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address /*to*/,\n",
                    "message": "Parameter '_scope_0' of ERC1400TokensRecipientMock._canReceive (ERC1400TokensRecipientMock.sol#118) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint /*value*/,\n",
                    "message": "Parameter '_scope_1' of ERC1400TokensRecipientMock._canReceive (ERC1400TokensRecipientMock.sol#119) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function canReceive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function tokensReceived(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function canReceive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata data,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata operatorData\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external view returns(bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata data,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata operatorData\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  bytes32 constant ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata data,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata /*operatorData*/\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    returns(bool)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    return(_canReceive(from, to, value, data));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    return(_canReceive(from, to, value, data));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    return(_canReceive(from, to, value, data));\n",
                    "message": null
                }
            ]
        }
    },
    "UniversalToken-f6de24d50c54471f85985e2303a04bb92c27ac71/contracts/mocks/CertificateControllerMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(address _certificateSigner, bool activated) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _setCertificateSigner(_certificateSigner, true);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _certificateControllerActivated = activated;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(_certificateSigners[msg.sender] || _checkCertificate(data, 0, 0x00000000), \"54\"); // 0x54\ttransfers halted (contract paused)\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "     if(data.length > 0 && (data[0] == hex\"10\" || data[0] == hex\"11\" || data[0] == hex\"22\" || data[0] == hex\"33\")) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "       return true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "     } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "       return false;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "     }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_10"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in CertificateControllerMock.sol:\n\t- pragma solidity^0.5.0 (CertificateControllerMock.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(address _certificateSigner, bool activated) public {\n",
                    "message": "Parameter '_certificateSigner' of CertificateControllerMock. (CertificateControllerMock.sol#19) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": 66,
                    "vulnerability_code": "  function _setCertificateSigner(address operator, bool authorized) internal {\n\n    require(operator != address(0)); // Action Blocked - Not a valid address\n\n    _certificateSigners[operator] = authorized;\n",
                    "message": "Function 'CertificateControllerMock._setCertificateSigner' (CertificateControllerMock.sol#63-66) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": 82,
                    "vulnerability_code": "  function _setCertificateControllerActivated(bool activated) internal {\n\n    _certificateControllerActivated = activated;\n",
                    "message": "Function 'CertificateControllerMock._setCertificateControllerActivated' (CertificateControllerMock.sol#80-82) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "   function _checkCertificate(bytes memory data, uint256 /*value*/, bytes4 /*functionSig*/) internal pure returns(bool) { // Comments to avoid compilation warnings for unused variables.\n\n     if(data.length > 0 && (data[0] == hex\"10\" || data[0] == hex\"11\" || data[0] == hex\"22\" || data[0] == hex\"33\")) {\n\n       return true;\n\n     } else {\n\n       return false;\n\n     }\n",
                    "message": "Function 'CertificateControllerMock._checkCertificate' (CertificateControllerMock.sol#88-94) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "   function _checkCertificate(bytes memory data, uint256 /*value*/, bytes4 /*functionSig*/) internal pure returns(bool) { // Comments to avoid compilation warnings for unused variables.\n",
                    "message": "Parameter '' of CertificateControllerMock._checkCertificate (CertificateControllerMock.sol#88) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "   function _checkCertificate(bytes memory data, uint256 /*value*/, bytes4 /*functionSig*/) internal pure returns(bool) { // Comments to avoid compilation warnings for unused variables.\n",
                    "message": "Parameter '_scope_0' of CertificateControllerMock._checkCertificate (CertificateControllerMock.sol#88) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  bool _certificateControllerActivated;\n",
                    "message": "Variable 'CertificateControllerMock._certificateControllerActivated' (CertificateControllerMock.sol#9) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  mapping(address => bool) internal _certificateSigners;\n",
                    "message": "Variable 'CertificateControllerMock._certificateSigners' (CertificateControllerMock.sol#12) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  mapping(address => uint256) internal _checkCount;\n",
                    "message": "Variable 'CertificateControllerMock._checkCount' (CertificateControllerMock.sol#15) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(_certificateSigners[msg.sender] || _checkCertificate(data, 0, 0x00000000), \"54\"); // 0x54\ttransfers halted (contract paused)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  bool _certificateControllerActivated;\n",
                    "message": null
                }
            ]
        }
    },
    "UniversalToken-f6de24d50c54471f85985e2303a04bb92c27ac71/contracts/interface/ERC1820Implementer.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in ERC1820Implementer.sol:\n\t- pragma solidity^0.5.0 (ERC1820Implementer.sol#7): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function canImplementInterfaceForAddress(bytes32 interfaceHash, address /*addr*/) // Comments to avoid compilation warnings for unused variables.\n",
                    "message": "Parameter '' of ERC1820Implementer.canImplementInterfaceForAddress (ERC1820Implementer.sol#15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": 29,
                    "vulnerability_code": "  function _setInterface(string memory interfaceLabel) internal {\n\n    _interfaceHashes[keccak256(abi.encodePacked(interfaceLabel))] = true;\n",
                    "message": "Function 'ERC1820Implementer._setInterface' (ERC1820Implementer.sol#27-29) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  mapping(bytes32 => bool) internal _interfaceHashes;\n",
                    "message": "Variable 'ERC1820Implementer._interfaceHashes' (ERC1820Implementer.sol#13) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  bytes32 constant ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\n",
                    "message": null
                }
            ]
        }
    },
    "UniversalToken-f6de24d50c54471f85985e2303a04bb92c27ac71/contracts/tools/BatchBalanceReader.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ERC1820Implementer._setInterface(BALANCE_READER);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint i = 0; i < tokenHolders.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint j = 0; j < tokenAddresses.length; j++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint k = 0; k < partitions.length; k++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint i = 0; i < tokenHolders.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      for (uint j = 0; j < tokenAddresses.length; j++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint i = 0; i < tokenHolders.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint j = 0; j < tokenAddresses.length; j++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint k = 0; k < partitions.length; k++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint i = 0; i < tokenHolders.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      for (uint j = 0; j < tokenAddresses.length; j++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function getDocument(bytes32 name) external view returns (string memory, bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function balancesOfByPartition(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  bytes32 constant ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address[] calldata tokenAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32[] calldata partitions\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    returns (uint256[] memory)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256[] memory balances = new uint256[](tokenAddresses.length * partitions.length * tokenHolders.length);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 index;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint i = 0; i < tokenHolders.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint i = 0; i < tokenHolders.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint i = 0; i < tokenHolders.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint j = 0; j < tokenAddresses.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint j = 0; j < tokenAddresses.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint j = 0; j < tokenAddresses.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint k = 0; k < partitions.length; k++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint k = 0; k < partitions.length; k++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint k = 0; k < partitions.length; k++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    index = i * (tokenAddresses.length * partitions.length) + j * partitions.length + k;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    index = i * (tokenAddresses.length * partitions.length) + j * partitions.length + k;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    index = i * (tokenAddresses.length * partitions.length) + j * partitions.length + k;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    index = i * (tokenAddresses.length * partitions.length) + j * partitions.length + k;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    index = i * (tokenAddresses.length * partitions.length) + j * partitions.length + k;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    balances[index] = IERC1400(tokenAddresses[j]).balanceOfByPartition(partitions[k], tokenHolders[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    balances[index] = IERC1400(tokenAddresses[j]).balanceOfByPartition(partitions[k], tokenHolders[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    balances[index] = IERC1400(tokenAddresses[j]).balanceOfByPartition(partitions[k], tokenHolders[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    balances[index] = IERC1400(tokenAddresses[j]).balanceOfByPartition(partitions[k], tokenHolders[i]);\n",
                    "message": null
                }
            ]
        }
    },
    "UniversalToken-f6de24d50c54471f85985e2303a04bb92c27ac71/contracts/certificate/certificateControllers/CertificateControllerNonce.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(address _certificateSigner, bool activated) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _setCertificateSigner(_certificateSigner, true);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _certificateControllerActivated = activated;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < 4; i++) { // replace 4 bytes corresponding to function selector\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(_certificateSigners[msg.sender] || _checkCertificate(data, 0, 0x00000000), \"54\"); // 0x54\ttransfers halted (contract paused)\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < 4; i++) { // replace 4 bytes corresponding to function selector\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_10"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": 186,
                    "vulnerability_code": "  function _checkCertificate(\n\n    bytes memory data,\n\n    uint256 amount,\n\n    bytes4 functionID\n\n  )\n\n    internal\n\n    view\n\n    returns(bool)\n\n  {\n\n    uint256 counter = _checkCount[msg.sender];\n\n\n\n    uint256 e;\n\n    bytes32 r;\n\n    bytes32 s;\n\n    uint8 v;\n\n\n\n    // Certificate should be 97 bytes long\n\n    if (data.length != 97) {\n\n      return false;\n\n    }\n\n\n\n    // Extract certificate information and expiration time from payload\n\n    assembly {\n\n      // Retrieve expirationTime & ECDSA elements from certificate which is a 97 long bytes\n\n      // Certificate encoding format is: <expirationTime (32 bytes)>@<r (32 bytes)>@<s (32 bytes)>@<v (1 byte)>\n\n      e := mload(add(data, 0x20))\n\n      r := mload(add(data, 0x40))\n\n      s := mload(add(data, 0x60))\n\n      v := byte(0, mload(add(data, 0x80)))\n\n    }\n\n\n\n    // Certificate should not be expired\n\n    if (e < now) {\n\n      return false;\n\n    }\n\n\n\n    if (v < 27) {\n\n      v += 27;\n\n    }\n\n\n\n    // Perform ecrecover to ensure message information corresponds to certificate\n\n    if (v == 27 || v == 28) {\n\n      // Extract payload and remove data argument\n\n      bytes memory payload;\n\n\n\n      assembly {\n\n        let payloadsize := sub(calldatasize, 160)\n\n        payload := mload(0x40) // allocate new memory\n\n        mstore(0x40, add(payload, and(add(add(payloadsize, 0x20), 0x1f), not(0x1f)))) // boolean trick for padding to 0x40\n\n        mstore(payload, payloadsize) // set length\n\n        calldatacopy(add(add(payload, 0x20), 4), 4, sub(payloadsize, 4))\n\n      }\n\n\n\n      if(functionID == 0x00000000) {\n\n        assembly {\n\n          calldatacopy(add(payload, 0x20), 0, 4)\n\n        }\n\n      } else {\n\n        for (uint i = 0; i < 4; i++) { // replace 4 bytes corresponding to function selector\n\n          payload[i] = functionID[i];\n\n        }\n\n      }\n\n\n\n      // Pack and hash\n\n      bytes memory pack = abi.encodePacked(\n\n        msg.sender,\n\n        this,\n\n        amount,\n\n        payload,\n\n        e,\n\n        counter\n\n      );\n\n      bytes32 hash = keccak256(pack);\n\n\n\n      // Check if certificate match expected transactions parameters\n\n      if (_certificateSigners[ecrecover(hash, v, r, s)]) {\n\n        return true;\n\n      }\n\n    }\n\n    return false;\n",
                    "message": "CertificateController._checkCertificate (CertificateControllerNonce.sol#106-186) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": 186,
                    "vulnerability_code": "  function _checkCertificate(\n\n    bytes memory data,\n\n    uint256 amount,\n\n    bytes4 functionID\n\n  )\n\n    internal\n\n    view\n\n    returns(bool)\n\n  {\n\n    uint256 counter = _checkCount[msg.sender];\n\n\n\n    uint256 e;\n\n    bytes32 r;\n\n    bytes32 s;\n\n    uint8 v;\n\n\n\n    // Certificate should be 97 bytes long\n\n    if (data.length != 97) {\n\n      return false;\n\n    }\n\n\n\n    // Extract certificate information and expiration time from payload\n\n    assembly {\n\n      // Retrieve expirationTime & ECDSA elements from certificate which is a 97 long bytes\n\n      // Certificate encoding format is: <expirationTime (32 bytes)>@<r (32 bytes)>@<s (32 bytes)>@<v (1 byte)>\n\n      e := mload(add(data, 0x20))\n\n      r := mload(add(data, 0x40))\n\n      s := mload(add(data, 0x60))\n\n      v := byte(0, mload(add(data, 0x80)))\n\n    }\n\n\n\n    // Certificate should not be expired\n\n    if (e < now) {\n\n      return false;\n\n    }\n\n\n\n    if (v < 27) {\n\n      v += 27;\n\n    }\n\n\n\n    // Perform ecrecover to ensure message information corresponds to certificate\n\n    if (v == 27 || v == 28) {\n\n      // Extract payload and remove data argument\n\n      bytes memory payload;\n\n\n\n      assembly {\n\n        let payloadsize := sub(calldatasize, 160)\n\n        payload := mload(0x40) // allocate new memory\n\n        mstore(0x40, add(payload, and(add(add(payloadsize, 0x20), 0x1f), not(0x1f)))) // boolean trick for padding to 0x40\n\n        mstore(payload, payloadsize) // set length\n\n        calldatacopy(add(add(payload, 0x20), 4), 4, sub(payloadsize, 4))\n\n      }\n\n\n\n      if(functionID == 0x00000000) {\n\n        assembly {\n\n          calldatacopy(add(payload, 0x20), 0, 4)\n\n        }\n\n      } else {\n\n        for (uint i = 0; i < 4; i++) { // replace 4 bytes corresponding to function selector\n\n          payload[i] = functionID[i];\n\n        }\n\n      }\n\n\n\n      // Pack and hash\n\n      bytes memory pack = abi.encodePacked(\n\n        msg.sender,\n\n        this,\n\n        amount,\n\n        payload,\n\n        e,\n\n        counter\n\n      );\n\n      bytes32 hash = keccak256(pack);\n\n\n\n      // Check if certificate match expected transactions parameters\n\n      if (_certificateSigners[ecrecover(hash, v, r, s)]) {\n\n        return true;\n\n      }\n\n    }\n\n    return false;\n",
                    "message": "CertificateController._checkCertificate uses assembly (CertificateControllerNonce.sol#106-186)\n\t- CertificateControllerNonce.sol#128-135\n\t- CertificateControllerNonce.sol#151-157\n\t- CertificateControllerNonce.sol#160-162\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in CertificateControllerNonce.sol:\n\t- pragma solidity^0.5.0 (CertificateControllerNonce.sol#7): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(address _certificateSigner, bool activated) public {\n",
                    "message": "Parameter '_certificateSigner' of CertificateController. (CertificateControllerNonce.sol#24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": 85,
                    "vulnerability_code": "  function _setCertificateSigner(address operator, bool authorized) internal {\n\n    require(operator != address(0)); // Action Blocked - Not a valid address\n\n    _certificateSigners[operator] = authorized;\n",
                    "message": "Function 'CertificateController._setCertificateSigner' (CertificateControllerNonce.sol#82-85) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": 100,
                    "vulnerability_code": "  function _setCertificateControllerActivated(bool activated) internal {\n\n    _certificateControllerActivated = activated;\n",
                    "message": "Function 'CertificateController._setCertificateControllerActivated' (CertificateControllerNonce.sol#98-100) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": 186,
                    "vulnerability_code": "  function _checkCertificate(\n\n    bytes memory data,\n\n    uint256 amount,\n\n    bytes4 functionID\n\n  )\n\n    internal\n\n    view\n\n    returns(bool)\n\n  {\n\n    uint256 counter = _checkCount[msg.sender];\n\n\n\n    uint256 e;\n\n    bytes32 r;\n\n    bytes32 s;\n\n    uint8 v;\n\n\n\n    // Certificate should be 97 bytes long\n\n    if (data.length != 97) {\n\n      return false;\n\n    }\n\n\n\n    // Extract certificate information and expiration time from payload\n\n    assembly {\n\n      // Retrieve expirationTime & ECDSA elements from certificate which is a 97 long bytes\n\n      // Certificate encoding format is: <expirationTime (32 bytes)>@<r (32 bytes)>@<s (32 bytes)>@<v (1 byte)>\n\n      e := mload(add(data, 0x20))\n\n      r := mload(add(data, 0x40))\n\n      s := mload(add(data, 0x60))\n\n      v := byte(0, mload(add(data, 0x80)))\n\n    }\n\n\n\n    // Certificate should not be expired\n\n    if (e < now) {\n\n      return false;\n\n    }\n\n\n\n    if (v < 27) {\n\n      v += 27;\n\n    }\n\n\n\n    // Perform ecrecover to ensure message information corresponds to certificate\n\n    if (v == 27 || v == 28) {\n\n      // Extract payload and remove data argument\n\n      bytes memory payload;\n\n\n\n      assembly {\n\n        let payloadsize := sub(calldatasize, 160)\n\n        payload := mload(0x40) // allocate new memory\n\n        mstore(0x40, add(payload, and(add(add(payloadsize, 0x20), 0x1f), not(0x1f)))) // boolean trick for padding to 0x40\n\n        mstore(payload, payloadsize) // set length\n\n        calldatacopy(add(add(payload, 0x20), 4), 4, sub(payloadsize, 4))\n\n      }\n\n\n\n      if(functionID == 0x00000000) {\n\n        assembly {\n\n          calldatacopy(add(payload, 0x20), 0, 4)\n\n        }\n\n      } else {\n\n        for (uint i = 0; i < 4; i++) { // replace 4 bytes corresponding to function selector\n\n          payload[i] = functionID[i];\n\n        }\n\n      }\n\n\n\n      // Pack and hash\n\n      bytes memory pack = abi.encodePacked(\n\n        msg.sender,\n\n        this,\n\n        amount,\n\n        payload,\n\n        e,\n\n        counter\n\n      );\n\n      bytes32 hash = keccak256(pack);\n\n\n\n      // Check if certificate match expected transactions parameters\n\n      if (_certificateSigners[ecrecover(hash, v, r, s)]) {\n\n        return true;\n\n      }\n\n    }\n\n    return false;\n",
                    "message": "Function 'CertificateController._checkCertificate' (CertificateControllerNonce.sol#106-186) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  bool _certificateControllerActivated;\n",
                    "message": "Variable 'CertificateController._certificateControllerActivated' (CertificateControllerNonce.sol#14) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  mapping(address => bool) internal _certificateSigners;\n",
                    "message": "Variable 'CertificateController._certificateSigners' (CertificateControllerNonce.sol#17) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  mapping(address => uint256) internal _checkCount;\n",
                    "message": "Variable 'CertificateController._checkCount' (CertificateControllerNonce.sol#20) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(_certificateSigners[msg.sender] || _checkCertificate(data, 0, 0x00000000), \"54\"); // 0x54\ttransfers halted (contract paused)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      if(functionID == 0x00000000) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function _checkCertificate(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  bool _certificateControllerActivated;\n",
                    "message": null
                }
            ]
        }
    },
    "UniversalToken-f6de24d50c54471f85985e2303a04bb92c27ac71/contracts/certificate/certificateControllers/CertificateControllerSalt.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(address _certificateSigner, bool activated) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _setCertificateSigner(_certificateSigner, true);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _certificateControllerActivated = activated;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < 4; i++) { // replace 4 bytes corresponding to function selector\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(_certificateSigners[msg.sender] || _checkCertificate(data, 0, 0x00000000), \"54\"); // 0x54\ttransfers halted (contract paused)\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      if (_certificateSigners[ecrecover(hash, v, r, s)] && !_usedCertificate[salt]) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < 4; i++) { // replace 4 bytes corresponding to function selector\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_10"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": 189,
                    "vulnerability_code": "  function _checkCertificate(\n\n    bytes memory data,\n\n    uint256 amount,\n\n    bytes4 functionID\n\n  )\n\n    internal\n\n    view\n\n    returns(bool)\n\n  {\n\n    bytes32 salt;\n\n    uint256 e;\n\n    bytes32 r;\n\n    bytes32 s;\n\n    uint8 v;\n\n\n\n    // Certificate should be 129 bytes long\n\n    if (data.length != 129) {\n\n      return false;\n\n    }\n\n\n\n    // Extract certificate information and expiration time from payload\n\n    assembly {\n\n      // Retrieve expirationTime & ECDSA elements from certificate which is a 97 long bytes\n\n      // Certificate encoding format is: <salt (32 bytes)>@<expirationTime (32 bytes)>@<r (32 bytes)>@<s (32 bytes)>@<v (1 byte)>\n\n      salt := mload(add(data, 0x20))\n\n      e := mload(add(data, 0x40))\n\n      r := mload(add(data, 0x60))\n\n      s := mload(add(data, 0x80))\n\n      v := byte(0, mload(add(data, 0xa0)))\n\n    }\n\n\n\n    // Certificate should not be expired\n\n    if (e < now) {\n\n      return false;\n\n    }\n\n\n\n    if (v < 27) {\n\n      v += 27;\n\n    }\n\n\n\n    // Perform ecrecover to ensure message information corresponds to certificate\n\n    if (v == 27 || v == 28) {\n\n      // Extract payload and remove data argument\n\n      bytes memory payload;\n\n\n\n      assembly {\n\n        let payloadsize := sub(calldatasize, 192)\n\n        payload := mload(0x40) // allocate new memory\n\n        mstore(0x40, add(payload, and(add(add(payloadsize, 0x20), 0x1f), not(0x1f)))) // boolean trick for padding to 0x40\n\n        mstore(payload, payloadsize) // set length\n\n        calldatacopy(add(add(payload, 0x20), 4), 4, sub(payloadsize, 4))\n\n      }\n\n\n\n      if(functionID == 0x00000000) {\n\n        assembly {\n\n          calldatacopy(add(payload, 0x20), 0, 4)\n\n        }\n\n      } else {\n\n        for (uint i = 0; i < 4; i++) { // replace 4 bytes corresponding to function selector\n\n          payload[i] = functionID[i];\n\n        }\n\n      }\n\n\n\n      // Pack and hash\n\n      bytes memory pack = abi.encodePacked(\n\n        msg.sender,\n\n        this,\n\n        amount,\n\n        payload,\n\n        e,\n\n        salt\n\n      );\n\n      bytes32 hash = keccak256(pack);\n\n\n\n      // Check if certificate match expected transactions parameters\n\n      if (_certificateSigners[ecrecover(hash, v, r, s)] && !_usedCertificate[salt]) {\n\n        return true;\n\n      }\n\n    }\n\n    return false;\n",
                    "message": "CertificateController._checkCertificate (CertificateControllerSalt.sol#109-189) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": 189,
                    "vulnerability_code": "  function _checkCertificate(\n\n    bytes memory data,\n\n    uint256 amount,\n\n    bytes4 functionID\n\n  )\n\n    internal\n\n    view\n\n    returns(bool)\n\n  {\n\n    bytes32 salt;\n\n    uint256 e;\n\n    bytes32 r;\n\n    bytes32 s;\n\n    uint8 v;\n\n\n\n    // Certificate should be 129 bytes long\n\n    if (data.length != 129) {\n\n      return false;\n\n    }\n\n\n\n    // Extract certificate information and expiration time from payload\n\n    assembly {\n\n      // Retrieve expirationTime & ECDSA elements from certificate which is a 97 long bytes\n\n      // Certificate encoding format is: <salt (32 bytes)>@<expirationTime (32 bytes)>@<r (32 bytes)>@<s (32 bytes)>@<v (1 byte)>\n\n      salt := mload(add(data, 0x20))\n\n      e := mload(add(data, 0x40))\n\n      r := mload(add(data, 0x60))\n\n      s := mload(add(data, 0x80))\n\n      v := byte(0, mload(add(data, 0xa0)))\n\n    }\n\n\n\n    // Certificate should not be expired\n\n    if (e < now) {\n\n      return false;\n\n    }\n\n\n\n    if (v < 27) {\n\n      v += 27;\n\n    }\n\n\n\n    // Perform ecrecover to ensure message information corresponds to certificate\n\n    if (v == 27 || v == 28) {\n\n      // Extract payload and remove data argument\n\n      bytes memory payload;\n\n\n\n      assembly {\n\n        let payloadsize := sub(calldatasize, 192)\n\n        payload := mload(0x40) // allocate new memory\n\n        mstore(0x40, add(payload, and(add(add(payloadsize, 0x20), 0x1f), not(0x1f)))) // boolean trick for padding to 0x40\n\n        mstore(payload, payloadsize) // set length\n\n        calldatacopy(add(add(payload, 0x20), 4), 4, sub(payloadsize, 4))\n\n      }\n\n\n\n      if(functionID == 0x00000000) {\n\n        assembly {\n\n          calldatacopy(add(payload, 0x20), 0, 4)\n\n        }\n\n      } else {\n\n        for (uint i = 0; i < 4; i++) { // replace 4 bytes corresponding to function selector\n\n          payload[i] = functionID[i];\n\n        }\n\n      }\n\n\n\n      // Pack and hash\n\n      bytes memory pack = abi.encodePacked(\n\n        msg.sender,\n\n        this,\n\n        amount,\n\n        payload,\n\n        e,\n\n        salt\n\n      );\n\n      bytes32 hash = keccak256(pack);\n\n\n\n      // Check if certificate match expected transactions parameters\n\n      if (_certificateSigners[ecrecover(hash, v, r, s)] && !_usedCertificate[salt]) {\n\n        return true;\n\n      }\n\n    }\n\n    return false;\n",
                    "message": "CertificateController._checkCertificate uses assembly (CertificateControllerSalt.sol#109-189)\n\t- CertificateControllerSalt.sol#130-138\n\t- CertificateControllerSalt.sol#154-160\n\t- CertificateControllerSalt.sol#163-165\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in CertificateControllerSalt.sol:\n\t- pragma solidity^0.5.0 (CertificateControllerSalt.sol#7): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(address _certificateSigner, bool activated) public {\n",
                    "message": "Parameter '_certificateSigner' of CertificateController. (CertificateControllerSalt.sol#27) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": 88,
                    "vulnerability_code": "  function _setCertificateSigner(address operator, bool authorized) internal {\n\n    require(operator != address(0)); // Action Blocked - Not a valid address\n\n    _certificateSigners[operator] = authorized;\n",
                    "message": "Function 'CertificateController._setCertificateSigner' (CertificateControllerSalt.sol#85-88) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 103,
                    "vulnerability_code": "  function _setCertificateControllerActivated(bool activated) internal {\n\n    _certificateControllerActivated = activated;\n",
                    "message": "Function 'CertificateController._setCertificateControllerActivated' (CertificateControllerSalt.sol#101-103) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": 189,
                    "vulnerability_code": "  function _checkCertificate(\n\n    bytes memory data,\n\n    uint256 amount,\n\n    bytes4 functionID\n\n  )\n\n    internal\n\n    view\n\n    returns(bool)\n\n  {\n\n    bytes32 salt;\n\n    uint256 e;\n\n    bytes32 r;\n\n    bytes32 s;\n\n    uint8 v;\n\n\n\n    // Certificate should be 129 bytes long\n\n    if (data.length != 129) {\n\n      return false;\n\n    }\n\n\n\n    // Extract certificate information and expiration time from payload\n\n    assembly {\n\n      // Retrieve expirationTime & ECDSA elements from certificate which is a 97 long bytes\n\n      // Certificate encoding format is: <salt (32 bytes)>@<expirationTime (32 bytes)>@<r (32 bytes)>@<s (32 bytes)>@<v (1 byte)>\n\n      salt := mload(add(data, 0x20))\n\n      e := mload(add(data, 0x40))\n\n      r := mload(add(data, 0x60))\n\n      s := mload(add(data, 0x80))\n\n      v := byte(0, mload(add(data, 0xa0)))\n\n    }\n\n\n\n    // Certificate should not be expired\n\n    if (e < now) {\n\n      return false;\n\n    }\n\n\n\n    if (v < 27) {\n\n      v += 27;\n\n    }\n\n\n\n    // Perform ecrecover to ensure message information corresponds to certificate\n\n    if (v == 27 || v == 28) {\n\n      // Extract payload and remove data argument\n\n      bytes memory payload;\n\n\n\n      assembly {\n\n        let payloadsize := sub(calldatasize, 192)\n\n        payload := mload(0x40) // allocate new memory\n\n        mstore(0x40, add(payload, and(add(add(payloadsize, 0x20), 0x1f), not(0x1f)))) // boolean trick for padding to 0x40\n\n        mstore(payload, payloadsize) // set length\n\n        calldatacopy(add(add(payload, 0x20), 4), 4, sub(payloadsize, 4))\n\n      }\n\n\n\n      if(functionID == 0x00000000) {\n\n        assembly {\n\n          calldatacopy(add(payload, 0x20), 0, 4)\n\n        }\n\n      } else {\n\n        for (uint i = 0; i < 4; i++) { // replace 4 bytes corresponding to function selector\n\n          payload[i] = functionID[i];\n\n        }\n\n      }\n\n\n\n      // Pack and hash\n\n      bytes memory pack = abi.encodePacked(\n\n        msg.sender,\n\n        this,\n\n        amount,\n\n        payload,\n\n        e,\n\n        salt\n\n      );\n\n      bytes32 hash = keccak256(pack);\n\n\n\n      // Check if certificate match expected transactions parameters\n\n      if (_certificateSigners[ecrecover(hash, v, r, s)] && !_usedCertificate[salt]) {\n\n        return true;\n\n      }\n\n    }\n\n    return false;\n",
                    "message": "Function 'CertificateController._checkCertificate' (CertificateControllerSalt.sol#109-189) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  bool _certificateControllerActivated;\n",
                    "message": "Variable 'CertificateController._certificateControllerActivated' (CertificateControllerSalt.sol#14) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  mapping(address => bool) internal _certificateSigners;\n",
                    "message": "Variable 'CertificateController._certificateSigners' (CertificateControllerSalt.sol#17) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  mapping(bytes32 => bool) internal _usedCertificate;\n",
                    "message": "Variable 'CertificateController._usedCertificate' (CertificateControllerSalt.sol#23) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      require(_certificateSigners[msg.sender] || _checkCertificate(data, 0, 0x00000000), \"54\"); // 0x54\ttransfers halted (contract paused)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      if(functionID == 0x00000000) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function _checkCertificate(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  bool _certificateControllerActivated;\n",
                    "message": null
                }
            ]
        }
    },
    "UniversalToken-f6de24d50c54471f85985e2303a04bb92c27ac71/contracts/extensions/tokenExtensions/IERC1400TokensValidator.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in IERC1400TokensValidator.sol:\n\t- pragma solidity^0.5.0 (IERC1400TokensValidator.sol#7): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function canValidate(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function tokensToValidate(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata data,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata operatorData\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external view returns(bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata data,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata operatorData\n",
                    "message": null
                }
            ]
        }
    },
    "UniversalToken-f6de24d50c54471f85985e2303a04bb92c27ac71/contracts/extensions/tokenExtensions/IERC1400TokensChecker.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in IERC1400TokensChecker.sol:\n\t- pragma solidity^0.5.0 (IERC1400TokensChecker.sol#7): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function canTransferByPartition(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata data,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata operatorData\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) external view returns (byte, bytes32, bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) external view returns (byte, bytes32, bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) external view returns (byte, bytes32, bytes32);\n",
                    "message": null
                }
            ]
        }
    },
    "UniversalToken-f6de24d50c54471f85985e2303a04bb92c27ac71/contracts/extensions/userExtensions/IERC1400TokensRecipient.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in IERC1400TokensRecipient.sol:\n\t- pragma solidity^0.5.0 (IERC1400TokensRecipient.sol#7): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function canReceive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function tokensReceived(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata data,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata operatorData\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external view returns(bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata data,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata operatorData\n",
                    "message": null
                }
            ]
        }
    },
    "UniversalToken-f6de24d50c54471f85985e2303a04bb92c27ac71/contracts/extensions/userExtensions/IERC1400TokensSender.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in IERC1400TokensSender.sol:\n\t- pragma solidity^0.5.0 (IERC1400TokensSender.sol#7): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function canTransfer(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function tokensToTransfer(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata data,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata operatorData\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) external view returns(bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata data,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata operatorData\n",
                    "message": null
                }
            ]
        }
    }
}