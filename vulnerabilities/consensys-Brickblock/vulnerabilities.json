{
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/contracts/PoaProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _master,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _registry\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(_master != address(0));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(_registry != address(0));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 _proxyMasterContractSlot = proxyMasterContractSlot;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 _proxyRegistrySlot = proxyRegistrySlot;\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_23"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "  function proxyMasterContract()\n\n    public\n\n    view\n\n    returns (address _masterContract)\n\n  {\n\n    bytes32 _proxyMasterContractSlot = proxyMasterContractSlot;\n\n    assembly {\n\n      _masterContract := sload(_proxyMasterContractSlot)\n\n    }\n",
                    "message": "PoaProxy.proxyMasterContract (PoaProxy.sol#35-44) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "  function proxyRegistry()\n\n    public\n\n    view\n\n    returns (address _proxyRegistry)\n\n  {\n\n    bytes32 _proxyRegistrySlot = proxyRegistrySlot;\n\n    assembly {\n\n      _proxyRegistry := sload(_proxyRegistrySlot)\n\n    }\n",
                    "message": "PoaProxy.proxyRegistry (PoaProxy.sol#46-55) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": 95,
                    "vulnerability_code": "  function getContractAddress(\n\n    string _name\n\n  )\n\n    public\n\n    view\n\n    returns (address _contractAddress)\n\n  {\n\n    bytes4 _sig = bytes4(keccak256(\"getContractAddress32(bytes32)\"));\n\n    bytes32 _name32 = keccak256(_name);\n\n    bytes32 _proxyRegistrySlot = proxyRegistrySlot;\n\n\n\n    assembly {\n\n      let _call := mload(0x40)          // set _call to free memory pointer\n\n      mstore(_call, _sig)               // store _sig at _call pointer\n\n      mstore(add(_call, 0x04), _name32) // store _name32 at _call offset by 4 bytes for pre-existing _sig\n\n\n\n      // staticcall(g, a, in, insize, out, outsize) => 0 on error 1 on success\n\n      let success := staticcall(\n\n        gas,    // g = gas: whatever was passed already\n\n        sload(_proxyRegistrySlot),  // a = address: address in storage\n\n        _call,  // in = mem in  mem[in..(in+insize): set to free memory pointer\n\n        0x24,   // insize = mem insize  mem[in..(in+insize): size of sig (bytes4) + bytes32 = 0x24\n\n        _call,   // out = mem out  mem[out..(out+outsize): output assigned to this storage address\n\n        0x20    // outsize = mem outsize  mem[out..(out+outsize): output should be 32byte slot (address size = 0x14 <  slot size 0x20)\n\n      )\n\n\n\n      // revert if not successful\n\n      if iszero(success) {\n\n        revert(0, 0)\n\n      }\n\n\n\n      _contractAddress := mload(_call) // assign result to return value\n\n      mstore(0x40, add(_call, 0x24)) // advance free memory pointer by largest _call size\n\n    }\n",
                    "message": "PoaProxy.getContractAddress (PoaProxy.sol#61-95) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": 106,
                    "vulnerability_code": "  function proxyIsContract(address _address)\n\n    private\n\n    view\n\n    returns (bool)\n\n  {\n\n    uint256 _size;\n\n    assembly { _size := extcodesize(_address) }\n\n    return _size > 0;\n",
                    "message": "PoaProxy.proxyIsContract (PoaProxy.sol#98-106) is declared view but contains assembly code\n"
                },
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": 181,
                    "vulnerability_code": "  function()\n\n    external\n\n    payable\n\n  {\n\n    bytes32 _proxyMasterContractSlot = proxyMasterContractSlot;\n\n    assembly {\n\n      // load address from first storage pointer\n\n      let _master := sload(_proxyMasterContractSlot)\n\n\n\n      // calldatacopy(t, f, s)\n\n      calldatacopy(\n\n        0x0, // t = mem position to\n\n        0x0, // f = mem position from\n\n        calldatasize // s = size bytes\n\n      )\n\n\n\n      // delegatecall(g, a, in, insize, out, outsize) => 0 on error 1 on success\n\n      let success := delegatecall(\n\n        gas, // g = gas\n\n        _master, // a = address\n\n        0x0, // in = mem in  mem[in..(in+insize)\n\n        calldatasize, // insize = mem insize  mem[in..(in+insize)\n\n        0x0, // out = mem out  mem[out..(out+outsize)\n\n        0 // outsize = mem outsize  mem[out..(out+outsize)\n\n      )\n\n\n\n      // returndatacopy(t, f, s)\n\n      returndatacopy(\n\n        0x0, // t = mem position to\n\n        0x0,  // f = mem position from\n\n        returndatasize // s = size bytes\n\n      )\n\n\n\n      // check if call was a success and return if no errors & revert if errors\n\n      if iszero(success) {\n\n        revert(0, 0)\n\n      }\n\n        return(\n\n          0x0,\n\n          returndatasize\n\n        )\n\n    }\n",
                    "message": "Contract locking ether found in PoaProxy.sol:\n\tContract PoaProxy has payable functions:\n\t - fallback (PoaProxy.sol#139-181)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": 29,
                    "vulnerability_code": "  constructor(\n\n    address _master,\n\n    address _registry\n\n  )\n\n    public\n\n  {\n\n    require(_master != address(0));\n\n    require(_registry != address(0));\n\n    bytes32 _proxyMasterContractSlot = proxyMasterContractSlot;\n\n    bytes32 _proxyRegistrySlot = proxyRegistrySlot;\n\n\n\n    // all storage locations are pre-calculated using hashes of names\n\n    assembly {\n\n      sstore(_proxyMasterContractSlot, _master) // store master address in master slot\n\n      sstore(_proxyRegistrySlot, _registry) // store registry address in registry slot\n\n    }\n",
                    "message": "PoaProxy.constructor uses assembly (PoaProxy.sol#13-29)\n\t- PoaProxy.sol#25-29\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "  function proxyMasterContract()\n\n    public\n\n    view\n\n    returns (address _masterContract)\n\n  {\n\n    bytes32 _proxyMasterContractSlot = proxyMasterContractSlot;\n\n    assembly {\n\n      _masterContract := sload(_proxyMasterContractSlot)\n\n    }\n",
                    "message": "PoaProxy.proxyMasterContract uses assembly (PoaProxy.sol#35-44)\n\t- PoaProxy.sol#41-44\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "  function proxyRegistry()\n\n    public\n\n    view\n\n    returns (address _proxyRegistry)\n\n  {\n\n    bytes32 _proxyRegistrySlot = proxyRegistrySlot;\n\n    assembly {\n\n      _proxyRegistry := sload(_proxyRegistrySlot)\n\n    }\n",
                    "message": "PoaProxy.proxyRegistry uses assembly (PoaProxy.sol#46-55)\n\t- PoaProxy.sol#52-55\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": 95,
                    "vulnerability_code": "  function getContractAddress(\n\n    string _name\n\n  )\n\n    public\n\n    view\n\n    returns (address _contractAddress)\n\n  {\n\n    bytes4 _sig = bytes4(keccak256(\"getContractAddress32(bytes32)\"));\n\n    bytes32 _name32 = keccak256(_name);\n\n    bytes32 _proxyRegistrySlot = proxyRegistrySlot;\n\n\n\n    assembly {\n\n      let _call := mload(0x40)          // set _call to free memory pointer\n\n      mstore(_call, _sig)               // store _sig at _call pointer\n\n      mstore(add(_call, 0x04), _name32) // store _name32 at _call offset by 4 bytes for pre-existing _sig\n\n\n\n      // staticcall(g, a, in, insize, out, outsize) => 0 on error 1 on success\n\n      let success := staticcall(\n\n        gas,    // g = gas: whatever was passed already\n\n        sload(_proxyRegistrySlot),  // a = address: address in storage\n\n        _call,  // in = mem in  mem[in..(in+insize): set to free memory pointer\n\n        0x24,   // insize = mem insize  mem[in..(in+insize): size of sig (bytes4) + bytes32 = 0x24\n\n        _call,   // out = mem out  mem[out..(out+outsize): output assigned to this storage address\n\n        0x20    // outsize = mem outsize  mem[out..(out+outsize): output should be 32byte slot (address size = 0x14 <  slot size 0x20)\n\n      )\n\n\n\n      // revert if not successful\n\n      if iszero(success) {\n\n        revert(0, 0)\n\n      }\n\n\n\n      _contractAddress := mload(_call) // assign result to return value\n\n      mstore(0x40, add(_call, 0x24)) // advance free memory pointer by largest _call size\n\n    }\n",
                    "message": "PoaProxy.getContractAddress uses assembly (PoaProxy.sol#61-95)\n\t- PoaProxy.sol#72-95\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": 106,
                    "vulnerability_code": "  function proxyIsContract(address _address)\n\n    private\n\n    view\n\n    returns (bool)\n\n  {\n\n    uint256 _size;\n\n    assembly { _size := extcodesize(_address) }\n\n    return _size > 0;\n",
                    "message": "PoaProxy.proxyIsContract uses assembly (PoaProxy.sol#98-106)\n\t- PoaProxy.sol#104-105\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "  function proxyChangeMaster(address _newMaster)\n\n    public\n\n    returns (bool)\n\n  {\n\n    require(msg.sender == getContractAddress(\"PoaManager\"));\n\n    require(_newMaster != address(0));\n\n    require(proxyMasterContract() != _newMaster);\n\n    require(proxyIsContract(_newMaster));\n\n    address _oldMaster = proxyMasterContract();\n\n    bytes32 _proxyMasterContractSlot = proxyMasterContractSlot;\n\n    assembly {\n\n      sstore(_proxyMasterContractSlot, _newMaster)\n\n    }\n\n\n\n    emit ProxyUpgradedEvent(_oldMaster, _newMaster);\n\n    getContractAddress(\"Logger\").call(\n\n      bytes4(keccak256(\"logProxyUpgradedEvent(address,address)\")),\n\n      _oldMaster, _newMaster\n\n    );\n\n\n\n    return true;\n",
                    "message": "PoaProxy.proxyChangeMaster uses assembly (PoaProxy.sol#112-133)\n\t- PoaProxy.sol#122-126\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": 181,
                    "vulnerability_code": "  function()\n\n    external\n\n    payable\n\n  {\n\n    bytes32 _proxyMasterContractSlot = proxyMasterContractSlot;\n\n    assembly {\n\n      // load address from first storage pointer\n\n      let _master := sload(_proxyMasterContractSlot)\n\n\n\n      // calldatacopy(t, f, s)\n\n      calldatacopy(\n\n        0x0, // t = mem position to\n\n        0x0, // f = mem position from\n\n        calldatasize // s = size bytes\n\n      )\n\n\n\n      // delegatecall(g, a, in, insize, out, outsize) => 0 on error 1 on success\n\n      let success := delegatecall(\n\n        gas, // g = gas\n\n        _master, // a = address\n\n        0x0, // in = mem in  mem[in..(in+insize)\n\n        calldatasize, // insize = mem insize  mem[in..(in+insize)\n\n        0x0, // out = mem out  mem[out..(out+outsize)\n\n        0 // outsize = mem outsize  mem[out..(out+outsize)\n\n      )\n\n\n\n      // returndatacopy(t, f, s)\n\n      returndatacopy(\n\n        0x0, // t = mem position to\n\n        0x0,  // f = mem position from\n\n        returndatasize // s = size bytes\n\n      )\n\n\n\n      // check if call was a success and return if no errors & revert if errors\n\n      if iszero(success) {\n\n        revert(0, 0)\n\n      }\n\n        return(\n\n          0x0,\n\n          returndatasize\n\n        )\n\n    }\n",
                    "message": "PoaProxy.fallback uses assembly (PoaProxy.sol#139-181)\n\t- PoaProxy.sol#144-181\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "  function proxyRegistry()\n\n    public\n\n    view\n\n    returns (address _proxyRegistry)\n\n  {\n\n    bytes32 _proxyRegistrySlot = proxyRegistrySlot;\n\n    assembly {\n\n      _proxyRegistry := sload(_proxyRegistrySlot)\n\n    }\n",
                    "message": "PoaProxy.proxyRegistry (PoaProxy.sol#46-55) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "  function proxyChangeMaster(address _newMaster)\n\n    public\n\n    returns (bool)\n\n  {\n\n    require(msg.sender == getContractAddress(\"PoaManager\"));\n\n    require(_newMaster != address(0));\n\n    require(proxyMasterContract() != _newMaster);\n\n    require(proxyIsContract(_newMaster));\n\n    address _oldMaster = proxyMasterContract();\n\n    bytes32 _proxyMasterContractSlot = proxyMasterContractSlot;\n\n    assembly {\n\n      sstore(_proxyMasterContractSlot, _newMaster)\n\n    }\n\n\n\n    emit ProxyUpgradedEvent(_oldMaster, _newMaster);\n\n    getContractAddress(\"Logger\").call(\n\n      bytes4(keccak256(\"logProxyUpgradedEvent(address,address)\")),\n\n      _oldMaster, _newMaster\n\n    );\n\n\n\n    return true;\n",
                    "message": "PoaProxy.proxyChangeMaster (PoaProxy.sol#112-133) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.23;\n",
                    "message": "Detected issues with version pragma in PoaProxy.sol:\n\t- pragma solidity0.4.23 (PoaProxy.sol#3): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "  function proxyChangeMaster(address _newMaster)\n\n    public\n\n    returns (bool)\n\n  {\n\n    require(msg.sender == getContractAddress(\"PoaManager\"));\n\n    require(_newMaster != address(0));\n\n    require(proxyMasterContract() != _newMaster);\n\n    require(proxyIsContract(_newMaster));\n\n    address _oldMaster = proxyMasterContract();\n\n    bytes32 _proxyMasterContractSlot = proxyMasterContractSlot;\n\n    assembly {\n\n      sstore(_proxyMasterContractSlot, _newMaster)\n\n    }\n\n\n\n    emit ProxyUpgradedEvent(_oldMaster, _newMaster);\n\n    getContractAddress(\"Logger\").call(\n\n      bytes4(keccak256(\"logProxyUpgradedEvent(address,address)\")),\n\n      _oldMaster, _newMaster\n\n    );\n\n\n\n    return true;\n",
                    "message": "Low level call in PoaProxy.proxyChangeMaster (PoaProxy.sol#112-133):\n\t-getContractAddress(Logger).call(bytes4(keccak256()(logProxyUpgradedEvent(address,address))),_oldMaster,_newMaster) PoaProxy.sol#127-130\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _master,\n",
                    "message": "Parameter '_master' of PoaProxy. (PoaProxy.sol#14) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _registry\n",
                    "message": "Parameter '_registry' of PoaProxy. (PoaProxy.sol#15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string _name\n",
                    "message": "Parameter '_name' of PoaProxy.getContractAddress (PoaProxy.sol#62) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function proxyChangeMaster(address _newMaster)\n",
                    "message": "Parameter '_newMaster' of PoaProxy.proxyChangeMaster (PoaProxy.sol#112) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  uint8 public constant version = 1;\n",
                    "message": "Constant 'PoaProxy.version' (PoaProxy.sol#7) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  bytes32 public constant proxyMasterContractSlot = keccak256(\"masterAddress\");\n",
                    "message": "Constant 'PoaProxy.proxyMasterContractSlot' (PoaProxy.sol#8) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  bytes32 public constant proxyRegistrySlot = keccak256(\"registry\");\n",
                    "message": "Constant 'PoaProxy.proxyRegistrySlot' (PoaProxy.sol#9) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function proxyMasterContract()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function proxyRegistry()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function getContractAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract PoaProxy {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function proxyMasterContract()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function proxyRegistry()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function getContractAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function proxyIsContract(address _address)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    getContractAddress(\"Logger\").call(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    getContractAddress(\"Logger\").call(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string _name\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/contracts/OraclizeAPI.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < h.length; i ++)\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    if(subindex == n.length)\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<bresult.length; i++){\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 683,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 683,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 690,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (byte(cborlen).length > ctr) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 697,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint x = 0; x < elemArray[i].length; x++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 703,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        while (byte(elemcborlen).length > ctr - lctr) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 725,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 725,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 732,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (byte(cborlen).length > ctr) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 739,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint x = 0; x < elemArray[i].length; x++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 742,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 742,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        while (byte(elemcborlen).length > ctr - lctr) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < h.length; i ++)\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<bresult.length; i++){\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < arrlen; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 697,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint x = 0; x < elemArray[i].length; x++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 723,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < arrlen; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 739,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint x = 0; x < elemArray[i].length; x++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 909,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i=0; i< n_random_bytes; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 770,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require((_nbytes > 0) && (_nbytes <= 32));\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 886,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (decimals){\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                   if (_b == 0) break;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 648,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    else _b--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 649,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                mint *= 10;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 651,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                mint += uint(bresult[i]) - 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if (bresult[i] == 46) decimals = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1045,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v != 27 && v != 28)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1046,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return (false, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 648,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    else _b--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < minLength; i ++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < h.length; i ++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        subindex++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 615,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 617,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 618,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<bresult.length; i++){\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 663,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            len++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < arrlen; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 692,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ctr++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < arrlen; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 696,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ctr++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 697,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint x = 0; x < elemArray[i].length; x++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 705,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                            ctr++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 709,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    ctr++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ctr++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 723,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < arrlen; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 734,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ctr++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < arrlen; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 738,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ctr++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 739,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint x = 0; x < elemArray[i].length; x++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 747,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                            ctr++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 751,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    ctr++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 754,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ctr++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 909,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i=0; i< n_random_bytes; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "DOCKER_RECEIVED_SIGNAL_20"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": 538,
                    "vulnerability_code": "    function getCodeSize(address _addr) constant internal returns(uint _size) {\n\n        assembly {\n\n            _size := extcodesize(_addr)\n\n        }\n",
                    "message": "usingOraclize.getCodeSize (OraclizeAPI.sol#534-538) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": 979,
                    "vulnerability_code": "    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n\n        uint minLength = length + toOffset;\n\n\n\n        // Buffer too small\n\n        require(to.length >= minLength); // Should be a better way?\n\n\n\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\n\n        uint i = 32 + fromOffset;\n\n        uint j = 32 + toOffset;\n\n\n\n        while (i < (32 + fromOffset + length)) {\n\n            assembly {\n\n                let tmp := mload(add(from, i))\n\n                mstore(add(to, j), tmp)\n\n            }\n\n            i += 32;\n\n            j += 32;\n\n        }\n\n\n\n        return to;\n",
                    "message": "usingOraclize.copyBytes (OraclizeAPI.sol#959-979) is declared view but contains assembly code\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": 85,
                    "vulnerability_code": "    modifier oraclizeAPI {\n\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n\n            oraclize_setNetwork(networkID_auto);\n\n\n\n        if(address(oraclize) != OAR.getAddress())\n\n            oraclize = OraclizeI(OAR.getAddress());\n\n\n\n        _;\n",
                    "message": "Reentrancy in usingOraclize.oraclizeAPI (OraclizeAPI.sol#77-85):\n\tExternal calls:\n\t- address(oraclize) != OAR.getAddress() (OraclizeAPI.sol#81-82)\n\t- oraclize = OraclizeI(OAR.getAddress()) (OraclizeAPI.sol#82)\n\tState variables written after the call(s):\n\t- oraclize (OraclizeAPI.sol#82)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 769,
                    "vulnerability_to_line": 812,
                    "vulnerability_code": "    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n\n        require((_nbytes > 0) && (_nbytes <= 32));\n\n        // Convert from seconds to ledger timer ticks\n\n        _delay *= 10;\n\n        bytes memory nbytes = new bytes(1);\n\n        nbytes[0] = byte(_nbytes);\n\n        bytes memory unonce = new bytes(32);\n\n        bytes memory sessionKeyHash = new bytes(32);\n\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n\n        assembly {\n\n            mstore(unonce, 0x20)\n\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n\n            mstore(sessionKeyHash, 0x20)\n\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n\n        }\n\n        bytes memory delay = new bytes(32);\n\n        assembly {\n\n            mstore(add(delay, 0x20), _delay)\n\n        }\n\n\n\n        bytes memory delay_bytes8 = new bytes(8);\n\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\n\n\n\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n\n\n\n        bytes memory delay_bytes8_left = new bytes(8);\n\n\n\n        assembly {\n\n            let x := mload(add(delay_bytes8, 0x20))\n\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n\n\n\n        }\n\n\n\n        oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\n\n        return queryId;\n",
                    "message": "Reentrancy in usingOraclize.oraclize_newRandomDSQuery (OraclizeAPI.sol#769-812):\n\tExternal calls:\n\t- sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash() (OraclizeAPI.sol#777)\n\t- queryId = oraclize_query(random,args,_customGasLimit) (OraclizeAPI.sol#793)\n\tExternal calls sending eth:\n\t- queryId = oraclize_query(random,args,_customGasLimit) (OraclizeAPI.sol#793)\n\tState variables written after the call(s):\n\t- oraclize_network_name (OraclizeAPI.sol#793)\n\t- oraclize_randomDS_args (OraclizeAPI.sol#810)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": 538,
                    "vulnerability_code": "    function getCodeSize(address _addr) constant internal returns(uint _size) {\n\n        assembly {\n\n            _size := extcodesize(_addr)\n\n        }\n",
                    "message": "usingOraclize.getCodeSize uses assembly (OraclizeAPI.sol#534-538)\n\t- OraclizeAPI.sol#535-538\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 769,
                    "vulnerability_to_line": 812,
                    "vulnerability_code": "    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n\n        require((_nbytes > 0) && (_nbytes <= 32));\n\n        // Convert from seconds to ledger timer ticks\n\n        _delay *= 10;\n\n        bytes memory nbytes = new bytes(1);\n\n        nbytes[0] = byte(_nbytes);\n\n        bytes memory unonce = new bytes(32);\n\n        bytes memory sessionKeyHash = new bytes(32);\n\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n\n        assembly {\n\n            mstore(unonce, 0x20)\n\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n\n            mstore(sessionKeyHash, 0x20)\n\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n\n        }\n\n        bytes memory delay = new bytes(32);\n\n        assembly {\n\n            mstore(add(delay, 0x20), _delay)\n\n        }\n\n\n\n        bytes memory delay_bytes8 = new bytes(8);\n\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\n\n\n\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n\n\n\n        bytes memory delay_bytes8_left = new bytes(8);\n\n\n\n        assembly {\n\n            let x := mload(add(delay_bytes8, 0x20))\n\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n\n\n\n        }\n\n\n\n        oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\n\n        return queryId;\n",
                    "message": "usingOraclize.oraclize_newRandomDSQuery uses assembly (OraclizeAPI.sol#769-812)\n\t- OraclizeAPI.sol#778-784\n\t- OraclizeAPI.sol#785-789\n\t- OraclizeAPI.sol#797-810\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 821,
                    "vulnerability_to_line": 847,
                    "vulnerability_code": "    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n\n        bool sigok;\n\n        address signer;\n\n\n\n        bytes32 sigr;\n\n        bytes32 sigs;\n\n\n\n        bytes memory sigr_ = new bytes(32);\n\n        uint offset = 4+(uint(dersig[3]) - 0x20);\n\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n\n        bytes memory sigs_ = new bytes(32);\n\n        offset += 32 + 2;\n\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n\n\n\n        assembly {\n\n            sigr := mload(add(sigr_, 32))\n\n            sigs := mload(add(sigs_, 32))\n\n        }\n\n\n\n\n\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n\n        if (address(keccak256(pubkey)) == signer) return true;\n\n        else {\n\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n\n            return (address(keccak256(pubkey)) == signer);\n\n        }\n",
                    "message": "usingOraclize.verifySig uses assembly (OraclizeAPI.sol#821-847)\n\t- OraclizeAPI.sol#835-841\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": 979,
                    "vulnerability_code": "    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n\n        uint minLength = length + toOffset;\n\n\n\n        // Buffer too small\n\n        require(to.length >= minLength); // Should be a better way?\n\n\n\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\n\n        uint i = 32 + fromOffset;\n\n        uint j = 32 + toOffset;\n\n\n\n        while (i < (32 + fromOffset + length)) {\n\n            assembly {\n\n                let tmp := mload(add(from, i))\n\n                mstore(add(to, j), tmp)\n\n            }\n\n            i += 32;\n\n            j += 32;\n\n        }\n\n\n\n        return to;\n",
                    "message": "usingOraclize.copyBytes uses assembly (OraclizeAPI.sol#959-979)\n\t- OraclizeAPI.sol#970-974\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 983,
                    "vulnerability_to_line": 1008,
                    "vulnerability_code": "    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n\n        // We do our own memory management here. Solidity uses memory offset\n\n        // 0x40 to store the current end of memory. We write past it (as\n\n        // writes are memory extensions), but don't update the offset so\n\n        // Solidity will reuse it. The memory used here is only needed for\n\n        // this context.\n\n\n\n        // FIXME: inline assembly can't access return values\n\n        bool ret;\n\n        address addr;\n\n\n\n        assembly {\n\n            let size := mload(0x40)\n\n            mstore(size, hash)\n\n            mstore(add(size, 32), v)\n\n            mstore(add(size, 64), r)\n\n            mstore(add(size, 96), s)\n\n\n\n            // NOTE: we can reuse the request memory because we deal with\n\n            //       the return code\n\n            ret := call(3000, 1, 0, size, 128, size, 32)\n\n            addr := mload(size)\n\n        }\n\n\n\n        return (ret, addr);\n",
                    "message": "usingOraclize.safer_ecrecover uses assembly (OraclizeAPI.sol#983-1008)\n\t- OraclizeAPI.sol#994-1007\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1011,
                    "vulnerability_to_line": 1049,
                    "vulnerability_code": "    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n\n        bytes32 r;\n\n        bytes32 s;\n\n        uint8 v;\n\n\n\n        if (sig.length != 65)\n\n          return (false, 0);\n\n\n\n        // The signature format is a compact form of:\n\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        assembly {\n\n            r := mload(add(sig, 32))\n\n            s := mload(add(sig, 64))\n\n\n\n            // Here we are loading the last 32 bytes. We exploit the fact that\n\n            // 'mload' will pad with zeroes if we overread.\n\n            // There is no 'mload8' to do this, but that would be nicer.\n\n            v := byte(0, mload(add(sig, 96)))\n\n\n\n            // Alternative solution:\n\n            // 'byte' is not working due to the Solidity parser, so lets\n\n            // use the second best option, 'and'\n\n            // v := and(mload(add(sig, 65)), 255)\n\n        }\n\n\n\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\n\n        // to match the YP range of [27, 28]\n\n        //\n\n        // geth uses [0, 1] and some clients have followed. This might change, see:\n\n        //  https://github.com/ethereum/go-ethereum/issues/2053\n\n        if (v < 27)\n\n          v += 27;\n\n\n\n        if (v != 27 && v != 28)\n\n            return (false, 0);\n\n\n\n        return safer_ecrecover(hash, v, r, s);\n",
                    "message": "usingOraclize.ecrecovery uses assembly (OraclizeAPI.sol#1011-1049)\n\t- OraclizeAPI.sol#1022-1042\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public cbAddress;\n",
                    "message": "OraclizeI.cbAddress should be constant (OraclizeAPI.sol#42)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n",
                    "message": "OraclizeI.query2 (OraclizeAPI.sol#45) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n",
                    "message": "OraclizeI.queryN (OraclizeAPI.sol#47) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPrice(string _datasource) public returns (uint _dsprice);\n",
                    "message": "OraclizeI.getPrice (OraclizeAPI.sol#49) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n",
                    "message": "OraclizeI.getPrice (OraclizeAPI.sol#50) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAddress() public returns (address _addr);\n",
                    "message": "OraclizeAddrResolverI.getAddress (OraclizeAPI.sol#56) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "    function __callback(bytes32 myid, string result) public {\n\n        __callback(myid, result, new bytes(0));\n",
                    "message": "usingOraclize.__callback (OraclizeAPI.sol#131-133) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.18;\n",
                    "message": "Detected issues with version pragma in OraclizeAPI.sol:\n\t- pragma solidity^0.4.18 (OraclizeAPI.sol#34): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\n",
                    "message": "Function 'OraclizeI.query_withGasLimit' (OraclizeAPI.sol#44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\n",
                    "message": "Function 'OraclizeI.query2_withGasLimit' (OraclizeAPI.sol#46) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\n",
                    "message": "Function 'OraclizeI.queryN_withGasLimit' (OraclizeAPI.sol#48) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n",
                    "message": "Function 'OraclizeI.randomDS_getSessionPubKeyHash' (OraclizeAPI.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": 1051,
                    "vulnerability_code": "contract usingOraclize {\n\n    uint constant day = 60*60*24;\n\n    uint constant week = 60*60*24*7;\n\n    uint constant month = 60*60*24*30;\n\n    byte constant proofType_NONE = 0x00;\n\n    byte constant proofType_TLSNotary = 0x10;\n\n    byte constant proofType_Android = 0x20;\n\n    byte constant proofType_Ledger = 0x30;\n\n    byte constant proofType_Native = 0xF0;\n\n    byte constant proofStorage_IPFS = 0x01;\n\n    uint8 constant networkID_auto = 0;\n\n    uint8 constant networkID_mainnet = 1;\n\n    uint8 constant networkID_testnet = 2;\n\n    uint8 constant networkID_morden = 2;\n\n    uint8 constant networkID_consensys = 161;\n\n\n\n    OraclizeAddrResolverI OAR;\n\n\n\n    OraclizeI oraclize;\n\n    modifier oraclizeAPI {\n\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n\n            oraclize_setNetwork(networkID_auto);\n\n\n\n        if(address(oraclize) != OAR.getAddress())\n\n            oraclize = OraclizeI(OAR.getAddress());\n\n\n\n        _;\n\n    }\n\n    modifier coupon(string code){\n\n        oraclize = OraclizeI(OAR.getAddress());\n\n        _;\n\n    }\n\n\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n\n      return oraclize_setNetwork();\n\n      networkID; // silence the warning and remain backwards compatible\n\n    }\n\n    function oraclize_setNetwork() internal returns(bool){\n\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\n\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n\n            oraclize_setNetworkName(\"eth_mainnet\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\n\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n\n            oraclize_setNetworkName(\"eth_ropsten3\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\n\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n\n            oraclize_setNetworkName(\"eth_kovan\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\n\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n\n            oraclize_setNetworkName(\"eth_rinkeby\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\n\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\n\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\n\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n\n            return true;\n\n        }\n\n        return false;\n\n    }\n\n\n\n    function __callback(bytes32 myid, string result) public {\n\n        __callback(myid, result, new bytes(0));\n\n    }\n\n    function __callback(bytes32 myid, string result, bytes proof) public {\n\n      return;\n\n      myid; result; proof; // Silence compiler warnings\n\n    }\n\n\n\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n\n        return oraclize.getPrice(datasource);\n\n    }\n\n\n\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n\n        return oraclize.getPrice(datasource, gaslimit);\n\n    }\n\n\n\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query.value(price)(0, datasource, arg);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN.value(price)(0, datasource, args);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n\n\n    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n\n\n    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN.value(price)(0, datasource, args);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n\n\n    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n\n\n    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n\n\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n\n        return oraclize.cbAddress();\n\n    }\n\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n\n        return oraclize.setProofType(proofP);\n\n    }\n\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n\n        return oraclize.setCustomGasPrice(gasPrice);\n\n    }\n\n\n\n    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n\n        return oraclize.randomDS_getSessionPubKeyHash();\n\n    }\n\n\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n\n        assembly {\n\n            _size := extcodesize(_addr)\n\n        }\n\n    }\n\n\n\n    function parseAddr(string _a) internal pure returns (address){\n\n        bytes memory tmp = bytes(_a);\n\n        uint160 iaddr = 0;\n\n        uint160 b1;\n\n        uint160 b2;\n\n        for (uint i=2; i<2+2*20; i+=2){\n\n            iaddr *= 256;\n\n            b1 = uint160(tmp[i]);\n\n            b2 = uint160(tmp[i+1]);\n\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n\n            iaddr += (b1*16+b2);\n\n        }\n\n        return address(iaddr);\n\n    }\n\n\n\n    function strCompare(string _a, string _b) internal pure returns (int) {\n\n        bytes memory a = bytes(_a);\n\n        bytes memory b = bytes(_b);\n\n        uint minLength = a.length;\n\n        if (b.length < minLength) minLength = b.length;\n\n        for (uint i = 0; i < minLength; i ++)\n\n            if (a[i] < b[i])\n\n                return -1;\n\n            else if (a[i] > b[i])\n\n                return 1;\n\n        if (a.length < b.length)\n\n            return -1;\n\n        else if (a.length > b.length)\n\n            return 1;\n\n        else\n\n            return 0;\n\n    }\n\n\n\n    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n\n        bytes memory h = bytes(_haystack);\n\n        bytes memory n = bytes(_needle);\n\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n\n            return -1;\n\n        else if(h.length > (2**128 -1))\n\n            return -1;\n\n        else\n\n        {\n\n            uint subindex = 0;\n\n            for (uint i = 0; i < h.length; i ++)\n\n            {\n\n                if (h[i] == n[0])\n\n                {\n\n                    subindex = 1;\n\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n\n                    {\n\n                        subindex++;\n\n                    }\n\n                    if(subindex == n.length)\n\n                        return int(i);\n\n                }\n\n            }\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n\n        bytes memory _ba = bytes(_a);\n\n        bytes memory _bb = bytes(_b);\n\n        bytes memory _bc = bytes(_c);\n\n        bytes memory _bd = bytes(_d);\n\n        bytes memory _be = bytes(_e);\n\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n\n        bytes memory babcde = bytes(abcde);\n\n        uint k = 0;\n\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n\n        return string(babcde);\n\n    }\n\n\n\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n\n        return strConcat(_a, _b, _c, _d, \"\");\n\n    }\n\n\n\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n\n        return strConcat(_a, _b, _c, \"\", \"\");\n\n    }\n\n\n\n    function strConcat(string _a, string _b) internal pure returns (string) {\n\n        return strConcat(_a, _b, \"\", \"\", \"\");\n\n    }\n\n\n\n    // parseInt\n\n    function parseInt(string _a) internal pure returns (uint) {\n\n        return parseInt(_a, 0);\n\n    }\n\n\n\n    // parseInt(parseFloat*10^_b)\n\n    function parseInt(string _a, uint _b) internal pure returns (uint) {\n\n        bytes memory bresult = bytes(_a);\n\n        uint mint = 0;\n\n        bool decimals = false;\n\n        for (uint i=0; i<bresult.length; i++){\n\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n\n                if (decimals){\n\n                   if (_b == 0) break;\n\n                    else _b--;\n\n                }\n\n                mint *= 10;\n\n                mint += uint(bresult[i]) - 48;\n\n            } else if (bresult[i] == 46) decimals = true;\n\n        }\n\n        if (_b > 0) mint *= 10**_b;\n\n        return mint;\n\n    }\n\n\n\n    function uint2str(uint i) internal pure returns (string){\n\n        if (i == 0) return \"0\";\n\n        uint j = i;\n\n        uint len;\n\n        while (j != 0){\n\n            len++;\n\n            j /= 10;\n\n        }\n\n        bytes memory bstr = new bytes(len);\n\n        uint k = len - 1;\n\n        while (i != 0){\n\n            bstr[k--] = byte(48 + i % 10);\n\n            i /= 10;\n\n        }\n\n        return string(bstr);\n\n    }\n\n\n\n    function stra2cbor(string[] arr) internal pure returns (bytes) {\n\n            uint arrlen = arr.length;\n\n\n\n            // get correct cbor output length\n\n            uint outputlen = 0;\n\n            bytes[] memory elemArray = new bytes[](arrlen);\n\n            for (uint i = 0; i < arrlen; i++) {\n\n                elemArray[i] = (bytes(arr[i]));\n\n                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\n\n            }\n\n            uint ctr = 0;\n\n            uint cborlen = arrlen + 0x80;\n\n            outputlen += byte(cborlen).length;\n\n            bytes memory res = new bytes(outputlen);\n\n\n\n            while (byte(cborlen).length > ctr) {\n\n                res[ctr] = byte(cborlen)[ctr];\n\n                ctr++;\n\n            }\n\n            for (i = 0; i < arrlen; i++) {\n\n                res[ctr] = 0x5F;\n\n                ctr++;\n\n                for (uint x = 0; x < elemArray[i].length; x++) {\n\n                    // if there's a bug with larger strings, this may be the culprit\n\n                    if (x % 23 == 0) {\n\n                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n\n                        elemcborlen += 0x40;\n\n                        uint lctr = ctr;\n\n                        while (byte(elemcborlen).length > ctr - lctr) {\n\n                            res[ctr] = byte(elemcborlen)[ctr - lctr];\n\n                            ctr++;\n\n                        }\n\n                    }\n\n                    res[ctr] = elemArray[i][x];\n\n                    ctr++;\n\n                }\n\n                res[ctr] = 0xFF;\n\n                ctr++;\n\n            }\n\n            return res;\n\n        }\n\n\n\n    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n\n            uint arrlen = arr.length;\n\n\n\n            // get correct cbor output length\n\n            uint outputlen = 0;\n\n            bytes[] memory elemArray = new bytes[](arrlen);\n\n            for (uint i = 0; i < arrlen; i++) {\n\n                elemArray[i] = (bytes(arr[i]));\n\n                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\n\n            }\n\n            uint ctr = 0;\n\n            uint cborlen = arrlen + 0x80;\n\n            outputlen += byte(cborlen).length;\n\n            bytes memory res = new bytes(outputlen);\n\n\n\n            while (byte(cborlen).length > ctr) {\n\n                res[ctr] = byte(cborlen)[ctr];\n\n                ctr++;\n\n            }\n\n            for (i = 0; i < arrlen; i++) {\n\n                res[ctr] = 0x5F;\n\n                ctr++;\n\n                for (uint x = 0; x < elemArray[i].length; x++) {\n\n                    // if there's a bug with larger strings, this may be the culprit\n\n                    if (x % 23 == 0) {\n\n                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n\n                        elemcborlen += 0x40;\n\n                        uint lctr = ctr;\n\n                        while (byte(elemcborlen).length > ctr - lctr) {\n\n                            res[ctr] = byte(elemcborlen)[ctr - lctr];\n\n                            ctr++;\n\n                        }\n\n                    }\n\n                    res[ctr] = elemArray[i][x];\n\n                    ctr++;\n\n                }\n\n                res[ctr] = 0xFF;\n\n                ctr++;\n\n            }\n\n            return res;\n\n        }\n\n\n\n\n\n    string oraclize_network_name;\n\n    function oraclize_setNetworkName(string _network_name) internal {\n\n        oraclize_network_name = _network_name;\n\n    }\n\n\n\n    function oraclize_getNetworkName() internal view returns (string) {\n\n        return oraclize_network_name;\n\n    }\n\n\n\n    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n\n        require((_nbytes > 0) && (_nbytes <= 32));\n\n        // Convert from seconds to ledger timer ticks\n\n        _delay *= 10;\n\n        bytes memory nbytes = new bytes(1);\n\n        nbytes[0] = byte(_nbytes);\n\n        bytes memory unonce = new bytes(32);\n\n        bytes memory sessionKeyHash = new bytes(32);\n\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n\n        assembly {\n\n            mstore(unonce, 0x20)\n\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n\n            mstore(sessionKeyHash, 0x20)\n\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n\n        }\n\n        bytes memory delay = new bytes(32);\n\n        assembly {\n\n            mstore(add(delay, 0x20), _delay)\n\n        }\n\n\n\n        bytes memory delay_bytes8 = new bytes(8);\n\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\n\n\n\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n\n\n\n        bytes memory delay_bytes8_left = new bytes(8);\n\n\n\n        assembly {\n\n            let x := mload(add(delay_bytes8, 0x20))\n\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n\n\n\n        }\n\n\n\n        oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\n\n        return queryId;\n\n    }\n\n\n\n    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n\n        oraclize_randomDS_args[queryId] = commitment;\n\n    }\n\n\n\n    mapping(bytes32=>bytes32) oraclize_randomDS_args;\n\n    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n\n\n\n    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n\n        bool sigok;\n\n        address signer;\n\n\n\n        bytes32 sigr;\n\n        bytes32 sigs;\n\n\n\n        bytes memory sigr_ = new bytes(32);\n\n        uint offset = 4+(uint(dersig[3]) - 0x20);\n\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n\n        bytes memory sigs_ = new bytes(32);\n\n        offset += 32 + 2;\n\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n\n\n\n        assembly {\n\n            sigr := mload(add(sigr_, 32))\n\n            sigs := mload(add(sigs_, 32))\n\n        }\n\n\n\n\n\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n\n        if (address(keccak256(pubkey)) == signer) return true;\n\n        else {\n\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n\n            return (address(keccak256(pubkey)) == signer);\n\n        }\n\n    }\n\n\n\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n\n        bool sigok;\n\n\n\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\n\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n\n\n\n        bytes memory appkey1_pubkey = new bytes(64);\n\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n\n\n\n        bytes memory tosign2 = new bytes(1+65+32);\n\n        tosign2[0] = byte(1); //role\n\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n\n\n\n        if (sigok == false) return false;\n\n\n\n\n\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\n\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n\n\n\n        bytes memory tosign3 = new bytes(1+65);\n\n        tosign3[0] = 0xFE;\n\n        copyBytes(proof, 3, 65, tosign3, 1);\n\n\n\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\n\n\n\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n\n\n\n        return sigok;\n\n    }\n\n\n\n    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n\n        require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n\n\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n\n        require(proofVerified);\n\n\n\n        _;\n\n    }\n\n\n\n    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n\n        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n\n\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n\n        if (proofVerified == false) return 2;\n\n\n\n        return 0;\n\n    }\n\n\n\n    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n\n        bool match_ = true;\n\n\n\n        require(prefix.length == n_random_bytes);\n\n\n\n        for (uint256 i=0; i< n_random_bytes; i++) {\n\n            if (content[i] != prefix[i]) match_ = false;\n\n        }\n\n\n\n        return match_;\n\n    }\n\n\n\n    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n\n\n\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\n\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n\n        bytes memory keyhash = new bytes(32);\n\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n\n        if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;\n\n\n\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n\n\n\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\n\n        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n\n\n\n        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\n\n        // This is to verify that the computed args match with the ones specified in the query.\n\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\n\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n\n\n\n        bytes memory sessionPubkey = new bytes(64);\n\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n\n\n\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n\n        if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match\n\n            delete oraclize_randomDS_args[queryId];\n\n        } else return false;\n\n\n\n\n\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\n\n        bytes memory tosign1 = new bytes(32+8+1+32);\n\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n\n\n\n        // verify if sessionPubkeyHash was verified already, if not.. let's do it!\n\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n\n        }\n\n\n\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n\n    }\n\n\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n\n    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n\n        uint minLength = length + toOffset;\n\n\n\n        // Buffer too small\n\n        require(to.length >= minLength); // Should be a better way?\n\n\n\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\n\n        uint i = 32 + fromOffset;\n\n        uint j = 32 + toOffset;\n\n\n\n        while (i < (32 + fromOffset + length)) {\n\n            assembly {\n\n                let tmp := mload(add(from, i))\n\n                mstore(add(to, j), tmp)\n\n            }\n\n            i += 32;\n\n            j += 32;\n\n        }\n\n\n\n        return to;\n\n    }\n\n\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n\n    // Duplicate Solidity's ecrecover, but catching the CALL return value\n\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n\n        // We do our own memory management here. Solidity uses memory offset\n\n        // 0x40 to store the current end of memory. We write past it (as\n\n        // writes are memory extensions), but don't update the offset so\n\n        // Solidity will reuse it. The memory used here is only needed for\n\n        // this context.\n\n\n\n        // FIXME: inline assembly can't access return values\n\n        bool ret;\n\n        address addr;\n\n\n\n        assembly {\n\n            let size := mload(0x40)\n\n            mstore(size, hash)\n\n            mstore(add(size, 32), v)\n\n            mstore(add(size, 64), r)\n\n            mstore(add(size, 96), s)\n\n\n\n            // NOTE: we can reuse the request memory because we deal with\n\n            //       the return code\n\n            ret := call(3000, 1, 0, size, 128, size, 32)\n\n            addr := mload(size)\n\n        }\n\n\n\n        return (ret, addr);\n\n    }\n\n\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n\n    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n\n        bytes32 r;\n\n        bytes32 s;\n\n        uint8 v;\n\n\n\n        if (sig.length != 65)\n\n          return (false, 0);\n\n\n\n        // The signature format is a compact form of:\n\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        assembly {\n\n            r := mload(add(sig, 32))\n\n            s := mload(add(sig, 64))\n\n\n\n            // Here we are loading the last 32 bytes. We exploit the fact that\n\n            // 'mload' will pad with zeroes if we overread.\n\n            // There is no 'mload8' to do this, but that would be nicer.\n\n            v := byte(0, mload(add(sig, 96)))\n\n\n\n            // Alternative solution:\n\n            // 'byte' is not working due to the Solidity parser, so lets\n\n            // use the second best option, 'and'\n\n            // v := and(mload(add(sig, 65)), 255)\n\n        }\n\n\n\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\n\n        // to match the YP range of [27, 28]\n\n        //\n\n        // geth uses [0, 1] and some clients have followed. This might change, see:\n\n        //  https://github.com/ethereum/go-ethereum/issues/2053\n\n        if (v < 27)\n\n          v += 27;\n\n\n\n        if (v != 27 && v != 28)\n\n            return (false, 0);\n\n\n\n        return safer_ecrecover(hash, v, r, s);\n\n    }\n\n\n",
                    "message": "Contract 'usingOraclize' (OraclizeAPI.sol#58-1051) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n\n      return oraclize_setNetwork();\n\n      networkID; // silence the warning and remain backwards compatible\n",
                    "message": "Function 'usingOraclize.oraclize_setNetwork' (OraclizeAPI.sol#91-94) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": 129,
                    "vulnerability_code": "    function oraclize_setNetwork() internal returns(bool){\n\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\n\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n\n            oraclize_setNetworkName(\"eth_mainnet\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\n\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n\n            oraclize_setNetworkName(\"eth_ropsten3\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\n\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n\n            oraclize_setNetworkName(\"eth_kovan\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\n\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n\n            oraclize_setNetworkName(\"eth_rinkeby\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\n\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\n\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\n\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n\n            return true;\n\n        }\n\n        return false;\n",
                    "message": "Function 'usingOraclize.oraclize_setNetwork' (OraclizeAPI.sol#95-129) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "    function __callback(bytes32 myid, string result) public {\n\n        __callback(myid, result, new bytes(0));\n",
                    "message": "Function 'usingOraclize.__callback' (OraclizeAPI.sol#131-133) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function __callback(bytes32 myid, string result, bytes proof) public {\n\n      return;\n\n      myid; result; proof; // Silence compiler warnings\n",
                    "message": "Function 'usingOraclize.__callback' (OraclizeAPI.sol#134-137) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": 141,
                    "vulnerability_code": "    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n\n        return oraclize.getPrice(datasource);\n",
                    "message": "Function 'usingOraclize.oraclize_getPrice' (OraclizeAPI.sol#139-141) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n\n        return oraclize.getPrice(datasource, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_getPrice' (OraclizeAPI.sol#143-145) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 151,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query.value(price)(0, datasource, arg);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#147-151) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": 156,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#152-156) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 161,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#157-161) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": 166,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#162-166) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": 171,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#167-171) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": 176,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#172-176) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": 181,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#177-181) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": 186,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#182-186) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": 192,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN.value(price)(0, datasource, args);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#187-192) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": 198,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#193-198) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": 204,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#199-204) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#205-210) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": 215,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#211-215) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": 220,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#216-220) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": 225,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#221-225) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": 230,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#226-230) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": 237,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#232-237) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#238-243) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": 249,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#244-249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": 255,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#250-255) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 262,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#256-262) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": 269,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#263-269) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": 276,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#270-276) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": 283,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#277-283) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 285,
                    "vulnerability_to_line": 292,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#285-292) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": 300,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#293-300) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": 308,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#301-308) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": 316,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#309-316) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#317-325) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 326,
                    "vulnerability_to_line": 334,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#326-334) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": 343,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#335-343) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": 352,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#344-352) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": 358,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN.value(price)(0, datasource, args);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#353-358) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": 364,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#359-364) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": 370,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#365-370) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": 376,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#371-376) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 381,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#377-381) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": 386,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#382-386) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": 391,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#387-391) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 392,
                    "vulnerability_to_line": 396,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#392-396) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": 403,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#398-403) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": 409,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#404-409) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": 415,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#410-415) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": 421,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#416-421) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": 428,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#422-428) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 429,
                    "vulnerability_to_line": 435,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#429-435) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 436,
                    "vulnerability_to_line": 442,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#436-442) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": 449,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#443-449) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 451,
                    "vulnerability_to_line": 458,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#451-458) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 459,
                    "vulnerability_to_line": 466,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#459-466) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 467,
                    "vulnerability_to_line": 474,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#467-474) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 475,
                    "vulnerability_to_line": 482,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#475-482) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": 491,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#483-491) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 492,
                    "vulnerability_to_line": 500,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#492-500) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": 509,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#501-509) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": 518,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (OraclizeAPI.sol#510-518) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": 522,
                    "vulnerability_code": "    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n\n        return oraclize.cbAddress();\n",
                    "message": "Function 'usingOraclize.oraclize_cbAddress' (OraclizeAPI.sol#520-522) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 525,
                    "vulnerability_code": "    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n\n        return oraclize.setProofType(proofP);\n",
                    "message": "Function 'usingOraclize.oraclize_setProof' (OraclizeAPI.sol#523-525) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": 528,
                    "vulnerability_code": "    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n\n        return oraclize.setCustomGasPrice(gasPrice);\n",
                    "message": "Function 'usingOraclize.oraclize_setCustomGasPrice' (OraclizeAPI.sol#526-528) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": 532,
                    "vulnerability_code": "    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n\n        return oraclize.randomDS_getSessionPubKeyHash();\n",
                    "message": "Function 'usingOraclize.oraclize_randomDS_getSessionPubKeyHash' (OraclizeAPI.sol#530-532) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseAddr(string _a) internal pure returns (address){\n",
                    "message": "Parameter '_a' of usingOraclize.parseAddr (OraclizeAPI.sol#540) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strCompare(string _a, string _b) internal pure returns (int) {\n",
                    "message": "Parameter '_a' of usingOraclize.strCompare (OraclizeAPI.sol#560) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strCompare(string _a, string _b) internal pure returns (int) {\n",
                    "message": "Parameter '_b' of usingOraclize.strCompare (OraclizeAPI.sol#560) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n",
                    "message": "Parameter '_haystack' of usingOraclize.indexOf (OraclizeAPI.sol#578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n",
                    "message": "Parameter '_needle' of usingOraclize.indexOf (OraclizeAPI.sol#578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": "Parameter '_a' of usingOraclize.strConcat (OraclizeAPI.sol#605) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": "Parameter '_b' of usingOraclize.strConcat (OraclizeAPI.sol#605) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": "Parameter '_c' of usingOraclize.strConcat (OraclizeAPI.sol#605) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": "Parameter '_d' of usingOraclize.strConcat (OraclizeAPI.sol#605) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": "Parameter '_e' of usingOraclize.strConcat (OraclizeAPI.sol#605) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 622,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": "Parameter '_a' of usingOraclize.strConcat (OraclizeAPI.sol#622) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 622,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": "Parameter '_b' of usingOraclize.strConcat (OraclizeAPI.sol#622) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 622,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": "Parameter '_c' of usingOraclize.strConcat (OraclizeAPI.sol#622) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 622,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": "Parameter '_d' of usingOraclize.strConcat (OraclizeAPI.sol#622) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": "Parameter '_a' of usingOraclize.strConcat (OraclizeAPI.sol#626) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": "Parameter '_b' of usingOraclize.strConcat (OraclizeAPI.sol#626) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": "Parameter '_c' of usingOraclize.strConcat (OraclizeAPI.sol#626) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 630,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b) internal pure returns (string) {\n",
                    "message": "Parameter '_a' of usingOraclize.strConcat (OraclizeAPI.sol#630) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 630,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b) internal pure returns (string) {\n",
                    "message": "Parameter '_b' of usingOraclize.strConcat (OraclizeAPI.sol#630) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 635,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseInt(string _a) internal pure returns (uint) {\n",
                    "message": "Parameter '_a' of usingOraclize.parseInt (OraclizeAPI.sol#635) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 640,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseInt(string _a, uint _b) internal pure returns (uint) {\n",
                    "message": "Parameter '_a' of usingOraclize.parseInt (OraclizeAPI.sol#640) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 640,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseInt(string _a, uint _b) internal pure returns (uint) {\n",
                    "message": "Parameter '_b' of usingOraclize.parseInt (OraclizeAPI.sol#640) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": 763,
                    "vulnerability_code": "    function oraclize_setNetworkName(string _network_name) internal {\n\n        oraclize_network_name = _network_name;\n",
                    "message": "Function 'usingOraclize.oraclize_setNetworkName' (OraclizeAPI.sol#761-763) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_setNetworkName(string _network_name) internal {\n",
                    "message": "Parameter '_network_name' of usingOraclize.oraclize_setNetworkName (OraclizeAPI.sol#761) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 765,
                    "vulnerability_to_line": 767,
                    "vulnerability_code": "    function oraclize_getNetworkName() internal view returns (string) {\n\n        return oraclize_network_name;\n",
                    "message": "Function 'usingOraclize.oraclize_getNetworkName' (OraclizeAPI.sol#765-767) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 769,
                    "vulnerability_to_line": 812,
                    "vulnerability_code": "    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n\n        require((_nbytes > 0) && (_nbytes <= 32));\n\n        // Convert from seconds to ledger timer ticks\n\n        _delay *= 10;\n\n        bytes memory nbytes = new bytes(1);\n\n        nbytes[0] = byte(_nbytes);\n\n        bytes memory unonce = new bytes(32);\n\n        bytes memory sessionKeyHash = new bytes(32);\n\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n\n        assembly {\n\n            mstore(unonce, 0x20)\n\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n\n            mstore(sessionKeyHash, 0x20)\n\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n\n        }\n\n        bytes memory delay = new bytes(32);\n\n        assembly {\n\n            mstore(add(delay, 0x20), _delay)\n\n        }\n\n\n\n        bytes memory delay_bytes8 = new bytes(8);\n\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\n\n\n\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n\n\n\n        bytes memory delay_bytes8_left = new bytes(8);\n\n\n\n        assembly {\n\n            let x := mload(add(delay_bytes8, 0x20))\n\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n\n\n\n        }\n\n\n\n        oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\n\n        return queryId;\n",
                    "message": "Function 'usingOraclize.oraclize_newRandomDSQuery' (OraclizeAPI.sol#769-812) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 769,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n",
                    "message": "Parameter '_delay' of usingOraclize.oraclize_newRandomDSQuery (OraclizeAPI.sol#769) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 769,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n",
                    "message": "Parameter '_nbytes' of usingOraclize.oraclize_newRandomDSQuery (OraclizeAPI.sol#769) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 769,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n",
                    "message": "Parameter '_customGasLimit' of usingOraclize.oraclize_newRandomDSQuery (OraclizeAPI.sol#769) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": 816,
                    "vulnerability_code": "    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n\n        oraclize_randomDS_args[queryId] = commitment;\n",
                    "message": "Function 'usingOraclize.oraclize_randomDS_setCommitment' (OraclizeAPI.sol#814-816) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": 882,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n\n        bool sigok;\n\n\n\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\n\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n\n\n\n        bytes memory appkey1_pubkey = new bytes(64);\n\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n\n\n\n        bytes memory tosign2 = new bytes(1+65+32);\n\n        tosign2[0] = byte(1); //role\n\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n\n\n\n        if (sigok == false) return false;\n\n\n\n\n\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\n\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n\n\n\n        bytes memory tosign3 = new bytes(1+65);\n\n        tosign3[0] = 0xFE;\n\n        copyBytes(proof, 3, 65, tosign3, 1);\n\n\n\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\n\n\n\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n\n\n\n        return sigok;\n",
                    "message": "Function 'usingOraclize.oraclize_randomDS_proofVerify__sessionKeyValidity' (OraclizeAPI.sol#849-882) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": 902,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n\n        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n\n\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n\n        if (proofVerified == false) return 2;\n\n\n\n        return 0;\n",
                    "message": "Function 'usingOraclize.oraclize_randomDS_proofVerify__returnCode' (OraclizeAPI.sol#894-902) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n",
                    "message": "Parameter '_queryId' of usingOraclize.oraclize_randomDS_proofVerify__returnCode (OraclizeAPI.sol#894) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n",
                    "message": "Parameter '_result' of usingOraclize.oraclize_randomDS_proofVerify__returnCode (OraclizeAPI.sol#894) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n",
                    "message": "Parameter '_proof' of usingOraclize.oraclize_randomDS_proofVerify__returnCode (OraclizeAPI.sol#894) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 904,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n",
                    "message": "Parameter 'n_random_bytes' of usingOraclize.matchBytes32Prefix (OraclizeAPI.sol#904) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": 956,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n\n\n\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\n\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n\n        bytes memory keyhash = new bytes(32);\n\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n\n        if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;\n\n\n\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n\n\n\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\n\n        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n\n\n\n        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\n\n        // This is to verify that the computed args match with the ones specified in the query.\n\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\n\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n\n\n\n        bytes memory sessionPubkey = new bytes(64);\n\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n\n\n\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n\n        if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match\n\n            delete oraclize_randomDS_args[queryId];\n\n        } else return false;\n\n\n\n\n\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\n\n        bytes memory tosign1 = new bytes(32+8+1+32);\n\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n\n\n\n        // verify if sessionPubkeyHash was verified already, if not.. let's do it!\n\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n\n        }\n\n\n\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n",
                    "message": "Function 'usingOraclize.oraclize_randomDS_proofVerify__main' (OraclizeAPI.sol#916-956) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n",
                    "message": "Parameter 'context_name' of usingOraclize.oraclize_randomDS_proofVerify__main (OraclizeAPI.sol#916) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 983,
                    "vulnerability_to_line": 1008,
                    "vulnerability_code": "    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n\n        // We do our own memory management here. Solidity uses memory offset\n\n        // 0x40 to store the current end of memory. We write past it (as\n\n        // writes are memory extensions), but don't update the offset so\n\n        // Solidity will reuse it. The memory used here is only needed for\n\n        // this context.\n\n\n\n        // FIXME: inline assembly can't access return values\n\n        bool ret;\n\n        address addr;\n\n\n\n        assembly {\n\n            let size := mload(0x40)\n\n            mstore(size, hash)\n\n            mstore(add(size, 32), v)\n\n            mstore(add(size, 64), r)\n\n            mstore(add(size, 96), s)\n\n\n\n            // NOTE: we can reuse the request memory because we deal with\n\n            //       the return code\n\n            ret := call(3000, 1, 0, size, 128, size, 32)\n\n            addr := mload(size)\n\n        }\n\n\n\n        return (ret, addr);\n",
                    "message": "Function 'usingOraclize.safer_ecrecover' (OraclizeAPI.sol#983-1008) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant day = 60*60*24;\n",
                    "message": "Constant 'usingOraclize.day' (OraclizeAPI.sol#59) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant week = 60*60*24*7;\n",
                    "message": "Constant 'usingOraclize.week' (OraclizeAPI.sol#60) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant month = 60*60*24*30;\n",
                    "message": "Constant 'usingOraclize.month' (OraclizeAPI.sol#61) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_NONE = 0x00;\n",
                    "message": "Constant 'usingOraclize.proofType_NONE' (OraclizeAPI.sol#62) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_TLSNotary = 0x10;\n",
                    "message": "Constant 'usingOraclize.proofType_TLSNotary' (OraclizeAPI.sol#63) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Android = 0x20;\n",
                    "message": "Constant 'usingOraclize.proofType_Android' (OraclizeAPI.sol#64) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Ledger = 0x30;\n",
                    "message": "Constant 'usingOraclize.proofType_Ledger' (OraclizeAPI.sol#65) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Native = 0xF0;\n",
                    "message": "Constant 'usingOraclize.proofType_Native' (OraclizeAPI.sol#66) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofStorage_IPFS = 0x01;\n",
                    "message": "Constant 'usingOraclize.proofStorage_IPFS' (OraclizeAPI.sol#67) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_auto = 0;\n",
                    "message": "Constant 'usingOraclize.networkID_auto' (OraclizeAPI.sol#68) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_mainnet = 1;\n",
                    "message": "Constant 'usingOraclize.networkID_mainnet' (OraclizeAPI.sol#69) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_testnet = 2;\n",
                    "message": "Constant 'usingOraclize.networkID_testnet' (OraclizeAPI.sol#70) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_morden = 2;\n",
                    "message": "Constant 'usingOraclize.networkID_morden' (OraclizeAPI.sol#71) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_consensys = 161;\n",
                    "message": "Constant 'usingOraclize.networkID_consensys' (OraclizeAPI.sol#72) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    OraclizeAddrResolverI OAR;\n",
                    "message": "Variable 'usingOraclize.OAR' (OraclizeAPI.sol#74) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 760,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string oraclize_network_name;\n",
                    "message": "Variable 'usingOraclize.oraclize_network_name' (OraclizeAPI.sol#760) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 818,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32=>bytes32) oraclize_randomDS_args;\n",
                    "message": "Variable 'usingOraclize.oraclize_randomDS_args' (OraclizeAPI.sol#818) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 819,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n",
                    "message": "Variable 'usingOraclize.oraclize_randomDS_sessionKeysHashVerified' (OraclizeAPI.sol#819) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 884,
                    "vulnerability_to_line": 892,
                    "vulnerability_code": "    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n\n        require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n\n\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n\n        require(proofVerified);\n\n\n\n        _;\n",
                    "message": "Modifier 'usingOraclize.oraclize_randomDS_proofVerify' (OraclizeAPI.sol#884-892) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant day = 60*60*24;\n",
                    "message": "usingOraclize.day (OraclizeAPI.sol#59) is never used in usingOraclize\nusingOraclize.week (OraclizeAPI.sol#60) is never used in usingOraclize\nusingOraclize.month (OraclizeAPI.sol#61) is never used in usingOraclize\nusingOraclize.proofType_NONE (OraclizeAPI.sol#62) is never used in usingOraclize\nusingOraclize.proofType_TLSNotary (OraclizeAPI.sol#63) is never used in usingOraclize\nusingOraclize.proofType_Android (OraclizeAPI.sol#64) is never used in usingOraclize\nusingOraclize.proofType_Ledger (OraclizeAPI.sol#65) is never used in usingOraclize\nusingOraclize.proofType_Native (OraclizeAPI.sol#66) is never used in usingOraclize\nusingOraclize.proofStorage_IPFS (OraclizeAPI.sol#67) is never used in usingOraclize\nusingOraclize.networkID_mainnet (OraclizeAPI.sol#69) is never used in usingOraclize\nusingOraclize.networkID_testnet (OraclizeAPI.sol#70) is never used in usingOraclize\nusingOraclize.networkID_morden (OraclizeAPI.sol#71) is never used in usingOraclize\nusingOraclize.networkID_consensys (OraclizeAPI.sol#72) is never used in usingOraclize\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_NONE = 0x00;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_TLSNotary = 0x10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Android = 0x20;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Ledger = 0x30;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Native = 0xF0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofStorage_IPFS = 0x01;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint cborlen = arrlen + 0x80;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 695,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                res[ctr] = 0x5F;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        elemcborlen += 0x40;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 711,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                res[ctr] = 0xFF;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 728,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint cborlen = arrlen + 0x80;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 737,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                res[ctr] = 0x5F;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 743,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        elemcborlen += 0x40;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 753,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                res[ctr] = 0xFF;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 829,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint offset = 4+(uint(dersig[3]) - 0x20);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 833,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 873,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        tosign3[0] = 0xFE;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getCodeSize(address _addr) constant internal returns(uint _size) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < h.length; i ++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 615,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 617,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 618,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<bresult.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 697,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint x = 0; x < elemArray[i].length; x++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 739,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint x = 0; x < elemArray[i].length; x++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 690,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (byte(cborlen).length > ctr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 703,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        while (byte(elemcborlen).length > ctr - lctr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 732,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (byte(cborlen).length > ctr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        while (byte(elemcborlen).length > ctr - lctr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getCodeSize(address _addr) constant internal returns(uint _size) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < minLength; i ++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < h.length; i ++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 615,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 617,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 618,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<bresult.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < arrlen; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < arrlen; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 697,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint x = 0; x < elemArray[i].length; x++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 723,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < arrlen; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < arrlen; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 739,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint x = 0; x < elemArray[i].length; x++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 690,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (byte(cborlen).length > ctr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 703,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        while (byte(elemcborlen).length > ctr - lctr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 732,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (byte(cborlen).length > ctr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        while (byte(elemcborlen).length > ctr - lctr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 969,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (i < (32 + fromOffset + length)) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract OraclizeI {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 983,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1011,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        __callback(myid, result, new bytes(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 810,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 940,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPrice(string _datasource) public returns (uint _dsprice);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function __callback(bytes32 myid, string result) public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function __callback(bytes32 myid, string result, bytes proof) public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function __callback(bytes32 myid, string result, bytes proof) public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 285,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 326,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 392,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 429,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 436,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 459,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 475,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 492,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseAddr(string _a) internal pure returns (address){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strCompare(string _a, string _b) internal pure returns (int) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strCompare(string _a, string _b) internal pure returns (int) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 622,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 622,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 622,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 622,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 622,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 630,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 630,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 630,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 635,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseInt(string _a) internal pure returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 640,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseInt(string _a, uint _b) internal pure returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint2str(uint i) internal pure returns (string){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 675,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stra2cbor(string[] arr) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 675,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stra2cbor(string[] arr) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_setNetworkName(string _network_name) internal {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 765,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_getNetworkName() internal view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 821,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 821,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 904,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1011,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 778,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 835,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 970,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 994,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1022,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant day = 60*60*24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant week = 60*60*24*7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant month = 60*60*24*30;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_NONE = 0x00;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_TLSNotary = 0x10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Android = 0x20;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Ledger = 0x30;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Native = 0xF0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofStorage_IPFS = 0x01;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_auto = 0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_mainnet = 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_testnet = 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_morden = 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_consensys = 161;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    OraclizeAddrResolverI OAR;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    OraclizeI oraclize;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 760,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string oraclize_network_name;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 818,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32=>bytes32) oraclize_randomDS_args;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 819,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n",
                    "message": null
                }
            ]
        }
    },
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/contracts/CentralLogger.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _registryAddress\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(_registryAddress != address(0));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    registry = IRegistry(_registryAddress);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_14"
            ],
            "vulnerability_findings": [
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": 272,
                    "vulnerability_code": "  function()\n\n    public\n\n    payable\n\n  {\n\n    revert();\n",
                    "message": "Contract locking ether found in CentralLogger.sol:\n\tContract CentralLogger has payable functions:\n\t - fallback (CentralLogger.sol#267-272)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": 272,
                    "vulnerability_code": "  function()\n\n    public\n\n    payable\n\n  {\n\n    revert();\n",
                    "message": "CentralLogger.fallback (CentralLogger.sol#267-272) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.23;\n",
                    "message": "Detected issues with version pragma in CentralLogger.sol:\n\t- pragma solidity0.4.23 (CentralLogger.sol#3): it allows old versions\n\t- pragma solidity0.4.23 (CentralLogger.sol#28): it allows old versions\n\t- pragma solidity0.4.23 (CentralLogger.sol#41): it allows old versions\n\t- pragma solidity0.4.23 (CentralLogger.sol#86): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _registryAddress\n",
                    "message": "Parameter '_registryAddress' of CentralLogger. (CentralLogger.sol#96) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _amount\n",
                    "message": "Parameter '_amount' of CentralLogger.logPayoutEvent (CentralLogger.sol#192) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _claimer,\n",
                    "message": "Parameter '_claimer' of CentralLogger.logClaimEvent (CentralLogger.sol#204) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _payout\n",
                    "message": "Parameter '_payout' of CentralLogger.logClaimEvent (CentralLogger.sol#205) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _oldAddress,\n",
                    "message": "Parameter '_oldAddress' of CentralLogger.logCustodianChangedEvent (CentralLogger.sol#225) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _newAddress\n",
                    "message": "Parameter '_newAddress' of CentralLogger.logCustodianChangedEvent (CentralLogger.sol#226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _reclaimer,\n",
                    "message": "Parameter '_reclaimer' of CentralLogger.logReclaimEvent (CentralLogger.sol#239) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _amount\n",
                    "message": "Parameter '_amount' of CentralLogger.logReclaimEvent (CentralLogger.sol#240) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _upgradedFrom,\n",
                    "message": "Parameter '_upgradedFrom' of CentralLogger.logProxyUpgradedEvent (CentralLogger.sol#253) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _upgradedTo\n",
                    "message": "Parameter '_upgradedTo' of CentralLogger.logProxyUpgradedEvent (CentralLogger.sol#254) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  uint8 public constant version = 1;\n",
                    "message": "Constant 'CentralLogger.version' (CentralLogger.sol#91) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract CentralLogger {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REDUNDANT_FALLBACK_REJECT",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    public\n",
                    "message": null
                }
            ]
        }
    },
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/contracts/Migrations.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": 26,
                    "vulnerability_code": "  function setCompleted(uint completed)\n\n    restricted\n\n    public\n\n  {\n\n    lastCompletedMigration = completed;\n",
                    "message": "Migrations.setCompleted (Migrations.sol#21-26) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "  function upgrade(address newAddress)\n\n    restricted\n\n    public\n\n  {\n\n    Migrations upgraded = Migrations(newAddress);\n\n    upgraded.setCompleted(lastCompletedMigration);\n",
                    "message": "Migrations.upgrade (Migrations.sol#28-34) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.23;\n",
                    "message": "Detected issues with version pragma in Migrations.sol:\n\t- pragma solidity0.4.23 (Migrations.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/contracts/stubs/RemoteContractStub.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _testNumber\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    testNumber = _testNumber;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  address public testAddress;\n",
                    "message": "RemoteContractStub.testAddress should be constant (RemoteContractStub.sol#8)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": 27,
                    "vulnerability_code": "  function add(\n\n    uint256 _num1,\n\n    uint256 _num2\n\n  )\n\n    public\n\n    pure\n\n    returns (uint256)\n\n  {\n\n    return _num1 + _num2;\n",
                    "message": "RemoteContractStub.add (RemoteContractStub.sol#18-27) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": 37,
                    "vulnerability_code": "  function setTestNumber(\n\n    uint256 _number\n\n  )\n\n    public\n\n    returns (bool)\n\n  {\n\n    testNumber = _number;\n\n    return true;\n",
                    "message": "RemoteContractStub.setTestNumber (RemoteContractStub.sol#29-37) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.23;\n",
                    "message": "Detected issues with version pragma in RemoteContractStub.sol:\n\t- pragma solidity0.4.23 (RemoteContractStub.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _testNumber\n",
                    "message": "Parameter '_testNumber' of RemoteContractStub. (RemoteContractStub.sol#11) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _num1,\n",
                    "message": "Parameter '_num1' of RemoteContractStub.add (RemoteContractStub.sol#19) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _num2\n",
                    "message": "Parameter '_num2' of RemoteContractStub.add (RemoteContractStub.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _number\n",
                    "message": "Parameter '_number' of RemoteContractStub.setTestNumber (RemoteContractStub.sol#30) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/contracts/stubs/RemoteContractUserStub.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _registryAddress\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(_registryAddress != address(0));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    registry = IRegistry(_registryAddress);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": 83,
                    "vulnerability_code": "  function remoteAdd(uint256 _num1, uint256 _num2)\n\n    public\n\n    view\n\n    returns (uint256)\n\n  {\n\n    RemoteContractStubInterface genericRemoteContract = getRemoteContractStub();\n\n    return genericRemoteContract.add(_num1, _num2);\n",
                    "message": "RemoteContractUserStub.remoteAdd (RemoteContractUserStub.sol#76-83) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": 92,
                    "vulnerability_code": "  function remoteTestNumber()\n\n    public\n\n    view\n\n    returns (uint256)\n\n  {\n\n    RemoteContractStubInterface genericRemoteContract = getRemoteContractStub();\n\n    return genericRemoteContract.testNumber();\n",
                    "message": "RemoteContractUserStub.remoteTestNumber (RemoteContractUserStub.sol#85-92) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 101,
                    "vulnerability_code": "  function remoteSetNumber(uint256 _newNumber)\n\n    public\n\n    returns (bool)\n\n  {\n\n    RemoteContractStubInterface genericRemoteContract = getRemoteContractStub();\n\n    require(genericRemoteContract.setTestNumber(_newNumber));\n\n    return true;\n",
                    "message": "RemoteContractUserStub.remoteSetNumber (RemoteContractUserStub.sol#94-101) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.23;\n",
                    "message": "Detected issues with version pragma in RemoteContractUserStub.sol:\n\t- pragma solidity0.4.23 (RemoteContractUserStub.sol#3): it allows old versions\n\t- pragma solidity0.4.23 (RemoteContractUserStub.sol#28): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _registryAddress\n",
                    "message": "Parameter '_registryAddress' of RemoteContractUserStub. (RemoteContractUserStub.sol#58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function remoteAdd(uint256 _num1, uint256 _num2)\n",
                    "message": "Parameter '_num1' of RemoteContractUserStub.remoteAdd (RemoteContractUserStub.sol#76) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function remoteAdd(uint256 _num1, uint256 _num2)\n",
                    "message": "Parameter '_num2' of RemoteContractUserStub.remoteAdd (RemoteContractUserStub.sol#76) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function remoteSetNumber(uint256 _newNumber)\n",
                    "message": "Parameter '_newNumber' of RemoteContractUserStub.remoteSetNumber (RemoteContractUserStub.sol#94) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  IRegistry private registry;\n",
                    "message": null
                }
            ]
        }
    },
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/contracts/stubs/BrokenRemoteContractStub.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _testNumber\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    testNumber = _testNumber;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": 24,
                    "vulnerability_code": "  function add(uint256 _num1, uint256 _num2)\n\n    public\n\n    pure\n\n    returns (uint256)\n\n  {\n\n    // intentionally broken for testing\n\n    return _num1 + _num2 + 3;\n",
                    "message": "BrokenRemoteContractStub.add (BrokenRemoteContractStub.sol#17-24) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": 32,
                    "vulnerability_code": "  function setTestNumber(uint256 _number)\n\n    public\n\n    returns (uint256)\n\n  {\n\n    testNumber = _number;\n\n    return testNumber;\n",
                    "message": "BrokenRemoteContractStub.setTestNumber (BrokenRemoteContractStub.sol#26-32) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.23;\n",
                    "message": "Detected issues with version pragma in BrokenRemoteContractStub.sol:\n\t- pragma solidity0.4.23 (BrokenRemoteContractStub.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _testNumber\n",
                    "message": "Parameter '_testNumber' of BrokenRemoteContractStub. (BrokenRemoteContractStub.sol#10) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function add(uint256 _num1, uint256 _num2)\n",
                    "message": "Parameter '_num1' of BrokenRemoteContractStub.add (BrokenRemoteContractStub.sol#17) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function add(uint256 _num1, uint256 _num2)\n",
                    "message": "Parameter '_num2' of BrokenRemoteContractStub.add (BrokenRemoteContractStub.sol#17) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function setTestNumber(uint256 _number)\n",
                    "message": "Parameter '_number' of BrokenRemoteContractStub.setTestNumber (BrokenRemoteContractStub.sol#26) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/contracts/stubs/PoaManagerStub.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _registry\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    registry = _registry;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_15"
            ],
            "vulnerability_findings": [
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": 77,
                    "vulnerability_code": "  function setupPoaToken\n\n  (\n\n    address _tokenAddress,\n\n    string _name,\n\n    string _symbol,\n\n    // fiat symbol used in ExchangeRates\n\n    string _fiatCurrency,\n\n    address _broker,\n\n    address _custodian,\n\n    uint256 _totalSupply,\n\n    // given as unix time (seconds since 01.01.1970)\n\n    uint256 _startTime,\n\n    // given as seconds offset from startTime\n\n    uint256 _fundingTimeout,\n\n    // given as seconds offset from fundingTimeout\n\n    uint256 _activationTimeout,\n\n    // given as fiat cents\n\n    uint256 _fundingGoalInCents\n\n  )\n\n    public\n\n    returns (bool)\n\n  {\n\n    IPoaToken(_tokenAddress).setupContract(\n\n      _name,\n\n      _symbol,\n\n      _fiatCurrency,\n\n      _broker,\n\n      _custodian,\n\n      _totalSupply,\n\n      _startTime,\n\n      _fundingTimeout,\n\n      _activationTimeout,\n\n      _fundingGoalInCents\n\n    );\n\n\n\n    return true;\n",
                    "message": "PoaManagerStub.setupPoaToken (PoaManagerStub.sol#41-77) does not use the value returned by external calls:\n\t-IPoaToken(_tokenAddress).setupContract(_name,_symbol,_fiatCurrency,_broker,_custodian,_totalSupply,_startTime,_fundingTimeout,_activationTimeout,_fundingGoalInCents) (PoaManagerStub.sol#63-74)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": 77,
                    "vulnerability_code": "  function setupPoaToken\n\n  (\n\n    address _tokenAddress,\n\n    string _name,\n\n    string _symbol,\n\n    // fiat symbol used in ExchangeRates\n\n    string _fiatCurrency,\n\n    address _broker,\n\n    address _custodian,\n\n    uint256 _totalSupply,\n\n    // given as unix time (seconds since 01.01.1970)\n\n    uint256 _startTime,\n\n    // given as seconds offset from startTime\n\n    uint256 _fundingTimeout,\n\n    // given as seconds offset from fundingTimeout\n\n    uint256 _activationTimeout,\n\n    // given as fiat cents\n\n    uint256 _fundingGoalInCents\n\n  )\n\n    public\n\n    returns (bool)\n\n  {\n\n    IPoaToken(_tokenAddress).setupContract(\n\n      _name,\n\n      _symbol,\n\n      _fiatCurrency,\n\n      _broker,\n\n      _custodian,\n\n      _totalSupply,\n\n      _startTime,\n\n      _fundingTimeout,\n\n      _activationTimeout,\n\n      _fundingGoalInCents\n\n    );\n\n\n\n    return true;\n",
                    "message": "PoaManagerStub.setupPoaToken (PoaManagerStub.sol#41-77) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.23;\n",
                    "message": "Detected issues with version pragma in PoaManagerStub.sol:\n\t- pragma solidity0.4.23 (PoaManagerStub.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _registry\n",
                    "message": "Parameter '_registry' of PoaManagerStub. (PoaManagerStub.sol#33) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _tokenAddress,\n",
                    "message": "Parameter '_tokenAddress' of PoaManagerStub.setupPoaToken (PoaManagerStub.sol#43) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string _name,\n",
                    "message": "Parameter '_name' of PoaManagerStub.setupPoaToken (PoaManagerStub.sol#44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string _symbol,\n",
                    "message": "Parameter '_symbol' of PoaManagerStub.setupPoaToken (PoaManagerStub.sol#45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string _fiatCurrency,\n",
                    "message": "Parameter '_fiatCurrency' of PoaManagerStub.setupPoaToken (PoaManagerStub.sol#47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _broker,\n",
                    "message": "Parameter '_broker' of PoaManagerStub.setupPoaToken (PoaManagerStub.sol#48) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _custodian,\n",
                    "message": "Parameter '_custodian' of PoaManagerStub.setupPoaToken (PoaManagerStub.sol#49) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _totalSupply,\n",
                    "message": "Parameter '_totalSupply' of PoaManagerStub.setupPoaToken (PoaManagerStub.sol#50) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _startTime,\n",
                    "message": "Parameter '_startTime' of PoaManagerStub.setupPoaToken (PoaManagerStub.sol#52) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _fundingTimeout,\n",
                    "message": "Parameter '_fundingTimeout' of PoaManagerStub.setupPoaToken (PoaManagerStub.sol#54) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _activationTimeout,\n",
                    "message": "Parameter '_activationTimeout' of PoaManagerStub.setupPoaToken (PoaManagerStub.sol#56) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _fundingGoalInCents\n",
                    "message": "Parameter '_fundingGoalInCents' of PoaManagerStub.setupPoaToken (PoaManagerStub.sol#58) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string _name,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string _symbol,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string _fiatCurrency,\n",
                    "message": null
                }
            ]
        }
    },
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/contracts/tools/WarpTool.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": 15,
                    "vulnerability_code": "  function warp()\n\n    public\n\n  {\n\n    state = !state;\n",
                    "message": "WarpTool.warp (WarpTool.sol#11-15) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.18;\n",
                    "message": "Detected issues with version pragma in WarpTool.sol:\n\t- pragma solidity^0.4.18 (WarpTool.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.18;\n",
                    "message": null
                }
            ]
        }
    },
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/contracts/interfaces/IWhitelist.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.23;\n",
                    "message": "Detected issues with version pragma in IWhitelist.sol:\n\t- pragma solidity0.4.23 (IWhitelist.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/contracts/interfaces/IAccessToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.23;\n",
                    "message": "Detected issues with version pragma in IAccessToken.sol:\n\t- pragma solidity0.4.23 (IAccessToken.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/contracts/interfaces/IBrickblockToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.23;\n",
                    "message": "Detected issues with version pragma in IBrickblockToken.sol:\n\t- pragma solidity0.4.23 (IBrickblockToken.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/contracts/interfaces/IPoaToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.23;\n",
                    "message": "Detected issues with version pragma in IPoaToken.sol:\n\t- pragma solidity0.4.23 (IPoaToken.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/contracts/interfaces/IExchangeRates.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.23;\n",
                    "message": "Detected issues with version pragma in IExchangeRates.sol:\n\t- pragma solidity0.4.23 (IExchangeRates.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/contracts/interfaces/IFeeManager.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.23;\n",
                    "message": "Detected issues with version pragma in IFeeManager.sol:\n\t- pragma solidity0.4.23 (IFeeManager.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/contracts/interfaces/IRegistry.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.23;\n",
                    "message": "Detected issues with version pragma in IRegistry.sol:\n\t- pragma solidity0.4.23 (IRegistry.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/contracts/interfaces/IExchangeRateProvider.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.23;\n",
                    "message": "Detected issues with version pragma in IExchangeRateProvider.sol:\n\t- pragma solidity0.4.23 (IExchangeRateProvider.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/contracts/interfaces/IPoaManager.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.23;\n",
                    "message": "Detected issues with version pragma in IPoaManager.sol:\n\t- pragma solidity0.4.23 (IPoaManager.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "smart-contracts-f1f5b04722b9569e1d4c0b62ac4c490c0a785fd8/frozen/contracts/tools/WarpTool.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": 15,
                    "vulnerability_code": "  function warp()\n\n    public\n\n  {\n\n    state = !state;\n",
                    "message": "WarpTool.warp (WarpTool.sol#11-15) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.18;\n",
                    "message": "Detected issues with version pragma in WarpTool.sol:\n\t- pragma solidity^0.4.18 (WarpTool.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.18;\n",
                    "message": null
                }
            ]
        }
    }
}