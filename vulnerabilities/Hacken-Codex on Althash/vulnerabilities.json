{
    "Codex-Rewards-Platform-395a888b54cc9fabbaed92bf068ff93ef4f3c433/contracts/CDEX_rewards.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            totalMembers += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 public periodFinish = 0;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 public rewardRate = 0;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 public rewardsDuration = 0;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(depositedRewardTokens == 0 && committedRewardTokens == 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 473,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(depositedRewardTokens == 0 && committedRewardTokens == 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 556,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_loyaltyTier1 > _loyaltyTier2 && _loyaltyTier2 > _loyaltyTier3);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 577,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_loyaltyTier1Bonus > _loyaltyTier2Bonus && _loyaltyTier2Bonus > _loyaltyTier3Bonus);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (reward > 0 && committedRewardTokens >= reward) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 loyaltyBonus = loyaltyBonuses[msg.sender];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            /// The withdraw is always for the full accrued reward amount\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            rewards[msg.sender] = 0;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            loyaltyBonuses[msg.sender] = 0;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 436,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            /// Decrements the committed reward tokens balance\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 437,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            committedRewardTokens = committedRewardTokens.sub(reward);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 438,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            /// Decrements the deposited loyalty bonus balance\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            /// Transfers the total accrued rewards plus the calculated bonus amount\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_32"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": 230,
                    "vulnerability_code": "interface CDEXTokenContract {\n\n\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external;\n\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n\n",
                    "message": "CDEXTokenContract (CDEX_rewards.sol#224-230) has incorrect ERC20 function interface(s):\n\t-transfer (CDEX_rewards.sol#227)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": 455,
                    "vulnerability_code": "    function exit() external {\n\n        withdraw(_balances[msg.sender]);\n\n        getReward();\n",
                    "message": "Reentrancy in CDEXStakingPool.exit (CDEX_rewards.sol#452-455):\n\tExternal calls:\n\t- withdraw(_balances[msg.sender]) (CDEX_rewards.sol#453)\n\t- getReward() (CDEX_rewards.sol#454)\n\tState variables written after the call(s):\n\t- _status (CDEX_rewards.sol#454)\n\t- committedRewardTokens (CDEX_rewards.sol#454)\n\t- depositedRewardTokens (CDEX_rewards.sol#454)\n\t- lastUpdateTime (CDEX_rewards.sol#454)\n\t- loyaltyBonuses (CDEX_rewards.sol#454)\n\t- rewardPerTokenStored (CDEX_rewards.sol#454)\n\t- rewards (CDEX_rewards.sol#454)\n\t- userRewardPerTokenPaid (CDEX_rewards.sol#454)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": 394,
                    "vulnerability_code": "    function stake(uint256 amount)\n\n        external\n\n        nonReentrant\n\n        notPaused\n\n        updateReward(msg.sender)\n\n    {\n\n        require(amount > 0);\n\n        /// Increments the total staked balance\n\n        _totalSupply = _totalSupply.add(amount);\n\n        \n\n        if(_balances[msg.sender] == 0) {\n\n            /// Increments the totalMembers if the sending address didn't have any previous balance\n\n            totalMembers += 1;\n\n            /// Adds the user address to the ranking tree\n\n            CDEXRanking.insert(amount, msg.sender);\n\n        } else {\n\n            /// Removes the user address from its current ranking node in the tree\n\n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n\n            /// Adds it again with the new value\n\n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n\n        }\n\n        /// Increments the sender's staked balance\n\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n\n        /// Transfer the tokens from the sender's balance into the contract\n\n        /// The amount needs to be previously approved in the token contract\n\n        bool success = CDEXToken.transferFrom(msg.sender, address(this), amount);\n\n        require(success);\n\n        /// Emits the event\n\n        emit Staked(msg.sender, amount);\n",
                    "message": "Reentrancy in CDEXStakingPool.stake (CDEX_rewards.sol#365-394):\n\tExternal calls:\n\t- CDEXRanking.insert(amount,msg.sender) (CDEX_rewards.sol#379)\n\t- CDEXRanking.remove(_balances[msg.sender],msg.sender) (CDEX_rewards.sol#382)\n\t- CDEXRanking.insert(_balances[msg.sender].add(amount),msg.sender) (CDEX_rewards.sol#384)\n\tState variables written after the call(s):\n\t- _balances (CDEX_rewards.sol#387)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": 421,
                    "vulnerability_code": "    function withdraw(uint256 amount)\n\n        public\n\n        nonReentrant\n\n        updateReward(msg.sender)\n\n    {\n\n        require(amount > 0);\n\n        /// Decrements the total staked balance\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        /// Removes the user address from its current ranking node in the tree\n\n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n\n        /// Decrements the sender's staked balance\n\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        /// If the balance is zero after decremented, decrements the totalMembers\n\n        if(_balances[msg.sender] == 0) {\n\n            totalMembers -= 1;\n\n        } else {\n\n            /// If not, adds the user address back into the ranking tree with the new balance\n\n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n\n        }\n\n        /// Transfers the tokens into the sender's address\n\n        CDEXToken.transfer(msg.sender, amount);\n\n        /// Emits the event\n\n        emit Withdrawn(msg.sender, amount);\n",
                    "message": "Reentrancy in CDEXStakingPool.withdraw (CDEX_rewards.sol#398-421):\n\tExternal calls:\n\t- CDEXRanking.remove(_balances[msg.sender],msg.sender) (CDEX_rewards.sol#407)\n\tState variables written after the call(s):\n\t- _balances (CDEX_rewards.sol#409)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": 421,
                    "vulnerability_code": "    function withdraw(uint256 amount)\n\n        public\n\n        nonReentrant\n\n        updateReward(msg.sender)\n\n    {\n\n        require(amount > 0);\n\n        /// Decrements the total staked balance\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        /// Removes the user address from its current ranking node in the tree\n\n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n\n        /// Decrements the sender's staked balance\n\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        /// If the balance is zero after decremented, decrements the totalMembers\n\n        if(_balances[msg.sender] == 0) {\n\n            totalMembers -= 1;\n\n        } else {\n\n            /// If not, adds the user address back into the ranking tree with the new balance\n\n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n\n        }\n\n        /// Transfers the tokens into the sender's address\n\n        CDEXToken.transfer(msg.sender, amount);\n\n        /// Emits the event\n\n        emit Withdrawn(msg.sender, amount);\n",
                    "message": "Reentrancy in CDEXStakingPool.withdraw (CDEX_rewards.sol#398-421):\n\tExternal calls:\n\t- CDEXRanking.remove(_balances[msg.sender],msg.sender) (CDEX_rewards.sol#407)\n\tState variables written after the call(s):\n\t- totalMembers (CDEX_rewards.sol#412)\n"
                },
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 343,
                    "vulnerability_to_line": 345,
                    "vulnerability_code": "    function min(uint256 a, uint256 b) public pure returns (uint256) {\n\n        return a < b ? a : b;\n",
                    "message": "CDEXStakingPool.min (CDEX_rewards.sol#343-345) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- a < b (CDEX_rewards.sol#344)\n"
                },
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": 532,
                    "vulnerability_code": "    function notifyRewardAmount(uint256 reward)\n\n        public\n\n        onlyOwner\n\n        updateReward(address(0))\n\n    {\n\n        /// Adding the decimal places to the reward\n\n        reward = reward.mul(1e8);\n\n        /// The notified reward must be less then or equal to the total deposited rewards.\n\n        require(reward <= depositedRewardTokens);\n\n        /// If not during staking period, calculates the new reward rate per second.\n\n        /// Else, adds the new reward to current non-distributed rewards.\n\n        if (block.timestamp >= periodFinish) {\n\n            rewardRate = reward.div(rewardsDuration);\n\n        } else {\n\n            uint256 remaining = periodFinish.sub(block.timestamp);\n\n            uint256 leftover = remaining.mul(rewardRate);\n\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n\n        }\n\n        /// Ensure the provided reward amount is not more than the balance in the contract.\n\n        /// This keeps the reward rate in the right range, preventing overflows due to\n\n        /// very high values of rewardRate in the earned and rewardsPerToken functions;\n\n        /// Reward + leftover must be less than 2^256 / 10^8 to avoid overflow.\n\n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n\n        /// Updates the last updated time\n\n        lastUpdateTime = block.timestamp;\n\n        /// Resets the staking period\n\n        periodFinish = block.timestamp.add(rewardsDuration);\n\n        /// Emits the event\n\n        emit RewardAdded(reward);\n",
                    "message": "CDEXStakingPool.notifyRewardAmount (CDEX_rewards.sol#503-532) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- block.timestamp >= periodFinish (CDEX_rewards.sol#514-520)\n\t- require(bool)(rewardRate <= depositedRewardTokens.div(rewardsDuration)) (CDEX_rewards.sol#525)\n"
                },
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 537,
                    "vulnerability_to_line": 544,
                    "vulnerability_code": "    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n\n        /// Checks if the previously defined period has already finished\n\n        require(block.timestamp > periodFinish);\n\n        /// Updates the duration\n\n        rewardsDuration = _rewardsDuration;\n\n        /// Emits the event\n\n        emit RewardsDurationUpdated(rewardsDuration);\n",
                    "message": "CDEXStakingPool.setRewardsDuration (CDEX_rewards.sol#537-544) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool)(block.timestamp > periodFinish) (CDEX_rewards.sol#539)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": 497,
                    "vulnerability_code": "    function depositTokens(uint256 amount) public onlyOwner {\n\n        /// Adding the decimal places to the amount\n\n        amount = amount.mul(1e8);\n\n        /// Calculating the total loyalty bonus percentage from the highest bonus tier\n\n        uint256 loyaltyBonusFromAmount = amount.mul(loyaltyTier1Bonus).div(10000);\n\n        /// Incrementing the total deposited loyalty bonus\n\n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(loyaltyBonusFromAmount);\n\n        /// Increasing the total deposited tokens with the amount minus bonus\n\n        depositedRewardTokens = depositedRewardTokens.add(amount.sub(loyaltyBonusFromAmount));\n\n        /// Transferring the whole amount to the contract\n\n        bool success = CDEXToken.transferFrom(owner, address(this), amount);\n\n        require(success);\n\n        /// Emits the event\n\n        emit RewardsDeposited(owner, address(this), amount);\n",
                    "message": "CDEXStakingPool.depositTokens (CDEX_rewards.sol#483-497) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": 532,
                    "vulnerability_code": "    function notifyRewardAmount(uint256 reward)\n\n        public\n\n        onlyOwner\n\n        updateReward(address(0))\n\n    {\n\n        /// Adding the decimal places to the reward\n\n        reward = reward.mul(1e8);\n\n        /// The notified reward must be less then or equal to the total deposited rewards.\n\n        require(reward <= depositedRewardTokens);\n\n        /// If not during staking period, calculates the new reward rate per second.\n\n        /// Else, adds the new reward to current non-distributed rewards.\n\n        if (block.timestamp >= periodFinish) {\n\n            rewardRate = reward.div(rewardsDuration);\n\n        } else {\n\n            uint256 remaining = periodFinish.sub(block.timestamp);\n\n            uint256 leftover = remaining.mul(rewardRate);\n\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n\n        }\n\n        /// Ensure the provided reward amount is not more than the balance in the contract.\n\n        /// This keeps the reward rate in the right range, preventing overflows due to\n\n        /// very high values of rewardRate in the earned and rewardsPerToken functions;\n\n        /// Reward + leftover must be less than 2^256 / 10^8 to avoid overflow.\n\n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n\n        /// Updates the last updated time\n\n        lastUpdateTime = block.timestamp;\n\n        /// Resets the staking period\n\n        periodFinish = block.timestamp.add(rewardsDuration);\n\n        /// Emits the event\n\n        emit RewardAdded(reward);\n",
                    "message": "CDEXStakingPool.notifyRewardAmount (CDEX_rewards.sol#503-532) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 4,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.21;\n",
                    "message": "Detected issues with version pragma in CDEX_rewards.sol:\n\t- pragma solidity0.4.21 (CDEX_rewards.sol#4): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": 31,
                    "vulnerability_code": "    function ReentrancyGuard() internal {\n\n        _status = _NOT_ENTERED;\n",
                    "message": "Function 'ReentrancyGuard.ReentrancyGuard' (CDEX_rewards.sol#29-31) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": 62,
                    "vulnerability_code": "    function Owned(address _owner) public {\n\n        require(_owner != address(0));\n\n        owner = _owner;\n\n        emit OwnerChanged(address(0), _owner);\n",
                    "message": "Function 'Owned.Owned' (CDEX_rewards.sol#58-62) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function Owned(address _owner) public {\n",
                    "message": "Parameter '_owner' of Owned.Owned (CDEX_rewards.sol#58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function nominateNewOwner(address _owner) external onlyOwner {\n",
                    "message": "Parameter '_owner' of Owned.nominateNewOwner (CDEX_rewards.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": 83,
                    "vulnerability_code": "    function _onlyOwner() private view {\n\n        require(msg.sender == owner);\n",
                    "message": "Function 'Owned._onlyOwner' (CDEX_rewards.sol#81-83) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": 97,
                    "vulnerability_code": "    function Pausable() internal {\n\n        /// This contract is abstract, and thus cannot be instantiated directly\n\n        require(owner != address(0));\n\n        /// Paused will be false, and lastPauseTime will be 0 upon initialisation\n",
                    "message": "Function 'Pausable.Pausable' (CDEX_rewards.sol#93-97) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setPaused(bool _paused) external onlyOwner {\n",
                    "message": "Parameter '_paused' of Pausable.setPaused (CDEX_rewards.sol#103) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": 286,
                    "vulnerability_code": "    function CDEXStakingPool(\n\n        address _owner,\n\n        address _CDEXTokenContractAddress,\n\n        address _rankingContractAddress\n\n    ) public Owned(_owner) {\n\n        CDEXToken = CDEXTokenContract(_CDEXTokenContractAddress);\n\n        CDEXRanking = CDEXRankingContract(_rankingContractAddress);\n",
                    "message": "Function 'CDEXStakingPool.CDEXStakingPool' (CDEX_rewards.sol#279-286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _CDEXTokenContractAddress,\n",
                    "message": "Parameter '_CDEXTokenContractAddress' of CDEXStakingPool.CDEXStakingPool (CDEX_rewards.sol#281) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _rankingContractAddress\n",
                    "message": "Parameter '_rankingContractAddress' of CDEXStakingPool.CDEXStakingPool (CDEX_rewards.sol#282) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setTokenContract(address _contractAddress) external onlyOwner {\n",
                    "message": "Parameter '_contractAddress' of CDEXStakingPool.setTokenContract (CDEX_rewards.sol#462) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRankingContract(address _contractAddress) external onlyOwner {\n",
                    "message": "Parameter '_contractAddress' of CDEXStakingPool.setRankingContract (CDEX_rewards.sol#471) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 537,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n",
                    "message": "Parameter '_rewardsDuration' of CDEXStakingPool.setRewardsDuration (CDEX_rewards.sol#537) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _loyaltyTier1, \n",
                    "message": "Parameter '_loyaltyTier1' of CDEXStakingPool.setLoyaltyTiers (CDEX_rewards.sol#551) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _loyaltyTier2, \n",
                    "message": "Parameter '_loyaltyTier2' of CDEXStakingPool.setLoyaltyTiers (CDEX_rewards.sol#552) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _loyaltyTier3\n",
                    "message": "Parameter '_loyaltyTier3' of CDEXStakingPool.setLoyaltyTiers (CDEX_rewards.sol#553) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _loyaltyTier1Bonus, \n",
                    "message": "Parameter '_loyaltyTier1Bonus' of CDEXStakingPool.setLoyaltyTiersBonus (CDEX_rewards.sol#572) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 573,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _loyaltyTier2Bonus, \n",
                    "message": "Parameter '_loyaltyTier2Bonus' of CDEXStakingPool.setLoyaltyTiersBonus (CDEX_rewards.sol#573) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _loyaltyTier3Bonus\n",
                    "message": "Parameter '_loyaltyTier3Bonus' of CDEXStakingPool.setLoyaltyTiersBonus (CDEX_rewards.sol#574) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    CDEXTokenContract public CDEXToken;\n",
                    "message": "Variable 'CDEXStakingPool.CDEXToken' (CDEX_rewards.sol#244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    CDEXRankingContract public CDEXRanking;\n",
                    "message": "Variable 'CDEXStakingPool.CDEXRanking' (CDEX_rewards.sol#245) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        nominatedOwner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        updateReward(address(0))\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setPaused(bool _paused) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setTokenContract(address _contractAddress) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRankingContract(address _contractAddress) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 537,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setLoyaltyTiers(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setLoyaltyTiersBonus(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private constant _NOT_ENTERED = 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private constant _ENTERED = 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _status;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _totalSupply;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) private _balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                }
            ]
        }
    },
    "Codex-Rewards-Platform-395a888b54cc9fabbaed92bf068ff93ef4f3c433/contracts/CDEX_ranking.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (j < values[aux].length && i < _positions) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (j < values[aux].length && i < _positions) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                _addresses[i] = values[aux][j];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (!self.nodes[self.nodes[cursor].left].red && !self.nodes[self.nodes[cursor].right].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    key = keyParent;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    if (!self.nodes[self.nodes[cursor].right].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[self.nodes[cursor].left].red = false;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        rotateRight(self, cursor);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        cursor = self.nodes[keyParent].right;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (!self.nodes[self.nodes[cursor].right].red && !self.nodes[self.nodes[cursor].left].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    key = keyParent;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    if (!self.nodes[self.nodes[cursor].left].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[self.nodes[cursor].right].red = false;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        rotateLeft(self, cursor);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        cursor = self.nodes[keyParent].left;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (tree.exists(_key) && values[_key].length - 1 >= _pos) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            value = values[_key][_pos];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        values[_key].length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                i++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                j++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_23"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint i;\n",
                    "message": "i in CDEXRanking.ranking (CDEX_ranking.sol#423) is a local variable never initialiazed\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": 351,
                    "vulnerability_code": "    function getValuesLength(uint _value) public view returns (uint length) {\n\n        length = values[_value].length;\n",
                    "message": "CDEXRanking.getValuesLength (CDEX_ranking.sol#349-351) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": 355,
                    "vulnerability_code": "    function root() public view returns (uint _key) {\n\n        _key = tree.root;\n",
                    "message": "CDEXRanking.root (CDEX_ranking.sol#353-355) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 357,
                    "vulnerability_to_line": 359,
                    "vulnerability_code": "    function first() public view returns (uint _key) {\n\n        _key = tree.first();\n",
                    "message": "CDEXRanking.first (CDEX_ranking.sol#357-359) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": 367,
                    "vulnerability_code": "    function next(uint key) public view returns (uint _key) {\n\n        _key = tree.next(key);\n",
                    "message": "CDEXRanking.next (CDEX_ranking.sol#365-367) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 373,
                    "vulnerability_to_line": 375,
                    "vulnerability_code": "    function exists(uint key) public view returns (bool _exists) {\n\n        _exists = tree.exists(key);\n",
                    "message": "CDEXRanking.exists (CDEX_ranking.sol#373-375) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 381,
                    "vulnerability_code": "    function getNode(uint _key) public view returns (uint key, uint parent, uint left, uint right, bool red) {\n\n        if (tree.exists(_key)) {\n\n            (key, parent, left, right, red) = tree.getNode(_key);\n\n        }\n",
                    "message": "CDEXRanking.getNode (CDEX_ranking.sol#377-381) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": 387,
                    "vulnerability_code": "    function getValue(uint _key, uint _pos) public view returns (address value) {\n\n        if (tree.exists(_key) && values[_key].length - 1 >= _pos) {\n\n            value = values[_key][_pos];\n\n        }\n",
                    "message": "CDEXRanking.getValue (CDEX_ranking.sol#383-387) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": 397,
                    "vulnerability_code": "    function insert(uint _key, address _value) public {\n\n        require(msg.sender == codexStakingContract || msg.sender == owner);\n\n        if (!tree.exists(_key)) {\n\n            tree.insert(_key);\n\n        }\n\n        values[_key].push(_value);\n\n        addressPosition[_value] = values[_key].length - 1;\n\n        emit Log(\"insert\", _key, _value);\n",
                    "message": "CDEXRanking.insert (CDEX_ranking.sol#389-397) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": 417,
                    "vulnerability_code": "    function remove(uint _key, address _value) public {\n\n        require(msg.sender == codexStakingContract || msg.sender == owner);\n\n        require(values[_key][addressPosition[_value]] == _value);\n\n        if (values[_key].length == 1) {\n\n            tree.remove(_key);\n\n        } else {\n\n            if (addressPosition[_value] != values[_key].length - 1) {\n\n                address movingValue = values[_key][values[_key].length - 1];\n\n                // Copying the last address in the array to the position of the address to be removed\n\n                values[_key][addressPosition[_value]] = movingValue;\n\n                // Updating the position reference for the moved value\n\n                addressPosition[movingValue] = addressPosition[_value];\n\n            }\n\n        }\n\n        emit Log(\"remove\", _key, values[_key][addressPosition[_value]]);\n\n        // Deleting the last position of the array\n\n        values[_key].length--;\n\n        addressPosition[_value] = 0;\n",
                    "message": "CDEXRanking.remove (CDEX_ranking.sol#399-417) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": 436,
                    "vulnerability_code": "    function ranking(uint _positions) public view returns (address[] memory, uint256[] memory) {\n\n        address[] memory _addresses = new address[](_positions);\n\n        uint256[] memory _balances = new uint256[](_positions);\n\n        uint aux = last();\n\n        uint i;\n\n        uint j;\n\n        while (i < _positions) {\n\n            j = 0;\n\n            while (j < values[aux].length && i < _positions) {\n\n                _addresses[i] = values[aux][j];\n\n                _balances[i] = aux;\n\n                i++;\n\n                j++;\n\n            }\n\n            aux = prev(aux);\n\n        }\n\n        return (_addresses, _balances);\n",
                    "message": "CDEXRanking.ranking (CDEX_ranking.sol#419-436) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.21;\n",
                    "message": "Detected issues with version pragma in CDEX_ranking.sol:\n\t- pragma solidity0.4.21 (CDEX_ranking.sol#3): it allows old versions\n\t- pragma solidity0.4.21 (CDEX_ranking.sol#326): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": 342,
                    "vulnerability_code": "    function CDEXRanking() public {\n\n        owner = msg.sender;\n",
                    "message": "Function 'CDEXRanking.CDEXRanking' (CDEX_ranking.sol#340-342) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCodexContractAddress(address _contractAddress) external {\n",
                    "message": "Parameter '_contractAddress' of CDEXRanking.setCodexContractAddress (CDEX_ranking.sol#344) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValuesLength(uint _value) public view returns (uint length) {\n",
                    "message": "Parameter '_value' of CDEXRanking.getValuesLength (CDEX_ranking.sol#349) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNode(uint _key) public view returns (uint key, uint parent, uint left, uint right, bool red) {\n",
                    "message": "Parameter '_key' of CDEXRanking.getNode (CDEX_ranking.sol#377) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValue(uint _key, uint _pos) public view returns (address value) {\n",
                    "message": "Parameter '_key' of CDEXRanking.getValue (CDEX_ranking.sol#383) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValue(uint _key, uint _pos) public view returns (address value) {\n",
                    "message": "Parameter '_pos' of CDEXRanking.getValue (CDEX_ranking.sol#383) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function insert(uint _key, address _value) public {\n",
                    "message": "Parameter '_key' of CDEXRanking.insert (CDEX_ranking.sol#389) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function insert(uint _key, address _value) public {\n",
                    "message": "Parameter '_value' of CDEXRanking.insert (CDEX_ranking.sol#389) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function remove(uint _key, address _value) public {\n",
                    "message": "Parameter '_key' of CDEXRanking.remove (CDEX_ranking.sol#399) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function remove(uint _key, address _value) public {\n",
                    "message": "Parameter '_value' of CDEXRanking.remove (CDEX_ranking.sol#399) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ranking(uint _positions) public view returns (address[] memory, uint256[] memory) {\n",
                    "message": "Parameter '_positions' of CDEXRanking.ranking (CDEX_ranking.sol#419) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        values[_key].length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (j < values[aux].length && i < _positions) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (self.nodes[_key].left != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (self.nodes[_key].right != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (cursor != EMPTY && target == self.nodes[cursor].right) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (cursor != EMPTY && target == self.nodes[cursor].left) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (probe != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (self.nodes[cursor].left != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (self.nodes[key].left != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (self.nodes[key].right != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (key != self.root && self.nodes[self.nodes[key].parent].red) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (key != self.root && !self.nodes[key].red) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (i < _positions) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (j < values[aux].length && i < _positions) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCodexContractAddress(address _contractAddress) external {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private constant EMPTY = 0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNode(Tree storage self, uint key) internal view returns (uint _returnKey, uint _parent, uint _left, uint _right, bool _red) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    BokkyPooBahsRedBlackTreeLibrary.Tree tree;\n",
                    "message": null
                }
            ]
        }
    },
    "Codex-Rewards-Platform-395a888b54cc9fabbaed92bf068ff93ef4f3c433/contracts/BokkyPooBahsRedBlackTreeLibrary.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (!self.nodes[self.nodes[cursor].left].red && !self.nodes[self.nodes[cursor].right].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    key = keyParent;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    if (!self.nodes[self.nodes[cursor].right].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[self.nodes[cursor].left].red = false;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        rotateRight(self, cursor);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        cursor = self.nodes[keyParent].right;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (!self.nodes[self.nodes[cursor].right].red && !self.nodes[self.nodes[cursor].left].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    key = keyParent;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    if (!self.nodes[self.nodes[cursor].left].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[self.nodes[cursor].right].red = false;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        rotateLeft(self, cursor);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        cursor = self.nodes[keyParent].left;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.21;\n",
                    "message": "Detected issues with version pragma in BokkyPooBahsRedBlackTreeLibrary.sol:\n\t- pragma solidity0.4.21 (BokkyPooBahsRedBlackTreeLibrary.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (self.nodes[_key].left != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (self.nodes[_key].right != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (cursor != EMPTY && target == self.nodes[cursor].right) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (cursor != EMPTY && target == self.nodes[cursor].left) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (probe != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (self.nodes[cursor].left != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (self.nodes[key].left != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (self.nodes[key].right != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (key != self.root && self.nodes[self.nodes[key].parent].red) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (key != self.root && !self.nodes[key].red) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private constant EMPTY = 0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNode(Tree storage self, uint key) internal view returns (uint _returnKey, uint _parent, uint _left, uint _right, bool _red) {\n",
                    "message": null
                }
            ]
        }
    },
    "Codex-Rewards-Platform-6ec987cf357d337a042e3d4c209f37466f5db220/contracts/CDEX_rewards.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            totalMembers += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 public periodFinish = 0;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 public rewardRate = 0;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 public rewardsDuration = 0;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_loyaltyTier1 > _loyaltyTier2 && _loyaltyTier2 > _loyaltyTier3);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_loyaltyTier1Bonus > _loyaltyTier2Bonus && _loyaltyTier2Bonus > _loyaltyTier3Bonus);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (reward > 0 && depositedRewardTokens >= reward) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 loyaltyBonus = loyaltyBonuses[msg.sender];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            /// The withdraw is always for the full accrued reward amount\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            rewards[msg.sender] = 0;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            loyaltyBonuses[msg.sender] = 0;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            /// Decrements the deposited reward tokens balance\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 436,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            depositedRewardTokens = depositedRewardTokens.sub(reward);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 437,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            /// Decrements the deposited loyalty bonus balance\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 438,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            /// Transfers the total accrued rewards plus the calculated bonus amount\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_32"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": 230,
                    "vulnerability_code": "interface CDEXTokenContract {\n\n\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external;\n\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n\n",
                    "message": "CDEXTokenContract (CDEX_rewards.sol#224-230) has incorrect ERC20 function interface(s):\n\t-transfer (CDEX_rewards.sol#227)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 451,
                    "vulnerability_to_line": 454,
                    "vulnerability_code": "    function exit() external {\n\n        withdraw(_balances[msg.sender]);\n\n        getReward();\n",
                    "message": "Reentrancy in CDEXStakingPool.exit (CDEX_rewards.sol#451-454):\n\tExternal calls:\n\t- withdraw(_balances[msg.sender]) (CDEX_rewards.sol#452)\n\t- getReward() (CDEX_rewards.sol#453)\n\tState variables written after the call(s):\n\t- _status (CDEX_rewards.sol#453)\n\t- lastUpdateTime (CDEX_rewards.sol#453)\n\t- loyaltyBonuses (CDEX_rewards.sol#453)\n\t- rewardPerTokenStored (CDEX_rewards.sol#453)\n\t- rewards (CDEX_rewards.sol#453)\n\t- userRewardPerTokenPaid (CDEX_rewards.sol#453)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": 393,
                    "vulnerability_code": "    function stake(uint256 amount)\n\n        external\n\n        nonReentrant\n\n        notPaused\n\n        updateReward(msg.sender)\n\n    {\n\n        require(amount > 0);\n\n        /// Increments the total staked balance\n\n        _totalSupply = _totalSupply.add(amount);\n\n        \n\n        if(_balances[msg.sender] == 0) {\n\n            /// Increments the totalMembers if the sending address didn't have any previous balance\n\n            totalMembers += 1;\n\n            /// Adds the user address to the ranking tree\n\n            CDEXRanking.insert(amount, msg.sender);\n\n        } else {\n\n            /// Removes the user address from its current ranking node in the tree\n\n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n\n            /// Adds it again with the new value\n\n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n\n        }\n\n        /// Increments the sender's staked balance\n\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n\n        /// Transfer the tokens from the sender's balance into the contract\n\n        /// The amount needs to be previously approved in the token contract\n\n        bool success = CDEXToken.transferFrom(msg.sender, address(this), amount);\n\n        require(success);\n\n        /// Emits the event\n\n        emit Staked(msg.sender, amount);\n",
                    "message": "Reentrancy in CDEXStakingPool.stake (CDEX_rewards.sol#364-393):\n\tExternal calls:\n\t- CDEXRanking.insert(amount,msg.sender) (CDEX_rewards.sol#378)\n\t- CDEXRanking.remove(_balances[msg.sender],msg.sender) (CDEX_rewards.sol#381)\n\t- CDEXRanking.insert(_balances[msg.sender].add(amount),msg.sender) (CDEX_rewards.sol#383)\n\tState variables written after the call(s):\n\t- _balances (CDEX_rewards.sol#386)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": 420,
                    "vulnerability_code": "    function withdraw(uint256 amount)\n\n        public\n\n        nonReentrant\n\n        updateReward(msg.sender)\n\n    {\n\n        require(amount > 0);\n\n        /// Decrements the total staked balance\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        /// Removes the user address from its current ranking node in the tree\n\n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n\n        /// Decrements the sender's staked balance\n\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        /// If the balance is zero after decremented, decrements the totalMembers\n\n        if(_balances[msg.sender] == 0) {\n\n            totalMembers -= 1;\n\n        } else {\n\n            /// If not, adds the user address back into the ranking tree with the new balance\n\n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n\n        }\n\n        /// Transfers the tokens into the sender's address\n\n        CDEXToken.transfer(msg.sender, amount);\n\n        /// Emits the event\n\n        emit Withdrawn(msg.sender, amount);\n",
                    "message": "Reentrancy in CDEXStakingPool.withdraw (CDEX_rewards.sol#397-420):\n\tExternal calls:\n\t- CDEXRanking.remove(_balances[msg.sender],msg.sender) (CDEX_rewards.sol#406)\n\tState variables written after the call(s):\n\t- _balances (CDEX_rewards.sol#408)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": 420,
                    "vulnerability_code": "    function withdraw(uint256 amount)\n\n        public\n\n        nonReentrant\n\n        updateReward(msg.sender)\n\n    {\n\n        require(amount > 0);\n\n        /// Decrements the total staked balance\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        /// Removes the user address from its current ranking node in the tree\n\n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n\n        /// Decrements the sender's staked balance\n\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        /// If the balance is zero after decremented, decrements the totalMembers\n\n        if(_balances[msg.sender] == 0) {\n\n            totalMembers -= 1;\n\n        } else {\n\n            /// If not, adds the user address back into the ranking tree with the new balance\n\n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n\n        }\n\n        /// Transfers the tokens into the sender's address\n\n        CDEXToken.transfer(msg.sender, amount);\n\n        /// Emits the event\n\n        emit Withdrawn(msg.sender, amount);\n",
                    "message": "Reentrancy in CDEXStakingPool.withdraw (CDEX_rewards.sol#397-420):\n\tExternal calls:\n\t- CDEXRanking.remove(_balances[msg.sender],msg.sender) (CDEX_rewards.sol#406)\n\tState variables written after the call(s):\n\t- totalMembers (CDEX_rewards.sol#411)\n"
                },
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": 344,
                    "vulnerability_code": "    function min(uint256 a, uint256 b) public pure returns (uint256) {\n\n        return a < b ? a : b;\n",
                    "message": "CDEXStakingPool.min (CDEX_rewards.sol#342-344) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- a < b (CDEX_rewards.sol#343)\n"
                },
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": 531,
                    "vulnerability_code": "    function notifyRewardAmount(uint256 reward)\n\n        public\n\n        onlyOwner\n\n        updateReward(address(0))\n\n    {\n\n        /// Adding the decimal places to the reward\n\n        reward = reward.mul(1e8);\n\n        /// The notified reward must be less then or equal to the total deposited rewards.\n\n        require(reward <= depositedRewardTokens);\n\n        /// If not during staking period, calculates the new reward rate per second.\n\n        /// Else, adds the new reward to current non-distributed rewards.\n\n        if (block.timestamp >= periodFinish) {\n\n            rewardRate = reward.div(rewardsDuration);\n\n        } else {\n\n            uint256 remaining = periodFinish.sub(block.timestamp);\n\n            uint256 leftover = remaining.mul(rewardRate);\n\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n\n        }\n\n        /// Ensure the provided reward amount is not more than the balance in the contract.\n\n        /// This keeps the reward rate in the right range, preventing overflows due to\n\n        /// very high values of rewardRate in the earned and rewardsPerToken functions;\n\n        /// Reward + leftover must be less than 2^256 / 10^8 to avoid overflow.\n\n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n\n        /// Updates the last updated time\n\n        lastUpdateTime = block.timestamp;\n\n        /// Resets the staking period\n\n        periodFinish = block.timestamp.add(rewardsDuration);\n\n        /// Emits the event\n\n        emit RewardAdded(reward);\n",
                    "message": "CDEXStakingPool.notifyRewardAmount (CDEX_rewards.sol#502-531) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- block.timestamp >= periodFinish (CDEX_rewards.sol#513-519)\n\t- require(bool)(rewardRate <= depositedRewardTokens.div(rewardsDuration)) (CDEX_rewards.sol#524)\n"
                },
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": 543,
                    "vulnerability_code": "    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n\n        /// Checks if the previously defined period has already finished\n\n        require(block.timestamp > periodFinish);\n\n        /// Updates the duration\n\n        rewardsDuration = _rewardsDuration;\n\n        /// Emits the event\n\n        emit RewardsDurationUpdated(rewardsDuration);\n",
                    "message": "CDEXStakingPool.setRewardsDuration (CDEX_rewards.sol#536-543) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool)(block.timestamp > periodFinish) (CDEX_rewards.sol#538)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 482,
                    "vulnerability_to_line": 496,
                    "vulnerability_code": "    function depositTokens(uint256 amount) public onlyOwner {\n\n        /// Adding the decimal places to the amount\n\n        amount = amount.mul(1e8);\n\n        /// Calculating the total loyalty bonus percentage from the highest bonus tier\n\n        uint256 loyaltyBonusFromAmount = amount.mul(loyaltyTier1Bonus).div(10000);\n\n        /// Incrementing the total deposited loyalty bonus\n\n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(loyaltyBonusFromAmount);\n\n        /// Increasing the total deposited tokens with the amount minus bonus\n\n        depositedRewardTokens = depositedRewardTokens.add(amount.sub(loyaltyBonusFromAmount));\n\n        /// Transferring the whole amount to the contract\n\n        bool success = CDEXToken.transferFrom(owner, address(this), amount);\n\n        require(success);\n\n        /// Emits the event\n\n        emit RewardsDeposited(owner, address(this), amount);\n",
                    "message": "CDEXStakingPool.depositTokens (CDEX_rewards.sol#482-496) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": 531,
                    "vulnerability_code": "    function notifyRewardAmount(uint256 reward)\n\n        public\n\n        onlyOwner\n\n        updateReward(address(0))\n\n    {\n\n        /// Adding the decimal places to the reward\n\n        reward = reward.mul(1e8);\n\n        /// The notified reward must be less then or equal to the total deposited rewards.\n\n        require(reward <= depositedRewardTokens);\n\n        /// If not during staking period, calculates the new reward rate per second.\n\n        /// Else, adds the new reward to current non-distributed rewards.\n\n        if (block.timestamp >= periodFinish) {\n\n            rewardRate = reward.div(rewardsDuration);\n\n        } else {\n\n            uint256 remaining = periodFinish.sub(block.timestamp);\n\n            uint256 leftover = remaining.mul(rewardRate);\n\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n\n        }\n\n        /// Ensure the provided reward amount is not more than the balance in the contract.\n\n        /// This keeps the reward rate in the right range, preventing overflows due to\n\n        /// very high values of rewardRate in the earned and rewardsPerToken functions;\n\n        /// Reward + leftover must be less than 2^256 / 10^8 to avoid overflow.\n\n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n\n        /// Updates the last updated time\n\n        lastUpdateTime = block.timestamp;\n\n        /// Resets the staking period\n\n        periodFinish = block.timestamp.add(rewardsDuration);\n\n        /// Emits the event\n\n        emit RewardAdded(reward);\n",
                    "message": "CDEXStakingPool.notifyRewardAmount (CDEX_rewards.sol#502-531) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 4,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.21;\n",
                    "message": "Detected issues with version pragma in CDEX_rewards.sol:\n\t- pragma solidity0.4.21 (CDEX_rewards.sol#4): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": 31,
                    "vulnerability_code": "    function ReentrancyGuard() internal {\n\n        _status = _NOT_ENTERED;\n",
                    "message": "Function 'ReentrancyGuard.ReentrancyGuard' (CDEX_rewards.sol#29-31) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": 62,
                    "vulnerability_code": "    function Owned(address _owner) public {\n\n        require(_owner != address(0));\n\n        owner = _owner;\n\n        emit OwnerChanged(address(0), _owner);\n",
                    "message": "Function 'Owned.Owned' (CDEX_rewards.sol#58-62) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function Owned(address _owner) public {\n",
                    "message": "Parameter '_owner' of Owned.Owned (CDEX_rewards.sol#58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function nominateNewOwner(address _owner) external onlyOwner {\n",
                    "message": "Parameter '_owner' of Owned.nominateNewOwner (CDEX_rewards.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": 83,
                    "vulnerability_code": "    function _onlyOwner() private view {\n\n        require(msg.sender == owner);\n",
                    "message": "Function 'Owned._onlyOwner' (CDEX_rewards.sol#81-83) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": 97,
                    "vulnerability_code": "    function Pausable() internal {\n\n        /// This contract is abstract, and thus cannot be instantiated directly\n\n        require(owner != address(0));\n\n        /// Paused will be false, and lastPauseTime will be 0 upon initialisation\n",
                    "message": "Function 'Pausable.Pausable' (CDEX_rewards.sol#93-97) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setPaused(bool _paused) external onlyOwner {\n",
                    "message": "Parameter '_paused' of Pausable.setPaused (CDEX_rewards.sol#103) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": 285,
                    "vulnerability_code": "    function CDEXStakingPool(\n\n        address _owner,\n\n        address _CDEXTokenContractAddress,\n\n        address _rankingContractAddress\n\n    ) public Owned(_owner) {\n\n        CDEXToken = CDEXTokenContract(_CDEXTokenContractAddress);\n\n        CDEXRanking = CDEXRankingContract(_rankingContractAddress);\n",
                    "message": "Function 'CDEXStakingPool.CDEXStakingPool' (CDEX_rewards.sol#278-285) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _CDEXTokenContractAddress,\n",
                    "message": "Parameter '_CDEXTokenContractAddress' of CDEXStakingPool.CDEXStakingPool (CDEX_rewards.sol#280) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _rankingContractAddress\n",
                    "message": "Parameter '_rankingContractAddress' of CDEXStakingPool.CDEXStakingPool (CDEX_rewards.sol#281) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setTokenContract(address _contractAddress) external onlyOwner {\n",
                    "message": "Parameter '_contractAddress' of CDEXStakingPool.setTokenContract (CDEX_rewards.sol#461) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRankingContract(address _contractAddress) external onlyOwner {\n",
                    "message": "Parameter '_contractAddress' of CDEXStakingPool.setRankingContract (CDEX_rewards.sol#470) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n",
                    "message": "Parameter '_rewardsDuration' of CDEXStakingPool.setRewardsDuration (CDEX_rewards.sol#536) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _loyaltyTier1, \n",
                    "message": "Parameter '_loyaltyTier1' of CDEXStakingPool.setLoyaltyTiers (CDEX_rewards.sol#550) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _loyaltyTier2, \n",
                    "message": "Parameter '_loyaltyTier2' of CDEXStakingPool.setLoyaltyTiers (CDEX_rewards.sol#551) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _loyaltyTier3\n",
                    "message": "Parameter '_loyaltyTier3' of CDEXStakingPool.setLoyaltyTiers (CDEX_rewards.sol#552) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _loyaltyTier1Bonus, \n",
                    "message": "Parameter '_loyaltyTier1Bonus' of CDEXStakingPool.setLoyaltyTiersBonus (CDEX_rewards.sol#571) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _loyaltyTier2Bonus, \n",
                    "message": "Parameter '_loyaltyTier2Bonus' of CDEXStakingPool.setLoyaltyTiersBonus (CDEX_rewards.sol#572) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 573,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _loyaltyTier3Bonus\n",
                    "message": "Parameter '_loyaltyTier3Bonus' of CDEXStakingPool.setLoyaltyTiersBonus (CDEX_rewards.sol#573) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    CDEXTokenContract public CDEXToken;\n",
                    "message": "Variable 'CDEXStakingPool.CDEXToken' (CDEX_rewards.sol#244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    CDEXRankingContract public CDEXRanking;\n",
                    "message": "Variable 'CDEXStakingPool.CDEXRanking' (CDEX_rewards.sol#245) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        nominatedOwner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        updateReward(address(0))\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setPaused(bool _paused) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setTokenContract(address _contractAddress) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRankingContract(address _contractAddress) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setLoyaltyTiers(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 570,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setLoyaltyTiersBonus(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private constant _NOT_ENTERED = 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private constant _ENTERED = 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _status;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _totalSupply;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) private _balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                }
            ]
        }
    },
    "Codex-Rewards-Platform-6ec987cf357d337a042e3d4c209f37466f5db220/contracts/CDEX_ranking.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (j < values[aux].length && i < _positions) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (j < values[aux].length && i < _positions) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                _addresses[i] = values[aux][j];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (!self.nodes[self.nodes[cursor].left].red && !self.nodes[self.nodes[cursor].right].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    key = keyParent;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    if (!self.nodes[self.nodes[cursor].right].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[self.nodes[cursor].left].red = false;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        rotateRight(self, cursor);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        cursor = self.nodes[keyParent].right;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (!self.nodes[self.nodes[cursor].right].red && !self.nodes[self.nodes[cursor].left].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    key = keyParent;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    if (!self.nodes[self.nodes[cursor].left].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[self.nodes[cursor].right].red = false;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        rotateLeft(self, cursor);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        cursor = self.nodes[keyParent].left;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (tree.exists(_key) && values[_key].length - 1 >= _pos) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            value = values[_key][_pos];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        values[_key].length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                i++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                j++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_23"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint i;\n",
                    "message": "i in CDEXRanking.ranking (CDEX_ranking.sol#423) is a local variable never initialiazed\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": 351,
                    "vulnerability_code": "    function getValuesLength(uint _value) public view returns (uint length) {\n\n        length = values[_value].length;\n",
                    "message": "CDEXRanking.getValuesLength (CDEX_ranking.sol#349-351) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": 355,
                    "vulnerability_code": "    function root() public view returns (uint _key) {\n\n        _key = tree.root;\n",
                    "message": "CDEXRanking.root (CDEX_ranking.sol#353-355) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 357,
                    "vulnerability_to_line": 359,
                    "vulnerability_code": "    function first() public view returns (uint _key) {\n\n        _key = tree.first();\n",
                    "message": "CDEXRanking.first (CDEX_ranking.sol#357-359) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": 367,
                    "vulnerability_code": "    function next(uint key) public view returns (uint _key) {\n\n        _key = tree.next(key);\n",
                    "message": "CDEXRanking.next (CDEX_ranking.sol#365-367) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 373,
                    "vulnerability_to_line": 375,
                    "vulnerability_code": "    function exists(uint key) public view returns (bool _exists) {\n\n        _exists = tree.exists(key);\n",
                    "message": "CDEXRanking.exists (CDEX_ranking.sol#373-375) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 381,
                    "vulnerability_code": "    function getNode(uint _key) public view returns (uint key, uint parent, uint left, uint right, bool red) {\n\n        if (tree.exists(_key)) {\n\n            (key, parent, left, right, red) = tree.getNode(_key);\n\n        }\n",
                    "message": "CDEXRanking.getNode (CDEX_ranking.sol#377-381) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": 387,
                    "vulnerability_code": "    function getValue(uint _key, uint _pos) public view returns (address value) {\n\n        if (tree.exists(_key) && values[_key].length - 1 >= _pos) {\n\n            value = values[_key][_pos];\n\n        }\n",
                    "message": "CDEXRanking.getValue (CDEX_ranking.sol#383-387) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": 397,
                    "vulnerability_code": "    function insert(uint _key, address _value) public {\n\n        require(msg.sender == codexStakingContract || msg.sender == owner);\n\n        if (!tree.exists(_key)) {\n\n            tree.insert(_key);\n\n        }\n\n        values[_key].push(_value);\n\n        addressPosition[_value] = values[_key].length - 1;\n\n        emit Log(\"insert\", _key, _value);\n",
                    "message": "CDEXRanking.insert (CDEX_ranking.sol#389-397) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": 417,
                    "vulnerability_code": "    function remove(uint _key, address _value) public {\n\n        require(msg.sender == codexStakingContract || msg.sender == owner);\n\n        require(values[_key][addressPosition[_value]] == _value);\n\n        if (values[_key].length == 1) {\n\n            tree.remove(_key);\n\n        } else {\n\n            if (addressPosition[_value] != values[_key].length - 1) {\n\n                address movingValue = values[_key][values[_key].length - 1];\n\n                // Copying the last address in the array to the position of the address to be removed\n\n                values[_key][addressPosition[_value]] = movingValue;\n\n                // Updating the position reference for the moved value\n\n                addressPosition[movingValue] = addressPosition[_value];\n\n            }\n\n        }\n\n        emit Log(\"remove\", _key, values[_key][addressPosition[_value]]);\n\n        // Deleting the last position of the array\n\n        values[_key].length--;\n\n        addressPosition[_value] = 0;\n",
                    "message": "CDEXRanking.remove (CDEX_ranking.sol#399-417) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": 436,
                    "vulnerability_code": "    function ranking(uint _positions) public view returns (address[] memory, uint256[] memory) {\n\n        address[] memory _addresses = new address[](_positions);\n\n        uint256[] memory _balances = new uint256[](_positions);\n\n        uint aux = last();\n\n        uint i;\n\n        uint j;\n\n        while (i < _positions) {\n\n            j = 0;\n\n            while (j < values[aux].length && i < _positions) {\n\n                _addresses[i] = values[aux][j];\n\n                _balances[i] = aux;\n\n                i++;\n\n                j++;\n\n            }\n\n            aux = prev(aux);\n\n        }\n\n        return (_addresses, _balances);\n",
                    "message": "CDEXRanking.ranking (CDEX_ranking.sol#419-436) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.21;\n",
                    "message": "Detected issues with version pragma in CDEX_ranking.sol:\n\t- pragma solidity0.4.21 (CDEX_ranking.sol#3): it allows old versions\n\t- pragma solidity0.4.21 (CDEX_ranking.sol#326): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": 342,
                    "vulnerability_code": "    function CDEXRanking() public {\n\n        owner = msg.sender;\n",
                    "message": "Function 'CDEXRanking.CDEXRanking' (CDEX_ranking.sol#340-342) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCodexContractAddress(address _contractAddress) external {\n",
                    "message": "Parameter '_contractAddress' of CDEXRanking.setCodexContractAddress (CDEX_ranking.sol#344) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValuesLength(uint _value) public view returns (uint length) {\n",
                    "message": "Parameter '_value' of CDEXRanking.getValuesLength (CDEX_ranking.sol#349) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNode(uint _key) public view returns (uint key, uint parent, uint left, uint right, bool red) {\n",
                    "message": "Parameter '_key' of CDEXRanking.getNode (CDEX_ranking.sol#377) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValue(uint _key, uint _pos) public view returns (address value) {\n",
                    "message": "Parameter '_key' of CDEXRanking.getValue (CDEX_ranking.sol#383) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValue(uint _key, uint _pos) public view returns (address value) {\n",
                    "message": "Parameter '_pos' of CDEXRanking.getValue (CDEX_ranking.sol#383) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function insert(uint _key, address _value) public {\n",
                    "message": "Parameter '_key' of CDEXRanking.insert (CDEX_ranking.sol#389) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function insert(uint _key, address _value) public {\n",
                    "message": "Parameter '_value' of CDEXRanking.insert (CDEX_ranking.sol#389) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function remove(uint _key, address _value) public {\n",
                    "message": "Parameter '_key' of CDEXRanking.remove (CDEX_ranking.sol#399) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function remove(uint _key, address _value) public {\n",
                    "message": "Parameter '_value' of CDEXRanking.remove (CDEX_ranking.sol#399) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ranking(uint _positions) public view returns (address[] memory, uint256[] memory) {\n",
                    "message": "Parameter '_positions' of CDEXRanking.ranking (CDEX_ranking.sol#419) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        values[_key].length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (j < values[aux].length && i < _positions) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (self.nodes[_key].left != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (self.nodes[_key].right != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (cursor != EMPTY && target == self.nodes[cursor].right) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (cursor != EMPTY && target == self.nodes[cursor].left) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (probe != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (self.nodes[cursor].left != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (self.nodes[key].left != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (self.nodes[key].right != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (key != self.root && self.nodes[self.nodes[key].parent].red) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (key != self.root && !self.nodes[key].red) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (i < _positions) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (j < values[aux].length && i < _positions) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCodexContractAddress(address _contractAddress) external {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private constant EMPTY = 0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNode(Tree storage self, uint key) internal view returns (uint _returnKey, uint _parent, uint _left, uint _right, bool _red) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    BokkyPooBahsRedBlackTreeLibrary.Tree tree;\n",
                    "message": null
                }
            ]
        }
    },
    "Codex-Rewards-Platform-6ec987cf357d337a042e3d4c209f37466f5db220/contracts/BokkyPooBahsRedBlackTreeLibrary.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (!self.nodes[self.nodes[cursor].left].red && !self.nodes[self.nodes[cursor].right].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    key = keyParent;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    if (!self.nodes[self.nodes[cursor].right].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[self.nodes[cursor].left].red = false;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        rotateRight(self, cursor);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        cursor = self.nodes[keyParent].right;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (!self.nodes[self.nodes[cursor].right].red && !self.nodes[self.nodes[cursor].left].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    key = keyParent;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    if (!self.nodes[self.nodes[cursor].left].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[self.nodes[cursor].right].red = false;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        rotateLeft(self, cursor);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        cursor = self.nodes[keyParent].left;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.21;\n",
                    "message": "Detected issues with version pragma in BokkyPooBahsRedBlackTreeLibrary.sol:\n\t- pragma solidity0.4.21 (BokkyPooBahsRedBlackTreeLibrary.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (self.nodes[_key].left != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (self.nodes[_key].right != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (cursor != EMPTY && target == self.nodes[cursor].right) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (cursor != EMPTY && target == self.nodes[cursor].left) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (probe != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (self.nodes[cursor].left != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (self.nodes[key].left != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (self.nodes[key].right != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (key != self.root && self.nodes[self.nodes[key].parent].red) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (key != self.root && !self.nodes[key].red) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private constant EMPTY = 0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNode(Tree storage self, uint key) internal view returns (uint _returnKey, uint _parent, uint _left, uint _right, bool _red) {\n",
                    "message": null
                }
            ]
        }
    },
    "Codex-Rewards-Platform-d364d0ef9258dd468f8202a352c58724d6b65638/contracts/CDEX_rewards.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            totalMembers += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 public periodFinish = 0;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 public rewardRate = 0;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 public rewardsDuration = 0;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (reward > 0 && depositedRewardTokens >= reward) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 436,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            /// The withdraw is always for the full accrued reward amount\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 437,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            rewards[msg.sender] = 0;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 438,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            /// Decrements the deposited reward tokens balance\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            depositedRewardTokens = depositedRewardTokens.sub(reward);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            /// Defines the bonus amount based on the sender's reward tier\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (_balances[msg.sender] >= loyaltyTier1) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                loyaltyBonus = reward.mul(loyaltyTier1Bonus).div(10000);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if (_balances[msg.sender] >= loyaltyTier2) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                loyaltyBonus = reward.mul(loyaltyTier2Bonus).div(10000);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_37"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": 231,
                    "vulnerability_code": "interface CDEXTokenContract {\n\n\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external;\n\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n\n",
                    "message": "CDEXTokenContract (CDEX_rewards.sol#225-231) has incorrect ERC20 function interface(s):\n\t-transfer (CDEX_rewards.sol#228)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": 465,
                    "vulnerability_code": "    function exit() external {\n\n        withdraw(_balances[msg.sender]);\n\n        getReward();\n",
                    "message": "Reentrancy in CDEXStakingPool.exit (CDEX_rewards.sol#462-465):\n\tExternal calls:\n\t- withdraw(_balances[msg.sender]) (CDEX_rewards.sol#463)\n\t- getReward() (CDEX_rewards.sol#464)\n\tState variables written after the call(s):\n\t- _status (CDEX_rewards.sol#464)\n\t- lastUpdateTime (CDEX_rewards.sol#464)\n\t- rewardPerTokenStored (CDEX_rewards.sol#464)\n\t- rewards (CDEX_rewards.sol#464)\n\t- userRewardPerTokenPaid (CDEX_rewards.sol#464)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": 394,
                    "vulnerability_code": "    function stake(uint256 amount)\n\n        external\n\n        nonReentrant\n\n        notPaused\n\n        updateReward(msg.sender)\n\n    {\n\n        require(amount > 0);\n\n        /// Increments the total staked balance\n\n        _totalSupply = _totalSupply.add(amount);\n\n        \n\n        if(_balances[msg.sender] == 0) {\n\n            /// Increments the totalMembers if the sending address didn't have any previous balance\n\n            totalMembers += 1;\n\n            /// Adds the user address to the ranking tree\n\n            CDEXRanking.insert(amount, msg.sender);\n\n        } else {\n\n            /// Removes the user address from its current ranking node in the tree\n\n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n\n            /// Adds it again with the new value\n\n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n\n        }\n\n        /// Increments the sender's staked balance\n\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n\n        /// Transfer the tokens from the sender's balance into the contract\n\n        /// The amount needs to be previously approved in the token contract\n\n        CDEXToken.transferFrom(msg.sender, address(this), amount);\n\n        /// Emits the event\n\n        emit Staked(msg.sender, amount);\n",
                    "message": "Reentrancy in CDEXStakingPool.stake (CDEX_rewards.sol#366-394):\n\tExternal calls:\n\t- CDEXRanking.insert(amount,msg.sender) (CDEX_rewards.sol#380)\n\t- CDEXRanking.remove(_balances[msg.sender],msg.sender) (CDEX_rewards.sol#383)\n\t- CDEXRanking.insert(_balances[msg.sender].add(amount),msg.sender) (CDEX_rewards.sol#385)\n\tState variables written after the call(s):\n\t- _balances (CDEX_rewards.sol#388)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": 423,
                    "vulnerability_code": "    function withdraw(uint256 amount)\n\n        public\n\n        nonReentrant\n\n        updateReward(msg.sender)\n\n    {\n\n        require(amount > 0);\n\n        /// Decrements the total staked balance\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        /// Removes the user address from its current ranking node in the tree\n\n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n\n        /// Decrements the sender's staked balance\n\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        /// If the balance is zero after decremented, decrements the totalMembers\n\n        if(_balances[msg.sender] == 0) {\n\n            totalMembers -= 1;\n\n        } else {\n\n            /// If not, adds the user address back into the ranking tree with the new balance\n\n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n\n        }\n\n        /// Transfers the tokens into the sender's address\n\n        // SWC-Unchecked Call Return Value: L415\n\n        CDEXToken.transfer(msg.sender, amount);\n\n        /// Emits the event\n\n        emit Withdrawn(msg.sender, amount);\n",
                    "message": "Reentrancy in CDEXStakingPool.withdraw (CDEX_rewards.sol#399-423):\n\tExternal calls:\n\t- CDEXRanking.remove(_balances[msg.sender],msg.sender) (CDEX_rewards.sol#408)\n\tState variables written after the call(s):\n\t- _balances (CDEX_rewards.sol#410)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 loyaltyBonus;\n",
                    "message": "loyaltyBonus in CDEXStakingPool.getReward (CDEX_rewards.sol#433) is a local variable never initialiazed\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": 394,
                    "vulnerability_code": "    function stake(uint256 amount)\n\n        external\n\n        nonReentrant\n\n        notPaused\n\n        updateReward(msg.sender)\n\n    {\n\n        require(amount > 0);\n\n        /// Increments the total staked balance\n\n        _totalSupply = _totalSupply.add(amount);\n\n        \n\n        if(_balances[msg.sender] == 0) {\n\n            /// Increments the totalMembers if the sending address didn't have any previous balance\n\n            totalMembers += 1;\n\n            /// Adds the user address to the ranking tree\n\n            CDEXRanking.insert(amount, msg.sender);\n\n        } else {\n\n            /// Removes the user address from its current ranking node in the tree\n\n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n\n            /// Adds it again with the new value\n\n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n\n        }\n\n        /// Increments the sender's staked balance\n\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n\n        /// Transfer the tokens from the sender's balance into the contract\n\n        /// The amount needs to be previously approved in the token contract\n\n        CDEXToken.transferFrom(msg.sender, address(this), amount);\n\n        /// Emits the event\n\n        emit Staked(msg.sender, amount);\n",
                    "message": "CDEXStakingPool.stake (CDEX_rewards.sol#366-394) does not use the value returned by external calls:\n\t-CDEXToken.transferFrom(msg.sender,address(this),amount) (CDEX_rewards.sol#391)\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 490,
                    "vulnerability_to_line": 501,
                    "vulnerability_code": "    function depositTokens(uint256 amount) public onlyOwner {\n\n        /// Adding the decimal places to the amount\n\n        amount = amount.mul(1e8);\n\n        /// Calculating the total loyalty bonus percentage from the total\n\n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(amount.mul(loyaltyBonusTotal).div(10000));\n\n        /// Increasing the total deposited tokens with the amount\n\n        depositedRewardTokens = depositedRewardTokens.add(amount);\n\n        /// Transferring the whole amount to the contract\n\n        CDEXToken.transferFrom(owner, address(this), amount);\n\n        /// Emits the event\n\n        emit RewardsDeposited(owner, address(this), amount);\n",
                    "message": "CDEXStakingPool.depositTokens (CDEX_rewards.sol#490-501) does not use the value returned by external calls:\n\t-CDEXToken.transferFrom(owner,address(this),amount) (CDEX_rewards.sol#498)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": 423,
                    "vulnerability_code": "    function withdraw(uint256 amount)\n\n        public\n\n        nonReentrant\n\n        updateReward(msg.sender)\n\n    {\n\n        require(amount > 0);\n\n        /// Decrements the total staked balance\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        /// Removes the user address from its current ranking node in the tree\n\n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n\n        /// Decrements the sender's staked balance\n\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        /// If the balance is zero after decremented, decrements the totalMembers\n\n        if(_balances[msg.sender] == 0) {\n\n            totalMembers -= 1;\n\n        } else {\n\n            /// If not, adds the user address back into the ranking tree with the new balance\n\n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n\n        }\n\n        /// Transfers the tokens into the sender's address\n\n        // SWC-Unchecked Call Return Value: L415\n\n        CDEXToken.transfer(msg.sender, amount);\n\n        /// Emits the event\n\n        emit Withdrawn(msg.sender, amount);\n",
                    "message": "Reentrancy in CDEXStakingPool.withdraw (CDEX_rewards.sol#399-423):\n\tExternal calls:\n\t- CDEXRanking.remove(_balances[msg.sender],msg.sender) (CDEX_rewards.sol#408)\n\tState variables written after the call(s):\n\t- totalMembers (CDEX_rewards.sol#413)\n"
                },
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 343,
                    "vulnerability_to_line": 345,
                    "vulnerability_code": "    function min(uint256 a, uint256 b) public pure returns (uint256) {\n\n        return a < b ? a : b;\n",
                    "message": "CDEXStakingPool.min (CDEX_rewards.sol#343-345) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- a < b (CDEX_rewards.sol#344)\n"
                },
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 507,
                    "vulnerability_to_line": 537,
                    "vulnerability_code": "    function notifyRewardAmount(uint256 reward)\n\n        public\n\n        onlyOwner\n\n        updateReward(address(0))\n\n    {\n\n        /// Adding the decimal places to the reward\n\n        reward = reward.mul(1e8);\n\n        /// The total deposited amount should cater for the rewards and the loyalty bonus.\n\n        /// Therefore, the notified reward must be equal to total deposited minus total possible bonus over the reward.\n\n        require(reward <= depositedRewardTokens.sub(reward.mul(loyaltyBonusTotal).div(10000)));\n\n        /// If not during staking period, calculates the new reward rate per second.\n\n        /// Else, adds the new reward to current non-distributed rewards.\n\n        if (block.timestamp >= periodFinish) {\n\n            rewardRate = reward.div(rewardsDuration);\n\n        } else {\n\n            uint256 remaining = periodFinish.sub(block.timestamp);\n\n            uint256 leftover = remaining.mul(rewardRate);\n\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n\n        }\n\n        /// Ensure the provided reward amount is not more than the balance in the contract.\n\n        /// This keeps the reward rate in the right range, preventing overflows due to\n\n        /// very high values of rewardRate in the earned and rewardsPerToken functions;\n\n        /// Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n\n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n\n        /// Updates the last updated time\n\n        lastUpdateTime = block.timestamp;\n\n        /// Resets the staking period\n\n        periodFinish = block.timestamp.add(rewardsDuration);\n\n        /// Emits the event\n\n        emit RewardAdded(reward);\n",
                    "message": "CDEXStakingPool.notifyRewardAmount (CDEX_rewards.sol#507-537) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool)(rewardRate <= depositedRewardTokens.div(rewardsDuration)) (CDEX_rewards.sol#530)\n\t- block.timestamp >= periodFinish (CDEX_rewards.sol#519-525)\n"
                },
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 542,
                    "vulnerability_to_line": 549,
                    "vulnerability_code": "    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n\n        /// Checks if the previously defined period has already finished\n\n        require(block.timestamp > periodFinish);\n\n        /// Updates the duration\n\n        rewardsDuration = _rewardsDuration;\n\n        /// Emits the event\n\n        emit RewardsDurationUpdated(rewardsDuration);\n",
                    "message": "CDEXStakingPool.setRewardsDuration (CDEX_rewards.sol#542-549) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool)(block.timestamp > periodFinish) (CDEX_rewards.sol#544)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": 474,
                    "vulnerability_code": "    function setTokenContract(address _contractAddress) public onlyOwner {\n\n        CDEXToken = CDEXTokenContract(_contractAddress);\n",
                    "message": "CDEXStakingPool.setTokenContract (CDEX_rewards.sol#472-474) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 479,
                    "vulnerability_to_line": 481,
                    "vulnerability_code": "    function setRankingContract(address _contractAddress) public onlyOwner {\n\n        CDEXRanking = CDEXRankingContract(_contractAddress);\n",
                    "message": "CDEXStakingPool.setRankingContract (CDEX_rewards.sol#479-481) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 490,
                    "vulnerability_to_line": 501,
                    "vulnerability_code": "    function depositTokens(uint256 amount) public onlyOwner {\n\n        /// Adding the decimal places to the amount\n\n        amount = amount.mul(1e8);\n\n        /// Calculating the total loyalty bonus percentage from the total\n\n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(amount.mul(loyaltyBonusTotal).div(10000));\n\n        /// Increasing the total deposited tokens with the amount\n\n        depositedRewardTokens = depositedRewardTokens.add(amount);\n\n        /// Transferring the whole amount to the contract\n\n        CDEXToken.transferFrom(owner, address(this), amount);\n\n        /// Emits the event\n\n        emit RewardsDeposited(owner, address(this), amount);\n",
                    "message": "CDEXStakingPool.depositTokens (CDEX_rewards.sol#490-501) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 507,
                    "vulnerability_to_line": 537,
                    "vulnerability_code": "    function notifyRewardAmount(uint256 reward)\n\n        public\n\n        onlyOwner\n\n        updateReward(address(0))\n\n    {\n\n        /// Adding the decimal places to the reward\n\n        reward = reward.mul(1e8);\n\n        /// The total deposited amount should cater for the rewards and the loyalty bonus.\n\n        /// Therefore, the notified reward must be equal to total deposited minus total possible bonus over the reward.\n\n        require(reward <= depositedRewardTokens.sub(reward.mul(loyaltyBonusTotal).div(10000)));\n\n        /// If not during staking period, calculates the new reward rate per second.\n\n        /// Else, adds the new reward to current non-distributed rewards.\n\n        if (block.timestamp >= periodFinish) {\n\n            rewardRate = reward.div(rewardsDuration);\n\n        } else {\n\n            uint256 remaining = periodFinish.sub(block.timestamp);\n\n            uint256 leftover = remaining.mul(rewardRate);\n\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n\n        }\n\n        /// Ensure the provided reward amount is not more than the balance in the contract.\n\n        /// This keeps the reward rate in the right range, preventing overflows due to\n\n        /// very high values of rewardRate in the earned and rewardsPerToken functions;\n\n        /// Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n\n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n\n        /// Updates the last updated time\n\n        lastUpdateTime = block.timestamp;\n\n        /// Resets the staking period\n\n        periodFinish = block.timestamp.add(rewardsDuration);\n\n        /// Emits the event\n\n        emit RewardAdded(reward);\n",
                    "message": "CDEXStakingPool.notifyRewardAmount (CDEX_rewards.sol#507-537) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.21;\n",
                    "message": "Detected issues with version pragma in CDEX_rewards.sol:\n\t- pragma solidity^0.4.21 (CDEX_rewards.sol#5): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": 32,
                    "vulnerability_code": "    function ReentrancyGuard() internal {\n\n        _status = _NOT_ENTERED;\n",
                    "message": "Function 'ReentrancyGuard.ReentrancyGuard' (CDEX_rewards.sol#30-32) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": 63,
                    "vulnerability_code": "    function Owned(address _owner) public {\n\n        require(_owner != address(0));\n\n        owner = _owner;\n\n        emit OwnerChanged(address(0), _owner);\n",
                    "message": "Function 'Owned.Owned' (CDEX_rewards.sol#59-63) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function Owned(address _owner) public {\n",
                    "message": "Parameter '_owner' of Owned.Owned (CDEX_rewards.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function nominateNewOwner(address _owner) external onlyOwner {\n",
                    "message": "Parameter '_owner' of Owned.nominateNewOwner (CDEX_rewards.sol#65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": 84,
                    "vulnerability_code": "    function _onlyOwner() private view {\n\n        require(msg.sender == owner);\n",
                    "message": "Function 'Owned._onlyOwner' (CDEX_rewards.sol#82-84) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 98,
                    "vulnerability_code": "    function Pausable() internal {\n\n        /// This contract is abstract, and thus cannot be instantiated directly\n\n        require(owner != address(0));\n\n        /// Paused will be false, and lastPauseTime will be 0 upon initialisation\n",
                    "message": "Function 'Pausable.Pausable' (CDEX_rewards.sol#94-98) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setPaused(bool _paused) external onlyOwner {\n",
                    "message": "Parameter '_paused' of Pausable.setPaused (CDEX_rewards.sol#104) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": 286,
                    "vulnerability_code": "    function CDEXStakingPool(\n\n        address _owner,\n\n        address _CDEXTokenContractAddress,\n\n        address _rankingContractAddress\n\n    ) public Owned(_owner) {\n\n        CDEXToken = CDEXTokenContract(_CDEXTokenContractAddress);\n\n        CDEXRanking = CDEXRankingContract(_rankingContractAddress);\n",
                    "message": "Function 'CDEXStakingPool.CDEXStakingPool' (CDEX_rewards.sol#279-286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _CDEXTokenContractAddress,\n",
                    "message": "Parameter '_CDEXTokenContractAddress' of CDEXStakingPool.CDEXStakingPool (CDEX_rewards.sol#281) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _rankingContractAddress\n",
                    "message": "Parameter '_rankingContractAddress' of CDEXStakingPool.CDEXStakingPool (CDEX_rewards.sol#282) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setTokenContract(address _contractAddress) public onlyOwner {\n",
                    "message": "Parameter '_contractAddress' of CDEXStakingPool.setTokenContract (CDEX_rewards.sol#472) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 479,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRankingContract(address _contractAddress) public onlyOwner {\n",
                    "message": "Parameter '_contractAddress' of CDEXStakingPool.setRankingContract (CDEX_rewards.sol#479) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n",
                    "message": "Parameter '_rewardsDuration' of CDEXStakingPool.setRewardsDuration (CDEX_rewards.sol#542) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 556,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _loyaltyTier1, \n",
                    "message": "Parameter '_loyaltyTier1' of CDEXStakingPool.setLoyaltyTiers (CDEX_rewards.sol#556) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 557,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _loyaltyTier2, \n",
                    "message": "Parameter '_loyaltyTier2' of CDEXStakingPool.setLoyaltyTiers (CDEX_rewards.sol#557) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 558,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _loyaltyTier3\n",
                    "message": "Parameter '_loyaltyTier3' of CDEXStakingPool.setLoyaltyTiers (CDEX_rewards.sol#558) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _loyaltyTier1Bonus, \n",
                    "message": "Parameter '_loyaltyTier1Bonus' of CDEXStakingPool.setLoyaltyTiersBonus (CDEX_rewards.sol#576) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 577,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _loyaltyTier2Bonus, \n",
                    "message": "Parameter '_loyaltyTier2Bonus' of CDEXStakingPool.setLoyaltyTiersBonus (CDEX_rewards.sol#577) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _loyaltyTier3Bonus\n",
                    "message": "Parameter '_loyaltyTier3Bonus' of CDEXStakingPool.setLoyaltyTiersBonus (CDEX_rewards.sol#578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    CDEXTokenContract public CDEXToken;\n",
                    "message": "Variable 'CDEXStakingPool.CDEXToken' (CDEX_rewards.sol#245) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    CDEXRankingContract public CDEXRanking;\n",
                    "message": "Variable 'CDEXStakingPool.CDEXRanking' (CDEX_rewards.sol#246) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        nominatedOwner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        updateReward(address(0))\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setPaused(bool _paused) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setTokenContract(address _contractAddress) public onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 479,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRankingContract(address _contractAddress) public onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setLoyaltyTiers(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setLoyaltyTiersBonus(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.21;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private constant _NOT_ENTERED = 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private constant _ENTERED = 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _status;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _totalSupply;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) private _balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                }
            ]
        }
    },
    "Codex-Rewards-Platform-d364d0ef9258dd468f8202a352c58724d6b65638/contracts/CDEX_ranking.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (j < values[aux].length && i < _positions) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (j < values[aux].length && i < _positions) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                _addresses[i] = values[aux][j];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (!self.nodes[self.nodes[cursor].left].red && !self.nodes[self.nodes[cursor].right].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    key = keyParent;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    if (!self.nodes[self.nodes[cursor].right].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[self.nodes[cursor].left].red = false;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        rotateRight(self, cursor);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        cursor = self.nodes[keyParent].right;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (!self.nodes[self.nodes[cursor].right].red && !self.nodes[self.nodes[cursor].left].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    key = keyParent;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    if (!self.nodes[self.nodes[cursor].left].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[self.nodes[cursor].right].red = false;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        rotateLeft(self, cursor);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        cursor = self.nodes[keyParent].left;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (tree.exists(_key) && values[_key].length - 1 >= _pos) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            value = values[_key][_pos];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        values[_key].length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                i++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                j++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_23"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint i;\n",
                    "message": "i in CDEXRanking.ranking (CDEX_ranking.sol#423) is a local variable never initialiazed\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": 351,
                    "vulnerability_code": "    function getValuesLength(uint _value) public view returns (uint length) {\n\n        length = values[_value].length;\n",
                    "message": "CDEXRanking.getValuesLength (CDEX_ranking.sol#349-351) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": 355,
                    "vulnerability_code": "    function root() public view returns (uint _key) {\n\n        _key = tree.root;\n",
                    "message": "CDEXRanking.root (CDEX_ranking.sol#353-355) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 357,
                    "vulnerability_to_line": 359,
                    "vulnerability_code": "    function first() public view returns (uint _key) {\n\n        _key = tree.first();\n",
                    "message": "CDEXRanking.first (CDEX_ranking.sol#357-359) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": 367,
                    "vulnerability_code": "    function next(uint key) public view returns (uint _key) {\n\n        _key = tree.next(key);\n",
                    "message": "CDEXRanking.next (CDEX_ranking.sol#365-367) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 373,
                    "vulnerability_to_line": 375,
                    "vulnerability_code": "    function exists(uint key) public view returns (bool _exists) {\n\n        _exists = tree.exists(key);\n",
                    "message": "CDEXRanking.exists (CDEX_ranking.sol#373-375) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 381,
                    "vulnerability_code": "    function getNode(uint _key) public view returns (uint key, uint parent, uint left, uint right, bool red) {\n\n        if (tree.exists(_key)) {\n\n            (key, parent, left, right, red) = tree.getNode(_key);\n\n        }\n",
                    "message": "CDEXRanking.getNode (CDEX_ranking.sol#377-381) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": 387,
                    "vulnerability_code": "    function getValue(uint _key, uint _pos) public view returns (address value) {\n\n        if (tree.exists(_key) && values[_key].length - 1 >= _pos) {\n\n            value = values[_key][_pos];\n\n        }\n",
                    "message": "CDEXRanking.getValue (CDEX_ranking.sol#383-387) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": 397,
                    "vulnerability_code": "    function insert(uint _key, address _value) public {\n\n        require(msg.sender == codexStakingContract || msg.sender == owner);\n\n        if (!tree.exists(_key)) {\n\n            tree.insert(_key);\n\n        }\n\n        values[_key].push(_value);\n\n        addressPosition[_value] = values[_key].length - 1;\n\n        emit Log(\"insert\", _key, _value);\n",
                    "message": "CDEXRanking.insert (CDEX_ranking.sol#389-397) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": 417,
                    "vulnerability_code": "    function remove(uint _key, address _value) public {\n\n        require(msg.sender == codexStakingContract || msg.sender == owner);\n\n        require(values[_key][addressPosition[_value]] == _value);\n\n        if (values[_key].length == 1) {\n\n            tree.remove(_key);\n\n        } else {\n\n            if (addressPosition[_value] != values[_key].length - 1) {\n\n                address movingValue = values[_key][values[_key].length - 1];\n\n                // Copying the last address in the array to the position of the address to be removed\n\n                values[_key][addressPosition[_value]] = movingValue;\n\n                // Updating the position reference for the moved value\n\n                addressPosition[movingValue] = addressPosition[_value];\n\n            }\n\n        }\n\n        emit Log(\"remove\", _key, values[_key][addressPosition[_value]]);\n\n        // Deleting the last position of the array\n\n        values[_key].length--;\n\n        addressPosition[_value] = 0;\n",
                    "message": "CDEXRanking.remove (CDEX_ranking.sol#399-417) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": 436,
                    "vulnerability_code": "    function ranking(uint _positions) public view returns (address[] memory, uint256[] memory) {\n\n        address[] memory _addresses = new address[](_positions);\n\n        uint256[] memory _balances = new uint256[](_positions);\n\n        uint aux = last();\n\n        uint i;\n\n        uint j;\n\n        while (i < _positions) {\n\n            j = 0;\n\n            while (j < values[aux].length && i < _positions) {\n\n                _addresses[i] = values[aux][j];\n\n                _balances[i] = aux;\n\n                i++;\n\n                j++;\n\n            }\n\n            aux = prev(aux);\n\n        }\n\n        return (_addresses, _balances);\n",
                    "message": "CDEXRanking.ranking (CDEX_ranking.sol#419-436) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.21;\n",
                    "message": "Detected issues with version pragma in CDEX_ranking.sol:\n\t- pragma solidity^0.4.21 (CDEX_ranking.sol#3): it allows old versions\n\t- pragma solidity^0.4.21 (CDEX_ranking.sol#326): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": 342,
                    "vulnerability_code": "    function CDEXRanking() public {\n\n        owner = msg.sender;\n",
                    "message": "Function 'CDEXRanking.CDEXRanking' (CDEX_ranking.sol#340-342) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCodexContractAddress(address _contractAddress) external {\n",
                    "message": "Parameter '_contractAddress' of CDEXRanking.setCodexContractAddress (CDEX_ranking.sol#344) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValuesLength(uint _value) public view returns (uint length) {\n",
                    "message": "Parameter '_value' of CDEXRanking.getValuesLength (CDEX_ranking.sol#349) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNode(uint _key) public view returns (uint key, uint parent, uint left, uint right, bool red) {\n",
                    "message": "Parameter '_key' of CDEXRanking.getNode (CDEX_ranking.sol#377) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValue(uint _key, uint _pos) public view returns (address value) {\n",
                    "message": "Parameter '_key' of CDEXRanking.getValue (CDEX_ranking.sol#383) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValue(uint _key, uint _pos) public view returns (address value) {\n",
                    "message": "Parameter '_pos' of CDEXRanking.getValue (CDEX_ranking.sol#383) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function insert(uint _key, address _value) public {\n",
                    "message": "Parameter '_key' of CDEXRanking.insert (CDEX_ranking.sol#389) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function insert(uint _key, address _value) public {\n",
                    "message": "Parameter '_value' of CDEXRanking.insert (CDEX_ranking.sol#389) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function remove(uint _key, address _value) public {\n",
                    "message": "Parameter '_key' of CDEXRanking.remove (CDEX_ranking.sol#399) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function remove(uint _key, address _value) public {\n",
                    "message": "Parameter '_value' of CDEXRanking.remove (CDEX_ranking.sol#399) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ranking(uint _positions) public view returns (address[] memory, uint256[] memory) {\n",
                    "message": "Parameter '_positions' of CDEXRanking.ranking (CDEX_ranking.sol#419) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        values[_key].length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (j < values[aux].length && i < _positions) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (self.nodes[_key].left != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (self.nodes[_key].right != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (cursor != EMPTY && target == self.nodes[cursor].right) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (cursor != EMPTY && target == self.nodes[cursor].left) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (probe != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (self.nodes[cursor].left != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (self.nodes[key].left != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (self.nodes[key].right != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (key != self.root && self.nodes[self.nodes[key].parent].red) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (key != self.root && !self.nodes[key].red) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (i < _positions) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (j < values[aux].length && i < _positions) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCodexContractAddress(address _contractAddress) external {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.21;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 326,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.21;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private constant EMPTY = 0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNode(Tree storage self, uint key) internal view returns (uint _returnKey, uint _parent, uint _left, uint _right, bool _red) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    BokkyPooBahsRedBlackTreeLibrary.Tree tree;\n",
                    "message": null
                }
            ]
        }
    },
    "Codex-Rewards-Platform-d364d0ef9258dd468f8202a352c58724d6b65638/contracts/BokkyPooBahsRedBlackTreeLibrary.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (!self.nodes[self.nodes[cursor].left].red && !self.nodes[self.nodes[cursor].right].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    key = keyParent;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    if (!self.nodes[self.nodes[cursor].right].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[self.nodes[cursor].left].red = false;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        rotateRight(self, cursor);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        cursor = self.nodes[keyParent].right;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (!self.nodes[self.nodes[cursor].right].red && !self.nodes[self.nodes[cursor].left].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    key = keyParent;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    if (!self.nodes[self.nodes[cursor].left].red) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[self.nodes[cursor].right].red = false;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        self.nodes[cursor].red = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        rotateLeft(self, cursor);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        cursor = self.nodes[keyParent].left;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.21;\n",
                    "message": "Detected issues with version pragma in BokkyPooBahsRedBlackTreeLibrary.sol:\n\t- pragma solidity^0.4.21 (BokkyPooBahsRedBlackTreeLibrary.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (self.nodes[_key].left != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (self.nodes[_key].right != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (cursor != EMPTY && target == self.nodes[cursor].right) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (cursor != EMPTY && target == self.nodes[cursor].left) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (probe != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (self.nodes[cursor].left != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (self.nodes[key].left != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (self.nodes[key].right != EMPTY) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (key != self.root && self.nodes[self.nodes[key].parent].red) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (key != self.root && !self.nodes[key].red) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.21;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private constant EMPTY = 0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNode(Tree storage self, uint key) internal view returns (uint _returnKey, uint _parent, uint _left, uint _right, bool _red) {\n",
                    "message": null
                }
            ]
        }
    }
}