{
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/test/mockContracts/StakingAuRaMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _addPoolToBeRemoved(_poolStakingAddress);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 953,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            intStorage[POOLS_LIKELIHOOD_SUM] -= likelihood[indexToDelete];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 955,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (intStorage[POOLS_LIKELIHOOD_SUM] < 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 956,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                intStorage[POOLS_LIKELIHOOD_SUM] = 0;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 958,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools[indexToDelete] = pools[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            likelihood[indexToDelete] = likelihood[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 960,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolToBeElectedIndex(pools[indexToDelete], indexToDelete);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 961,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolToBeElectedIndex(_stakingAddress, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 975,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools[indexToDelete] = pools[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 976,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolToBeRemovedIndex(pools[indexToDelete], indexToDelete);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolToBeRemovedIndex(_stakingAddress, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 978,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 979,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 988,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 989,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools[indexToRemove] = pools[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 990,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolIndex(pools[indexToRemove], indexToRemove);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 991,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolIndex(_stakingAddress, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 992,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 993,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1009,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1010,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools[indexToRemove] = pools[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1011,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolInactiveIndex(pools[indexToRemove], indexToRemove);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1012,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolInactiveIndex(_stakingAddress, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1013,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1014,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators[indexToRemove] = delegators[delegators.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolDelegatorIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolDelegatorIndex(_poolStakingAddress, _delegator, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators[indexToRemove] = delegators[delegators.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolDelegatorInactiveIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolDelegatorInactiveIndex(_poolStakingAddress, _delegator, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 963,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            likelihood.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 978,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 992,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1013,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[STAKING_EPOCH]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_251"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": 396,
                    "vulnerability_code": "    function withdraw(address _fromPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n\n        address payable staker = msg.sender;\n\n        _withdraw(_fromPoolStakingAddress, staker, _amount);\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, _amount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(_amount);\n\n        }\n\n        emit Withdrawn(_fromPoolStakingAddress, staker, stakingEpoch(), _amount);\n",
                    "message": "StakingBase.withdraw (StakingAuRaMock.sol#385-396) sends eth to arbitrary user\n\tDangerous calls:\n\t- staker.transfer(_amount) (StakingAuRaMock.sol#393)\n"
                },
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n        uint256 epoch = stakingEpoch();\n\n        address payable staker = msg.sender;\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(epoch > orderWithdrawEpoch(_poolStakingAddress, staker));\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        uint256 claimAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n        require(claimAmount != 0);\n\n\n\n        uint256 resultingStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(claimAmount);\n\n\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, 0);\n\n        _setOrderedWithdrawAmountTotal(\n\n            _poolStakingAddress,\n\n            orderedWithdrawAmountTotal(_poolStakingAddress).sub(claimAmount)\n\n        );\n\n        _setStakeAmount(_poolStakingAddress, staker, resultingStakeAmount);\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(claimAmount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, claimAmount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(claimAmount);\n\n        }\n\n\n\n        emit Claimed(_poolStakingAddress, staker, epoch, claimAmount);\n",
                    "message": "StakingBase.claimOrderedWithdraw (StakingAuRaMock.sol#480-517) sends eth to arbitrary user\n\tDangerous calls:\n\t- staker.transfer(claimAmount) (StakingAuRaMock.sol#513)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner (StakingAuRaMock.sol#97) is never initialized. It is used in:\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1024,
                    "vulnerability_to_line": 1056,
                    "vulnerability_code": "    function _initialize(\n\n        address _validatorSetContract,\n\n        address[] memory _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        bool _erc20Restricted\n\n    ) internal {\n\n        require(!isInitialized()); // initialization can only be done once\n\n        require(_validatorSetContract != address(0));\n\n        require(_initialStakingAddresses.length > 0);\n\n        require(_delegatorMinStake != 0);\n\n        require(_candidateMinStake != 0);\n\n\n\n        IBlockReward blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract());\n\n        require(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0);\n\n\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSetContract;\n\n\n\n        address unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator();\n\n\n\n        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n\n            require(_initialStakingAddresses[i] != address(0));\n\n            _addPoolActive(_initialStakingAddresses[i], false);\n\n            if (_initialStakingAddresses[i] != unremovableStakingAddress) {\n\n                _addPoolToBeRemoved(_initialStakingAddresses[i]);\n\n            }\n\n        }\n\n\n\n        _setDelegatorMinStake(_delegatorMinStake);\n\n        _setCandidateMinStake(_candidateMinStake);\n\n\n\n        boolStorage[ERC20_RESTRICTED] = _erc20Restricted;\n",
                    "message": "Reentrancy in StakingBase._initialize (StakingAuRaMock.sol#1024-1056):\n\tExternal calls:\n\t- blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract()) (StakingAuRaMock.sol#1037)\n\t- require(bool)(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0) (StakingAuRaMock.sol#1038)\n\tState variables written after the call(s):\n\t- addressStorage (StakingAuRaMock.sol#1040)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": 1333,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._stake (StakingAuRaMock.sol#1296-1333):\n\tExternal calls:\n\t- poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress) (StakingAuRaMock.sol#1298)\n\t- require(bool)(! validatorSet.isValidatorBanned(poolMiningAddress)) (StakingAuRaMock.sol#1303)\n\t- _addPoolActive(_poolStakingAddress,_poolStakingAddress != validatorSet.unremovableValidator()) (StakingAuRaMock.sol#1326)\n\tState variables written after the call(s):\n\t- intArrayStorage (StakingAuRaMock.sol#1332)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": 1370,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n\n\n        // How much can `staker` withdraw from `_poolStakingAddress` at the moment?\n\n        require(_amount <= maxWithdrawAllowed(_poolStakingAddress, _staker));\n\n\n\n        uint256 currentStakeAmount = stakeAmount(_poolStakingAddress, _staker);\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, _staker);\n\n        uint256 resultingStakeAmount = currentStakeAmount.sub(alreadyOrderedAmount).sub(_amount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 minAllowedStake = (_poolStakingAddress == _staker) ? getCandidateMinStake() : getDelegatorMinStake();\n\n        require(resultingStakeAmount == 0 || resultingStakeAmount >= minAllowedStake);\n\n\n\n        _setStakeAmount(_poolStakingAddress, _staker, currentStakeAmount.sub(_amount));\n\n        uint256 amountByEpoch = stakeAmountByCurrentEpoch(_poolStakingAddress, _staker);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            amountByEpoch >= _amount ? amountByEpoch - _amount : 0\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(_amount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._withdraw (StakingAuRaMock.sol#1340-1370):\n\tExternal calls:\n\t- require(bool)(_amount <= maxWithdrawAllowed(_poolStakingAddress,_staker)) (StakingAuRaMock.sol#1345)\n\tState variables written after the call(s):\n\t- uintStorage (StakingAuRaMock.sol#1356)\n\t- uintStorage (StakingAuRaMock.sol#1363)\n\t- uintStorage (StakingAuRaMock.sol#1358-1362)\n\t- uintStorage (StakingAuRaMock.sol#1358-1362)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": 1370,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n\n\n        // How much can `staker` withdraw from `_poolStakingAddress` at the moment?\n\n        require(_amount <= maxWithdrawAllowed(_poolStakingAddress, _staker));\n\n\n\n        uint256 currentStakeAmount = stakeAmount(_poolStakingAddress, _staker);\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, _staker);\n\n        uint256 resultingStakeAmount = currentStakeAmount.sub(alreadyOrderedAmount).sub(_amount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 minAllowedStake = (_poolStakingAddress == _staker) ? getCandidateMinStake() : getDelegatorMinStake();\n\n        require(resultingStakeAmount == 0 || resultingStakeAmount >= minAllowedStake);\n\n\n\n        _setStakeAmount(_poolStakingAddress, _staker, currentStakeAmount.sub(_amount));\n\n        uint256 amountByEpoch = stakeAmountByCurrentEpoch(_poolStakingAddress, _staker);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            amountByEpoch >= _amount ? amountByEpoch - _amount : 0\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(_amount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._withdraw (StakingAuRaMock.sol#1340-1370):\n\tExternal calls:\n\t- require(bool)(_amount <= maxWithdrawAllowed(_poolStakingAddress,_staker)) (StakingAuRaMock.sol#1345)\n\t- _withdrawCheckPool(_poolStakingAddress,_staker) (StakingAuRaMock.sol#1366)\n\tState variables written after the call(s):\n\t- intArrayStorage (StakingAuRaMock.sol#1369)\n\t- intStorage (StakingAuRaMock.sol#1369)\n\t- uintStorage (StakingAuRaMock.sol#1366)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n        uint256 epoch = stakingEpoch();\n\n        address payable staker = msg.sender;\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(epoch > orderWithdrawEpoch(_poolStakingAddress, staker));\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        uint256 claimAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n        require(claimAmount != 0);\n\n\n\n        uint256 resultingStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(claimAmount);\n\n\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, 0);\n\n        _setOrderedWithdrawAmountTotal(\n\n            _poolStakingAddress,\n\n            orderedWithdrawAmountTotal(_poolStakingAddress).sub(claimAmount)\n\n        );\n\n        _setStakeAmount(_poolStakingAddress, staker, resultingStakeAmount);\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(claimAmount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, claimAmount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(claimAmount);\n\n        }\n\n\n\n        emit Claimed(_poolStakingAddress, staker, epoch, claimAmount);\n",
                    "message": "Reentrancy in StakingBase.claimOrderedWithdraw (StakingAuRaMock.sol#480-517):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingAuRaMock.sol#487)\n\tState variables written after the call(s):\n\t- uintStorage (StakingAuRaMock.sol#494)\n\t- uintStorage (StakingAuRaMock.sol#495-498)\n\t- uintStorage (StakingAuRaMock.sol#499)\n\t- uintStorage (StakingAuRaMock.sol#500)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n        uint256 epoch = stakingEpoch();\n\n        address payable staker = msg.sender;\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(epoch > orderWithdrawEpoch(_poolStakingAddress, staker));\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        uint256 claimAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n        require(claimAmount != 0);\n\n\n\n        uint256 resultingStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(claimAmount);\n\n\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, 0);\n\n        _setOrderedWithdrawAmountTotal(\n\n            _poolStakingAddress,\n\n            orderedWithdrawAmountTotal(_poolStakingAddress).sub(claimAmount)\n\n        );\n\n        _setStakeAmount(_poolStakingAddress, staker, resultingStakeAmount);\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(claimAmount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, claimAmount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(claimAmount);\n\n        }\n\n\n\n        emit Claimed(_poolStakingAddress, staker, epoch, claimAmount);\n",
                    "message": "Reentrancy in StakingBase.claimOrderedWithdraw (StakingAuRaMock.sol#480-517):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingAuRaMock.sol#487)\n\t- _withdrawCheckPool(_poolStakingAddress,staker) (StakingAuRaMock.sol#503)\n\tState variables written after the call(s):\n\t- intArrayStorage (StakingAuRaMock.sol#506)\n\t- intStorage (StakingAuRaMock.sol#506)\n\t- uintStorage (StakingAuRaMock.sol#503)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1511,
                    "vulnerability_to_line": 1537,
                    "vulnerability_code": "    function initialize(\n\n        address _validatorSetContract,\n\n        address[] calldata _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        uint256 _stakingEpochDuration,\n\n        uint256 _stakingEpochStartBlock,\n\n        uint256 _stakeWithdrawDisallowPeriod,\n\n        bool _erc20Restricted\n\n    ) external {\n\n        require(_stakingEpochDuration != 0);\n\n        require(_stakingEpochDuration > _stakeWithdrawDisallowPeriod);\n\n        IValidatorSet validatorSet = IValidatorSet(_validatorSetContract);\n\n        IBlockReward blockReward = IBlockReward(validatorSet.blockRewardContract());\n\n        require(_stakingEpochDuration >= validatorSet.MAX_VALIDATORS() * blockReward.DELEGATORS_ALIQUOT() * 2 + 1);\n\n        require(_stakeWithdrawDisallowPeriod != 0);\n\n        super._initialize(\n\n            _validatorSetContract,\n\n            _initialStakingAddresses,\n\n            _delegatorMinStake,\n\n            _candidateMinStake,\n\n            _erc20Restricted\n\n        );\n\n        uintStorage[STAKING_EPOCH_DURATION] = _stakingEpochDuration;\n\n        uintStorage[STAKE_WITHDRAW_DISALLOW_PERIOD] = _stakeWithdrawDisallowPeriod;\n\n        uintStorage[STAKING_EPOCH_START_BLOCK] = _stakingEpochStartBlock;\n",
                    "message": "Reentrancy in StakingAuRa.initialize (StakingAuRaMock.sol#1511-1537):\n\tExternal calls:\n\t- blockReward = IBlockReward(validatorSet.blockRewardContract()) (StakingAuRaMock.sol#1524)\n\t- require(bool)(_stakingEpochDuration >= validatorSet.MAX_VALIDATORS() * blockReward.DELEGATORS_ALIQUOT() * 2 + 1) (StakingAuRaMock.sol#1525)\n\t- super._initialize(_validatorSetContract,_initialStakingAddresses,_delegatorMinStake,_candidateMinStake,_erc20Restricted) (StakingAuRaMock.sol#1527-1533)\n\tState variables written after the call(s):\n\t- uintStorage (StakingAuRaMock.sol#1534)\n\t- uintStorage (StakingAuRaMock.sol#1535)\n\t- uintStorage (StakingAuRaMock.sol#1536)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": 362,
                    "vulnerability_code": "    function moveStake(\n\n        address _fromPoolStakingAddress,\n\n        address _toPoolStakingAddress,\n\n        uint256 _amount\n\n    ) external gasPriceIsValid onlyInitialized {\n\n        require(_fromPoolStakingAddress != _toPoolStakingAddress);\n\n        address staker = msg.sender;\n\n        _withdraw(_fromPoolStakingAddress, staker, _amount);\n\n        _stake(_toPoolStakingAddress, staker, _amount);\n\n        emit StakeMoved(_fromPoolStakingAddress, _toPoolStakingAddress, staker, stakingEpoch(), _amount);\n",
                    "message": "Reentrancy in StakingBase.moveStake (StakingAuRaMock.sol#352-362):\n\tExternal calls:\n\t- _withdraw(_fromPoolStakingAddress,staker,_amount) (StakingAuRaMock.sol#359)\n\t- _stake(_toPoolStakingAddress,staker,_amount) (StakingAuRaMock.sol#360)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingAuRaMock.sol#360)\n\t- intArrayStorage (StakingAuRaMock.sol#360)\n\t- intStorage (StakingAuRaMock.sol#360)\n\t- uintStorage (StakingAuRaMock.sol#360)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
                    "message": "Reentrancy in StakingBase.orderWithdraw (StakingAuRaMock.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingAuRaMock.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingAuRaMock.sol#416)\n\tState variables written after the call(s):\n\t- uintStorage (StakingAuRaMock.sol#428)\n\t- uintStorage (StakingAuRaMock.sol#450)\n\t- uintStorage (StakingAuRaMock.sol#453)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
                    "message": "Reentrancy in StakingBase.orderWithdraw (StakingAuRaMock.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingAuRaMock.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingAuRaMock.sol#416)\n\t- unremovableStakingAddress = validatorSetContract.unremovableValidator() (StakingAuRaMock.sol#436)\n\tState variables written after the call(s):\n\t- uintStorage (StakingAuRaMock.sol#440)\n\t- uintStorage (StakingAuRaMock.sol#443)\n\t- uintStorage (StakingAuRaMock.sol#464)\n\t- uintStorage (StakingAuRaMock.sol#469)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": 344,
                    "vulnerability_code": "    function removeMyPool() external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address stakingAddress = msg.sender;\n\n        address miningAddress = validatorSet.miningByStakingAddress(stakingAddress);\n\n        // initial validator cannot remove their pool during the initial staking epoch\n\n        require(stakingEpoch() > 0 || !validatorSet.isValidator(miningAddress));\n\n        require(stakingAddress != validatorSet.unremovableValidator());\n\n        _removePool(stakingAddress);\n",
                    "message": "Reentrancy in StakingBase.removeMyPool (StakingAuRaMock.sol#336-344):\n\tExternal calls:\n\t- miningAddress = validatorSet.miningByStakingAddress(stakingAddress) (StakingAuRaMock.sol#339)\n\t- require(bool)(stakingEpoch() > 0 || ! validatorSet.isValidator(miningAddress)) (StakingAuRaMock.sol#341)\n\t- require(bool)(stakingAddress != validatorSet.unremovableValidator()) (StakingAuRaMock.sol#342)\n\tState variables written after the call(s):\n\t- uintStorage (StakingAuRaMock.sol#343)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
                    "message": "StakingBase.orderWithdraw.validatorSetContract (local variable @ StakingAuRaMock.sol#407) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingAuRaMock.sol#853-855)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
                    "message": "StakingBase.claimOrderedWithdraw.validatorSetContract (local variable @ StakingAuRaMock.sol#481) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingAuRaMock.sol#853-855)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 633,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
                    "message": "StakingBase.maxWithdrawAllowed.validatorSetContract (local variable @ StakingAuRaMock.sol#633) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingAuRaMock.sol#853-855)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
                    "message": "StakingBase.maxWithdrawOrderAllowed.validatorSetContract (local variable @ StakingAuRaMock.sol#665) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingAuRaMock.sol#853-855)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1024,
                    "vulnerability_to_line": 1056,
                    "vulnerability_code": "    function _initialize(\n\n        address _validatorSetContract,\n\n        address[] memory _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        bool _erc20Restricted\n\n    ) internal {\n\n        require(!isInitialized()); // initialization can only be done once\n\n        require(_validatorSetContract != address(0));\n\n        require(_initialStakingAddresses.length > 0);\n\n        require(_delegatorMinStake != 0);\n\n        require(_candidateMinStake != 0);\n\n\n\n        IBlockReward blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract());\n\n        require(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0);\n\n\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSetContract;\n\n\n\n        address unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator();\n\n\n\n        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n\n            require(_initialStakingAddresses[i] != address(0));\n\n            _addPoolActive(_initialStakingAddresses[i], false);\n\n            if (_initialStakingAddresses[i] != unremovableStakingAddress) {\n\n                _addPoolToBeRemoved(_initialStakingAddresses[i]);\n\n            }\n\n        }\n\n\n\n        _setDelegatorMinStake(_delegatorMinStake);\n\n        _setCandidateMinStake(_candidateMinStake);\n\n\n\n        boolStorage[ERC20_RESTRICTED] = _erc20Restricted;\n",
                    "message": "Reentrancy in StakingBase._initialize (StakingAuRaMock.sol#1024-1056):\n\tExternal calls:\n\t- blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract()) (StakingAuRaMock.sol#1037)\n\t- require(bool)(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0) (StakingAuRaMock.sol#1038)\n\t- unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator() (StakingAuRaMock.sol#1042)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingAuRaMock.sol#1046)\n\t- addressArrayStorage (StakingAuRaMock.sol#1048)\n\t- boolStorage (StakingAuRaMock.sol#1055)\n\t- intArrayStorage (StakingAuRaMock.sol#1046)\n\t- intArrayStorage (StakingAuRaMock.sol#1048)\n\t- intStorage (StakingAuRaMock.sol#1048)\n\t- uintStorage (StakingAuRaMock.sol#1046)\n\t- uintStorage (StakingAuRaMock.sol#1048)\n\t- uintStorage (StakingAuRaMock.sol#1052)\n\t- uintStorage (StakingAuRaMock.sol#1053)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": 1333,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._stake (StakingAuRaMock.sol#1296-1333):\n\tExternal calls:\n\t- poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress) (StakingAuRaMock.sol#1298)\n\t- require(bool)(! validatorSet.isValidatorBanned(poolMiningAddress)) (StakingAuRaMock.sol#1303)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingAuRaMock.sol#1329)\n\t- uintStorage (StakingAuRaMock.sol#1316)\n\t- uintStorage (StakingAuRaMock.sol#1317-1321)\n\t- uintStorage (StakingAuRaMock.sol#1322)\n\t- uintStorage (StakingAuRaMock.sol#1329)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": 1333,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._stake (StakingAuRaMock.sol#1296-1333):\n\tExternal calls:\n\t- poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress) (StakingAuRaMock.sol#1298)\n\t- require(bool)(! validatorSet.isValidatorBanned(poolMiningAddress)) (StakingAuRaMock.sol#1303)\n\t- _addPoolActive(_poolStakingAddress,_poolStakingAddress != validatorSet.unremovableValidator()) (StakingAuRaMock.sol#1326)\n\tState variables written after the call(s):\n\t- intStorage (StakingAuRaMock.sol#1332)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": 1391,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n\n        if (_staker == _poolStakingAddress) {\n\n            IValidatorSet validatorSet = validatorSetContract();\n\n            address unremovableStakingAddress = validatorSet.unremovableValidator();\n\n\n\n            if (_poolStakingAddress != unremovableStakingAddress) {\n\n                if (validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress))) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                } else {\n\n                    _removePool(_poolStakingAddress);\n\n                }\n\n            }\n\n        } else {\n\n            _removePoolDelegator(_poolStakingAddress, _staker);\n\n        }\n",
                    "message": "Reentrancy in StakingBase._withdrawCheckPool (StakingAuRaMock.sol#1376-1391):\n\tExternal calls:\n\t- unremovableStakingAddress = validatorSet.unremovableValidator() (StakingAuRaMock.sol#1379)\n\t- validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress)) (StakingAuRaMock.sol#1382-1386)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingAuRaMock.sol#1383)\n\t- intArrayStorage (StakingAuRaMock.sol#1383)\n\t- intStorage (StakingAuRaMock.sol#1383)\n\t- uintStorage (StakingAuRaMock.sol#1383)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": 1391,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n\n        if (_staker == _poolStakingAddress) {\n\n            IValidatorSet validatorSet = validatorSetContract();\n\n            address unremovableStakingAddress = validatorSet.unremovableValidator();\n\n\n\n            if (_poolStakingAddress != unremovableStakingAddress) {\n\n                if (validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress))) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                } else {\n\n                    _removePool(_poolStakingAddress);\n\n                }\n\n            }\n\n        } else {\n\n            _removePoolDelegator(_poolStakingAddress, _staker);\n\n        }\n",
                    "message": "Reentrancy in StakingBase._withdrawCheckPool (StakingAuRaMock.sol#1376-1391):\n\tExternal calls:\n\t- unremovableStakingAddress = validatorSet.unremovableValidator() (StakingAuRaMock.sol#1379)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingAuRaMock.sol#1385)\n\t- intArrayStorage (StakingAuRaMock.sol#1385)\n\t- intStorage (StakingAuRaMock.sol#1385)\n\t- uintStorage (StakingAuRaMock.sol#1385)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1511,
                    "vulnerability_to_line": 1537,
                    "vulnerability_code": "    function initialize(\n\n        address _validatorSetContract,\n\n        address[] calldata _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        uint256 _stakingEpochDuration,\n\n        uint256 _stakingEpochStartBlock,\n\n        uint256 _stakeWithdrawDisallowPeriod,\n\n        bool _erc20Restricted\n\n    ) external {\n\n        require(_stakingEpochDuration != 0);\n\n        require(_stakingEpochDuration > _stakeWithdrawDisallowPeriod);\n\n        IValidatorSet validatorSet = IValidatorSet(_validatorSetContract);\n\n        IBlockReward blockReward = IBlockReward(validatorSet.blockRewardContract());\n\n        require(_stakingEpochDuration >= validatorSet.MAX_VALIDATORS() * blockReward.DELEGATORS_ALIQUOT() * 2 + 1);\n\n        require(_stakeWithdrawDisallowPeriod != 0);\n\n        super._initialize(\n\n            _validatorSetContract,\n\n            _initialStakingAddresses,\n\n            _delegatorMinStake,\n\n            _candidateMinStake,\n\n            _erc20Restricted\n\n        );\n\n        uintStorage[STAKING_EPOCH_DURATION] = _stakingEpochDuration;\n\n        uintStorage[STAKE_WITHDRAW_DISALLOW_PERIOD] = _stakeWithdrawDisallowPeriod;\n\n        uintStorage[STAKING_EPOCH_START_BLOCK] = _stakingEpochStartBlock;\n",
                    "message": "Reentrancy in StakingAuRa.initialize (StakingAuRaMock.sol#1511-1537):\n\tExternal calls:\n\t- blockReward = IBlockReward(validatorSet.blockRewardContract()) (StakingAuRaMock.sol#1524)\n\t- require(bool)(_stakingEpochDuration >= validatorSet.MAX_VALIDATORS() * blockReward.DELEGATORS_ALIQUOT() * 2 + 1) (StakingAuRaMock.sol#1525)\n\t- super._initialize(_validatorSetContract,_initialStakingAddresses,_delegatorMinStake,_candidateMinStake,_erc20Restricted) (StakingAuRaMock.sol#1527-1533)\n\tState variables written after the call(s):\n\t- boolStorage (StakingAuRaMock.sol#1527-1533)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
                    "message": "Reentrancy in StakingBase.orderWithdraw (StakingAuRaMock.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingAuRaMock.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingAuRaMock.sol#416)\n\t- unremovableStakingAddress = validatorSetContract.unremovableValidator() (StakingAuRaMock.sol#436)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingAuRaMock.sol#440)\n\t- addressArrayStorage (StakingAuRaMock.sol#443)\n\t- intArrayStorage (StakingAuRaMock.sol#440)\n\t- intArrayStorage (StakingAuRaMock.sol#443)\n\t- intArrayStorage (StakingAuRaMock.sol#472)\n\t- intStorage (StakingAuRaMock.sol#440)\n\t- intStorage (StakingAuRaMock.sol#472)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
                    "message": "Reentrancy in StakingBase.orderWithdraw (StakingAuRaMock.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingAuRaMock.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingAuRaMock.sol#416)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingAuRaMock.sol#450)\n\t- addressArrayStorage (StakingAuRaMock.sol#453)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": 344,
                    "vulnerability_code": "    function removeMyPool() external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address stakingAddress = msg.sender;\n\n        address miningAddress = validatorSet.miningByStakingAddress(stakingAddress);\n\n        // initial validator cannot remove their pool during the initial staking epoch\n\n        require(stakingEpoch() > 0 || !validatorSet.isValidator(miningAddress));\n\n        require(stakingAddress != validatorSet.unremovableValidator());\n\n        _removePool(stakingAddress);\n",
                    "message": "Reentrancy in StakingBase.removeMyPool (StakingAuRaMock.sol#336-344):\n\tExternal calls:\n\t- miningAddress = validatorSet.miningByStakingAddress(stakingAddress) (StakingAuRaMock.sol#339)\n\t- require(bool)(stakingEpoch() > 0 || ! validatorSet.isValidator(miningAddress)) (StakingAuRaMock.sol#341)\n\t- require(bool)(stakingAddress != validatorSet.unremovableValidator()) (StakingAuRaMock.sol#342)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingAuRaMock.sol#343)\n\t- intArrayStorage (StakingAuRaMock.sol#343)\n\t- intStorage (StakingAuRaMock.sol#343)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (StakingAuRaMock.sol#97)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": 598,
                    "vulnerability_code": "    function erc20Restricted() public view returns(bool) {\n\n        return boolStorage[ERC20_RESTRICTED];\n",
                    "message": "StakingBase.erc20Restricted (StakingAuRaMock.sol#596-598) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function erc20Restricted() external view returns(bool);\n",
                    "message": "IStaking.erc20Restricted (StakingAuRaMock.sol#41) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "IStaking.poolDelegators (StakingAuRaMock.sol#46) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": 735,
                    "vulnerability_code": "    function poolDelegators(address _poolStakingAddress) public view returns(address[] memory) {\n\n        return addressArrayStorage[keccak256(abi.encode(POOL_DELEGATORS, _poolStakingAddress))];\n",
                    "message": "StakingBase.poolDelegators (StakingAuRaMock.sol#733-735) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": 695,
                    "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n\n        return false;\n",
                    "message": "StakingBase.onTokenTransfer (StakingAuRaMock.sol#693-695) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 741,
                    "vulnerability_to_line": 743,
                    "vulnerability_code": "    function poolDelegatorsInactive(address _poolStakingAddress) public view returns(address[] memory) {\n\n        return addressArrayStorage[keccak256(abi.encode(POOL_DELEGATORS_INACTIVE, _poolStakingAddress))];\n",
                    "message": "StakingBase.poolDelegatorsInactive (StakingAuRaMock.sol#741-743) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingEpochEndBlock() external view returns(uint256);\n",
                    "message": "IStakingAuRa.stakingEpochEndBlock (StakingAuRaMock.sol#1457) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1574,
                    "vulnerability_to_line": 1577,
                    "vulnerability_code": "    function stakingEpochEndBlock() public view returns(uint256) {\n\n        uint256 startBlock = stakingEpochStartBlock();\n\n        return startBlock + stakingEpochDuration() - (startBlock == 0 ? 0 : 1);\n",
                    "message": "StakingAuRa.stakingEpochEndBlock (StakingAuRaMock.sol#1574-1577) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1595,
                    "vulnerability_to_line": 1597,
                    "vulnerability_code": "    function addPoolActiveMock(address _stakingAddress) public {\n\n        _addPoolActive(_stakingAddress, true);\n",
                    "message": "StakingAuRaMock.addPoolActiveMock (StakingAuRaMock.sol#1595-1597) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1599,
                    "vulnerability_to_line": 1601,
                    "vulnerability_code": "    function addPoolInactiveMock(address _stakingAddress) public {\n\n        _addPoolInactive(_stakingAddress);\n",
                    "message": "StakingAuRaMock.addPoolInactiveMock (StakingAuRaMock.sol#1599-1601) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1603,
                    "vulnerability_to_line": 1605,
                    "vulnerability_code": "    function setCurrentBlockNumber(uint256 _blockNumber) public {\n\n        uintStorage[keccak256(\"currentBlockNumber\")] = _blockNumber;\n",
                    "message": "StakingAuRaMock.setCurrentBlockNumber (StakingAuRaMock.sol#1603-1605) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1607,
                    "vulnerability_to_line": 1609,
                    "vulnerability_code": "    function setErc20TokenContractMock(address _erc20TokenContract) public {\n\n        addressStorage[ERC20_TOKEN_CONTRACT] = _erc20TokenContract;\n",
                    "message": "StakingAuRaMock.setErc20TokenContractMock (StakingAuRaMock.sol#1607-1609) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1611,
                    "vulnerability_to_line": 1613,
                    "vulnerability_code": "    function setErc20Restricted(bool _erc20Restricted) public {\n\n        boolStorage[ERC20_RESTRICTED] = _erc20Restricted;\n",
                    "message": "StakingAuRaMock.setErc20Restricted (StakingAuRaMock.sol#1611-1613) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1615,
                    "vulnerability_to_line": 1617,
                    "vulnerability_code": "    function setStakeAmountTotal(address _poolStakingAddress, uint256 _amount) public {\n\n        _setStakeAmountTotal(_poolStakingAddress, _amount);\n",
                    "message": "StakingAuRaMock.setStakeAmountTotal (StakingAuRaMock.sol#1615-1617) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1619,
                    "vulnerability_to_line": 1621,
                    "vulnerability_code": "    function setValidatorSetAddress(address _validatorSetAddress) public {\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSetAddress;\n",
                    "message": "StakingAuRaMock.setValidatorSetAddress (StakingAuRaMock.sol#1619-1621) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in StakingAuRaMock.sol:\n\t- pragma solidity0.5.9 (StakingAuRaMock.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRaMock.sol#17): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRaMock.sol#34): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRaMock.sol#54): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRaMock.sol#89): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRaMock.sol#120): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRaMock.sol#138): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRaMock.sol#177): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRaMock.sol#1440): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRaMock.sol#1462): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRaMock.sol#1589): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address) external;\n",
                    "message": "Parameter '' of IBlockReward.initialize (StakingAuRaMock.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function DELEGATORS_ALIQUOT() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IBlockReward.DELEGATORS_ALIQUOT' (StakingAuRaMock.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IERC20Minting.balanceOf (StakingAuRaMock.sol#29) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
                    "message": "Parameter '' of IStaking.clearUnremovableValidator (StakingAuRaMock.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address) external;\n",
                    "message": "Parameter '' of IStaking.removePool (StakingAuRaMock.sol#40) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "Parameter '' of IStaking.poolDelegators (StakingAuRaMock.sol#46) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (StakingAuRaMock.sol#47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (StakingAuRaMock.sol#47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (StakingAuRaMock.sol#48) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (StakingAuRaMock.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (StakingAuRaMock.sol#60) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (StakingAuRaMock.sol#61) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (StakingAuRaMock.sol#62) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (StakingAuRaMock.sol#63) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (StakingAuRaMock.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (StakingAuRaMock.sol#67) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (StakingAuRaMock.sol#67) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (StakingAuRaMock.sol#74) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (StakingAuRaMock.sol#75) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (StakingAuRaMock.sol#76) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (StakingAuRaMock.sol#77) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (StakingAuRaMock.sol#78) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (StakingAuRaMock.sol#80) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (StakingAuRaMock.sol#83) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (StakingAuRaMock.sol#97) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address _unremovableStakingAddress) external onlyValidatorSetContract {\n",
                    "message": "Parameter '_unremovableStakingAddress' of StakingBase.clearUnremovableValidator (StakingAuRaMock.sol#308) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address _stakingAddress) external onlyValidatorSetContract {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.removePool (StakingAuRaMock.sol#328) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address _poolStakingAddress) public view returns(address[] memory) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegators (StakingAuRaMock.sol#733) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 829,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _poolStakingAddress,\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountMinusOrderedWithdraw (StakingAuRaMock.sol#829) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 830,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _staker\n",
                    "message": "Parameter '_staker' of StakingBase.stakeAmountMinusOrderedWithdraw (StakingAuRaMock.sol#830) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 841,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address _poolStakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountTotalMinusOrderedWithdraw (StakingAuRaMock.sol#841) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _fromPoolStakingAddress,\n",
                    "message": "Parameter '_fromPoolStakingAddress' of StakingBase.moveStake (StakingAuRaMock.sol#353) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _toPoolStakingAddress,\n",
                    "message": "Parameter '_toPoolStakingAddress' of StakingBase.moveStake (StakingAuRaMock.sol#354) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _amount\n",
                    "message": "Parameter '_amount' of StakingBase.moveStake (StakingAuRaMock.sol#355) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stake(address _toPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_toPoolStakingAddress' of StakingBase.stake (StakingAuRaMock.sol#368) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stake(address _toPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_amount' of StakingBase.stake (StakingAuRaMock.sol#368) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeNative(address _toPoolStakingAddress) external gasPriceIsValid onlyInitialized payable {\n",
                    "message": "Parameter '_toPoolStakingAddress' of StakingBase.stakeNative (StakingAuRaMock.sol#375) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function withdraw(address _fromPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_fromPoolStakingAddress' of StakingBase.withdraw (StakingAuRaMock.sol#385) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function withdraw(address _fromPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_amount' of StakingBase.withdraw (StakingAuRaMock.sol#385) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.orderWithdraw (StakingAuRaMock.sol#406) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_amount' of StakingBase.orderWithdraw (StakingAuRaMock.sol#406) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.claimOrderedWithdraw (StakingAuRaMock.sol#480) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErc20TokenContract(address _erc20TokenContract) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_erc20TokenContract' of StakingBase.setErc20TokenContract (StakingAuRaMock.sol#522) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCandidateMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_minStake' of StakingBase.setCandidateMinStake (StakingAuRaMock.sol#531) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setDelegatorMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_minStake' of StakingBase.setDelegatorMinStake (StakingAuRaMock.sol#538) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isPoolActive(address _stakingAddress) public view returns(bool) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.isPoolActive (StakingAuRaMock.sol#623) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function maxWithdrawAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.maxWithdrawAllowed (StakingAuRaMock.sol#632) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function maxWithdrawAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.maxWithdrawAllowed (StakingAuRaMock.sol#632) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function maxWithdrawOrderAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.maxWithdrawOrderAllowed (StakingAuRaMock.sol#664) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function maxWithdrawOrderAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.maxWithdrawOrderAllowed (StakingAuRaMock.sol#664) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n",
                    "message": "Parameter '' of StakingBase.onTokenTransfer (StakingAuRaMock.sol#693) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n",
                    "message": "Parameter '_scope_0' of StakingBase.onTokenTransfer (StakingAuRaMock.sol#693) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n",
                    "message": "Parameter '_scope_1' of StakingBase.onTokenTransfer (StakingAuRaMock.sol#693) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderedWithdrawAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.orderedWithdrawAmount (StakingAuRaMock.sol#701) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderedWithdrawAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.orderedWithdrawAmount (StakingAuRaMock.sol#701) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 708,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderedWithdrawAmountTotal(address _poolStakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.orderedWithdrawAmountTotal (StakingAuRaMock.sol#708) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderWithdrawEpoch(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.orderWithdrawEpoch (StakingAuRaMock.sol#717) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderWithdrawEpoch(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.orderWithdrawEpoch (StakingAuRaMock.sol#717) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 725,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotal(address _poolStakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountTotal (StakingAuRaMock.sol#725) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 741,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorsInactive(address _poolStakingAddress) public view returns(address[] memory) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegatorsInactive (StakingAuRaMock.sol#741) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 751,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegatorIndex (StakingAuRaMock.sol#751) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 751,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
                    "message": "Parameter '_delegator' of StakingBase.poolDelegatorIndex (StakingAuRaMock.sol#751) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegatorInactiveIndex (StakingAuRaMock.sol#761) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
                    "message": "Parameter '_delegator' of StakingBase.poolDelegatorInactiveIndex (StakingAuRaMock.sol#761) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 770,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolIndex(address _stakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.poolIndex (StakingAuRaMock.sol#770) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolInactiveIndex(address _stakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.poolInactiveIndex (StakingAuRaMock.sol#777) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolToBeElectedIndex(address _stakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.poolToBeElectedIndex (StakingAuRaMock.sol#786) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolToBeRemovedIndex(address _stakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.poolToBeRemovedIndex (StakingAuRaMock.sol#795) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmount (StakingAuRaMock.sol#804) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.stakeAmount (StakingAuRaMock.sol#804) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountByCurrentEpoch(address _poolStakingAddress, address _staker)\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountByCurrentEpoch (StakingAuRaMock.sol#813) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountByCurrentEpoch(address _poolStakingAddress, address _staker)\n",
                    "message": "Parameter '_staker' of StakingBase.stakeAmountByCurrentEpoch (StakingAuRaMock.sol#813) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 892,
                    "vulnerability_to_line": 903,
                    "vulnerability_code": "    function _addPoolActive(address _stakingAddress, bool _toBeElected) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS];\n\n        if (!isPoolActive(_stakingAddress)) {\n\n            _setPoolIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n            require(pools.length <= _getMaxCandidates());\n\n        }\n\n        _removePoolInactive(_stakingAddress);\n\n        if (_toBeElected) {\n\n            _addPoolToBeElected(_stakingAddress);\n\n        }\n",
                    "message": "Function 'StakingBase._addPoolActive' (StakingAuRaMock.sol#892-903) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 892,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolActive(address _stakingAddress, bool _toBeElected) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._addPoolActive (StakingAuRaMock.sol#892) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 892,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolActive(address _stakingAddress, bool _toBeElected) internal {\n",
                    "message": "Parameter '_toBeElected' of StakingBase._addPoolActive (StakingAuRaMock.sol#892) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 908,
                    "vulnerability_to_line": 915,
                    "vulnerability_code": "    function _addPoolInactive(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_INACTIVE];\n\n        uint256 index = poolInactiveIndex(_stakingAddress);\n\n        if (index >= pools.length || pools[index] != _stakingAddress) {\n\n            _setPoolInactiveIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n        }\n",
                    "message": "Function 'StakingBase._addPoolInactive' (StakingAuRaMock.sol#908-915) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 908,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolInactive(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._addPoolInactive (StakingAuRaMock.sol#908) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 929,
                    "vulnerability_code": "    function _addPoolToBeElected(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_ELECTED];\n\n        uint256 index = poolToBeElectedIndex(_stakingAddress);\n\n        if (index >= pools.length || pools[index] != _stakingAddress) {\n\n            _setPoolToBeElectedIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n            intArrayStorage[POOLS_LIKELIHOOD].push(0);\n\n        }\n\n        _deletePoolToBeRemoved(_stakingAddress);\n",
                    "message": "Function 'StakingBase._addPoolToBeElected' (StakingAuRaMock.sol#920-929) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolToBeElected(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._addPoolToBeElected (StakingAuRaMock.sol#920) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": 942,
                    "vulnerability_code": "    function _addPoolToBeRemoved(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_REMOVED];\n\n        uint256 index = poolToBeRemovedIndex(_stakingAddress);\n\n        if (index >= pools.length || pools[index] != _stakingAddress) {\n\n            _setPoolToBeRemovedIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n        }\n\n        _deletePoolToBeElected(_stakingAddress);\n",
                    "message": "Function 'StakingBase._addPoolToBeRemoved' (StakingAuRaMock.sol#934-942) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolToBeRemoved(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._addPoolToBeRemoved (StakingAuRaMock.sol#934) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 948,
                    "vulnerability_to_line": 965,
                    "vulnerability_code": "    function _deletePoolToBeElected(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_ELECTED];\n\n        int256[] storage likelihood = intArrayStorage[POOLS_LIKELIHOOD];\n\n        if (pools.length != likelihood.length) return;\n\n        uint256 indexToDelete = poolToBeElectedIndex(_stakingAddress);\n\n        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n\n            intStorage[POOLS_LIKELIHOOD_SUM] -= likelihood[indexToDelete];\n\n            if (intStorage[POOLS_LIKELIHOOD_SUM] < 0) {\n\n                intStorage[POOLS_LIKELIHOOD_SUM] = 0;\n\n            }\n\n            pools[indexToDelete] = pools[pools.length - 1];\n\n            likelihood[indexToDelete] = likelihood[pools.length - 1];\n\n            _setPoolToBeElectedIndex(pools[indexToDelete], indexToDelete);\n\n            _setPoolToBeElectedIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n            likelihood.length--;\n\n        }\n",
                    "message": "Function 'StakingBase._deletePoolToBeElected' (StakingAuRaMock.sol#948-965) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 948,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _deletePoolToBeElected(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._deletePoolToBeElected (StakingAuRaMock.sol#948) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 971,
                    "vulnerability_to_line": 980,
                    "vulnerability_code": "    function _deletePoolToBeRemoved(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_REMOVED];\n\n        uint256 indexToDelete = poolToBeRemovedIndex(_stakingAddress);\n\n        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n\n            pools[indexToDelete] = pools[pools.length - 1];\n\n            _setPoolToBeRemovedIndex(pools[indexToDelete], indexToDelete);\n\n            _setPoolToBeRemovedIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n        }\n",
                    "message": "Function 'StakingBase._deletePoolToBeRemoved' (StakingAuRaMock.sol#971-980) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 971,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _deletePoolToBeRemoved(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._deletePoolToBeRemoved (StakingAuRaMock.sol#971) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 985,
                    "vulnerability_to_line": 1001,
                    "vulnerability_code": "    function _removePool(address _stakingAddress) internal {\n\n        uint256 indexToRemove = poolIndex(_stakingAddress);\n\n        address[] storage pools = addressArrayStorage[POOLS];\n\n        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n\n            pools[indexToRemove] = pools[pools.length - 1];\n\n            _setPoolIndex(pools[indexToRemove], indexToRemove);\n\n            _setPoolIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n        }\n\n        if (stakeAmountTotal(_stakingAddress) != 0) {\n\n            _addPoolInactive(_stakingAddress);\n\n        } else {\n\n            _removePoolInactive(_stakingAddress);\n\n        }\n\n        _deletePoolToBeElected(_stakingAddress);\n\n        _deletePoolToBeRemoved(_stakingAddress);\n",
                    "message": "Function 'StakingBase._removePool' (StakingAuRaMock.sol#985-1001) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 985,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePool(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._removePool (StakingAuRaMock.sol#985) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1006,
                    "vulnerability_to_line": 1015,
                    "vulnerability_code": "    function _removePoolInactive(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_INACTIVE];\n\n        uint256 indexToRemove = poolInactiveIndex(_stakingAddress);\n\n        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n\n            pools[indexToRemove] = pools[pools.length - 1];\n\n            _setPoolInactiveIndex(pools[indexToRemove], indexToRemove);\n\n            _setPoolInactiveIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n        }\n",
                    "message": "Function 'StakingBase._removePoolInactive' (StakingAuRaMock.sol#1006-1015) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1006,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolInactive(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._removePoolInactive (StakingAuRaMock.sol#1006) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1024,
                    "vulnerability_to_line": 1056,
                    "vulnerability_code": "    function _initialize(\n\n        address _validatorSetContract,\n\n        address[] memory _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        bool _erc20Restricted\n\n    ) internal {\n\n        require(!isInitialized()); // initialization can only be done once\n\n        require(_validatorSetContract != address(0));\n\n        require(_initialStakingAddresses.length > 0);\n\n        require(_delegatorMinStake != 0);\n\n        require(_candidateMinStake != 0);\n\n\n\n        IBlockReward blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract());\n\n        require(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0);\n\n\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSetContract;\n\n\n\n        address unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator();\n\n\n\n        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n\n            require(_initialStakingAddresses[i] != address(0));\n\n            _addPoolActive(_initialStakingAddresses[i], false);\n\n            if (_initialStakingAddresses[i] != unremovableStakingAddress) {\n\n                _addPoolToBeRemoved(_initialStakingAddresses[i]);\n\n            }\n\n        }\n\n\n\n        _setDelegatorMinStake(_delegatorMinStake);\n\n        _setCandidateMinStake(_candidateMinStake);\n\n\n\n        boolStorage[ERC20_RESTRICTED] = _erc20Restricted;\n",
                    "message": "Function 'StakingBase._initialize' (StakingAuRaMock.sol#1024-1056) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1025,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _validatorSetContract,\n",
                    "message": "Parameter '_validatorSetContract' of StakingBase._initialize (StakingAuRaMock.sol#1025) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1026,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _initialStakingAddresses,\n",
                    "message": "Parameter '_initialStakingAddresses' of StakingBase._initialize (StakingAuRaMock.sol#1026) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1027,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _delegatorMinStake,\n",
                    "message": "Parameter '_delegatorMinStake' of StakingBase._initialize (StakingAuRaMock.sol#1027) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1028,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _candidateMinStake,\n",
                    "message": "Parameter '_candidateMinStake' of StakingBase._initialize (StakingAuRaMock.sol#1028) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1029,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _erc20Restricted\n",
                    "message": "Parameter '_erc20Restricted' of StakingBase._initialize (StakingAuRaMock.sol#1029) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": 1067,
                    "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n\n        uintStorage[keccak256(abi.encode(ORDER_WITHDRAW_EPOCH, _poolStakingAddress, _staker))] = _stakingEpoch;\n",
                    "message": "Function 'StakingBase._setOrderWithdrawEpoch' (StakingAuRaMock.sol#1065-1067) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setOrderWithdrawEpoch (StakingAuRaMock.sol#1065) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._setOrderWithdrawEpoch (StakingAuRaMock.sol#1065) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n",
                    "message": "Parameter '_stakingEpoch' of StakingBase._setOrderWithdrawEpoch (StakingAuRaMock.sol#1065) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": 1076,
                    "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_DELEGATOR_INDEX, _poolStakingAddress, _delegator))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolDelegatorIndex' (StakingAuRaMock.sol#1074-1076) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setPoolDelegatorIndex (StakingAuRaMock.sol#1074) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._setPoolDelegatorIndex (StakingAuRaMock.sol#1074) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolDelegatorIndex (StakingAuRaMock.sol#1074) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": 1085,
                    "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_DELEGATOR_INACTIVE_INDEX, _poolStakingAddress, _delegator))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolDelegatorInactiveIndex' (StakingAuRaMock.sol#1083-1085) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setPoolDelegatorInactiveIndex (StakingAuRaMock.sol#1083) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._setPoolDelegatorInactiveIndex (StakingAuRaMock.sol#1083) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolDelegatorInactiveIndex (StakingAuRaMock.sol#1083) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1093,
                    "vulnerability_code": "    function _setPoolIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_INDEX, _stakingAddress))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolIndex' (StakingAuRaMock.sol#1091-1093) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._setPoolIndex (StakingAuRaMock.sol#1091) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolIndex (StakingAuRaMock.sol#1091) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1099,
                    "vulnerability_to_line": 1101,
                    "vulnerability_code": "    function _setPoolInactiveIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_INACTIVE_INDEX, _stakingAddress))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolInactiveIndex' (StakingAuRaMock.sol#1099-1101) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1099,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolInactiveIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._setPoolInactiveIndex (StakingAuRaMock.sol#1099) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1099,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolInactiveIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolInactiveIndex (StakingAuRaMock.sol#1099) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1108,
                    "vulnerability_to_line": 1110,
                    "vulnerability_code": "    function _setPoolToBeElectedIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_TO_BE_ELECTED_INDEX, _stakingAddress))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolToBeElectedIndex' (StakingAuRaMock.sol#1108-1110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolToBeElectedIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._setPoolToBeElectedIndex (StakingAuRaMock.sol#1108) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolToBeElectedIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolToBeElectedIndex (StakingAuRaMock.sol#1108) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1117,
                    "vulnerability_to_line": 1119,
                    "vulnerability_code": "    function _setPoolToBeRemovedIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_TO_BE_REMOVED_INDEX, _stakingAddress))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolToBeRemovedIndex' (StakingAuRaMock.sol#1117-1119) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolToBeRemovedIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._setPoolToBeRemovedIndex (StakingAuRaMock.sol#1117) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolToBeRemovedIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolToBeRemovedIndex (StakingAuRaMock.sol#1117) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": 1135,
                    "vulnerability_code": "    function _addPoolDelegator(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS, _poolStakingAddress))\n\n        ];\n\n        if (delegators.length == 0 || delegators[poolDelegatorIndex(_poolStakingAddress, _delegator)] != _delegator) {\n\n            _setPoolDelegatorIndex(_poolStakingAddress, _delegator, delegators.length);\n\n            delegators.push(_delegator);\n\n            require(delegators.length <= MAX_DELEGATORS_PER_POOL);\n\n        }\n\n        _removePoolDelegatorInactive(_poolStakingAddress, _delegator);\n",
                    "message": "Function 'StakingBase._addPoolDelegator' (StakingAuRaMock.sol#1125-1135) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._addPoolDelegator (StakingAuRaMock.sol#1125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._addPoolDelegator (StakingAuRaMock.sol#1125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1141,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function _addPoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS_INACTIVE, _poolStakingAddress))\n\n        ];\n\n        if (\n\n            delegators.length == 0 ||\n\n            delegators[poolDelegatorInactiveIndex(_poolStakingAddress, _delegator)] != _delegator\n\n        ) {\n\n            _setPoolDelegatorInactiveIndex(_poolStakingAddress, _delegator, delegators.length);\n\n            delegators.push(_delegator);\n\n        }\n",
                    "message": "Function 'StakingBase._addPoolDelegatorInactive' (StakingAuRaMock.sol#1141-1152) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._addPoolDelegatorInactive (StakingAuRaMock.sol#1141) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._addPoolDelegatorInactive (StakingAuRaMock.sol#1141) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": 1174,
                    "vulnerability_code": "    function _removePoolDelegator(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS, _poolStakingAddress))\n\n        ];\n\n        uint256 indexToRemove = poolDelegatorIndex(_poolStakingAddress, _delegator);\n\n        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n\n            delegators[indexToRemove] = delegators[delegators.length - 1];\n\n            _setPoolDelegatorIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n\n            _setPoolDelegatorIndex(_poolStakingAddress, _delegator, 0);\n\n            delegators.length--;\n\n        }\n\n        if (stakeAmount(_poolStakingAddress, _delegator) != 0) {\n\n            _addPoolDelegatorInactive(_poolStakingAddress, _delegator);\n\n        } else {\n\n            _removePoolDelegatorInactive(_poolStakingAddress, _delegator);\n\n        }\n",
                    "message": "Function 'StakingBase._removePoolDelegator' (StakingAuRaMock.sol#1158-1174) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._removePoolDelegator (StakingAuRaMock.sol#1158) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._removePoolDelegator (StakingAuRaMock.sol#1158) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1180,
                    "vulnerability_to_line": 1191,
                    "vulnerability_code": "    function _removePoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS_INACTIVE, _poolStakingAddress))\n\n        ];\n\n        uint256 indexToRemove = poolDelegatorInactiveIndex(_poolStakingAddress, _delegator);\n\n        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n\n            delegators[indexToRemove] = delegators[delegators.length - 1];\n\n            _setPoolDelegatorInactiveIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n\n            _setPoolDelegatorInactiveIndex(_poolStakingAddress, _delegator, 0);\n\n            delegators.length--;\n\n        }\n",
                    "message": "Function 'StakingBase._removePoolDelegatorInactive' (StakingAuRaMock.sol#1180-1191) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._removePoolDelegatorInactive (StakingAuRaMock.sol#1180) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._removePoolDelegatorInactive (StakingAuRaMock.sol#1180) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1197,
                    "vulnerability_to_line": 1207,
                    "vulnerability_code": "    function _setLikelihood(address _poolStakingAddress) internal {\n\n        (bool isToBeElected, uint256 index) = _isPoolToBeElected(_poolStakingAddress);\n\n\n\n        if (!isToBeElected) return;\n\n\n\n        int256 oldValue = intArrayStorage[POOLS_LIKELIHOOD][index];\n\n        int256 newValue = int256(stakeAmountTotalMinusOrderedWithdraw(_poolStakingAddress) * 100 / STAKE_UNIT);\n\n\n\n        intArrayStorage[POOLS_LIKELIHOOD][index] = newValue;\n\n        intStorage[POOLS_LIKELIHOOD_SUM] += newValue - oldValue;\n",
                    "message": "Function 'StakingBase._setLikelihood' (StakingAuRaMock.sol#1197-1207) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setLikelihood(address _poolStakingAddress) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setLikelihood (StakingAuRaMock.sol#1197) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1214,
                    "vulnerability_to_line": 1216,
                    "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(ORDERED_WITHDRAW_AMOUNT, _poolStakingAddress, _staker))] = _amount;\n",
                    "message": "Function 'StakingBase._setOrderedWithdrawAmount' (StakingAuRaMock.sol#1214-1216) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setOrderedWithdrawAmount (StakingAuRaMock.sol#1214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._setOrderedWithdrawAmount (StakingAuRaMock.sol#1214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._setOrderedWithdrawAmount (StakingAuRaMock.sol#1214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1222,
                    "vulnerability_to_line": 1224,
                    "vulnerability_code": "    function _setOrderedWithdrawAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(ORDERED_WITHDRAW_AMOUNT_TOTAL, _poolStakingAddress))] = _amount;\n",
                    "message": "Function 'StakingBase._setOrderedWithdrawAmountTotal' (StakingAuRaMock.sol#1222-1224) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setOrderedWithdrawAmountTotal (StakingAuRaMock.sol#1222) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._setOrderedWithdrawAmountTotal (StakingAuRaMock.sol#1222) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": 1233,
                    "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(STAKE_AMOUNT, _poolStakingAddress, _staker))] = _amount;\n",
                    "message": "Function 'StakingBase._setStakeAmount' (StakingAuRaMock.sol#1231-1233) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setStakeAmount (StakingAuRaMock.sol#1231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._setStakeAmount (StakingAuRaMock.sol#1231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._setStakeAmount (StakingAuRaMock.sol#1231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1241,
                    "vulnerability_to_line": 1249,
                    "vulnerability_code": "    function _setStakeAmountByCurrentEpoch(\n\n        address _poolStakingAddress,\n\n        address _staker,\n\n        uint256 _amount\n\n    ) internal {\n\n        uintStorage[keccak256(abi.encode(\n\n            STAKE_AMOUNT_BY_EPOCH, _poolStakingAddress, _staker, stakingEpoch()\n\n        ))] = _amount;\n",
                    "message": "Function 'StakingBase._setStakeAmountByCurrentEpoch' (StakingAuRaMock.sol#1241-1249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _poolStakingAddress,\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setStakeAmountByCurrentEpoch (StakingAuRaMock.sol#1242) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _staker,\n",
                    "message": "Parameter '_staker' of StakingBase._setStakeAmountByCurrentEpoch (StakingAuRaMock.sol#1243) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _amount\n",
                    "message": "Parameter '_amount' of StakingBase._setStakeAmountByCurrentEpoch (StakingAuRaMock.sol#1244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1254,
                    "vulnerability_to_line": 1256,
                    "vulnerability_code": "    function _setStakeAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(STAKE_AMOUNT_TOTAL, _poolStakingAddress))] = _amount;\n",
                    "message": "Function 'StakingBase._setStakeAmountTotal' (StakingAuRaMock.sol#1254-1256) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setStakeAmountTotal (StakingAuRaMock.sol#1254) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._setStakeAmountTotal (StakingAuRaMock.sol#1254) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": 1263,
                    "vulnerability_code": "    function _setDelegatorMinStake(uint256 _minStake) internal {\n\n        uintStorage[DELEGATOR_MIN_STAKE] = _minStake * STAKE_UNIT;\n",
                    "message": "Function 'StakingBase._setDelegatorMinStake' (StakingAuRaMock.sol#1261-1263) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setDelegatorMinStake(uint256 _minStake) internal {\n",
                    "message": "Parameter '_minStake' of StakingBase._setDelegatorMinStake (StakingAuRaMock.sol#1261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1268,
                    "vulnerability_to_line": 1270,
                    "vulnerability_code": "    function _setCandidateMinStake(uint256 _minStake) internal {\n\n        uintStorage[CANDIDATE_MIN_STAKE] = _minStake * STAKE_UNIT;\n",
                    "message": "Function 'StakingBase._setCandidateMinStake' (StakingAuRaMock.sol#1268-1270) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCandidateMinStake(uint256 _minStake) internal {\n",
                    "message": "Parameter '_minStake' of StakingBase._setCandidateMinStake (StakingAuRaMock.sol#1268) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1276,
                    "vulnerability_to_line": 1289,
                    "vulnerability_code": "    function _stake(address _toPoolStakingAddress, uint256 _amount) internal {\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            require(msg.value == 0);\n\n        }\n\n        address staker = msg.sender;\n\n        _stake(_toPoolStakingAddress, staker, _amount);\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.stake(staker, _amount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n        }\n\n        emit Staked(_toPoolStakingAddress, staker, stakingEpoch(), _amount);\n",
                    "message": "Function 'StakingBase._stake' (StakingAuRaMock.sol#1276-1289) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _toPoolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_toPoolStakingAddress' of StakingBase._stake (StakingAuRaMock.sol#1276) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _toPoolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._stake (StakingAuRaMock.sol#1276) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": 1333,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Function 'StakingBase._stake' (StakingAuRaMock.sol#1296-1333) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._stake (StakingAuRaMock.sol#1296) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._stake (StakingAuRaMock.sol#1296) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._stake (StakingAuRaMock.sol#1296) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": 1370,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n\n\n        // How much can `staker` withdraw from `_poolStakingAddress` at the moment?\n\n        require(_amount <= maxWithdrawAllowed(_poolStakingAddress, _staker));\n\n\n\n        uint256 currentStakeAmount = stakeAmount(_poolStakingAddress, _staker);\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, _staker);\n\n        uint256 resultingStakeAmount = currentStakeAmount.sub(alreadyOrderedAmount).sub(_amount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 minAllowedStake = (_poolStakingAddress == _staker) ? getCandidateMinStake() : getDelegatorMinStake();\n\n        require(resultingStakeAmount == 0 || resultingStakeAmount >= minAllowedStake);\n\n\n\n        _setStakeAmount(_poolStakingAddress, _staker, currentStakeAmount.sub(_amount));\n\n        uint256 amountByEpoch = stakeAmountByCurrentEpoch(_poolStakingAddress, _staker);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            amountByEpoch >= _amount ? amountByEpoch - _amount : 0\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(_amount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Function 'StakingBase._withdraw' (StakingAuRaMock.sol#1340-1370) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._withdraw (StakingAuRaMock.sol#1340) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._withdraw (StakingAuRaMock.sol#1340) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._withdraw (StakingAuRaMock.sol#1340) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": 1391,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n\n        if (_staker == _poolStakingAddress) {\n\n            IValidatorSet validatorSet = validatorSetContract();\n\n            address unremovableStakingAddress = validatorSet.unremovableValidator();\n\n\n\n            if (_poolStakingAddress != unremovableStakingAddress) {\n\n                if (validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress))) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                } else {\n\n                    _removePool(_poolStakingAddress);\n\n                }\n\n            }\n\n        } else {\n\n            _removePoolDelegator(_poolStakingAddress, _staker);\n\n        }\n",
                    "message": "Function 'StakingBase._withdrawCheckPool' (StakingAuRaMock.sol#1376-1391) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._withdrawCheckPool (StakingAuRaMock.sol#1376) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._withdrawCheckPool (StakingAuRaMock.sol#1376) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1394,
                    "vulnerability_to_line": 1396,
                    "vulnerability_code": "    function _getCurrentBlockNumber() internal view returns(uint256) {\n\n        return block.number;\n",
                    "message": "Function 'StakingBase._getCurrentBlockNumber' (StakingAuRaMock.sol#1394-1396) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1400,
                    "vulnerability_to_line": 1402,
                    "vulnerability_code": "    function _getMaxCandidates() internal pure returns(uint256) {\n\n        return MAX_CANDIDATES;\n",
                    "message": "Function 'StakingBase._getMaxCandidates' (StakingAuRaMock.sol#1400-1402) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1410,
                    "vulnerability_to_line": 1419,
                    "vulnerability_code": "    function _isPoolToBeElected(address _stakingAddress) internal view returns(bool toBeElected, uint256 index) {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_ELECTED];\n\n        if (pools.length != 0) {\n\n            index = poolToBeElectedIndex(_stakingAddress);\n\n            if (pools[index] == _stakingAddress) {\n\n                return (true, index);\n\n            }\n\n        }\n\n        return (false, 0);\n",
                    "message": "Function 'StakingBase._isPoolToBeElected' (StakingAuRaMock.sol#1410-1419) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isPoolToBeElected(address _stakingAddress) internal view returns(bool toBeElected, uint256 index) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._isPoolToBeElected (StakingAuRaMock.sol#1410) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": 1435,
                    "vulnerability_code": "    function _isWithdrawAllowed(address _miningAddress) internal view returns(bool) {\n\n        if (validatorSetContract().isValidatorBanned(_miningAddress)) {\n\n            // No one can withdraw from `_poolStakingAddress` until the ban is expired\n\n            return false;\n\n        }\n\n\n\n        if (!areStakeAndWithdrawAllowed()) {\n\n            return false;\n\n        }\n\n\n\n        return true;\n",
                    "message": "Function 'StakingBase._isWithdrawAllowed' (StakingAuRaMock.sol#1424-1435) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isWithdrawAllowed(address _miningAddress) internal view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of StakingBase._isWithdrawAllowed (StakingAuRaMock.sol#1424) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1445,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IStakingAuRa.initialize (StakingAuRaMock.sol#1445) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_0' of IStakingAuRa.initialize (StakingAuRaMock.sol#1446) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_1' of IStakingAuRa.initialize (StakingAuRaMock.sol#1447) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1448,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_2' of IStakingAuRa.initialize (StakingAuRaMock.sol#1448) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1449,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_3' of IStakingAuRa.initialize (StakingAuRaMock.sol#1449) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_4' of IStakingAuRa.initialize (StakingAuRaMock.sol#1450) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_5' of IStakingAuRa.initialize (StakingAuRaMock.sol#1451) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_6' of IStakingAuRa.initialize (StakingAuRaMock.sol#1452) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingEpochStartBlock(uint256) external;\n",
                    "message": "Parameter '' of IStakingAuRa.setStakingEpochStartBlock (StakingAuRaMock.sol#1454) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _validatorSetContract,\n",
                    "message": "Parameter '_validatorSetContract' of StakingAuRa.initialize (StakingAuRaMock.sol#1512) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
                    "message": "Parameter '_initialStakingAddresses' of StakingAuRa.initialize (StakingAuRaMock.sol#1513) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _delegatorMinStake,\n",
                    "message": "Parameter '_delegatorMinStake' of StakingAuRa.initialize (StakingAuRaMock.sol#1514) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1515,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _candidateMinStake,\n",
                    "message": "Parameter '_candidateMinStake' of StakingAuRa.initialize (StakingAuRaMock.sol#1515) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1516,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpochDuration,\n",
                    "message": "Parameter '_stakingEpochDuration' of StakingAuRa.initialize (StakingAuRaMock.sol#1516) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpochStartBlock,\n",
                    "message": "Parameter '_stakingEpochStartBlock' of StakingAuRa.initialize (StakingAuRaMock.sol#1517) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakeWithdrawDisallowPeriod,\n",
                    "message": "Parameter '_stakeWithdrawDisallowPeriod' of StakingAuRa.initialize (StakingAuRaMock.sol#1518) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1519,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _erc20Restricted\n",
                    "message": "Parameter '_erc20Restricted' of StakingAuRa.initialize (StakingAuRaMock.sol#1519) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingEpochStartBlock(uint256 _blockNumber) external onlyValidatorSetContract {\n",
                    "message": "Parameter '_blockNumber' of StakingAuRa.setStakingEpochStartBlock (StakingAuRaMock.sol#1542) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addPool(uint256 _amount, address _miningAddress) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_amount' of StakingAuRa.addPool (StakingAuRaMock.sol#1478) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addPool(uint256 _amount, address _miningAddress) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_miningAddress' of StakingAuRa.addPool (StakingAuRaMock.sol#1478) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1490,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addPoolNative(address _miningAddress) external gasPriceIsValid onlyInitialized payable {\n",
                    "message": "Parameter '_miningAddress' of StakingAuRa.addPoolNative (StakingAuRaMock.sol#1490) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1625,
                    "vulnerability_to_line": 1627,
                    "vulnerability_code": "    function _getCurrentBlockNumber() internal view returns(uint256) {\n\n        return uintStorage[keccak256(\"currentBlockNumber\")];\n",
                    "message": "Function 'StakingAuRaMock._getCurrentBlockNumber' (StakingAuRaMock.sol#1625-1627) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1629,
                    "vulnerability_to_line": 1631,
                    "vulnerability_code": "    function _getMaxCandidates() internal pure returns(uint256) {\n\n        return 100;\n",
                    "message": "Function 'StakingAuRaMock._getMaxCandidates' (StakingAuRaMock.sol#1629-1631) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addPoolActiveMock(address _stakingAddress) public {\n",
                    "message": "Parameter '_stakingAddress' of StakingAuRaMock.addPoolActiveMock (StakingAuRaMock.sol#1595) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1599,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addPoolInactiveMock(address _stakingAddress) public {\n",
                    "message": "Parameter '_stakingAddress' of StakingAuRaMock.addPoolInactiveMock (StakingAuRaMock.sol#1599) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1603,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCurrentBlockNumber(uint256 _blockNumber) public {\n",
                    "message": "Parameter '_blockNumber' of StakingAuRaMock.setCurrentBlockNumber (StakingAuRaMock.sol#1603) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErc20TokenContractMock(address _erc20TokenContract) public {\n",
                    "message": "Parameter '_erc20TokenContract' of StakingAuRaMock.setErc20TokenContractMock (StakingAuRaMock.sol#1607) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1611,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErc20Restricted(bool _erc20Restricted) public {\n",
                    "message": "Parameter '_erc20Restricted' of StakingAuRaMock.setErc20Restricted (StakingAuRaMock.sol#1611) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1615,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakeAmountTotal(address _poolStakingAddress, uint256 _amount) public {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingAuRaMock.setStakeAmountTotal (StakingAuRaMock.sol#1615) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1615,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakeAmountTotal(address _poolStakingAddress, uint256 _amount) public {\n",
                    "message": "Parameter '_amount' of StakingAuRaMock.setStakeAmountTotal (StakingAuRaMock.sol#1615) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1619,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setValidatorSetAddress(address _validatorSetAddress) public {\n",
                    "message": "Parameter '_validatorSetAddress' of StakingAuRaMock.setValidatorSetAddress (StakingAuRaMock.sol#1619) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (StakingAuRaMock.sol#101) is never used in StakingAuRaMock\nEternalStorage.bytesStorage (StakingAuRaMock.sol#103) is never used in StakingAuRaMock\nEternalStorage.bytes32Storage (StakingAuRaMock.sol#106) is never used in StakingAuRaMock\nEternalStorage.uintArrayStorage (StakingAuRaMock.sol#108) is never used in StakingAuRaMock\nEternalStorage.stringArrayStorage (StakingAuRaMock.sol#109) is never used in StakingAuRaMock\nEternalStorage.bytesArrayStorage (StakingAuRaMock.sol#111) is never used in StakingAuRaMock\nEternalStorage.boolArrayStorage (StakingAuRaMock.sol#112) is never used in StakingAuRaMock\nEternalStorage.bytes32ArrayStorage (StakingAuRaMock.sol#114) is never used in StakingAuRaMock\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 963,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            likelihood.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 978,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 992,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 1013,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 1167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 1467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract StakingAuRa is IStakingAuRa, StakingBase {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_MSGVALUE_EQUALS_ZERO",
                    "vulnerability_from_line": 1279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(msg.value == 0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErc20TokenContract(address _erc20TokenContract) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCandidateMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setDelegatorMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory likelihoods, int256 sum) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isPoolToBeElected(address _stakingAddress) internal view returns(bool toBeElected, uint256 index) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _delegatorMinStake,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1515,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _candidateMinStake,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1516,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpochDuration,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpochStartBlock,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakeWithdrawDisallowPeriod,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1519,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _erc20Restricted\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1521,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingEpochDuration != 0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingEpochDuration > _stakeWithdrawDisallowPeriod);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingEpochDuration > _stakeWithdrawDisallowPeriod);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSet = IValidatorSet(_validatorSetContract);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IBlockReward blockReward = IBlockReward(validatorSet.blockRewardContract());\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingEpochDuration >= validatorSet.MAX_VALIDATORS() * blockReward.DELEGATORS_ALIQUOT() * 2 + 1);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingEpochDuration >= validatorSet.MAX_VALIDATORS() * blockReward.DELEGATORS_ALIQUOT() * 2 + 1);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingEpochDuration >= validatorSet.MAX_VALIDATORS() * blockReward.DELEGATORS_ALIQUOT() * 2 + 1);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingEpochDuration >= validatorSet.MAX_VALIDATORS() * blockReward.DELEGATORS_ALIQUOT() * 2 + 1);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingEpochDuration >= validatorSet.MAX_VALIDATORS() * blockReward.DELEGATORS_ALIQUOT() * 2 + 1);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1526,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakeWithdrawDisallowPeriod != 0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        super._initialize(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _initialStakingAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _candidateMinStake,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[STAKING_EPOCH_DURATION] = _stakingEpochDuration;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1535,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[STAKE_WITHDRAW_DISALLOW_PERIOD] = _stakeWithdrawDisallowPeriod;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[STAKING_EPOCH_START_BLOCK] = _stakingEpochStartBlock;\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/test/mockContracts/BlockRewardAuRaMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = extraLength; i < receivers.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 819,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1009,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1020,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1043,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = from; i < to; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 819,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < DELEGATORS_ALIQUOT; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 641,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (validatorStake != 0 && totalStaked != 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 642,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (validatorHasMore30Per) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 643,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    rewardPercent = REWARD_PERCENT_MULTIPLIER * validatorStake / totalStaked;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    rewardPercent = REWARD_PERCENT_MULTIPLIER * 3 / 10;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (stakingEpoch != 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 805,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                // Accumulate blocks producing statistics for each of the\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 806,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                // active validators during the current staking epoch\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 807,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 808,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 809,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 995,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 996,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                totalReward != 0 && _erc20TokenContract != address(0) ||\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 997,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 998,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                _erc20Restricted\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 999,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1000,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                j = 0;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1002,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    ratio[i] = uintStorage[keccak256(abi.encode(\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1003,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1004,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    ))];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < extraLength; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = extraLength; i < receivers.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            j++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 582,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uintStorage[QUEUE_ER_FIRST]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = from; i < to; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 807,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 819,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1009,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1020,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1043,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = range[1]; i < range[2]; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = range[1]; i < range[2]; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uintStorage[QUEUE_V_FIRST]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < DELEGATORS_ALIQUOT; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "DOCKER_RECEIVED_SIGNAL_20"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner (BlockRewardAuRaMock.sol#80) is never initialized. It is used in:\n"
                },
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": 1138,
                    "vulnerability_code": "    function _distributeRewards(\n\n        IValidatorSet _validatorSetContract,\n\n        address _erc20TokenContract,\n\n        bool _erc20Restricted,\n\n        IStakingAuRa _stakingContract,\n\n        uint256 _stakingEpoch,\n\n        uint256 _rewardPointBlock\n\n    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n\n        uint256 i;\n\n        uint256 j;\n\n\n\n        receivers = new address[](0);\n\n        rewards = new uint256[](0);\n\n        noop = true;\n\n\n\n        if (block.number == _rewardPointBlock - 1) {\n\n            boolStorage[IS_REWARDING] = true;\n\n        } else if (block.number == _rewardPointBlock) {\n\n            address[] memory validators = _validatorSetContract.getValidators();\n\n            uint256[] memory ratio = new uint256[](validators.length);\n\n\n\n            uint256 totalReward;\n\n            bool isRewarding = false;\n\n\n\n            totalReward = uintStorage[BRIDGE_TOKEN_FEE];\n\n\n\n            if (!_erc20Restricted) {\n\n                // Accumulated bridge fee plus token inflation\n\n                uint256 inflationPercent;\n\n                if (_stakingEpoch <= 24) {\n\n                    inflationPercent = 32;\n\n                } else if (_stakingEpoch <= 48) {\n\n                    inflationPercent = 16;\n\n                } else if (_stakingEpoch <= 72) {\n\n                    inflationPercent = 8;\n\n                } else {\n\n                    inflationPercent = 4;\n\n                }\n\n                totalReward += snapshotTotalStakeAmount() * inflationPercent / 4800;\n\n            }\n\n\n\n            if (\n\n                totalReward != 0 && _erc20TokenContract != address(0) ||\n\n                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n\n                _erc20Restricted\n\n            ) {\n\n                j = 0;\n\n                for (i = 0; i < validators.length; i++) {\n\n                    ratio[i] = uintStorage[keccak256(abi.encode(\n\n                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n\n                    ))];\n\n                    j += ratio[i];\n\n                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n\n                }\n\n                if (j != 0) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        ratio[i] = REWARD_PERCENT_MULTIPLIER * ratio[i] / j;\n\n                    }\n\n                }\n\n            }\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_TOKEN_FEE] = 0;\n\n\n\n                totalReward += uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n\n\n\n                if (_erc20TokenContract != address(0)) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        uintStorage[keccak256(abi.encode(\n\n                            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, validators[i]\n\n                        ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    }\n\n                    isRewarding = true;\n\n                }\n\n\n\n                uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            totalReward = uintStorage[BRIDGE_NATIVE_FEE];\n\n\n\n            if (_erc20Restricted) {\n\n                // Accumulated bridge fee plus 2.5% per year coin inflation\n\n                totalReward += _stakingContract.stakingEpochDuration() * 1 ether;\n\n            }\n\n\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_NATIVE_FEE] = 0;\n\n\n\n                totalReward += uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n\n\n\n                for (i = 0; i < validators.length; i++) {\n\n                    uintStorage[keccak256(abi.encode(\n\n                        EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, validators[i]\n\n                    ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                }\n\n                isRewarding = true;\n\n\n\n                uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            if (isRewarding) {\n\n                for (i = 0; i < validators.length; i++) {\n\n                    _enqueueValidator(validators[i]);\n\n                }\n\n                if (validators.length == 0) {\n\n                    boolStorage[IS_REWARDING] = false;\n\n                }\n\n            } else {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            noop = false;\n\n        } else if (block.number > _rewardPointBlock) {\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress == address(0)) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            if (_validatorsQueueSize() == 0) {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            if (_validatorSetContract.isValidatorBanned(_validatorSetContract.miningByStakingAddress(stakingAddress))) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            address[] storage stakers = addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n            uint256[] memory range = new uint256[](3); // array instead of local vars because the stack is too deep\n\n            range[0] = (_validatorsQueueSize() + 1) % DELEGATORS_ALIQUOT; // offset\n\n            range[1] = range[0] * stakers.length / DELEGATORS_ALIQUOT; // from\n\n            range[2] = (range[0] + 1) * stakers.length / DELEGATORS_ALIQUOT; // to\n\n\n\n            if (range[0] == 0) {\n\n                range[2] += stakers.length % DELEGATORS_ALIQUOT;\n\n            } else {\n\n                range[1] += stakers.length % DELEGATORS_ALIQUOT;\n\n            }\n\n\n\n            if (range[1] >= range[2]) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n                SNAPSHOT_REWARD_PERCENTS, stakingAddress\n\n            ))];\n\n            uint256 accrued;\n\n            uint256 poolReward;\n\n\n\n            receivers = new address[](range[2] - range[1]);\n\n            rewards = new uint256[](receivers.length);\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                IERC20Minting(_erc20TokenContract).mintReward(receivers, rewards);\n\n                _subTokenRewardUndistributed(accrued);\n\n                noop = false;\n\n            }\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                _subNativeRewardUndistributed(accrued);\n\n                noop = false;\n\n            } else {\n\n                return (new address[](0), new uint256[](0), noop);\n\n            }\n\n        }\n",
                    "message": "BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#954-1138) uses a dangerous strict equality:\n\t- block.number == _rewardPointBlock - 1\n\t- block.number == _rewardPointBlock\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": 1138,
                    "vulnerability_code": "    function _distributeRewards(\n\n        IValidatorSet _validatorSetContract,\n\n        address _erc20TokenContract,\n\n        bool _erc20Restricted,\n\n        IStakingAuRa _stakingContract,\n\n        uint256 _stakingEpoch,\n\n        uint256 _rewardPointBlock\n\n    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n\n        uint256 i;\n\n        uint256 j;\n\n\n\n        receivers = new address[](0);\n\n        rewards = new uint256[](0);\n\n        noop = true;\n\n\n\n        if (block.number == _rewardPointBlock - 1) {\n\n            boolStorage[IS_REWARDING] = true;\n\n        } else if (block.number == _rewardPointBlock) {\n\n            address[] memory validators = _validatorSetContract.getValidators();\n\n            uint256[] memory ratio = new uint256[](validators.length);\n\n\n\n            uint256 totalReward;\n\n            bool isRewarding = false;\n\n\n\n            totalReward = uintStorage[BRIDGE_TOKEN_FEE];\n\n\n\n            if (!_erc20Restricted) {\n\n                // Accumulated bridge fee plus token inflation\n\n                uint256 inflationPercent;\n\n                if (_stakingEpoch <= 24) {\n\n                    inflationPercent = 32;\n\n                } else if (_stakingEpoch <= 48) {\n\n                    inflationPercent = 16;\n\n                } else if (_stakingEpoch <= 72) {\n\n                    inflationPercent = 8;\n\n                } else {\n\n                    inflationPercent = 4;\n\n                }\n\n                totalReward += snapshotTotalStakeAmount() * inflationPercent / 4800;\n\n            }\n\n\n\n            if (\n\n                totalReward != 0 && _erc20TokenContract != address(0) ||\n\n                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n\n                _erc20Restricted\n\n            ) {\n\n                j = 0;\n\n                for (i = 0; i < validators.length; i++) {\n\n                    ratio[i] = uintStorage[keccak256(abi.encode(\n\n                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n\n                    ))];\n\n                    j += ratio[i];\n\n                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n\n                }\n\n                if (j != 0) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        ratio[i] = REWARD_PERCENT_MULTIPLIER * ratio[i] / j;\n\n                    }\n\n                }\n\n            }\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_TOKEN_FEE] = 0;\n\n\n\n                totalReward += uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n\n\n\n                if (_erc20TokenContract != address(0)) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        uintStorage[keccak256(abi.encode(\n\n                            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, validators[i]\n\n                        ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    }\n\n                    isRewarding = true;\n\n                }\n\n\n\n                uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            totalReward = uintStorage[BRIDGE_NATIVE_FEE];\n\n\n\n            if (_erc20Restricted) {\n\n                // Accumulated bridge fee plus 2.5% per year coin inflation\n\n                totalReward += _stakingContract.stakingEpochDuration() * 1 ether;\n\n            }\n\n\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_NATIVE_FEE] = 0;\n\n\n\n                totalReward += uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n\n\n\n                for (i = 0; i < validators.length; i++) {\n\n                    uintStorage[keccak256(abi.encode(\n\n                        EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, validators[i]\n\n                    ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                }\n\n                isRewarding = true;\n\n\n\n                uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            if (isRewarding) {\n\n                for (i = 0; i < validators.length; i++) {\n\n                    _enqueueValidator(validators[i]);\n\n                }\n\n                if (validators.length == 0) {\n\n                    boolStorage[IS_REWARDING] = false;\n\n                }\n\n            } else {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            noop = false;\n\n        } else if (block.number > _rewardPointBlock) {\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress == address(0)) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            if (_validatorsQueueSize() == 0) {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            if (_validatorSetContract.isValidatorBanned(_validatorSetContract.miningByStakingAddress(stakingAddress))) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            address[] storage stakers = addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n            uint256[] memory range = new uint256[](3); // array instead of local vars because the stack is too deep\n\n            range[0] = (_validatorsQueueSize() + 1) % DELEGATORS_ALIQUOT; // offset\n\n            range[1] = range[0] * stakers.length / DELEGATORS_ALIQUOT; // from\n\n            range[2] = (range[0] + 1) * stakers.length / DELEGATORS_ALIQUOT; // to\n\n\n\n            if (range[0] == 0) {\n\n                range[2] += stakers.length % DELEGATORS_ALIQUOT;\n\n            } else {\n\n                range[1] += stakers.length % DELEGATORS_ALIQUOT;\n\n            }\n\n\n\n            if (range[1] >= range[2]) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n                SNAPSHOT_REWARD_PERCENTS, stakingAddress\n\n            ))];\n\n            uint256 accrued;\n\n            uint256 poolReward;\n\n\n\n            receivers = new address[](range[2] - range[1]);\n\n            rewards = new uint256[](receivers.length);\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                IERC20Minting(_erc20TokenContract).mintReward(receivers, rewards);\n\n                _subTokenRewardUndistributed(accrued);\n\n                noop = false;\n\n            }\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                _subNativeRewardUndistributed(accrued);\n\n                noop = false;\n\n            } else {\n\n                return (new address[](0), new uint256[](0), noop);\n\n            }\n\n        }\n",
                    "message": "Reentrancy in BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#954-1138):\n\tExternal calls:\n\t- validators = _validatorSetContract.getValidators() (BlockRewardAuRaMock.sol#972)\n\t- totalReward += _stakingContract.stakingEpochDuration() * 1000000000000000000 (BlockRewardAuRaMock.sol#1035)\n\tState variables written after the call(s):\n\t- uintStorage (BlockRewardAuRaMock.sol#1039)\n\t- uintStorage (BlockRewardAuRaMock.sol#1043-1047)\n\t- uintStorage (BlockRewardAuRaMock.sol#1044-1046)\n\t- uintStorage (BlockRewardAuRaMock.sol#1050)\n\t- uintStorage (BlockRewardAuRaMock.sol#1055)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": 1138,
                    "vulnerability_code": "    function _distributeRewards(\n\n        IValidatorSet _validatorSetContract,\n\n        address _erc20TokenContract,\n\n        bool _erc20Restricted,\n\n        IStakingAuRa _stakingContract,\n\n        uint256 _stakingEpoch,\n\n        uint256 _rewardPointBlock\n\n    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n\n        uint256 i;\n\n        uint256 j;\n\n\n\n        receivers = new address[](0);\n\n        rewards = new uint256[](0);\n\n        noop = true;\n\n\n\n        if (block.number == _rewardPointBlock - 1) {\n\n            boolStorage[IS_REWARDING] = true;\n\n        } else if (block.number == _rewardPointBlock) {\n\n            address[] memory validators = _validatorSetContract.getValidators();\n\n            uint256[] memory ratio = new uint256[](validators.length);\n\n\n\n            uint256 totalReward;\n\n            bool isRewarding = false;\n\n\n\n            totalReward = uintStorage[BRIDGE_TOKEN_FEE];\n\n\n\n            if (!_erc20Restricted) {\n\n                // Accumulated bridge fee plus token inflation\n\n                uint256 inflationPercent;\n\n                if (_stakingEpoch <= 24) {\n\n                    inflationPercent = 32;\n\n                } else if (_stakingEpoch <= 48) {\n\n                    inflationPercent = 16;\n\n                } else if (_stakingEpoch <= 72) {\n\n                    inflationPercent = 8;\n\n                } else {\n\n                    inflationPercent = 4;\n\n                }\n\n                totalReward += snapshotTotalStakeAmount() * inflationPercent / 4800;\n\n            }\n\n\n\n            if (\n\n                totalReward != 0 && _erc20TokenContract != address(0) ||\n\n                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n\n                _erc20Restricted\n\n            ) {\n\n                j = 0;\n\n                for (i = 0; i < validators.length; i++) {\n\n                    ratio[i] = uintStorage[keccak256(abi.encode(\n\n                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n\n                    ))];\n\n                    j += ratio[i];\n\n                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n\n                }\n\n                if (j != 0) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        ratio[i] = REWARD_PERCENT_MULTIPLIER * ratio[i] / j;\n\n                    }\n\n                }\n\n            }\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_TOKEN_FEE] = 0;\n\n\n\n                totalReward += uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n\n\n\n                if (_erc20TokenContract != address(0)) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        uintStorage[keccak256(abi.encode(\n\n                            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, validators[i]\n\n                        ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    }\n\n                    isRewarding = true;\n\n                }\n\n\n\n                uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            totalReward = uintStorage[BRIDGE_NATIVE_FEE];\n\n\n\n            if (_erc20Restricted) {\n\n                // Accumulated bridge fee plus 2.5% per year coin inflation\n\n                totalReward += _stakingContract.stakingEpochDuration() * 1 ether;\n\n            }\n\n\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_NATIVE_FEE] = 0;\n\n\n\n                totalReward += uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n\n\n\n                for (i = 0; i < validators.length; i++) {\n\n                    uintStorage[keccak256(abi.encode(\n\n                        EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, validators[i]\n\n                    ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                }\n\n                isRewarding = true;\n\n\n\n                uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            if (isRewarding) {\n\n                for (i = 0; i < validators.length; i++) {\n\n                    _enqueueValidator(validators[i]);\n\n                }\n\n                if (validators.length == 0) {\n\n                    boolStorage[IS_REWARDING] = false;\n\n                }\n\n            } else {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            noop = false;\n\n        } else if (block.number > _rewardPointBlock) {\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress == address(0)) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            if (_validatorsQueueSize() == 0) {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            if (_validatorSetContract.isValidatorBanned(_validatorSetContract.miningByStakingAddress(stakingAddress))) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            address[] storage stakers = addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n            uint256[] memory range = new uint256[](3); // array instead of local vars because the stack is too deep\n\n            range[0] = (_validatorsQueueSize() + 1) % DELEGATORS_ALIQUOT; // offset\n\n            range[1] = range[0] * stakers.length / DELEGATORS_ALIQUOT; // from\n\n            range[2] = (range[0] + 1) * stakers.length / DELEGATORS_ALIQUOT; // to\n\n\n\n            if (range[0] == 0) {\n\n                range[2] += stakers.length % DELEGATORS_ALIQUOT;\n\n            } else {\n\n                range[1] += stakers.length % DELEGATORS_ALIQUOT;\n\n            }\n\n\n\n            if (range[1] >= range[2]) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n                SNAPSHOT_REWARD_PERCENTS, stakingAddress\n\n            ))];\n\n            uint256 accrued;\n\n            uint256 poolReward;\n\n\n\n            receivers = new address[](range[2] - range[1]);\n\n            rewards = new uint256[](receivers.length);\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                IERC20Minting(_erc20TokenContract).mintReward(receivers, rewards);\n\n                _subTokenRewardUndistributed(accrued);\n\n                noop = false;\n\n            }\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                _subNativeRewardUndistributed(accrued);\n\n                noop = false;\n\n            } else {\n\n                return (new address[](0), new uint256[](0), noop);\n\n            }\n\n        }\n",
                    "message": "Reentrancy in BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#954-1138):\n\tExternal calls:\n\t- IERC20Minting(_erc20TokenContract).mintReward(receivers,rewards) (BlockRewardAuRaMock.sol#1116)\n\tState variables written after the call(s):\n\t- uintStorage (BlockRewardAuRaMock.sol#1117)\n\t- uintStorage (BlockRewardAuRaMock.sol#1132)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": 279,
                    "vulnerability_code": "    function migrateMintingStatistics(address _bridge, IBlockReward _prevBlockRewardContract) external onlyOwner {\n\n        require(mintedTotally() == 0);\n\n        uint256 prevMinted = _prevBlockRewardContract.mintedTotally();\n\n        uint256 prevMintedByBridge = _prevBlockRewardContract.mintedTotallyByBridge(_bridge);\n\n        require(prevMinted != 0);\n\n        require(prevMintedByBridge != 0);\n\n        uintStorage[MINTED_TOTALLY] = prevMinted;\n\n        uintStorage[keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))] = prevMintedByBridge;\n",
                    "message": "Reentrancy in BlockRewardBase.migrateMintingStatistics (BlockRewardAuRaMock.sol#271-279):\n\tExternal calls:\n\t- prevMinted = _prevBlockRewardContract.mintedTotally() (BlockRewardAuRaMock.sol#273)\n\t- prevMintedByBridge = _prevBlockRewardContract.mintedTotallyByBridge(_bridge) (BlockRewardAuRaMock.sol#274)\n\tState variables written after the call(s):\n\t- uintStorage (BlockRewardAuRaMock.sol#277)\n\t- uintStorage (BlockRewardAuRaMock.sol#278)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": 872,
                    "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
                    "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRaMock.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRaMock.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRaMock.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRaMock.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRaMock.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRaMock.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRaMock.sol#803-809)\n\t- (newStakingEpochHasBegun,poolsToBeElectedLength) = validatorSet.newValidatorSet() (BlockRewardAuRaMock.sol#812)\n\t- newValidatorSet = validatorSet.getPendingValidators() (BlockRewardAuRaMock.sol#817)\n\t- stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]) (BlockRewardAuRaMock.sol#820)\n\tState variables written after the call(s):\n\t- addressArrayStorage (BlockRewardAuRaMock.sol#824)\n\t- addressStorage (BlockRewardAuRaMock.sol#822)\n\t- boolStorage (BlockRewardAuRaMock.sol#830)\n\t- uintArrayStorage (BlockRewardAuRaMock.sol#825)\n\t- uintStorage (BlockRewardAuRaMock.sol#822)\n\t- uintStorage (BlockRewardAuRaMock.sol#829)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": 872,
                    "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
                    "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRaMock.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRaMock.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRaMock.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRaMock.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRaMock.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRaMock.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRaMock.sol#803-809)\n\t- (newStakingEpochHasBegun,poolsToBeElectedLength) = validatorSet.newValidatorSet() (BlockRewardAuRaMock.sol#812)\n\tState variables written after the call(s):\n\t- addressStorage (BlockRewardAuRaMock.sol#842)\n\t- uintStorage (BlockRewardAuRaMock.sol#842)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": 872,
                    "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
                    "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRaMock.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRaMock.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRaMock.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRaMock.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRaMock.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRaMock.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRaMock.sol#803-809)\n\t- (newStakingEpochHasBegun,poolsToBeElectedLength) = validatorSet.newValidatorSet() (BlockRewardAuRaMock.sol#812)\n\t- _setSnapshot(stakingAddress_scope_0,stakingContract,(validatorsQueueSize + 1) % DELEGATORS_ALIQUOT) (BlockRewardAuRaMock.sol#846)\n\tState variables written after the call(s):\n\t- boolStorage (BlockRewardAuRaMock.sol#849)\n\t- uintStorage (BlockRewardAuRaMock.sol#846)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": 872,
                    "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
                    "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRaMock.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRaMock.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRaMock.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRaMock.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRaMock.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRaMock.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRaMock.sol#803-809)\n\t- (newStakingEpochHasBegun,poolsToBeElectedLength) = validatorSet.newValidatorSet() (BlockRewardAuRaMock.sol#812)\n\t- (receiversNative,rewardsNative,noop) = _distributeRewards(validatorSet,stakingContract.erc20TokenContract(),stakingContract.erc20Restricted(),IStakingAuRa(address(stakingContract)),stakingEpoch,rewardPointBlock) (BlockRewardAuRaMock.sol#857-864)\n\tState variables written after the call(s):\n\t- addressStorage (BlockRewardAuRaMock.sol#857-864)\n\t- boolStorage (BlockRewardAuRaMock.sol#857-864)\n\t- uintStorage (BlockRewardAuRaMock.sol#857-864)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": 872,
                    "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
                    "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRaMock.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRaMock.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRaMock.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRaMock.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRaMock.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRaMock.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRaMock.sol#803-809)\n\t- (newStakingEpochHasBegun,poolsToBeElectedLength) = validatorSet.newValidatorSet() (BlockRewardAuRaMock.sol#812)\n\t- newValidatorSet = validatorSet.getPendingValidators() (BlockRewardAuRaMock.sol#817)\n\t- stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]) (BlockRewardAuRaMock.sol#820)\n\t- _setSnapshot(stakingAddress_scope_0,stakingContract,(validatorsQueueSize + 1) % DELEGATORS_ALIQUOT) (BlockRewardAuRaMock.sol#846)\n\t- (receiversNative,rewardsNative,noop) = _distributeRewards(validatorSet,stakingContract.erc20TokenContract(),stakingContract.erc20Restricted(),IStakingAuRa(address(stakingContract)),stakingEpoch,rewardPointBlock) (BlockRewardAuRaMock.sol#857-864)\n\tState variables written after the call(s):\n\t- addressStorage (BlockRewardAuRaMock.sol#871)\n\t- uintStorage (BlockRewardAuRaMock.sol#871)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 960,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _rewardPointBlock\n",
                    "message": "BlockRewardAuRa._distributeRewards._rewardPointBlock (local variable @ BlockRewardAuRaMock.sol#960) shadows:\n\t- BlockRewardAuRa._rewardPointBlock (function @ BlockRewardAuRaMock.sol#1195-1200)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 976,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bool isRewarding = false;\n",
                    "message": "BlockRewardAuRa._distributeRewards.isRewarding (local variable @ BlockRewardAuRaMock.sol#976) shadows:\n\t- BlockRewardBase.isRewarding (function @ BlockRewardAuRaMock.sol#377-379)\n\t- IBlockReward.isRewarding (function @ BlockRewardAuRaMock.sol#9)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": 1138,
                    "vulnerability_code": "    function _distributeRewards(\n\n        IValidatorSet _validatorSetContract,\n\n        address _erc20TokenContract,\n\n        bool _erc20Restricted,\n\n        IStakingAuRa _stakingContract,\n\n        uint256 _stakingEpoch,\n\n        uint256 _rewardPointBlock\n\n    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n\n        uint256 i;\n\n        uint256 j;\n\n\n\n        receivers = new address[](0);\n\n        rewards = new uint256[](0);\n\n        noop = true;\n\n\n\n        if (block.number == _rewardPointBlock - 1) {\n\n            boolStorage[IS_REWARDING] = true;\n\n        } else if (block.number == _rewardPointBlock) {\n\n            address[] memory validators = _validatorSetContract.getValidators();\n\n            uint256[] memory ratio = new uint256[](validators.length);\n\n\n\n            uint256 totalReward;\n\n            bool isRewarding = false;\n\n\n\n            totalReward = uintStorage[BRIDGE_TOKEN_FEE];\n\n\n\n            if (!_erc20Restricted) {\n\n                // Accumulated bridge fee plus token inflation\n\n                uint256 inflationPercent;\n\n                if (_stakingEpoch <= 24) {\n\n                    inflationPercent = 32;\n\n                } else if (_stakingEpoch <= 48) {\n\n                    inflationPercent = 16;\n\n                } else if (_stakingEpoch <= 72) {\n\n                    inflationPercent = 8;\n\n                } else {\n\n                    inflationPercent = 4;\n\n                }\n\n                totalReward += snapshotTotalStakeAmount() * inflationPercent / 4800;\n\n            }\n\n\n\n            if (\n\n                totalReward != 0 && _erc20TokenContract != address(0) ||\n\n                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n\n                _erc20Restricted\n\n            ) {\n\n                j = 0;\n\n                for (i = 0; i < validators.length; i++) {\n\n                    ratio[i] = uintStorage[keccak256(abi.encode(\n\n                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n\n                    ))];\n\n                    j += ratio[i];\n\n                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n\n                }\n\n                if (j != 0) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        ratio[i] = REWARD_PERCENT_MULTIPLIER * ratio[i] / j;\n\n                    }\n\n                }\n\n            }\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_TOKEN_FEE] = 0;\n\n\n\n                totalReward += uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n\n\n\n                if (_erc20TokenContract != address(0)) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        uintStorage[keccak256(abi.encode(\n\n                            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, validators[i]\n\n                        ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    }\n\n                    isRewarding = true;\n\n                }\n\n\n\n                uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            totalReward = uintStorage[BRIDGE_NATIVE_FEE];\n\n\n\n            if (_erc20Restricted) {\n\n                // Accumulated bridge fee plus 2.5% per year coin inflation\n\n                totalReward += _stakingContract.stakingEpochDuration() * 1 ether;\n\n            }\n\n\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_NATIVE_FEE] = 0;\n\n\n\n                totalReward += uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n\n\n\n                for (i = 0; i < validators.length; i++) {\n\n                    uintStorage[keccak256(abi.encode(\n\n                        EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, validators[i]\n\n                    ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                }\n\n                isRewarding = true;\n\n\n\n                uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            if (isRewarding) {\n\n                for (i = 0; i < validators.length; i++) {\n\n                    _enqueueValidator(validators[i]);\n\n                }\n\n                if (validators.length == 0) {\n\n                    boolStorage[IS_REWARDING] = false;\n\n                }\n\n            } else {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            noop = false;\n\n        } else if (block.number > _rewardPointBlock) {\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress == address(0)) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            if (_validatorsQueueSize() == 0) {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            if (_validatorSetContract.isValidatorBanned(_validatorSetContract.miningByStakingAddress(stakingAddress))) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            address[] storage stakers = addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n            uint256[] memory range = new uint256[](3); // array instead of local vars because the stack is too deep\n\n            range[0] = (_validatorsQueueSize() + 1) % DELEGATORS_ALIQUOT; // offset\n\n            range[1] = range[0] * stakers.length / DELEGATORS_ALIQUOT; // from\n\n            range[2] = (range[0] + 1) * stakers.length / DELEGATORS_ALIQUOT; // to\n\n\n\n            if (range[0] == 0) {\n\n                range[2] += stakers.length % DELEGATORS_ALIQUOT;\n\n            } else {\n\n                range[1] += stakers.length % DELEGATORS_ALIQUOT;\n\n            }\n\n\n\n            if (range[1] >= range[2]) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n                SNAPSHOT_REWARD_PERCENTS, stakingAddress\n\n            ))];\n\n            uint256 accrued;\n\n            uint256 poolReward;\n\n\n\n            receivers = new address[](range[2] - range[1]);\n\n            rewards = new uint256[](receivers.length);\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                IERC20Minting(_erc20TokenContract).mintReward(receivers, rewards);\n\n                _subTokenRewardUndistributed(accrued);\n\n                noop = false;\n\n            }\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                _subNativeRewardUndistributed(accrued);\n\n                noop = false;\n\n            } else {\n\n                return (new address[](0), new uint256[](0), noop);\n\n            }\n\n        }\n",
                    "message": "Reentrancy in BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#954-1138):\n\tExternal calls:\n\t- validators = _validatorSetContract.getValidators() (BlockRewardAuRaMock.sol#972)\n\tState variables written after the call(s):\n\t- uintStorage (BlockRewardAuRaMock.sol#1015)\n\t- uintStorage (BlockRewardAuRaMock.sol#1020-1024)\n\t- uintStorage (BlockRewardAuRaMock.sol#1021-1023)\n\t- uintStorage (BlockRewardAuRaMock.sol#1028)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": 1138,
                    "vulnerability_code": "    function _distributeRewards(\n\n        IValidatorSet _validatorSetContract,\n\n        address _erc20TokenContract,\n\n        bool _erc20Restricted,\n\n        IStakingAuRa _stakingContract,\n\n        uint256 _stakingEpoch,\n\n        uint256 _rewardPointBlock\n\n    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n\n        uint256 i;\n\n        uint256 j;\n\n\n\n        receivers = new address[](0);\n\n        rewards = new uint256[](0);\n\n        noop = true;\n\n\n\n        if (block.number == _rewardPointBlock - 1) {\n\n            boolStorage[IS_REWARDING] = true;\n\n        } else if (block.number == _rewardPointBlock) {\n\n            address[] memory validators = _validatorSetContract.getValidators();\n\n            uint256[] memory ratio = new uint256[](validators.length);\n\n\n\n            uint256 totalReward;\n\n            bool isRewarding = false;\n\n\n\n            totalReward = uintStorage[BRIDGE_TOKEN_FEE];\n\n\n\n            if (!_erc20Restricted) {\n\n                // Accumulated bridge fee plus token inflation\n\n                uint256 inflationPercent;\n\n                if (_stakingEpoch <= 24) {\n\n                    inflationPercent = 32;\n\n                } else if (_stakingEpoch <= 48) {\n\n                    inflationPercent = 16;\n\n                } else if (_stakingEpoch <= 72) {\n\n                    inflationPercent = 8;\n\n                } else {\n\n                    inflationPercent = 4;\n\n                }\n\n                totalReward += snapshotTotalStakeAmount() * inflationPercent / 4800;\n\n            }\n\n\n\n            if (\n\n                totalReward != 0 && _erc20TokenContract != address(0) ||\n\n                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n\n                _erc20Restricted\n\n            ) {\n\n                j = 0;\n\n                for (i = 0; i < validators.length; i++) {\n\n                    ratio[i] = uintStorage[keccak256(abi.encode(\n\n                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n\n                    ))];\n\n                    j += ratio[i];\n\n                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n\n                }\n\n                if (j != 0) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        ratio[i] = REWARD_PERCENT_MULTIPLIER * ratio[i] / j;\n\n                    }\n\n                }\n\n            }\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_TOKEN_FEE] = 0;\n\n\n\n                totalReward += uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n\n\n\n                if (_erc20TokenContract != address(0)) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        uintStorage[keccak256(abi.encode(\n\n                            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, validators[i]\n\n                        ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    }\n\n                    isRewarding = true;\n\n                }\n\n\n\n                uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            totalReward = uintStorage[BRIDGE_NATIVE_FEE];\n\n\n\n            if (_erc20Restricted) {\n\n                // Accumulated bridge fee plus 2.5% per year coin inflation\n\n                totalReward += _stakingContract.stakingEpochDuration() * 1 ether;\n\n            }\n\n\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_NATIVE_FEE] = 0;\n\n\n\n                totalReward += uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n\n\n\n                for (i = 0; i < validators.length; i++) {\n\n                    uintStorage[keccak256(abi.encode(\n\n                        EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, validators[i]\n\n                    ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                }\n\n                isRewarding = true;\n\n\n\n                uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            if (isRewarding) {\n\n                for (i = 0; i < validators.length; i++) {\n\n                    _enqueueValidator(validators[i]);\n\n                }\n\n                if (validators.length == 0) {\n\n                    boolStorage[IS_REWARDING] = false;\n\n                }\n\n            } else {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            noop = false;\n\n        } else if (block.number > _rewardPointBlock) {\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress == address(0)) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            if (_validatorsQueueSize() == 0) {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            if (_validatorSetContract.isValidatorBanned(_validatorSetContract.miningByStakingAddress(stakingAddress))) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            address[] storage stakers = addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n            uint256[] memory range = new uint256[](3); // array instead of local vars because the stack is too deep\n\n            range[0] = (_validatorsQueueSize() + 1) % DELEGATORS_ALIQUOT; // offset\n\n            range[1] = range[0] * stakers.length / DELEGATORS_ALIQUOT; // from\n\n            range[2] = (range[0] + 1) * stakers.length / DELEGATORS_ALIQUOT; // to\n\n\n\n            if (range[0] == 0) {\n\n                range[2] += stakers.length % DELEGATORS_ALIQUOT;\n\n            } else {\n\n                range[1] += stakers.length % DELEGATORS_ALIQUOT;\n\n            }\n\n\n\n            if (range[1] >= range[2]) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n                SNAPSHOT_REWARD_PERCENTS, stakingAddress\n\n            ))];\n\n            uint256 accrued;\n\n            uint256 poolReward;\n\n\n\n            receivers = new address[](range[2] - range[1]);\n\n            rewards = new uint256[](receivers.length);\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                IERC20Minting(_erc20TokenContract).mintReward(receivers, rewards);\n\n                _subTokenRewardUndistributed(accrued);\n\n                noop = false;\n\n            }\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                _subNativeRewardUndistributed(accrued);\n\n                noop = false;\n\n            } else {\n\n                return (new address[](0), new uint256[](0), noop);\n\n            }\n\n        }\n",
                    "message": "Reentrancy in BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#954-1138):\n\tExternal calls:\n\t- validators = _validatorSetContract.getValidators() (BlockRewardAuRaMock.sol#972)\n\t- totalReward += _stakingContract.stakingEpochDuration() * 1000000000000000000 (BlockRewardAuRaMock.sol#1035)\n\tState variables written after the call(s):\n\t- addressStorage (BlockRewardAuRaMock.sol#1055)\n\t- boolStorage (BlockRewardAuRaMock.sol#1058)\n\t- boolStorage (BlockRewardAuRaMock.sol#1061)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": 682,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n\n        uint256 validatorStake = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, _stakingAddress);\n\n        uint256 totalStaked = _stakingContract.stakeAmountTotalMinusOrderedWithdraw(_stakingAddress);\n\n        uint256 delegatorsAmount = totalStaked >= validatorStake ? totalStaked - validatorStake : 0;\n\n        bool validatorHasMore30Per = validatorStake * 7 > delegatorsAmount * 3;\n\n\n\n        address[] memory delegators = _stakingContract.poolDelegators(_stakingAddress);\n\n        uint256 rewardPercent;\n\n\n\n        address[] storage stakers = addressArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_STAKERS, _stakingAddress\n\n        ))];\n\n\n\n        uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_REWARD_PERCENTS, _stakingAddress\n\n        ))];\n\n\n\n        if (_offset == 0) {\n\n            // Calculate reward percent for validator\n\n            rewardPercent = 0;\n\n            if (validatorStake != 0 && totalStaked != 0) {\n\n                if (validatorHasMore30Per) {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * validatorStake / totalStaked;\n\n                } else {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * 3 / 10;\n\n                }\n\n            }\n\n            stakers.push(_stakingAddress);\n\n            rewardPercents.push(rewardPercent);\n\n            addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES].push(_stakingAddress);\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] += totalStaked;\n\n        }\n\n\n\n        uint256 from = _offset * delegators.length / DELEGATORS_ALIQUOT;\n\n        uint256 to = (_offset + 1) * delegators.length / DELEGATORS_ALIQUOT;\n\n\n\n        if (_offset == 0) {\n\n            to += delegators.length % DELEGATORS_ALIQUOT;\n\n        } else {\n\n            from += delegators.length % DELEGATORS_ALIQUOT;\n\n        }\n\n\n\n        // Calculate reward percent for each delegator\n\n        for (uint256 i = from; i < to; i++) {\n\n            rewardPercent = 0;\n\n\n\n            if (validatorHasMore30Per) {\n\n                if (totalStaked != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent / totalStaked;\n\n                }\n\n            } else {\n\n                if (delegatorsAmount != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent * 7 / (delegatorsAmount * 10);\n\n                }\n\n            }\n\n\n\n            stakers.push(delegators[i]);\n\n            rewardPercents.push(rewardPercent);\n\n        }\n",
                    "message": "Reentrancy in BlockRewardBase._setSnapshot (BlockRewardAuRaMock.sol#621-682):\n\tExternal calls:\n\t- validatorStake = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress,_stakingAddress) (BlockRewardAuRaMock.sol#622)\n\t- totalStaked = _stakingContract.stakeAmountTotalMinusOrderedWithdraw(_stakingAddress) (BlockRewardAuRaMock.sol#623)\n\t- delegators = _stakingContract.poolDelegators(_stakingAddress) (BlockRewardAuRaMock.sol#627)\n\tState variables written after the call(s):\n\t- addressArrayStorage (BlockRewardAuRaMock.sol#650)\n\t- uintStorage (BlockRewardAuRaMock.sol#651)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": 872,
                    "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
                    "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRaMock.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRaMock.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRaMock.sol#784)\n\tState variables written after the call(s):\n\t- boolStorage (BlockRewardAuRaMock.sol#790)\n\t- boolStorage (BlockRewardAuRaMock.sol#795)\n\t- uintStorage (BlockRewardAuRaMock.sol#788)\n\t- uintStorage (BlockRewardAuRaMock.sol#789)\n\t- uintStorage (BlockRewardAuRaMock.sol#793)\n\t- uintStorage (BlockRewardAuRaMock.sol#794)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": 872,
                    "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
                    "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRaMock.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRaMock.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRaMock.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRaMock.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRaMock.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRaMock.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRaMock.sol#803-809)\n\tState variables written after the call(s):\n\t- uintStorage (BlockRewardAuRaMock.sol#807)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": 872,
                    "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
                    "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRaMock.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRaMock.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRaMock.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRaMock.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRaMock.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRaMock.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRaMock.sol#803-809)\n\t- (newStakingEpochHasBegun,poolsToBeElectedLength) = validatorSet.newValidatorSet() (BlockRewardAuRaMock.sol#812)\n\t- newValidatorSet = validatorSet.getPendingValidators() (BlockRewardAuRaMock.sol#817)\n\t- stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]) (BlockRewardAuRaMock.sol#820)\n\tState variables written after the call(s):\n\t- addressArrayStorage (BlockRewardAuRaMock.sol#828)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (BlockRewardAuRaMock.sol#80)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isRewarding() external view returns(bool);\n",
                    "message": "IBlockReward.isRewarding (BlockRewardAuRaMock.sol#9) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 379,
                    "vulnerability_code": "    function isRewarding() public view returns(bool) {\n\n        return boolStorage[IS_REWARDING];\n",
                    "message": "BlockRewardBase.isRewarding (BlockRewardAuRaMock.sol#377-379) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isSnapshotting() external view returns(bool);\n",
                    "message": "IBlockReward.isSnapshotting (BlockRewardAuRaMock.sol#10) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": 385,
                    "vulnerability_code": "    function isSnapshotting() public view returns(bool) {\n\n        return boolStorage[IS_SNAPSHOTTING];\n",
                    "message": "BlockRewardBase.isSnapshotting (BlockRewardAuRaMock.sol#383-385) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": 420,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))];\n",
                    "message": "BlockRewardBase.mintedTotallyByBridge (BlockRewardAuRaMock.sol#418-420) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) external view returns(uint256);\n",
                    "message": "IBlockReward.mintedTotallyByBridge (BlockRewardAuRaMock.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": 341,
                    "vulnerability_code": "    function blockRewardContractId() public pure returns(bytes4) {\n\n        return BLOCK_REWARD_CONTRACT_ID;\n",
                    "message": "BlockRewardBase.blockRewardContractId (BlockRewardAuRaMock.sol#339-341) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": 346,
                    "vulnerability_code": "    function ercToErcBridgesAllowed() public view returns(address[] memory) {\n\n        return addressArrayStorage[ERC_TO_ERC_BRIDGES_ALLOWED];\n",
                    "message": "BlockRewardBase.ercToErcBridgesAllowed (BlockRewardAuRaMock.sol#344-346) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": 351,
                    "vulnerability_code": "    function ercToNativeBridgesAllowed() public view returns(address[] memory) {\n\n        return addressArrayStorage[ERC_TO_NATIVE_BRIDGES_ALLOWED];\n",
                    "message": "BlockRewardBase.ercToNativeBridgesAllowed (BlockRewardAuRaMock.sol#349-351) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": 362,
                    "vulnerability_code": "    function getBridgeNativeFee() public view returns(uint256) {\n\n        return uintStorage[BRIDGE_NATIVE_FEE];\n",
                    "message": "BlockRewardBase.getBridgeNativeFee (BlockRewardAuRaMock.sol#360-362) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": 368,
                    "vulnerability_code": "    function getBridgeTokenFee() public view returns(uint256) {\n\n        return uintStorage[BRIDGE_TOKEN_FEE];\n",
                    "message": "BlockRewardBase.getBridgeTokenFee (BlockRewardAuRaMock.sol#366-368) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": 392,
                    "vulnerability_code": "    function mintedForAccount(address _account) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(MINTED_FOR_ACCOUNT, _account))];\n",
                    "message": "BlockRewardBase.mintedForAccount (BlockRewardAuRaMock.sol#390-392) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": 406,
                    "vulnerability_code": "    function mintedForAccountInBlock(address _account, uint256 _blockNumber)\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        return uintStorage[\n\n            keccak256(abi.encode(MINTED_FOR_ACCOUNT_IN_BLOCK, _account, _blockNumber))\n\n        ];\n",
                    "message": "BlockRewardBase.mintedForAccountInBlock (BlockRewardAuRaMock.sol#398-406) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": 413,
                    "vulnerability_code": "    function mintedInBlock(uint256 _blockNumber) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(MINTED_IN_BLOCK, _blockNumber))];\n",
                    "message": "BlockRewardBase.mintedInBlock (BlockRewardAuRaMock.sol#411-413) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": 432,
                    "vulnerability_code": "    function nativeToErcBridgesAllowed() public view returns(address[] memory) {\n\n        return addressArrayStorage[NATIVE_TO_ERC_BRIDGES_ALLOWED];\n",
                    "message": "BlockRewardBase.nativeToErcBridgesAllowed (BlockRewardAuRaMock.sol#430-432) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": 445,
                    "vulnerability_code": "    function snapshotRewardPercents(address _validatorStakingAddress) public view returns(uint256[] memory) {\n\n        return uintArrayStorage[\n\n            keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, _validatorStakingAddress))\n\n        ];\n",
                    "message": "BlockRewardBase.snapshotRewardPercents (BlockRewardAuRaMock.sol#441-445) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": 456,
                    "vulnerability_code": "    function snapshotStakers(address _validatorStakingAddress) public view returns(address[] memory) {\n\n        return addressArrayStorage[\n\n            keccak256(abi.encode(SNAPSHOT_STAKERS, _validatorStakingAddress))\n\n        ];\n",
                    "message": "BlockRewardBase.snapshotStakers (BlockRewardAuRaMock.sol#452-456) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 463,
                    "vulnerability_code": "    function snapshotStakingAddresses() public view returns(address[] memory) {\n\n        return addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n",
                    "message": "BlockRewardBase.snapshotStakingAddresses (BlockRewardAuRaMock.sol#461-463) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 882,
                    "vulnerability_to_line": 887,
                    "vulnerability_code": "    function getBlocksCreated(\n\n        uint256 _stakingEpoch,\n\n        address _validatorMiningAddress\n\n    ) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(BLOCKS_CREATED, _stakingEpoch, _validatorMiningAddress))];\n",
                    "message": "BlockRewardAuRa.getBlocksCreated (BlockRewardAuRaMock.sol#882-887) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 893,
                    "vulnerability_to_line": 900,
                    "vulnerability_code": "    function getEpochPoolNativeReward(\n\n        uint256 _stakingEpoch,\n\n        address _poolStakingAddress\n\n    ) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(\n\n            EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, _poolStakingAddress\n\n        ))];\n",
                    "message": "BlockRewardAuRa.getEpochPoolNativeReward (BlockRewardAuRaMock.sol#893-900) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 906,
                    "vulnerability_to_line": 913,
                    "vulnerability_code": "    function getEpochPoolTokenReward(\n\n        uint256 _stakingEpoch,\n\n        address _poolStakingAddress\n\n    ) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(\n\n            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, _poolStakingAddress\n\n        ))];\n",
                    "message": "BlockRewardAuRa.getEpochPoolTokenReward (BlockRewardAuRaMock.sol#906-913) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": 918,
                    "vulnerability_code": "    function getNativeRewardUndistributed() public view returns(uint256) {\n\n        return uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n",
                    "message": "BlockRewardAuRa.getNativeRewardUndistributed (BlockRewardAuRaMock.sol#916-918) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 921,
                    "vulnerability_to_line": 923,
                    "vulnerability_code": "    function getTokenRewardUndistributed() public view returns(uint256) {\n\n        return uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n",
                    "message": "BlockRewardAuRa.getTokenRewardUndistributed (BlockRewardAuRaMock.sol#921-923) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1217,
                    "vulnerability_to_line": 1219,
                    "vulnerability_code": "    function setIsSnapshotting(bool _isSnapshotting) public {\n\n        boolStorage[IS_SNAPSHOTTING] = _isSnapshotting;\n",
                    "message": "BlockRewardAuRaMock.setIsSnapshotting (BlockRewardAuRaMock.sol#1217-1219) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in BlockRewardAuRaMock.sol:\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#17): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#52): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#72): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#103): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#121): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#160): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#687): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#704): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#716): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#738): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#748): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRaMock.sol#1213): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address) external;\n",
                    "message": "Parameter '' of IBlockReward.initialize (BlockRewardAuRaMock.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function DELEGATORS_ALIQUOT() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IBlockReward.DELEGATORS_ALIQUOT' (BlockRewardAuRaMock.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (BlockRewardAuRaMock.sol#22) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (BlockRewardAuRaMock.sol#23) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (BlockRewardAuRaMock.sol#24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (BlockRewardAuRaMock.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (BlockRewardAuRaMock.sol#26) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (BlockRewardAuRaMock.sol#27) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (BlockRewardAuRaMock.sol#30) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (BlockRewardAuRaMock.sol#30) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (BlockRewardAuRaMock.sol#37) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (BlockRewardAuRaMock.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (BlockRewardAuRaMock.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (BlockRewardAuRaMock.sol#40) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (BlockRewardAuRaMock.sol#41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (BlockRewardAuRaMock.sol#43) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (BlockRewardAuRaMock.sol#46) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
                    "message": "Parameter '' of IStaking.clearUnremovableValidator (BlockRewardAuRaMock.sol#56) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address) external;\n",
                    "message": "Parameter '' of IStaking.removePool (BlockRewardAuRaMock.sol#58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "Parameter '' of IStaking.poolDelegators (BlockRewardAuRaMock.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (BlockRewardAuRaMock.sol#65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (BlockRewardAuRaMock.sol#65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (BlockRewardAuRaMock.sol#66) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (BlockRewardAuRaMock.sol#80) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address _validatorSet) external {\n",
                    "message": "Parameter '_validatorSet' of BlockRewardBase.initialize (BlockRewardAuRaMock.sol#260) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256) {\n",
                    "message": "Parameter '_bridge' of BlockRewardBase.mintedTotallyByBridge (BlockRewardAuRaMock.sol#418) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addBridgeNativeFeeReceivers(uint256 _amount) external onlyErcToNativeBridge {\n",
                    "message": "Parameter '_amount' of BlockRewardBase.addBridgeNativeFeeReceivers (BlockRewardAuRaMock.sol#231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addBridgeTokenFeeReceivers(uint256 _amount) external onlyXToErcBridge {\n",
                    "message": "Parameter '_amount' of BlockRewardBase.addBridgeTokenFeeReceivers (BlockRewardAuRaMock.sol#240) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExtraReceiver(uint256 _amount, address _receiver) external onlyErcToNativeBridge {\n",
                    "message": "Parameter '_amount' of BlockRewardBase.addExtraReceiver (BlockRewardAuRaMock.sol#249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExtraReceiver(uint256 _amount, address _receiver) external onlyErcToNativeBridge {\n",
                    "message": "Parameter '_receiver' of BlockRewardBase.addExtraReceiver (BlockRewardAuRaMock.sol#249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function migrateMintingStatistics(address _bridge, IBlockReward _prevBlockRewardContract) external onlyOwner {\n",
                    "message": "Parameter '_bridge' of BlockRewardBase.migrateMintingStatistics (BlockRewardAuRaMock.sol#271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function migrateMintingStatistics(address _bridge, IBlockReward _prevBlockRewardContract) external onlyOwner {\n",
                    "message": "Parameter '_prevBlockRewardContract' of BlockRewardBase.migrateMintingStatistics (BlockRewardAuRaMock.sol#271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErcToNativeBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_bridgesAllowed' of BlockRewardBase.setErcToNativeBridgesAllowed (BlockRewardAuRaMock.sol#284) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setNativeToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_bridgesAllowed' of BlockRewardBase.setNativeToErcBridgesAllowed (BlockRewardAuRaMock.sol#302) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErcToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_bridgesAllowed' of BlockRewardBase.setErcToErcBridgesAllowed (BlockRewardAuRaMock.sol#320) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedForAccount(address _account) public view returns(uint256) {\n",
                    "message": "Parameter '_account' of BlockRewardBase.mintedForAccount (BlockRewardAuRaMock.sol#390) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedForAccountInBlock(address _account, uint256 _blockNumber)\n",
                    "message": "Parameter '_account' of BlockRewardBase.mintedForAccountInBlock (BlockRewardAuRaMock.sol#398) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedForAccountInBlock(address _account, uint256 _blockNumber)\n",
                    "message": "Parameter '_blockNumber' of BlockRewardBase.mintedForAccountInBlock (BlockRewardAuRaMock.sol#398) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedInBlock(uint256 _blockNumber) public view returns(uint256) {\n",
                    "message": "Parameter '_blockNumber' of BlockRewardBase.mintedInBlock (BlockRewardAuRaMock.sol#411) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function snapshotRewardPercents(address _validatorStakingAddress) public view returns(uint256[] memory) {\n",
                    "message": "Parameter '_validatorStakingAddress' of BlockRewardBase.snapshotRewardPercents (BlockRewardAuRaMock.sol#441) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function snapshotStakers(address _validatorStakingAddress) public view returns(address[] memory) {\n",
                    "message": "Parameter '_validatorStakingAddress' of BlockRewardBase.snapshotStakers (BlockRewardAuRaMock.sol#452) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": 557,
                    "vulnerability_code": "    function _mintNativeCoins(\n\n        address[] memory _receivers,\n\n        uint256[] memory _rewards,\n\n        uint256 _queueLimit\n\n    )\n\n        internal\n\n        returns(address[] memory receivers, uint256[] memory rewards)\n\n    {\n\n        uint256 extraLength = extraReceiversQueueSize();\n\n\n\n        if (extraLength > _queueLimit) {\n\n            extraLength = _queueLimit;\n\n        }\n\n\n\n        receivers = new address[](extraLength + _receivers.length);\n\n        rewards = new uint256[](receivers.length);\n\n\n\n        uint256 i;\n\n        uint256 j = 0;\n\n\n\n        for (i = 0; i < extraLength; i++) {\n\n            (uint256 amount, address receiver, address bridge) = _dequeueExtraReceiver();\n\n            receivers[i] = receiver;\n\n            rewards[i] = amount;\n\n            _setMinted(amount, receiver, bridge);\n\n        }\n\n\n\n        for (i = extraLength; i < receivers.length; i++) {\n\n            receivers[i] = _receivers[j];\n\n            rewards[i] = _rewards[j];\n\n            j++;\n\n        }\n\n\n\n        emit MintedNative(receivers, rewards);\n\n\n\n        return (receivers, rewards);\n",
                    "message": "Function 'BlockRewardBase._mintNativeCoins' (BlockRewardAuRaMock.sol#521-557) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _receivers,\n",
                    "message": "Parameter '_receivers' of BlockRewardBase._mintNativeCoins (BlockRewardAuRaMock.sol#522) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] memory _rewards,\n",
                    "message": "Parameter '_rewards' of BlockRewardBase._mintNativeCoins (BlockRewardAuRaMock.sol#523) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _queueLimit\n",
                    "message": "Parameter '_queueLimit' of BlockRewardBase._mintNativeCoins (BlockRewardAuRaMock.sol#524) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": 584,
                    "vulnerability_code": "    function _dequeueExtraReceiver() internal returns(uint256 amount, address receiver, address bridge) {\n\n        uint256 queueFirst = uintStorage[QUEUE_ER_FIRST];\n\n        uint256 queueLast = uintStorage[QUEUE_ER_LAST];\n\n\n\n        if (queueLast < queueFirst) {\n\n            amount = 0;\n\n            receiver = address(0);\n\n            bridge = address(0);\n\n        } else {\n\n            bytes32 amountHash = keccak256(abi.encode(QUEUE_ER_AMOUNT, queueFirst));\n\n            bytes32 receiverHash = keccak256(abi.encode(QUEUE_ER_RECEIVER, queueFirst));\n\n            bytes32 bridgeHash = keccak256(abi.encode(QUEUE_ER_BRIDGE, queueFirst));\n\n            amount = uintStorage[amountHash];\n\n            receiver = addressStorage[receiverHash];\n\n            bridge = addressStorage[bridgeHash];\n\n            delete uintStorage[amountHash];\n\n            delete addressStorage[receiverHash];\n\n            delete addressStorage[bridgeHash];\n\n            uintStorage[QUEUE_ER_FIRST]++;\n\n        }\n",
                    "message": "Function 'BlockRewardBase._dequeueExtraReceiver' (BlockRewardAuRaMock.sol#564-584) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": 597,
                    "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n\n        uint256 queueLast = uintStorage[QUEUE_ER_LAST] + 1;\n\n        uintStorage[keccak256(abi.encode(QUEUE_ER_AMOUNT, queueLast))] = _amount;\n\n        addressStorage[keccak256(abi.encode(QUEUE_ER_RECEIVER, queueLast))] = _receiver;\n\n        addressStorage[keccak256(abi.encode(QUEUE_ER_BRIDGE, queueLast))] = _bridge;\n\n        uintStorage[QUEUE_ER_LAST] = queueLast;\n",
                    "message": "Function 'BlockRewardBase._enqueueExtraReceiver' (BlockRewardAuRaMock.sol#591-597) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n",
                    "message": "Parameter '_amount' of BlockRewardBase._enqueueExtraReceiver (BlockRewardAuRaMock.sol#591) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n",
                    "message": "Parameter '_receiver' of BlockRewardBase._enqueueExtraReceiver (BlockRewardAuRaMock.sol#591) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n",
                    "message": "Parameter '_bridge' of BlockRewardBase._enqueueExtraReceiver (BlockRewardAuRaMock.sol#591) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": 610,
                    "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n\n        uintStorage[keccak256(abi.encode(MINTED_FOR_ACCOUNT_IN_BLOCK, _account, block.number))] = _amount;\n\n        uintStorage[keccak256(abi.encode(MINTED_FOR_ACCOUNT, _account))] += _amount;\n\n        uintStorage[keccak256(abi.encode(MINTED_IN_BLOCK, block.number))] += _amount;\n\n        uintStorage[keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))] += _amount;\n\n        uintStorage[MINTED_TOTALLY] += _amount;\n",
                    "message": "Function 'BlockRewardBase._setMinted' (BlockRewardAuRaMock.sol#604-610) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n",
                    "message": "Parameter '_amount' of BlockRewardBase._setMinted (BlockRewardAuRaMock.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n",
                    "message": "Parameter '_account' of BlockRewardBase._setMinted (BlockRewardAuRaMock.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n",
                    "message": "Parameter '_bridge' of BlockRewardBase._setMinted (BlockRewardAuRaMock.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": 682,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n\n        uint256 validatorStake = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, _stakingAddress);\n\n        uint256 totalStaked = _stakingContract.stakeAmountTotalMinusOrderedWithdraw(_stakingAddress);\n\n        uint256 delegatorsAmount = totalStaked >= validatorStake ? totalStaked - validatorStake : 0;\n\n        bool validatorHasMore30Per = validatorStake * 7 > delegatorsAmount * 3;\n\n\n\n        address[] memory delegators = _stakingContract.poolDelegators(_stakingAddress);\n\n        uint256 rewardPercent;\n\n\n\n        address[] storage stakers = addressArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_STAKERS, _stakingAddress\n\n        ))];\n\n\n\n        uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_REWARD_PERCENTS, _stakingAddress\n\n        ))];\n\n\n\n        if (_offset == 0) {\n\n            // Calculate reward percent for validator\n\n            rewardPercent = 0;\n\n            if (validatorStake != 0 && totalStaked != 0) {\n\n                if (validatorHasMore30Per) {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * validatorStake / totalStaked;\n\n                } else {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * 3 / 10;\n\n                }\n\n            }\n\n            stakers.push(_stakingAddress);\n\n            rewardPercents.push(rewardPercent);\n\n            addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES].push(_stakingAddress);\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] += totalStaked;\n\n        }\n\n\n\n        uint256 from = _offset * delegators.length / DELEGATORS_ALIQUOT;\n\n        uint256 to = (_offset + 1) * delegators.length / DELEGATORS_ALIQUOT;\n\n\n\n        if (_offset == 0) {\n\n            to += delegators.length % DELEGATORS_ALIQUOT;\n\n        } else {\n\n            from += delegators.length % DELEGATORS_ALIQUOT;\n\n        }\n\n\n\n        // Calculate reward percent for each delegator\n\n        for (uint256 i = from; i < to; i++) {\n\n            rewardPercent = 0;\n\n\n\n            if (validatorHasMore30Per) {\n\n                if (totalStaked != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent / totalStaked;\n\n                }\n\n            } else {\n\n                if (delegatorsAmount != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent * 7 / (delegatorsAmount * 10);\n\n                }\n\n            }\n\n\n\n            stakers.push(delegators[i]);\n\n            rewardPercents.push(rewardPercent);\n\n        }\n",
                    "message": "Function 'BlockRewardBase._setSnapshot' (BlockRewardAuRaMock.sol#621-682) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n",
                    "message": "Parameter '_stakingAddress' of BlockRewardBase._setSnapshot (BlockRewardAuRaMock.sol#621) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n",
                    "message": "Parameter '_stakingContract' of BlockRewardBase._setSnapshot (BlockRewardAuRaMock.sol#621) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n",
                    "message": "Parameter '_offset' of BlockRewardBase._setSnapshot (BlockRewardAuRaMock.sol#621) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 699,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IERC20Minting.balanceOf (BlockRewardAuRaMock.sol#699) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 708,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(uint256, address) external;\n",
                    "message": "Parameter '' of IRandomAuRa.initialize (BlockRewardAuRaMock.sol#708) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 708,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(uint256, address) external;\n",
                    "message": "Parameter '_scope_0' of IRandomAuRa.initialize (BlockRewardAuRaMock.sol#708) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHashCallable(address, bytes32) external view returns(bool);\n",
                    "message": "Parameter '' of IRandomAuRa.commitHashCallable (BlockRewardAuRaMock.sol#710) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHashCallable(address, bytes32) external view returns(bool);\n",
                    "message": "Parameter '_scope_0' of IRandomAuRa.commitHashCallable (BlockRewardAuRaMock.sol#710) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 711,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSecretCallable(address, uint256) external view returns(bool);\n",
                    "message": "Parameter '' of IRandomAuRa.revealSecretCallable (BlockRewardAuRaMock.sol#711) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 711,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSecretCallable(address, uint256) external view returns(bool);\n",
                    "message": "Parameter '_scope_0' of IRandomAuRa.revealSecretCallable (BlockRewardAuRaMock.sol#711) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 721,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IStakingAuRa.initialize (BlockRewardAuRaMock.sol#721) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_0' of IStakingAuRa.initialize (BlockRewardAuRaMock.sol#722) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 723,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_1' of IStakingAuRa.initialize (BlockRewardAuRaMock.sol#723) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 724,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_2' of IStakingAuRa.initialize (BlockRewardAuRaMock.sol#724) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 725,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_3' of IStakingAuRa.initialize (BlockRewardAuRaMock.sol#725) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_4' of IStakingAuRa.initialize (BlockRewardAuRaMock.sol#726) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_5' of IStakingAuRa.initialize (BlockRewardAuRaMock.sol#727) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 728,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_6' of IStakingAuRa.initialize (BlockRewardAuRaMock.sol#728) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 730,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingEpochStartBlock(uint256) external;\n",
                    "message": "Parameter '' of IStakingAuRa.setStakingEpochStartBlock (BlockRewardAuRaMock.sol#730) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 742,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeMaliciousValidator(address) external;\n",
                    "message": "Parameter '' of IValidatorSetAuRa.removeMaliciousValidator (BlockRewardAuRaMock.sol#742) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 743,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '' of IValidatorSetAuRa.reportMaliciousCallable (BlockRewardAuRaMock.sol#743) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 743,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '_scope_0' of IValidatorSetAuRa.reportMaliciousCallable (BlockRewardAuRaMock.sol#743) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 743,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '_scope_1' of IValidatorSetAuRa.reportMaliciousCallable (BlockRewardAuRaMock.sol#743) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 883,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpoch,\n",
                    "message": "Parameter '_stakingEpoch' of BlockRewardAuRa.getBlocksCreated (BlockRewardAuRaMock.sol#883) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 884,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _validatorMiningAddress\n",
                    "message": "Parameter '_validatorMiningAddress' of BlockRewardAuRa.getBlocksCreated (BlockRewardAuRaMock.sol#884) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpoch,\n",
                    "message": "Parameter '_stakingEpoch' of BlockRewardAuRa.getEpochPoolNativeReward (BlockRewardAuRaMock.sol#894) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 895,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _poolStakingAddress\n",
                    "message": "Parameter '_poolStakingAddress' of BlockRewardAuRa.getEpochPoolNativeReward (BlockRewardAuRaMock.sol#895) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 907,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpoch,\n",
                    "message": "Parameter '_stakingEpoch' of BlockRewardAuRa.getEpochPoolTokenReward (BlockRewardAuRaMock.sol#907) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 908,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _poolStakingAddress\n",
                    "message": "Parameter '_poolStakingAddress' of BlockRewardAuRa.getEpochPoolTokenReward (BlockRewardAuRaMock.sol#908) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": 1138,
                    "vulnerability_code": "    function _distributeRewards(\n\n        IValidatorSet _validatorSetContract,\n\n        address _erc20TokenContract,\n\n        bool _erc20Restricted,\n\n        IStakingAuRa _stakingContract,\n\n        uint256 _stakingEpoch,\n\n        uint256 _rewardPointBlock\n\n    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n\n        uint256 i;\n\n        uint256 j;\n\n\n\n        receivers = new address[](0);\n\n        rewards = new uint256[](0);\n\n        noop = true;\n\n\n\n        if (block.number == _rewardPointBlock - 1) {\n\n            boolStorage[IS_REWARDING] = true;\n\n        } else if (block.number == _rewardPointBlock) {\n\n            address[] memory validators = _validatorSetContract.getValidators();\n\n            uint256[] memory ratio = new uint256[](validators.length);\n\n\n\n            uint256 totalReward;\n\n            bool isRewarding = false;\n\n\n\n            totalReward = uintStorage[BRIDGE_TOKEN_FEE];\n\n\n\n            if (!_erc20Restricted) {\n\n                // Accumulated bridge fee plus token inflation\n\n                uint256 inflationPercent;\n\n                if (_stakingEpoch <= 24) {\n\n                    inflationPercent = 32;\n\n                } else if (_stakingEpoch <= 48) {\n\n                    inflationPercent = 16;\n\n                } else if (_stakingEpoch <= 72) {\n\n                    inflationPercent = 8;\n\n                } else {\n\n                    inflationPercent = 4;\n\n                }\n\n                totalReward += snapshotTotalStakeAmount() * inflationPercent / 4800;\n\n            }\n\n\n\n            if (\n\n                totalReward != 0 && _erc20TokenContract != address(0) ||\n\n                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n\n                _erc20Restricted\n\n            ) {\n\n                j = 0;\n\n                for (i = 0; i < validators.length; i++) {\n\n                    ratio[i] = uintStorage[keccak256(abi.encode(\n\n                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n\n                    ))];\n\n                    j += ratio[i];\n\n                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n\n                }\n\n                if (j != 0) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        ratio[i] = REWARD_PERCENT_MULTIPLIER * ratio[i] / j;\n\n                    }\n\n                }\n\n            }\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_TOKEN_FEE] = 0;\n\n\n\n                totalReward += uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n\n\n\n                if (_erc20TokenContract != address(0)) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        uintStorage[keccak256(abi.encode(\n\n                            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, validators[i]\n\n                        ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    }\n\n                    isRewarding = true;\n\n                }\n\n\n\n                uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            totalReward = uintStorage[BRIDGE_NATIVE_FEE];\n\n\n\n            if (_erc20Restricted) {\n\n                // Accumulated bridge fee plus 2.5% per year coin inflation\n\n                totalReward += _stakingContract.stakingEpochDuration() * 1 ether;\n\n            }\n\n\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_NATIVE_FEE] = 0;\n\n\n\n                totalReward += uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n\n\n\n                for (i = 0; i < validators.length; i++) {\n\n                    uintStorage[keccak256(abi.encode(\n\n                        EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, validators[i]\n\n                    ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                }\n\n                isRewarding = true;\n\n\n\n                uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            if (isRewarding) {\n\n                for (i = 0; i < validators.length; i++) {\n\n                    _enqueueValidator(validators[i]);\n\n                }\n\n                if (validators.length == 0) {\n\n                    boolStorage[IS_REWARDING] = false;\n\n                }\n\n            } else {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            noop = false;\n\n        } else if (block.number > _rewardPointBlock) {\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress == address(0)) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            if (_validatorsQueueSize() == 0) {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            if (_validatorSetContract.isValidatorBanned(_validatorSetContract.miningByStakingAddress(stakingAddress))) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            address[] storage stakers = addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n            uint256[] memory range = new uint256[](3); // array instead of local vars because the stack is too deep\n\n            range[0] = (_validatorsQueueSize() + 1) % DELEGATORS_ALIQUOT; // offset\n\n            range[1] = range[0] * stakers.length / DELEGATORS_ALIQUOT; // from\n\n            range[2] = (range[0] + 1) * stakers.length / DELEGATORS_ALIQUOT; // to\n\n\n\n            if (range[0] == 0) {\n\n                range[2] += stakers.length % DELEGATORS_ALIQUOT;\n\n            } else {\n\n                range[1] += stakers.length % DELEGATORS_ALIQUOT;\n\n            }\n\n\n\n            if (range[1] >= range[2]) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n                SNAPSHOT_REWARD_PERCENTS, stakingAddress\n\n            ))];\n\n            uint256 accrued;\n\n            uint256 poolReward;\n\n\n\n            receivers = new address[](range[2] - range[1]);\n\n            rewards = new uint256[](receivers.length);\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                IERC20Minting(_erc20TokenContract).mintReward(receivers, rewards);\n\n                _subTokenRewardUndistributed(accrued);\n\n                noop = false;\n\n            }\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                _subNativeRewardUndistributed(accrued);\n\n                noop = false;\n\n            } else {\n\n                return (new address[](0), new uint256[](0), noop);\n\n            }\n\n        }\n",
                    "message": "Function 'BlockRewardAuRa._distributeRewards' (BlockRewardAuRaMock.sol#954-1138) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 955,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet _validatorSetContract,\n",
                    "message": "Parameter '_validatorSetContract' of BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#955) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 956,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _erc20TokenContract,\n",
                    "message": "Parameter '_erc20TokenContract' of BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#956) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _erc20Restricted,\n",
                    "message": "Parameter '_erc20Restricted' of BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#957) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 958,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IStakingAuRa _stakingContract,\n",
                    "message": "Parameter '_stakingContract' of BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#958) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpoch,\n",
                    "message": "Parameter '_stakingEpoch' of BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#959) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 960,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _rewardPointBlock\n",
                    "message": "Parameter '_rewardPointBlock' of BlockRewardAuRa._distributeRewards (BlockRewardAuRaMock.sol#960) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1143,
                    "vulnerability_to_line": 1155,
                    "vulnerability_code": "    function _dequeueValidator() internal returns(address validatorStakingAddress) {\n\n        uint256 queueFirst = uintStorage[QUEUE_V_FIRST];\n\n        uint256 queueLast = uintStorage[QUEUE_V_LAST];\n\n\n\n        if (queueLast < queueFirst) {\n\n            validatorStakingAddress = address(0);\n\n        } else {\n\n            bytes32 hash = keccak256(abi.encode(QUEUE_V_LIST, queueFirst));\n\n            validatorStakingAddress = addressStorage[hash];\n\n            delete addressStorage[hash];\n\n            uintStorage[QUEUE_V_FIRST]++;\n\n        }\n",
                    "message": "Function 'BlockRewardAuRa._dequeueValidator' (BlockRewardAuRaMock.sol#1143-1155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1160,
                    "vulnerability_to_line": 1166,
                    "vulnerability_code": "    function _enqueueValidator(address _validatorStakingAddress) internal {\n\n        uint256 queueLast = uintStorage[QUEUE_V_LAST];\n\n        for (uint256 i = 0; i < DELEGATORS_ALIQUOT; i++) {\n\n            addressStorage[keccak256(abi.encode(QUEUE_V_LIST, ++queueLast))] = _validatorStakingAddress;\n\n        }\n\n        uintStorage[QUEUE_V_LAST] = queueLast;\n",
                    "message": "Function 'BlockRewardAuRa._enqueueValidator' (BlockRewardAuRaMock.sol#1160-1166) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _enqueueValidator(address _validatorStakingAddress) internal {\n",
                    "message": "Parameter '_validatorStakingAddress' of BlockRewardAuRa._enqueueValidator (BlockRewardAuRaMock.sol#1160) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1171,
                    "vulnerability_to_line": 1177,
                    "vulnerability_code": "    function _subNativeRewardUndistributed(uint256 _minus) internal {\n\n        if (uintStorage[NATIVE_REWARD_UNDISTRIBUTED] < _minus) {\n\n            uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = 0;\n\n        } else {\n\n            uintStorage[NATIVE_REWARD_UNDISTRIBUTED] -= _minus;\n\n        }\n",
                    "message": "Function 'BlockRewardAuRa._subNativeRewardUndistributed' (BlockRewardAuRaMock.sol#1171-1177) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _subNativeRewardUndistributed(uint256 _minus) internal {\n",
                    "message": "Parameter '_minus' of BlockRewardAuRa._subNativeRewardUndistributed (BlockRewardAuRaMock.sol#1171) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": 1188,
                    "vulnerability_code": "    function _subTokenRewardUndistributed(uint256 _minus) internal {\n\n        if (uintStorage[TOKEN_REWARD_UNDISTRIBUTED] < _minus) {\n\n            uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = 0;\n\n        } else {\n\n            uintStorage[TOKEN_REWARD_UNDISTRIBUTED] -= _minus;\n\n        }\n",
                    "message": "Function 'BlockRewardAuRa._subTokenRewardUndistributed' (BlockRewardAuRaMock.sol#1182-1188) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _subTokenRewardUndistributed(uint256 _minus) internal {\n",
                    "message": "Parameter '_minus' of BlockRewardAuRa._subTokenRewardUndistributed (BlockRewardAuRaMock.sol#1182) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1195,
                    "vulnerability_to_line": 1200,
                    "vulnerability_code": "    function _rewardPointBlock(\n\n        IStakingAuRa _stakingContract,\n\n        IValidatorSet _validatorSetContract\n\n    ) internal view returns(uint256) {\n\n        return _stakingContract.stakingEpochEndBlock() - _validatorSetContract.MAX_VALIDATORS()*DELEGATORS_ALIQUOT - 1;\n",
                    "message": "Function 'BlockRewardAuRa._rewardPointBlock' (BlockRewardAuRaMock.sol#1195-1200) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IStakingAuRa _stakingContract,\n",
                    "message": "Parameter '_stakingContract' of BlockRewardAuRa._rewardPointBlock (BlockRewardAuRaMock.sol#1196) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet _validatorSetContract\n",
                    "message": "Parameter '_validatorSetContract' of BlockRewardAuRa._rewardPointBlock (BlockRewardAuRaMock.sol#1197) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1205,
                    "vulnerability_to_line": 1207,
                    "vulnerability_code": "    function _validatorsQueueSize() internal view returns(uint256) {\n\n        return uintStorage[QUEUE_V_LAST] + 1 - uintStorage[QUEUE_V_FIRST];\n",
                    "message": "Function 'BlockRewardAuRa._validatorsQueueSize' (BlockRewardAuRaMock.sol#1205-1207) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setIsSnapshotting(bool _isSnapshotting) public {\n",
                    "message": "Parameter '_isSnapshotting' of BlockRewardAuRaMock.setIsSnapshotting (BlockRewardAuRaMock.sol#1217) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (BlockRewardAuRaMock.sol#84) is never used in BlockRewardAuRaMock\nEternalStorage.bytesStorage (BlockRewardAuRaMock.sol#86) is never used in BlockRewardAuRaMock\nEternalStorage.intStorage (BlockRewardAuRaMock.sol#88) is never used in BlockRewardAuRaMock\nEternalStorage.bytes32Storage (BlockRewardAuRaMock.sol#89) is never used in BlockRewardAuRaMock\nEternalStorage.stringArrayStorage (BlockRewardAuRaMock.sol#92) is never used in BlockRewardAuRaMock\nEternalStorage.bytesArrayStorage (BlockRewardAuRaMock.sol#94) is never used in BlockRewardAuRaMock\nEternalStorage.boolArrayStorage (BlockRewardAuRaMock.sol#95) is never used in BlockRewardAuRaMock\nEternalStorage.intArrayStorage (BlockRewardAuRaMock.sol#96) is never used in BlockRewardAuRaMock\nEternalStorage.bytes32ArrayStorage (BlockRewardAuRaMock.sol#97) is never used in BlockRewardAuRaMock\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == 0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 570,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            receiver = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bridge = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            validatorStakingAddress = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = extraLength; i < receivers.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 819,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1009,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1020,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1043,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 819,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1009,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1020,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1043,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErcToNativeBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setNativeToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErcToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns(address[] memory receivers, uint256[] memory rewards)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _dequeueExtraReceiver() internal returns(uint256 amount, address receiver, address bridge) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 743,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 766,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 961,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/test/mockContracts/ValidatorSetAuRaMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 557,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < prevValidators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _queueValidators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 708,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 711,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                miningAddresses[i] = miningAddresses[miningAddresses.length - 1];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                miningAddresses.length--;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 771,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _stakingAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < poolsToBeRemoved.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 m = 0; m < reportedValidators.length; m++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 708,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 m = 0; m < reportedValidators.length; m++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (validatorSetApplyBlock() == 0 && newStakingEpoch) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // Apply a new validator set formed by the `newValidatorSet` function\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address[] memory previousValidators = getPreviousValidators();\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address[] memory currentValidators = getValidators();\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 i;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // Save the previous validator set\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                _setIsValidatorOnPreviousEpoch(previousValidators[i], false);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 648,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 649,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolsToBeElected.length >= MAX_VALIDATORS &&\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 651,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 653,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 655,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (likelihood.length > 0 && likelihoodSum > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 657,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                address[] memory newValidators = new address[](\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (likelihood.length > 0 && likelihoodSum > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 657,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                address[] memory newValidators = new address[](\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 659,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                );\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 661,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 663,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1076,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (reportsNumber > validatorsNumber * 50 && reportsNumber > averageReportsNumber * 10) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1077,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                return (false, true);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1078,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1086,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (currentBlock > ancientBlocksLimit && _blockNumber < currentBlock - ancientBlocksLimit) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1087,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return (false, false); // avoid reporting about ancient blocks\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1088,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 592,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (int256 i = queueLast; i >= queueFirst; i--) {\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 667,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    poolsToBeElectedLength--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                miningAddresses.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 557,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < prevValidators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _queueValidators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 577,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uintStorage[keccak256(abi.encode(BAN_COUNTER, _miningAddress))]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        queueLast++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 627,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            intStorage[QUEUE_PV_FIRST]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 634,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[CHANGE_REQUEST_COUNT]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 708,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 737,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uintStorage[keccak256(abi.encode(VALIDATOR_COUNTER, _miningAddress))]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 771,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _stakingAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < poolsToBeRemoved.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 858,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 m = 0; m < reportedValidators.length; m++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[keccak256(abi.encode(REPORTING_COUNTER, _reportingMiningAddress, currentStakingEpoch))]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "DOCKER_RECEIVED_SIGNAL_33"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner (ValidatorSetAuRaMock.sol#89) is never initialized. It is used in:\n\t- clearUnremovableValidator (ValidatorSetAuRaMock.sol#218-223)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": 1147,
                    "vulnerability_code": "    function _incrementReportingCounter(address _reportingMiningAddress) internal {\n\n        if (!isReportValidatorValid(_reportingMiningAddress)) return;\n\n        uint256 currentStakingEpoch = IStaking(stakingContract()).stakingEpoch();\n\n        uintStorage[keccak256(abi.encode(REPORTING_COUNTER, _reportingMiningAddress, currentStakingEpoch))]++;\n\n        uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))]++;\n",
                    "message": "Reentrancy in ValidatorSetAuRa._incrementReportingCounter (ValidatorSetAuRaMock.sol#1142-1147):\n\tExternal calls:\n\t- ! isReportValidatorValid(_reportingMiningAddress) (ValidatorSetAuRaMock.sol#1143)\n\t- currentStakingEpoch = IStaking(stakingContract()).stakingEpoch() (ValidatorSetAuRaMock.sol#1144)\n\tState variables written after the call(s):\n\t- uintStorage (ValidatorSetAuRaMock.sol#1145)\n\t- uintStorage (ValidatorSetAuRaMock.sol#1146)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 642,
                    "vulnerability_to_line": 687,
                    "vulnerability_code": "    function _newValidatorSet() internal returns(uint256) {\n\n        IStaking staking = IStaking(stakingContract());\n\n        address[] memory poolsToBeElected = staking.getPoolsToBeElected();\n\n        address unremovableStakingAddress = unremovableValidator();\n\n\n\n        // Choose new validators\n\n        if (\n\n            poolsToBeElected.length >= MAX_VALIDATORS &&\n\n            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n\n        ) {\n\n            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n\n\n\n            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n\n\n\n            if (likelihood.length > 0 && likelihoodSum > 0) {\n\n                address[] memory newValidators = new address[](\n\n                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n\n                );\n\n\n\n                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n\n                for (uint256 i = 0; i < newValidators.length; i++) {\n\n                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n\n                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n\n                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n\n                    likelihoodSum -= likelihood[randomPoolIndex];\n\n                    poolsToBeElectedLength--;\n\n                    poolsToBeElected[randomPoolIndex] = poolsToBeElected[poolsToBeElectedLength];\n\n                    likelihood[randomPoolIndex] = likelihood[poolsToBeElectedLength];\n\n                }\n\n\n\n                _setPendingValidators(staking, newValidators, unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            _setPendingValidators(staking, poolsToBeElected, unremovableStakingAddress);\n\n        }\n\n\n\n        // From this moment the `getPendingValidators()` will return a new validator set\n\n\n\n        staking.incrementStakingEpoch();\n\n        _setValidatorSetApplyBlock(0);\n\n\n\n        _incrementChangeRequestCount();\n\n        _enqueuePendingValidators(true);\n\n\n\n        return poolsToBeElected.length;\n",
                    "message": "Reentrancy in ValidatorSetBase._newValidatorSet (ValidatorSetAuRaMock.sol#642-687):\n\tExternal calls:\n\t- poolsToBeElected = staking.getPoolsToBeElected() (ValidatorSetAuRaMock.sol#644)\n\t- randomNumber = IRandom(randomContract()).getCurrentSeed() (ValidatorSetAuRaMock.sol#652)\n\t- (likelihood,likelihoodSum) = staking.getPoolsLikelihood() (ValidatorSetAuRaMock.sol#654)\n\t- _setPendingValidators(staking,newValidators,unremovableStakingAddress) (ValidatorSetAuRaMock.sol#672)\n\t- _setPendingValidators(staking,poolsToBeElected,unremovableStakingAddress) (ValidatorSetAuRaMock.sol#675)\n\t- staking.incrementStakingEpoch() (ValidatorSetAuRaMock.sol#680)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetAuRaMock.sol#684)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1153,
                    "vulnerability_to_line": 1165,
                    "vulnerability_code": "    function _removeMaliciousValidatorAuRa(address _miningAddress) internal {\n\n        if (isValidatorBanned(_miningAddress)) {\n\n            // The malicious validator is already banned\n\n            return;\n\n        }\n\n\n\n        if (_removeMaliciousValidator(_miningAddress)) {\n\n            // From this moment `getPendingValidators()` will return the new validator set\n\n            _incrementChangeRequestCount();\n\n            _enqueuePendingValidators(false);\n\n            _clearReportingCounter(_miningAddress);\n\n        }\n",
                    "message": "Reentrancy in ValidatorSetAuRa._removeMaliciousValidatorAuRa (ValidatorSetAuRaMock.sol#1153-1165):\n\tExternal calls:\n\t- _removeMaliciousValidator(_miningAddress) (ValidatorSetAuRaMock.sol#1159-1164)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetAuRaMock.sol#1162)\n\t- uintStorage (ValidatorSetAuRaMock.sol#1161)\n\t- uintStorage (ValidatorSetAuRaMock.sol#1162)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1153,
                    "vulnerability_to_line": 1165,
                    "vulnerability_code": "    function _removeMaliciousValidatorAuRa(address _miningAddress) internal {\n\n        if (isValidatorBanned(_miningAddress)) {\n\n            // The malicious validator is already banned\n\n            return;\n\n        }\n\n\n\n        if (_removeMaliciousValidator(_miningAddress)) {\n\n            // From this moment `getPendingValidators()` will return the new validator set\n\n            _incrementChangeRequestCount();\n\n            _enqueuePendingValidators(false);\n\n            _clearReportingCounter(_miningAddress);\n\n        }\n",
                    "message": "Reentrancy in ValidatorSetAuRa._removeMaliciousValidatorAuRa (ValidatorSetAuRaMock.sol#1153-1165):\n\tExternal calls:\n\t- _removeMaliciousValidator(_miningAddress) (ValidatorSetAuRaMock.sol#1159-1164)\n\t- _clearReportingCounter(_miningAddress) (ValidatorSetAuRaMock.sol#1163)\n\tState variables written after the call(s):\n\t- uintStorage (ValidatorSetAuRaMock.sol#1163)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 960,
                    "vulnerability_to_line": 1011,
                    "vulnerability_code": "    function reportMalicious(\n\n        address _maliciousMiningAddress,\n\n        uint256 _blockNumber,\n\n        bytes calldata\n\n    ) external onlyInitialized {\n\n        address reportingMiningAddress = msg.sender;\n\n\n\n        _incrementReportingCounter(reportingMiningAddress);\n\n\n\n        (\n\n            bool callable,\n\n            bool removeReportingValidator\n\n        ) = reportMaliciousCallable(\n\n            reportingMiningAddress,\n\n            _maliciousMiningAddress,\n\n            _blockNumber\n\n        );\n\n\n\n        if (!callable) {\n\n            if (removeReportingValidator) {\n\n                // Reporting validator reported too often, so\n\n                // treat them as a malicious as well\n\n                _removeMaliciousValidatorAuRa(reportingMiningAddress);\n\n            }\n\n            return;\n\n        }\n\n\n\n        address[] storage reportedValidators = addressArrayStorage[keccak256(abi.encode(\n\n            MALICE_REPORTED_FOR_BLOCK, _maliciousMiningAddress, _blockNumber\n\n        ))];\n\n\n\n        reportedValidators.push(reportingMiningAddress);\n\n\n\n        emit ReportedMalicious(reportingMiningAddress, _maliciousMiningAddress, _blockNumber);\n\n\n\n        uint256 validatorsLength = getValidators().length;\n\n        bool remove;\n\n\n\n        if (validatorsLength > 3) {\n\n            // If more than 2/3 of validators reported about malicious validator\n\n            // for the same `blockNumber`\n\n            remove = reportedValidators.length.mul(3) > validatorsLength.mul(2);\n\n        } else {\n\n            // If more than 1/2 of validators reported about malicious validator\n\n            // for the same `blockNumber`\n\n            remove = reportedValidators.length.mul(2) > validatorsLength;\n\n        }\n\n\n\n        if (remove) {\n\n            _removeMaliciousValidatorAuRa(_maliciousMiningAddress);\n\n        }\n",
                    "message": "Reentrancy in ValidatorSetAuRa.reportMalicious (ValidatorSetAuRaMock.sol#960-1011):\n\tExternal calls:\n\t- _incrementReportingCounter(reportingMiningAddress) (ValidatorSetAuRaMock.sol#967)\n\t- (callable,removeReportingValidator) = reportMaliciousCallable(reportingMiningAddress,_maliciousMiningAddress,_blockNumber) (ValidatorSetAuRaMock.sol#969-976)\n\t- _removeMaliciousValidatorAuRa(reportingMiningAddress) (ValidatorSetAuRaMock.sol#982)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetAuRaMock.sol#982)\n\t- boolStorage (ValidatorSetAuRaMock.sol#982)\n\t- uintStorage (ValidatorSetAuRaMock.sol#982)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 960,
                    "vulnerability_to_line": 1011,
                    "vulnerability_code": "    function reportMalicious(\n\n        address _maliciousMiningAddress,\n\n        uint256 _blockNumber,\n\n        bytes calldata\n\n    ) external onlyInitialized {\n\n        address reportingMiningAddress = msg.sender;\n\n\n\n        _incrementReportingCounter(reportingMiningAddress);\n\n\n\n        (\n\n            bool callable,\n\n            bool removeReportingValidator\n\n        ) = reportMaliciousCallable(\n\n            reportingMiningAddress,\n\n            _maliciousMiningAddress,\n\n            _blockNumber\n\n        );\n\n\n\n        if (!callable) {\n\n            if (removeReportingValidator) {\n\n                // Reporting validator reported too often, so\n\n                // treat them as a malicious as well\n\n                _removeMaliciousValidatorAuRa(reportingMiningAddress);\n\n            }\n\n            return;\n\n        }\n\n\n\n        address[] storage reportedValidators = addressArrayStorage[keccak256(abi.encode(\n\n            MALICE_REPORTED_FOR_BLOCK, _maliciousMiningAddress, _blockNumber\n\n        ))];\n\n\n\n        reportedValidators.push(reportingMiningAddress);\n\n\n\n        emit ReportedMalicious(reportingMiningAddress, _maliciousMiningAddress, _blockNumber);\n\n\n\n        uint256 validatorsLength = getValidators().length;\n\n        bool remove;\n\n\n\n        if (validatorsLength > 3) {\n\n            // If more than 2/3 of validators reported about malicious validator\n\n            // for the same `blockNumber`\n\n            remove = reportedValidators.length.mul(3) > validatorsLength.mul(2);\n\n        } else {\n\n            // If more than 1/2 of validators reported about malicious validator\n\n            // for the same `blockNumber`\n\n            remove = reportedValidators.length.mul(2) > validatorsLength;\n\n        }\n\n\n\n        if (remove) {\n\n            _removeMaliciousValidatorAuRa(_maliciousMiningAddress);\n\n        }\n",
                    "message": "Reentrancy in ValidatorSetAuRa.reportMalicious (ValidatorSetAuRaMock.sol#960-1011):\n\tExternal calls:\n\t- _incrementReportingCounter(reportingMiningAddress) (ValidatorSetAuRaMock.sol#967)\n\t- (callable,removeReportingValidator) = reportMaliciousCallable(reportingMiningAddress,_maliciousMiningAddress,_blockNumber) (ValidatorSetAuRaMock.sol#969-976)\n\t- _removeMaliciousValidatorAuRa(_maliciousMiningAddress) (ValidatorSetAuRaMock.sol#1009)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetAuRaMock.sol#1009)\n\t- boolStorage (ValidatorSetAuRaMock.sol#1009)\n\t- uintStorage (ValidatorSetAuRaMock.sol#1009)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 941,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IStakingAuRa stakingContract = IStakingAuRa(stakingContract());\n",
                    "message": "ValidatorSetAuRa.newValidatorSet.stakingContract (local variable @ ValidatorSetAuRaMock.sol#941) shadows:\n\t- ValidatorSetBase.stakingContract (function @ ValidatorSetAuRaMock.sol#485-487)\n\t- IValidatorSet.stakingContract (function @ ValidatorSetAuRaMock.sol#73)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1124,
                    "vulnerability_to_line": 1136,
                    "vulnerability_code": "    function _clearReportingCounter(address _miningAddress) internal {\n\n        uint256 currentStakingEpoch = IStaking(stakingContract()).stakingEpoch();\n\n        uint256 total = reportingCounterTotal(currentStakingEpoch);\n\n        uint256 counter = reportingCounter(_miningAddress, currentStakingEpoch);\n\n\n\n        uintStorage[keccak256(abi.encode(REPORTING_COUNTER, _miningAddress, currentStakingEpoch))] = 0;\n\n\n\n        if (total >= counter) {\n\n            uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))] -= counter;\n\n        } else {\n\n            uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))] = 0;\n\n        }\n",
                    "message": "Reentrancy in ValidatorSetAuRa._clearReportingCounter (ValidatorSetAuRaMock.sol#1124-1136):\n\tExternal calls:\n\t- currentStakingEpoch = IStaking(stakingContract()).stakingEpoch() (ValidatorSetAuRaMock.sol#1125)\n\tState variables written after the call(s):\n\t- uintStorage (ValidatorSetAuRaMock.sol#1129)\n\t- uintStorage (ValidatorSetAuRaMock.sol#1132)\n\t- uintStorage (ValidatorSetAuRaMock.sol#1134)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 642,
                    "vulnerability_to_line": 687,
                    "vulnerability_code": "    function _newValidatorSet() internal returns(uint256) {\n\n        IStaking staking = IStaking(stakingContract());\n\n        address[] memory poolsToBeElected = staking.getPoolsToBeElected();\n\n        address unremovableStakingAddress = unremovableValidator();\n\n\n\n        // Choose new validators\n\n        if (\n\n            poolsToBeElected.length >= MAX_VALIDATORS &&\n\n            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n\n        ) {\n\n            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n\n\n\n            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n\n\n\n            if (likelihood.length > 0 && likelihoodSum > 0) {\n\n                address[] memory newValidators = new address[](\n\n                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n\n                );\n\n\n\n                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n\n                for (uint256 i = 0; i < newValidators.length; i++) {\n\n                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n\n                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n\n                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n\n                    likelihoodSum -= likelihood[randomPoolIndex];\n\n                    poolsToBeElectedLength--;\n\n                    poolsToBeElected[randomPoolIndex] = poolsToBeElected[poolsToBeElectedLength];\n\n                    likelihood[randomPoolIndex] = likelihood[poolsToBeElectedLength];\n\n                }\n\n\n\n                _setPendingValidators(staking, newValidators, unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            _setPendingValidators(staking, poolsToBeElected, unremovableStakingAddress);\n\n        }\n\n\n\n        // From this moment the `getPendingValidators()` will return a new validator set\n\n\n\n        staking.incrementStakingEpoch();\n\n        _setValidatorSetApplyBlock(0);\n\n\n\n        _incrementChangeRequestCount();\n\n        _enqueuePendingValidators(true);\n\n\n\n        return poolsToBeElected.length;\n",
                    "message": "Reentrancy in ValidatorSetBase._newValidatorSet (ValidatorSetAuRaMock.sol#642-687):\n\tExternal calls:\n\t- poolsToBeElected = staking.getPoolsToBeElected() (ValidatorSetAuRaMock.sol#644)\n\t- randomNumber = IRandom(randomContract()).getCurrentSeed() (ValidatorSetAuRaMock.sol#652)\n\t- (likelihood,likelihoodSum) = staking.getPoolsLikelihood() (ValidatorSetAuRaMock.sol#654)\n\t- _setPendingValidators(staking,newValidators,unremovableStakingAddress) (ValidatorSetAuRaMock.sol#672)\n\t- _setPendingValidators(staking,poolsToBeElected,unremovableStakingAddress) (ValidatorSetAuRaMock.sol#675)\n\t- staking.incrementStakingEpoch() (ValidatorSetAuRaMock.sol#680)\n\tState variables written after the call(s):\n\t- boolStorage (ValidatorSetAuRaMock.sol#684)\n\t- intStorage (ValidatorSetAuRaMock.sol#684)\n\t- uintStorage (ValidatorSetAuRaMock.sol#681)\n\t- uintStorage (ValidatorSetAuRaMock.sol#683)\n\t- uintStorage (ValidatorSetAuRaMock.sol#684)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": 718,
                    "vulnerability_code": "    function _removeMaliciousValidator(address _miningAddress) internal returns(bool) {\n\n        address stakingAddress = stakingByMiningAddress(_miningAddress);\n\n\n\n        if (stakingAddress == unremovableValidator()) {\n\n            return false;\n\n        }\n\n\n\n        // Ban the malicious validator for the next 3 months\n\n        _banValidator(_miningAddress);\n\n\n\n        // Remove malicious validator from the `pools`\n\n        IStaking(stakingContract()).removePool(stakingAddress);\n\n\n\n        address[] storage miningAddresses = addressArrayStorage[PENDING_VALIDATORS];\n\n\n\n        for (uint256 i = 0; i < miningAddresses.length; i++) {\n\n            if (miningAddresses[i] == _miningAddress) {\n\n                // Remove the malicious validator from `pendingValidators`\n\n                miningAddresses[i] = miningAddresses[miningAddresses.length - 1];\n\n                miningAddresses.length--;\n\n                return true;\n\n            }\n\n        }\n\n\n\n        return false;\n",
                    "message": "Reentrancy in ValidatorSetBase._removeMaliciousValidator (ValidatorSetAuRaMock.sol#693-718):\n\tExternal calls:\n\t- IStaking(stakingContract()).removePool(stakingAddress) (ValidatorSetAuRaMock.sol#704)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetAuRaMock.sol#711)\n\t- addressArrayStorage (ValidatorSetAuRaMock.sol#712)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1153,
                    "vulnerability_to_line": 1165,
                    "vulnerability_code": "    function _removeMaliciousValidatorAuRa(address _miningAddress) internal {\n\n        if (isValidatorBanned(_miningAddress)) {\n\n            // The malicious validator is already banned\n\n            return;\n\n        }\n\n\n\n        if (_removeMaliciousValidator(_miningAddress)) {\n\n            // From this moment `getPendingValidators()` will return the new validator set\n\n            _incrementChangeRequestCount();\n\n            _enqueuePendingValidators(false);\n\n            _clearReportingCounter(_miningAddress);\n\n        }\n",
                    "message": "Reentrancy in ValidatorSetAuRa._removeMaliciousValidatorAuRa (ValidatorSetAuRaMock.sol#1153-1165):\n\tExternal calls:\n\t- _removeMaliciousValidator(_miningAddress) (ValidatorSetAuRaMock.sol#1159-1164)\n\tState variables written after the call(s):\n\t- boolStorage (ValidatorSetAuRaMock.sol#1162)\n\t- intStorage (ValidatorSetAuRaMock.sol#1162)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (ValidatorSetAuRaMock.sol#89)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function changeRequestCount() external view returns(uint256);\n",
                    "message": "IValidatorSet.changeRequestCount (ValidatorSetAuRaMock.sol#61) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": 367,
                    "vulnerability_code": "    function changeRequestCount() public view returns(uint256) {\n\n        return uintStorage[CHANGE_REQUEST_COUNT];\n",
                    "message": "ValidatorSetBase.changeRequestCount (ValidatorSetAuRaMock.sol#365-367) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": 508,
                    "vulnerability_code": "    function validatorIndex(address _miningAddress) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(VALIDATOR_INDEX, _miningAddress))];\n",
                    "message": "ValidatorSetBase.validatorIndex (ValidatorSetAuRaMock.sol#506-508) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "IValidatorSet.validatorIndex (ValidatorSetAuRaMock.sol#75) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": 347,
                    "vulnerability_code": "    function banCounter(address _miningAddress) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(BAN_COUNTER, _miningAddress))];\n",
                    "message": "ValidatorSetBase.banCounter (ValidatorSetAuRaMock.sol#345-347) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 497,
                    "vulnerability_to_line": 499,
                    "vulnerability_code": "    function validatorCounter(address _miningAddress) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(VALIDATOR_COUNTER, _miningAddress))];\n",
                    "message": "ValidatorSetBase.validatorCounter (ValidatorSetAuRaMock.sol#497-499) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1019,
                    "vulnerability_to_line": 1026,
                    "vulnerability_code": "    function maliceReportedForBlock(\n\n        address _maliciousMiningAddress,\n\n        uint256 _blockNumber\n\n    ) public view returns(address[] memory) {\n\n        return addressArrayStorage[keccak256(abi.encode(\n\n            MALICE_REPORTED_FOR_BLOCK, _maliciousMiningAddress, _blockNumber\n\n        ))];\n",
                    "message": "ValidatorSetAuRa.maliceReportedForBlock (ValidatorSetAuRaMock.sol#1019-1026) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1183,
                    "vulnerability_to_line": 1185,
                    "vulnerability_code": "    function clearPendingValidators() public {\n\n        delete addressArrayStorage[PENDING_VALIDATORS];\n",
                    "message": "ValidatorSetAuRaMock.clearPendingValidators (ValidatorSetAuRaMock.sol#1183-1185) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1187,
                    "vulnerability_to_line": 1189,
                    "vulnerability_code": "    function enqueuePendingValidators() public {\n\n        _enqueuePendingValidators(true);\n",
                    "message": "ValidatorSetAuRaMock.enqueuePendingValidators (ValidatorSetAuRaMock.sol#1187-1189) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1191,
                    "vulnerability_to_line": 1193,
                    "vulnerability_code": "    function setBannedUntil(address _miningAddress, uint256 _bannedUntil) public {\n\n        uintStorage[keccak256(abi.encode(BANNED_UNTIL, _miningAddress))] = _bannedUntil;\n",
                    "message": "ValidatorSetAuRaMock.setBannedUntil (ValidatorSetAuRaMock.sol#1191-1193) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1195,
                    "vulnerability_to_line": 1197,
                    "vulnerability_code": "    function setBlockRewardContract(address _address) public {\n\n        addressStorage[BLOCK_REWARD_CONTRACT] = _address;\n",
                    "message": "ValidatorSetAuRaMock.setBlockRewardContract (ValidatorSetAuRaMock.sol#1195-1197) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1199,
                    "vulnerability_to_line": 1201,
                    "vulnerability_code": "    function setCurrentBlockNumber(uint256 _blockNumber) public {\n\n        uintStorage[keccak256(\"currentBlockNumber\")] = _blockNumber;\n",
                    "message": "ValidatorSetAuRaMock.setCurrentBlockNumber (ValidatorSetAuRaMock.sol#1199-1201) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1203,
                    "vulnerability_to_line": 1205,
                    "vulnerability_code": "    function setRandomContract(address _address) public {\n\n        addressStorage[RANDOM_CONTRACT] = _address;\n",
                    "message": "ValidatorSetAuRaMock.setRandomContract (ValidatorSetAuRaMock.sol#1203-1205) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1207,
                    "vulnerability_to_line": 1209,
                    "vulnerability_code": "    function setSystemAddress(address _systemAddress) public {\n\n        addressStorage[keccak256(\"systemAddress\")] = _systemAddress;\n",
                    "message": "ValidatorSetAuRaMock.setSystemAddress (ValidatorSetAuRaMock.sol#1207-1209) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1211,
                    "vulnerability_to_line": 1213,
                    "vulnerability_code": "    function setValidatorSetApplyBlock(uint256 _blockNumber) public {\n\n        _setValidatorSetApplyBlock(_blockNumber);\n",
                    "message": "ValidatorSetAuRaMock.setValidatorSetApplyBlock (ValidatorSetAuRaMock.sol#1211-1213) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1217,
                    "vulnerability_to_line": 1227,
                    "vulnerability_code": "    function getRandomIndex(\n\n        int256[] memory _likelihood,\n\n        int256 _likelihoodSum,\n\n        uint256 _randomNumber\n\n    ) public pure returns(uint256) {\n\n        return _getRandomIndex(\n\n            _likelihood,\n\n            _likelihoodSum,\n\n            uint256(keccak256(abi.encode(_randomNumber)))\n\n        );\n",
                    "message": "ValidatorSetAuRaMock.getRandomIndex (ValidatorSetAuRaMock.sol#1217-1227) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in ValidatorSetAuRaMock.sol:\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#17): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#26): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#46): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#81): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#112): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#130): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#169): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#866): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#876): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#898): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRaMock.sol#1170): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address) external;\n",
                    "message": "Parameter '' of IBlockReward.initialize (ValidatorSetAuRaMock.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function DELEGATORS_ALIQUOT() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IBlockReward.DELEGATORS_ALIQUOT' (ValidatorSetAuRaMock.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
                    "message": "Parameter '' of IStaking.clearUnremovableValidator (ValidatorSetAuRaMock.sol#30) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address) external;\n",
                    "message": "Parameter '' of IStaking.removePool (ValidatorSetAuRaMock.sol#32) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "Parameter '' of IStaking.poolDelegators (ValidatorSetAuRaMock.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (ValidatorSetAuRaMock.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (ValidatorSetAuRaMock.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (ValidatorSetAuRaMock.sol#40) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (ValidatorSetAuRaMock.sol#51) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (ValidatorSetAuRaMock.sol#52) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (ValidatorSetAuRaMock.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (ValidatorSetAuRaMock.sol#54) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (ValidatorSetAuRaMock.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (ValidatorSetAuRaMock.sol#56) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (ValidatorSetAuRaMock.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (ValidatorSetAuRaMock.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (ValidatorSetAuRaMock.sol#66) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (ValidatorSetAuRaMock.sol#67) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (ValidatorSetAuRaMock.sol#68) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (ValidatorSetAuRaMock.sol#69) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (ValidatorSetAuRaMock.sol#70) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (ValidatorSetAuRaMock.sol#72) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (ValidatorSetAuRaMock.sol#75) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (ValidatorSetAuRaMock.sol#89) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _blockRewardContract,\n",
                    "message": "Parameter '_blockRewardContract' of ValidatorSetBase.initialize (ValidatorSetAuRaMock.sol#294) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _randomContract,\n",
                    "message": "Parameter '_randomContract' of ValidatorSetBase.initialize (ValidatorSetAuRaMock.sol#295) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _stakingContract,\n",
                    "message": "Parameter '_stakingContract' of ValidatorSetBase.initialize (ValidatorSetAuRaMock.sol#296) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialMiningAddresses,\n",
                    "message": "Parameter '_initialMiningAddresses' of ValidatorSetBase.initialize (ValidatorSetAuRaMock.sol#297) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
                    "message": "Parameter '_initialStakingAddresses' of ValidatorSetBase.initialize (ValidatorSetAuRaMock.sol#298) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _firstValidatorIsUnremovable\n",
                    "message": "Parameter '_firstValidatorIsUnremovable' of ValidatorSetBase.initialize (ValidatorSetAuRaMock.sol#299) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address _miningAddress, address _stakingAddress) external onlyStakingContract {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.setStakingAddress (ValidatorSetAuRaMock.sol#337) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address _miningAddress, address _stakingAddress) external onlyStakingContract {\n",
                    "message": "Parameter '_stakingAddress' of ValidatorSetBase.setStakingAddress (ValidatorSetAuRaMock.sol#337) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.isReportValidatorValid (ValidatorSetAuRaMock.sol#428) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.isValidator (ValidatorSetAuRaMock.sol#447) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.isValidatorBanned (ValidatorSetAuRaMock.sol#461) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address _stakingAddress) public view returns(address) {\n",
                    "message": "Parameter '_stakingAddress' of ValidatorSetBase.miningByStakingAddress (ValidatorSetAuRaMock.sol#468) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address _miningAddress) public view returns(address) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.stakingByMiningAddress (ValidatorSetAuRaMock.sol#480) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address _miningAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.validatorIndex (ValidatorSetAuRaMock.sol#506) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function banCounter(address _miningAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.banCounter (ValidatorSetAuRaMock.sol#345) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bannedUntil(address _miningAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.bannedUntil (ValidatorSetAuRaMock.sol#354) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorOnPreviousEpoch(address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.isValidatorOnPreviousEpoch (ValidatorSetAuRaMock.sol#454) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 497,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCounter(address _miningAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.validatorCounter (ValidatorSetAuRaMock.sol#497) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": 569,
                    "vulnerability_code": "    function _applyQueueValidators(address[] memory _queueValidators) internal {\n\n        address[] memory prevValidators = getValidators();\n\n        uint256 i;\n\n\n\n        // Clear indexes for old validator set\n\n        for (i = 0; i < prevValidators.length; i++) {\n\n            _setValidatorIndex(prevValidators[i], 0);\n\n            _setIsValidator(prevValidators[i], false);\n\n        }\n\n\n\n        addressArrayStorage[CURRENT_VALIDATORS] = _queueValidators;\n\n\n\n        // Set indexes for new validator set\n\n        for (i = 0; i < _queueValidators.length; i++) {\n\n            _setValidatorIndex(_queueValidators[i], i);\n\n            _setIsValidator(_queueValidators[i], true);\n\n        }\n",
                    "message": "Function 'ValidatorSetBase._applyQueueValidators' (ValidatorSetAuRaMock.sol#552-569) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _applyQueueValidators(address[] memory _queueValidators) internal {\n",
                    "message": "Parameter '_queueValidators' of ValidatorSetBase._applyQueueValidators (ValidatorSetAuRaMock.sol#552) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": 581,
                    "vulnerability_code": "    function _banValidator(address _miningAddress) internal {\n\n        if (_banStart() > bannedUntil(_miningAddress)) {\n\n            uintStorage[keccak256(abi.encode(BAN_COUNTER, _miningAddress))]++;\n\n        }\n\n\n\n        uintStorage[keccak256(abi.encode(BANNED_UNTIL, _miningAddress))] = _banUntil();\n",
                    "message": "Function 'ValidatorSetBase._banValidator' (ValidatorSetAuRaMock.sol#575-581) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _banValidator(address _miningAddress) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase._banValidator (ValidatorSetAuRaMock.sol#575) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": 607,
                    "vulnerability_code": "    function _enqueuePendingValidators(bool _newStakingEpoch) internal {\n\n        int256 queueFirst = intStorage[QUEUE_PV_FIRST];\n\n        int256 queueLast = intStorage[QUEUE_PV_LAST];\n\n\n\n        for (int256 i = queueLast; i >= queueFirst; i--) {\n\n            if (uintStorage[keccak256(abi.encode(QUEUE_PV_BLOCK, i))] == _getCurrentBlockNumber()) {\n\n                addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, i))] = getPendingValidators();\n\n                if (_newStakingEpoch) {\n\n                    boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, i))] = true;\n\n                }\n\n                return;\n\n            }\n\n        }\n\n\n\n        queueLast++;\n\n        addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, queueLast))] = getPendingValidators();\n\n        boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, queueLast))] = _newStakingEpoch;\n\n        uintStorage[keccak256(abi.encode(QUEUE_PV_BLOCK, queueLast))] = _getCurrentBlockNumber();\n\n        intStorage[QUEUE_PV_LAST] = queueLast;\n",
                    "message": "Function 'ValidatorSetBase._enqueuePendingValidators' (ValidatorSetAuRaMock.sol#588-607) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _enqueuePendingValidators(bool _newStakingEpoch) internal {\n",
                    "message": "Parameter '_newStakingEpoch' of ValidatorSetBase._enqueuePendingValidators (ValidatorSetAuRaMock.sol#588) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 614,
                    "vulnerability_to_line": 629,
                    "vulnerability_code": "    function _dequeuePendingValidators() internal returns(address[] memory newSet, bool newStakingEpoch) {\n\n        int256 queueFirst = intStorage[QUEUE_PV_FIRST];\n\n        int256 queueLast = intStorage[QUEUE_PV_LAST];\n\n\n\n        if (queueLast < queueFirst) {\n\n            newSet = new address[](0);\n\n            newStakingEpoch = false;\n\n        } else {\n\n            newSet = addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, queueFirst))];\n\n            newStakingEpoch = boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, queueFirst))];\n\n            delete addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, queueFirst))];\n\n            delete boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, queueFirst))];\n\n            delete uintStorage[keccak256(abi.encode(QUEUE_PV_BLOCK, queueFirst))];\n\n            intStorage[QUEUE_PV_FIRST]++;\n\n        }\n",
                    "message": "Function 'ValidatorSetBase._dequeuePendingValidators' (ValidatorSetAuRaMock.sol#614-629) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 633,
                    "vulnerability_to_line": 635,
                    "vulnerability_code": "    function _incrementChangeRequestCount() internal {\n\n        uintStorage[CHANGE_REQUEST_COUNT]++;\n",
                    "message": "Function 'ValidatorSetBase._incrementChangeRequestCount' (ValidatorSetAuRaMock.sol#633-635) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 642,
                    "vulnerability_to_line": 687,
                    "vulnerability_code": "    function _newValidatorSet() internal returns(uint256) {\n\n        IStaking staking = IStaking(stakingContract());\n\n        address[] memory poolsToBeElected = staking.getPoolsToBeElected();\n\n        address unremovableStakingAddress = unremovableValidator();\n\n\n\n        // Choose new validators\n\n        if (\n\n            poolsToBeElected.length >= MAX_VALIDATORS &&\n\n            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n\n        ) {\n\n            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n\n\n\n            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n\n\n\n            if (likelihood.length > 0 && likelihoodSum > 0) {\n\n                address[] memory newValidators = new address[](\n\n                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n\n                );\n\n\n\n                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n\n                for (uint256 i = 0; i < newValidators.length; i++) {\n\n                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n\n                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n\n                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n\n                    likelihoodSum -= likelihood[randomPoolIndex];\n\n                    poolsToBeElectedLength--;\n\n                    poolsToBeElected[randomPoolIndex] = poolsToBeElected[poolsToBeElectedLength];\n\n                    likelihood[randomPoolIndex] = likelihood[poolsToBeElectedLength];\n\n                }\n\n\n\n                _setPendingValidators(staking, newValidators, unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            _setPendingValidators(staking, poolsToBeElected, unremovableStakingAddress);\n\n        }\n\n\n\n        // From this moment the `getPendingValidators()` will return a new validator set\n\n\n\n        staking.incrementStakingEpoch();\n\n        _setValidatorSetApplyBlock(0);\n\n\n\n        _incrementChangeRequestCount();\n\n        _enqueuePendingValidators(true);\n\n\n\n        return poolsToBeElected.length;\n",
                    "message": "Function 'ValidatorSetBase._newValidatorSet' (ValidatorSetAuRaMock.sol#642-687) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": 718,
                    "vulnerability_code": "    function _removeMaliciousValidator(address _miningAddress) internal returns(bool) {\n\n        address stakingAddress = stakingByMiningAddress(_miningAddress);\n\n\n\n        if (stakingAddress == unremovableValidator()) {\n\n            return false;\n\n        }\n\n\n\n        // Ban the malicious validator for the next 3 months\n\n        _banValidator(_miningAddress);\n\n\n\n        // Remove malicious validator from the `pools`\n\n        IStaking(stakingContract()).removePool(stakingAddress);\n\n\n\n        address[] storage miningAddresses = addressArrayStorage[PENDING_VALIDATORS];\n\n\n\n        for (uint256 i = 0; i < miningAddresses.length; i++) {\n\n            if (miningAddresses[i] == _miningAddress) {\n\n                // Remove the malicious validator from `pendingValidators`\n\n                miningAddresses[i] = miningAddresses[miningAddresses.length - 1];\n\n                miningAddresses.length--;\n\n                return true;\n\n            }\n\n        }\n\n\n\n        return false;\n",
                    "message": "Function 'ValidatorSetBase._removeMaliciousValidator' (ValidatorSetAuRaMock.sol#693-718) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeMaliciousValidator(address _miningAddress) internal returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase._removeMaliciousValidator (ValidatorSetAuRaMock.sol#693) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 724,
                    "vulnerability_to_line": 726,
                    "vulnerability_code": "    function _setInitiateChangeAllowed(bool _allowed) internal {\n\n        boolStorage[INITIATE_CHANGE_ALLOWED] = _allowed;\n",
                    "message": "Function 'ValidatorSetBase._setInitiateChangeAllowed' (ValidatorSetAuRaMock.sol#724-726) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 724,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setInitiateChangeAllowed(bool _allowed) internal {\n",
                    "message": "Parameter '_allowed' of ValidatorSetBase._setInitiateChangeAllowed (ValidatorSetAuRaMock.sol#724) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": 739,
                    "vulnerability_code": "    function _setIsValidator(address _miningAddress, bool _isValidator) internal {\n\n        boolStorage[keccak256(abi.encode(IS_VALIDATOR, _miningAddress))] = _isValidator;\n\n\n\n        if (_isValidator) {\n\n            uintStorage[keccak256(abi.encode(VALIDATOR_COUNTER, _miningAddress))]++;\n\n        }\n",
                    "message": "Function 'ValidatorSetBase._setIsValidator' (ValidatorSetAuRaMock.sol#733-739) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIsValidator(address _miningAddress, bool _isValidator) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase._setIsValidator (ValidatorSetAuRaMock.sol#733) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIsValidator(address _miningAddress, bool _isValidator) internal {\n",
                    "message": "Parameter '_isValidator' of ValidatorSetBase._setIsValidator (ValidatorSetAuRaMock.sol#733) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": 747,
                    "vulnerability_code": "    function _setIsValidatorOnPreviousEpoch(address _miningAddress, bool _isValidator) internal {\n\n        boolStorage[keccak256(abi.encode(IS_VALIDATOR_ON_PREVIOUS_EPOCH, _miningAddress))] = _isValidator;\n",
                    "message": "Function 'ValidatorSetBase._setIsValidatorOnPreviousEpoch' (ValidatorSetAuRaMock.sol#745-747) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIsValidatorOnPreviousEpoch(address _miningAddress, bool _isValidator) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase._setIsValidatorOnPreviousEpoch (ValidatorSetAuRaMock.sol#745) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIsValidatorOnPreviousEpoch(address _miningAddress, bool _isValidator) internal {\n",
                    "message": "Parameter '_isValidator' of ValidatorSetBase._setIsValidatorOnPreviousEpoch (ValidatorSetAuRaMock.sol#745) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 756,
                    "vulnerability_to_line": 779,
                    "vulnerability_code": "    function _setPendingValidators(\n\n        IStaking _stakingContract,\n\n        address[] memory _stakingAddresses,\n\n        address _unremovableStakingAddress\n\n    ) internal {\n\n        if (_stakingAddresses.length == 0) return;\n\n\n\n        uint256 i;\n\n\n\n        delete addressArrayStorage[PENDING_VALIDATORS];\n\n\n\n        if (_unremovableStakingAddress != address(0)) {\n\n            addressArrayStorage[PENDING_VALIDATORS].push(miningByStakingAddress(_unremovableStakingAddress));\n\n        }\n\n\n\n        for (i = 0; i < _stakingAddresses.length; i++) {\n\n            addressArrayStorage[PENDING_VALIDATORS].push(miningByStakingAddress(_stakingAddresses[i]));\n\n        }\n\n\n\n        address[] memory poolsToBeRemoved = _stakingContract.getPoolsToBeRemoved();\n\n        for (i = 0; i < poolsToBeRemoved.length; i++) {\n\n            _stakingContract.removePool(poolsToBeRemoved[i]);\n\n        }\n",
                    "message": "Function 'ValidatorSetBase._setPendingValidators' (ValidatorSetAuRaMock.sol#756-779) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IStaking _stakingContract,\n",
                    "message": "Parameter '_stakingContract' of ValidatorSetBase._setPendingValidators (ValidatorSetAuRaMock.sol#757) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 758,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _stakingAddresses,\n",
                    "message": "Parameter '_stakingAddresses' of ValidatorSetBase._setPendingValidators (ValidatorSetAuRaMock.sol#758) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 759,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _unremovableStakingAddress\n",
                    "message": "Parameter '_unremovableStakingAddress' of ValidatorSetBase._setPendingValidators (ValidatorSetAuRaMock.sol#759) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": 789,
                    "vulnerability_code": "    function _setQueueValidators(address[] memory _miningAddresses, bool _newStakingEpoch) internal {\n\n        addressArrayStorage[QUEUE_VALIDATORS] = _miningAddresses;\n\n        boolStorage[QUEUE_VALIDATORS_NEW_STAKING_EPOCH] = _newStakingEpoch;\n",
                    "message": "Function 'ValidatorSetBase._setQueueValidators' (ValidatorSetAuRaMock.sol#786-789) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setQueueValidators(address[] memory _miningAddresses, bool _newStakingEpoch) internal {\n",
                    "message": "Parameter '_miningAddresses' of ValidatorSetBase._setQueueValidators (ValidatorSetAuRaMock.sol#786) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setQueueValidators(address[] memory _miningAddresses, bool _newStakingEpoch) internal {\n",
                    "message": "Parameter '_newStakingEpoch' of ValidatorSetBase._setQueueValidators (ValidatorSetAuRaMock.sol#786) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": 805,
                    "vulnerability_code": "    function _setStakingAddress(address _miningAddress, address _stakingAddress) internal {\n\n        require(_miningAddress != address(0));\n\n        require(_stakingAddress != address(0));\n\n        require(_miningAddress != _stakingAddress);\n\n        require(miningByStakingAddress(_stakingAddress) == address(0));\n\n        require(miningByStakingAddress(_miningAddress) == address(0));\n\n        require(stakingByMiningAddress(_stakingAddress) == address(0));\n\n        require(stakingByMiningAddress(_miningAddress) == address(0));\n\n        addressStorage[keccak256(abi.encode(MINING_BY_STAKING_ADDRESS, _stakingAddress))] = _miningAddress;\n\n        addressStorage[keccak256(abi.encode(STAKING_BY_MINING_ADDRESS, _miningAddress))] = _stakingAddress;\n",
                    "message": "Function 'ValidatorSetBase._setStakingAddress' (ValidatorSetAuRaMock.sol#795-805) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakingAddress(address _miningAddress, address _stakingAddress) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase._setStakingAddress (ValidatorSetAuRaMock.sol#795) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakingAddress(address _miningAddress, address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of ValidatorSetBase._setStakingAddress (ValidatorSetAuRaMock.sol#795) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 810,
                    "vulnerability_to_line": 812,
                    "vulnerability_code": "    function _setUnremovableValidator(address _stakingAddress) internal {\n\n        addressStorage[UNREMOVABLE_STAKING_ADDRESS] = _stakingAddress;\n",
                    "message": "Function 'ValidatorSetBase._setUnremovableValidator' (ValidatorSetAuRaMock.sol#810-812) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 810,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setUnremovableValidator(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of ValidatorSetBase._setUnremovableValidator (ValidatorSetAuRaMock.sol#810) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 818,
                    "vulnerability_to_line": 820,
                    "vulnerability_code": "    function _setValidatorIndex(address _miningAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(VALIDATOR_INDEX, _miningAddress))] = _index;\n",
                    "message": "Function 'ValidatorSetBase._setValidatorIndex' (ValidatorSetAuRaMock.sol#818-820) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 818,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setValidatorIndex(address _miningAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase._setValidatorIndex (ValidatorSetAuRaMock.sol#818) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 818,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setValidatorIndex(address _miningAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of ValidatorSetBase._setValidatorIndex (ValidatorSetAuRaMock.sol#818) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 826,
                    "vulnerability_to_line": 828,
                    "vulnerability_code": "    function _setValidatorSetApplyBlock(uint256 _blockNumber) internal {\n\n        uintStorage[VALIDATOR_SET_APPLY_BLOCK] = _blockNumber;\n",
                    "message": "Function 'ValidatorSetBase._setValidatorSetApplyBlock' (ValidatorSetAuRaMock.sol#826-828) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 826,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setValidatorSetApplyBlock(uint256 _blockNumber) internal {\n",
                    "message": "Parameter '_blockNumber' of ValidatorSetBase._setValidatorSetApplyBlock (ValidatorSetAuRaMock.sol#826) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 832,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _banStart() internal view returns(uint256);\n",
                    "message": "Function 'ValidatorSetBase._banStart' (ValidatorSetAuRaMock.sol#832) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 836,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _banUntil() internal view returns(uint256);\n",
                    "message": "Function 'ValidatorSetBase._banUntil' (ValidatorSetAuRaMock.sol#836) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 839,
                    "vulnerability_to_line": 841,
                    "vulnerability_code": "    function _getCurrentBlockNumber() internal view returns(uint256) {\n\n        return block.number;\n",
                    "message": "Function 'ValidatorSetBase._getCurrentBlockNumber' (ValidatorSetAuRaMock.sol#839-841) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 848,
                    "vulnerability_to_line": 861,
                    "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n\n        internal\n\n        pure\n\n        returns(uint256)\n\n    {\n\n        int256 r = int256(_randomNumber % uint256(_likelihoodSum)) + 1;\n\n        uint256 index = 0;\n\n        while (true) {\n\n            r -= _likelihood[index];\n\n            if (r <= 0) break;\n\n            index++;\n\n        }\n\n        return index;\n",
                    "message": "Function 'ValidatorSetBase._getRandomIndex' (ValidatorSetAuRaMock.sol#848-861) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n",
                    "message": "Parameter '_likelihood' of ValidatorSetBase._getRandomIndex (ValidatorSetAuRaMock.sol#848) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n",
                    "message": "Parameter '_likelihoodSum' of ValidatorSetBase._getRandomIndex (ValidatorSetAuRaMock.sol#848) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n",
                    "message": "Parameter '_randomNumber' of ValidatorSetBase._getRandomIndex (ValidatorSetAuRaMock.sol#848) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 870,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeMaliciousValidator(address) external;\n",
                    "message": "Parameter '' of IValidatorSetAuRa.removeMaliciousValidator (ValidatorSetAuRaMock.sol#870) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 871,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '' of IValidatorSetAuRa.reportMaliciousCallable (ValidatorSetAuRaMock.sol#871) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 871,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '_scope_0' of IValidatorSetAuRa.reportMaliciousCallable (ValidatorSetAuRaMock.sol#871) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 871,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '_scope_1' of IValidatorSetAuRa.reportMaliciousCallable (ValidatorSetAuRaMock.sol#871) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 881,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IStakingAuRa.initialize (ValidatorSetAuRaMock.sol#881) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 882,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_0' of IStakingAuRa.initialize (ValidatorSetAuRaMock.sol#882) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 883,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_1' of IStakingAuRa.initialize (ValidatorSetAuRaMock.sol#883) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 884,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_2' of IStakingAuRa.initialize (ValidatorSetAuRaMock.sol#884) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 885,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_3' of IStakingAuRa.initialize (ValidatorSetAuRaMock.sol#885) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 886,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_4' of IStakingAuRa.initialize (ValidatorSetAuRaMock.sol#886) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 887,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_5' of IStakingAuRa.initialize (ValidatorSetAuRaMock.sol#887) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 888,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_6' of IStakingAuRa.initialize (ValidatorSetAuRaMock.sol#888) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 890,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingEpochStartBlock(uint256) external;\n",
                    "message": "Parameter '' of IStakingAuRa.setStakingEpochStartBlock (ValidatorSetAuRaMock.sol#890) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 950,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeMaliciousValidator(address _miningAddress) external onlyRandomContract {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetAuRa.removeMaliciousValidator (ValidatorSetAuRaMock.sol#950) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _reportingMiningAddress,\n",
                    "message": "Parameter '_reportingMiningAddress' of ValidatorSetAuRa.reportMaliciousCallable (ValidatorSetAuRaMock.sol#1057) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _maliciousMiningAddress,\n",
                    "message": "Parameter '_maliciousMiningAddress' of ValidatorSetAuRa.reportMaliciousCallable (ValidatorSetAuRaMock.sol#1058) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _blockNumber\n",
                    "message": "Parameter '_blockNumber' of ValidatorSetAuRa.reportMaliciousCallable (ValidatorSetAuRaMock.sol#1059) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1111,
                    "vulnerability_to_line": 1113,
                    "vulnerability_code": "    function _banStart() internal view returns(uint256) {\n\n        return _getCurrentBlockNumber();\n",
                    "message": "Function 'ValidatorSetAuRa._banStart' (ValidatorSetAuRaMock.sol#1111-1113) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1116,
                    "vulnerability_to_line": 1118,
                    "vulnerability_code": "    function _banUntil() internal view returns(uint256) {\n\n        return _banStart() + 1555200; // 90 days (for 5 seconds block)\n",
                    "message": "Function 'ValidatorSetAuRa._banUntil' (ValidatorSetAuRaMock.sol#1116-1118) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 961,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _maliciousMiningAddress,\n",
                    "message": "Parameter '_maliciousMiningAddress' of ValidatorSetAuRa.reportMalicious (ValidatorSetAuRaMock.sol#961) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _blockNumber,\n",
                    "message": "Parameter '_blockNumber' of ValidatorSetAuRa.reportMalicious (ValidatorSetAuRaMock.sol#962) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 963,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata\n",
                    "message": "Parameter '' of ValidatorSetAuRa.reportMalicious (ValidatorSetAuRaMock.sol#963) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1020,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _maliciousMiningAddress,\n",
                    "message": "Parameter '_maliciousMiningAddress' of ValidatorSetAuRa.maliceReportedForBlock (ValidatorSetAuRaMock.sol#1020) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1021,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _blockNumber\n",
                    "message": "Parameter '_blockNumber' of ValidatorSetAuRa.maliceReportedForBlock (ValidatorSetAuRaMock.sol#1021) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1032,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportingCounter(address _reportingMiningAddress, uint256 _stakingEpoch) public view returns(uint256) {\n",
                    "message": "Parameter '_reportingMiningAddress' of ValidatorSetAuRa.reportingCounter (ValidatorSetAuRaMock.sol#1032) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1032,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportingCounter(address _reportingMiningAddress, uint256 _stakingEpoch) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingEpoch' of ValidatorSetAuRa.reportingCounter (ValidatorSetAuRaMock.sol#1032) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1039,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportingCounterTotal(uint256 _stakingEpoch) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingEpoch' of ValidatorSetAuRa.reportingCounterTotal (ValidatorSetAuRaMock.sol#1039) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1124,
                    "vulnerability_to_line": 1136,
                    "vulnerability_code": "    function _clearReportingCounter(address _miningAddress) internal {\n\n        uint256 currentStakingEpoch = IStaking(stakingContract()).stakingEpoch();\n\n        uint256 total = reportingCounterTotal(currentStakingEpoch);\n\n        uint256 counter = reportingCounter(_miningAddress, currentStakingEpoch);\n\n\n\n        uintStorage[keccak256(abi.encode(REPORTING_COUNTER, _miningAddress, currentStakingEpoch))] = 0;\n\n\n\n        if (total >= counter) {\n\n            uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))] -= counter;\n\n        } else {\n\n            uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))] = 0;\n\n        }\n",
                    "message": "Function 'ValidatorSetAuRa._clearReportingCounter' (ValidatorSetAuRaMock.sol#1124-1136) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _clearReportingCounter(address _miningAddress) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetAuRa._clearReportingCounter (ValidatorSetAuRaMock.sol#1124) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": 1147,
                    "vulnerability_code": "    function _incrementReportingCounter(address _reportingMiningAddress) internal {\n\n        if (!isReportValidatorValid(_reportingMiningAddress)) return;\n\n        uint256 currentStakingEpoch = IStaking(stakingContract()).stakingEpoch();\n\n        uintStorage[keccak256(abi.encode(REPORTING_COUNTER, _reportingMiningAddress, currentStakingEpoch))]++;\n\n        uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))]++;\n",
                    "message": "Function 'ValidatorSetAuRa._incrementReportingCounter' (ValidatorSetAuRaMock.sol#1142-1147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _incrementReportingCounter(address _reportingMiningAddress) internal {\n",
                    "message": "Parameter '_reportingMiningAddress' of ValidatorSetAuRa._incrementReportingCounter (ValidatorSetAuRaMock.sol#1142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1153,
                    "vulnerability_to_line": 1165,
                    "vulnerability_code": "    function _removeMaliciousValidatorAuRa(address _miningAddress) internal {\n\n        if (isValidatorBanned(_miningAddress)) {\n\n            // The malicious validator is already banned\n\n            return;\n\n        }\n\n\n\n        if (_removeMaliciousValidator(_miningAddress)) {\n\n            // From this moment `getPendingValidators()` will return the new validator set\n\n            _incrementChangeRequestCount();\n\n            _enqueuePendingValidators(false);\n\n            _clearReportingCounter(_miningAddress);\n\n        }\n",
                    "message": "Function 'ValidatorSetAuRa._removeMaliciousValidatorAuRa' (ValidatorSetAuRaMock.sol#1153-1165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeMaliciousValidatorAuRa(address _miningAddress) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetAuRa._removeMaliciousValidatorAuRa (ValidatorSetAuRaMock.sol#1153) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": 1233,
                    "vulnerability_code": "    function _getCurrentBlockNumber() internal view returns(uint256) {\n\n        return uintStorage[keccak256(\"currentBlockNumber\")];\n",
                    "message": "Function 'ValidatorSetAuRaMock._getCurrentBlockNumber' (ValidatorSetAuRaMock.sol#1231-1233) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBannedUntil(address _miningAddress, uint256 _bannedUntil) public {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetAuRaMock.setBannedUntil (ValidatorSetAuRaMock.sol#1191) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBannedUntil(address _miningAddress, uint256 _bannedUntil) public {\n",
                    "message": "Parameter '_bannedUntil' of ValidatorSetAuRaMock.setBannedUntil (ValidatorSetAuRaMock.sol#1191) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBlockRewardContract(address _address) public {\n",
                    "message": "Parameter '_address' of ValidatorSetAuRaMock.setBlockRewardContract (ValidatorSetAuRaMock.sol#1195) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCurrentBlockNumber(uint256 _blockNumber) public {\n",
                    "message": "Parameter '_blockNumber' of ValidatorSetAuRaMock.setCurrentBlockNumber (ValidatorSetAuRaMock.sol#1199) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRandomContract(address _address) public {\n",
                    "message": "Parameter '_address' of ValidatorSetAuRaMock.setRandomContract (ValidatorSetAuRaMock.sol#1203) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1207,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setSystemAddress(address _systemAddress) public {\n",
                    "message": "Parameter '_systemAddress' of ValidatorSetAuRaMock.setSystemAddress (ValidatorSetAuRaMock.sol#1207) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setValidatorSetApplyBlock(uint256 _blockNumber) public {\n",
                    "message": "Parameter '_blockNumber' of ValidatorSetAuRaMock.setValidatorSetApplyBlock (ValidatorSetAuRaMock.sol#1211) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        int256[] memory _likelihood,\n",
                    "message": "Parameter '_likelihood' of ValidatorSetAuRaMock.getRandomIndex (ValidatorSetAuRaMock.sol#1218) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        int256 _likelihoodSum,\n",
                    "message": "Parameter '_likelihoodSum' of ValidatorSetAuRaMock.getRandomIndex (ValidatorSetAuRaMock.sol#1219) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _randomNumber\n",
                    "message": "Parameter '_randomNumber' of ValidatorSetAuRaMock.getRandomIndex (ValidatorSetAuRaMock.sol#1220) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1235,
                    "vulnerability_to_line": 1237,
                    "vulnerability_code": "    function _getSystemAddress() internal view returns(address) {\n\n        return addressStorage[keccak256(\"systemAddress\")];\n",
                    "message": "Function 'ValidatorSetAuRaMock._getSystemAddress' (ValidatorSetAuRaMock.sol#1235-1237) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (ValidatorSetAuRaMock.sol#93) is never used in ValidatorSetAuRaMock\nEternalStorage.bytesStorage (ValidatorSetAuRaMock.sol#95) is never used in ValidatorSetAuRaMock\nEternalStorage.bytes32Storage (ValidatorSetAuRaMock.sol#98) is never used in ValidatorSetAuRaMock\nEternalStorage.uintArrayStorage (ValidatorSetAuRaMock.sol#100) is never used in ValidatorSetAuRaMock\nEternalStorage.stringArrayStorage (ValidatorSetAuRaMock.sol#101) is never used in ValidatorSetAuRaMock\nEternalStorage.bytesArrayStorage (ValidatorSetAuRaMock.sol#103) is never used in ValidatorSetAuRaMock\nEternalStorage.boolArrayStorage (ValidatorSetAuRaMock.sol#104) is never used in ValidatorSetAuRaMock\nEternalStorage.intArrayStorage (ValidatorSetAuRaMock.sol#105) is never used in ValidatorSetAuRaMock\nEternalStorage.bytes32ArrayStorage (ValidatorSetAuRaMock.sol#106) is never used in ValidatorSetAuRaMock\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == 0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _setUnremovableValidator(address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 m = 0; m < reportedValidators.length; m++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 m = 0; m < reportedValidators.length; m++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 871,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 939,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external onlyBlockRewardContract returns(bool called, uint256 poolsToBeElectedLength) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) public view returns(bool callable, bool removeReportingValidator) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialMiningAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _firstValidatorIsUnremovable\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isInitialized()); // initialization can only be done once\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isInitialized()); // initialization can only be done once\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_blockRewardContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_blockRewardContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_blockRewardContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_randomContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_randomContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_randomContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_initialMiningAddresses.length > 0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_initialMiningAddresses.length > 0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_initialMiningAddresses.length == _initialStakingAddresses.length);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_initialMiningAddresses.length == _initialStakingAddresses.length);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_initialMiningAddresses.length == _initialStakingAddresses.length);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        addressStorage[BLOCK_REWARD_CONTRACT] = _blockRewardContract;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        addressStorage[RANDOM_CONTRACT] = _randomContract;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        addressStorage[STAKING_CONTRACT] = _stakingContract;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] storage currentValidators = addressArrayStorage[CURRENT_VALIDATORS];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] storage pendingValidators = addressArrayStorage[PENDING_VALIDATORS];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentValidators.push(_initialMiningAddresses[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentValidators.push(_initialMiningAddresses[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pendingValidators.push(_initialMiningAddresses[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pendingValidators.push(_initialMiningAddresses[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setValidatorIndex(_initialMiningAddresses[i], i);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setValidatorIndex(_initialMiningAddresses[i], i);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setValidatorIndex(_initialMiningAddresses[i], i);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setIsValidator(_initialMiningAddresses[i], true);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setIsValidator(_initialMiningAddresses[i], true);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setStakingAddress(_initialMiningAddresses[i], _initialStakingAddresses[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setStakingAddress(_initialMiningAddresses[i], _initialStakingAddresses[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setStakingAddress(_initialMiningAddresses[i], _initialStakingAddresses[i]);\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/test/mockContracts/ERC677BridgeTokenRewardableMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract MintableToken is StandardToken, Ownable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  bool public mintingFinished = false;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(string memory _name, string memory _symbol, uint8 _decimals) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    name = _name;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    symbol = _symbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    decimals = _decimals;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string memory _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 459,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string memory _symbol,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 _decimals\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) public DetailedERC20(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _symbol,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _decimals\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 465,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 570,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string memory _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string memory _symbol,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 573,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 _decimals\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) public ERC677BridgeToken(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _symbol,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 577,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _decimals\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string memory _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string memory _symbol,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 648,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 _decimals\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 649,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) public ERC677BridgeTokenRewardable(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 651,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _symbol,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    _decimals\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 653,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  ) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 601,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < _receivers.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(_bridgeContract != address(0) && isContract(_bridgeContract));\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 473,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(_recipient != address(0) && _recipient != address(this));\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(_blockRewardContract != address(0) && isContract(_blockRewardContract));\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(_stakingContract != address(0) && isContract(_stakingContract));\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 507,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    if (isContract(_to) && !contractFallback(_to, _value, new bytes(0))) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 508,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      if (_to == bridgeContract) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        revert();\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit ContractFallbackCallFailed(msg.sender, _to, _value);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 601,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < _receivers.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_86"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": 539,
                    "vulnerability_code": "  function isContract(address _addr)\n\n    internal\n\n    view\n\n    returns (bool)\n\n  {\n\n    uint length;\n\n    assembly { length := extcodesize(_addr) }\n\n    return length > 0;\n",
                    "message": "ERC677BridgeToken.isContract (ERC677BridgeTokenRewardableMock.sol#531-539) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": 539,
                    "vulnerability_code": "  function isContract(address _addr)\n\n    internal\n\n    view\n\n    returns (bool)\n\n  {\n\n    uint length;\n\n    assembly { length := extcodesize(_addr) }\n\n    return length > 0;\n",
                    "message": "ERC677BridgeToken.isContract uses assembly (ERC677BridgeTokenRewardableMock.sol#531-539)\n\t- ERC677BridgeTokenRewardableMock.sol#537\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function totalSupply() public view returns(uint256);\n",
                    "message": "ERC20Basic.totalSupply (ERC677BridgeTokenRewardableMock.sol#26) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": 129,
                    "vulnerability_code": "  function totalSupply() public view returns (uint256) {\n\n    return totalSupply_;\n",
                    "message": "BasicToken.totalSupply (ERC677BridgeTokenRewardableMock.sol#127-129) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "  function balanceOf(address _owner) public view returns (uint256) {\n\n    return balances[_owner];\n",
                    "message": "BasicToken.balanceOf (ERC677BridgeTokenRewardableMock.sol#151-153) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function balanceOf(address who) public view returns(uint256);\n",
                    "message": "ERC20Basic.balanceOf (ERC677BridgeTokenRewardableMock.sol#27) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 326,
                    "vulnerability_to_line": 335,
                    "vulnerability_code": "  function allowance(\n\n    address _owner,\n\n    address _spender\n\n   )\n\n    public\n\n    view\n\n    returns (uint256)\n\n  {\n\n    return allowed[_owner][_spender];\n",
                    "message": "StandardToken.allowance (ERC677BridgeTokenRewardableMock.sol#326-335) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function allowance(address owner, address spender) public view returns(uint256);\n",
                    "message": "ERC20.allowance (ERC677BridgeTokenRewardableMock.sol#39) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function approve(address spender, uint256 value) public returns(bool);\n",
                    "message": "ERC20.approve (ERC677BridgeTokenRewardableMock.sol#41) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": 318,
                    "vulnerability_code": "  function approve(address _spender, uint256 _value) public returns (bool) {\n\n    allowed[msg.sender][_spender] = _value;\n\n    emit Approval(msg.sender, _spender, _value);\n\n    return true;\n",
                    "message": "StandardToken.approve (ERC677BridgeTokenRewardableMock.sol#314-318) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": 432,
                    "vulnerability_code": "  function mint(\n\n    address _to,\n\n    uint256 _amount\n\n  )\n\n    hasMintPermission\n\n    canMint\n\n    public\n\n    returns (bool)\n\n  {\n\n    totalSupply_ = totalSupply_.add(_amount);\n\n    balances[_to] = balances[_to].add(_amount);\n\n    emit Mint(_to, _amount);\n\n    emit Transfer(address(0), _to, _amount);\n\n    return true;\n",
                    "message": "MintableToken.mint (ERC677BridgeTokenRewardableMock.sol#418-432) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function mint(address, uint256) public returns(bool);\n",
                    "message": "IBurnableMintableERC677Token.mint (ERC677BridgeTokenRewardableMock.sol#54) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function burn(uint256 _value) public;\n",
                    "message": "IBurnableMintableERC677Token.burn (ERC677BridgeTokenRewardableMock.sol#55) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": 173,
                    "vulnerability_code": "  function burn(uint256 _value) public {\n\n    _burn(msg.sender, _value);\n",
                    "message": "BurnableToken.burn (ERC677BridgeTokenRewardableMock.sol#171-173) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": 559,
                    "vulnerability_code": "  function claimTokens(address _token, address payable _to) public onlyOwner {\n\n    require(_to != address(0));\n\n    if (_token == address(0)) {\n\n      _to.transfer(address(this).balance);\n\n      return;\n\n    }\n\n\n\n    DetailedERC20 token = DetailedERC20(_token);\n\n    uint256 balance = token.balanceOf(address(this));\n\n    require(token.transfer(_to, balance));\n",
                    "message": "ERC677BridgeToken.claimTokens (ERC677BridgeTokenRewardableMock.sol#549-559) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function claimTokens(address _token, address payable _to) public;\n",
                    "message": "IBurnableMintableERC677Token.claimTokens (ERC677BridgeTokenRewardableMock.sol#56) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": 245,
                    "vulnerability_code": "  function renounceOwnership() public onlyOwner {\n\n    emit OwnershipRenounced(owner);\n\n    owner = address(0);\n",
                    "message": "Ownable.renounceOwnership (ERC677BridgeTokenRewardableMock.sol#242-245) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": 547,
                    "vulnerability_code": "  function renounceOwnership() public onlyOwner {\n\n    revert();\n",
                    "message": "ERC677BridgeToken.renounceOwnership (ERC677BridgeTokenRewardableMock.sol#545-547) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": 253,
                    "vulnerability_code": "  function transferOwnership(address _newOwner) public onlyOwner {\n\n    _transferOwnership(_newOwner);\n",
                    "message": "Ownable.transferOwnership (ERC677BridgeTokenRewardableMock.sol#251-253) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 347,
                    "vulnerability_to_line": 357,
                    "vulnerability_code": "  function increaseApproval(\n\n    address _spender,\n\n    uint _addedValue\n\n  )\n\n    public\n\n    returns (bool)\n\n  {\n\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n    return true;\n",
                    "message": "StandardToken.increaseApproval (ERC677BridgeTokenRewardableMock.sol#347-357) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 384,
                    "vulnerability_code": "  function decreaseApproval(\n\n    address _spender,\n\n    uint _subtractedValue\n\n  )\n\n    public\n\n    returns (bool)\n\n  {\n\n    uint oldValue = allowed[msg.sender][_spender];\n\n    if (_subtractedValue > oldValue) {\n\n      allowed[msg.sender][_spender] = 0;\n\n    } else {\n\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\n    }\n\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n    return true;\n",
                    "message": "StandardToken.decreaseApproval (ERC677BridgeTokenRewardableMock.sol#369-384) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": 543,
                    "vulnerability_code": "  function finishMinting() public returns (bool) {\n\n    revert();\n",
                    "message": "ERC677BridgeToken.finishMinting (ERC677BridgeTokenRewardableMock.sol#541-543) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 438,
                    "vulnerability_to_line": 442,
                    "vulnerability_code": "  function finishMinting() onlyOwner canMint public returns (bool) {\n\n    mintingFinished = true;\n\n    emit MintFinished();\n\n    return true;\n",
                    "message": "MintableToken.finishMinting (ERC677BridgeTokenRewardableMock.sol#438-442) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 467,
                    "vulnerability_to_line": 470,
                    "vulnerability_code": "  function setBridgeContract(address _bridgeContract) onlyOwner public {\n\n    require(_bridgeContract != address(0) && isContract(_bridgeContract));\n\n    bridgeContract = _bridgeContract;\n",
                    "message": "ERC677BridgeToken.setBridgeContract (ERC677BridgeTokenRewardableMock.sol#467-470) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 495,
                    "vulnerability_to_line": 497,
                    "vulnerability_code": "  function getTokenInterfacesVersion() public pure returns(uint64 major, uint64 minor, uint64 patch) {\n\n    return (2, 0, 0);\n",
                    "message": "ERC677BridgeToken.getTokenInterfacesVersion (ERC677BridgeTokenRewardableMock.sol#495-497) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 590,
                    "vulnerability_to_line": 593,
                    "vulnerability_code": "  function setBlockRewardContract(address _blockRewardContract) onlyOwner public {\n\n    require(_blockRewardContract != address(0) && isContract(_blockRewardContract));\n\n    blockRewardContract = _blockRewardContract;\n",
                    "message": "ERC677BridgeTokenRewardable.setBlockRewardContract (ERC677BridgeTokenRewardableMock.sol#590-593) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": 598,
                    "vulnerability_code": "  function setStakingContract(address _stakingContract) onlyOwner public {\n\n    require(_stakingContract != address(0) && isContract(_stakingContract));\n\n    stakingContract = _stakingContract;\n",
                    "message": "ERC677BridgeTokenRewardable.setStakingContract (ERC677BridgeTokenRewardableMock.sol#595-598) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in ERC677BridgeTokenRewardableMock.sol:\n\t- pragma solidity0.5.9 (ERC677BridgeTokenRewardableMock.sol#3): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": 529,
                    "vulnerability_code": "  function contractFallback(\n\n    address _to,\n\n    uint _value,\n\n    bytes memory _data\n\n  )\n\n    private\n\n    returns(bool)\n\n  {\n\n    (bool success,) = _to.call(\n\n      abi.encodeWithSignature(\"onTokenTransfer(address,uint256,bytes)\", msg.sender, _value, _data)\n\n    );\n\n    return success;\n",
                    "message": "Low level call in ERC677BridgeToken.contractFallback (ERC677BridgeTokenRewardableMock.sol#517-529):\n\t-(success) = _to.call(abi.encodeWithSignature(onTokenTransfer(address,uint256,bytes),msg.sender,_value,_data)) ERC677BridgeTokenRewardableMock.sol#525-527\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function transferAndCall(address, uint, bytes calldata) external returns(bool);\n",
                    "message": "Parameter '' of ERC677.transferAndCall (ERC677BridgeTokenRewardableMock.sol#48) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function transferAndCall(address, uint, bytes calldata) external returns(bool);\n",
                    "message": "Parameter '_scope_0' of ERC677.transferAndCall (ERC677BridgeTokenRewardableMock.sol#48) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function transferAndCall(address, uint, bytes calldata) external returns(bool);\n",
                    "message": "Parameter '_scope_1' of ERC677.transferAndCall (ERC677BridgeTokenRewardableMock.sol#48) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function mint(address, uint256) public returns(bool);\n",
                    "message": "Parameter '' of IBurnableMintableERC677Token.mint (ERC677BridgeTokenRewardableMock.sol#54) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function mint(address, uint256) public returns(bool);\n",
                    "message": "Parameter '_scope_0' of IBurnableMintableERC677Token.mint (ERC677BridgeTokenRewardableMock.sol#54) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function balanceOf(address _owner) public view returns (uint256) {\n",
                    "message": "Parameter '_owner' of BasicToken.balanceOf (ERC677BridgeTokenRewardableMock.sol#151) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function transfer(address _to, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_to' of BasicToken.transfer (ERC677BridgeTokenRewardableMock.sol#136) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function transfer(address _to, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_value' of BasicToken.transfer (ERC677BridgeTokenRewardableMock.sol#136) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function burn(uint256 _value) public {\n",
                    "message": "Parameter '_value' of BurnableToken.burn (ERC677BridgeTokenRewardableMock.sol#171) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": 184,
                    "vulnerability_code": "  function _burn(address _who, uint256 _value) internal {\n\n    require(_value <= balances[_who]);\n\n    // no need to require value <= totalSupply, since that would imply the\n\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n\n\n    balances[_who] = balances[_who].sub(_value);\n\n    totalSupply_ = totalSupply_.sub(_value);\n\n    emit Burn(_who, _value);\n\n    emit Transfer(_who, address(0), _value);\n",
                    "message": "Function 'BurnableToken._burn' (ERC677BridgeTokenRewardableMock.sol#175-184) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function _burn(address _who, uint256 _value) internal {\n",
                    "message": "Parameter '_who' of BurnableToken._burn (ERC677BridgeTokenRewardableMock.sol#175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function _burn(address _who, uint256 _value) internal {\n",
                    "message": "Parameter '_value' of BurnableToken._burn (ERC677BridgeTokenRewardableMock.sol#175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(string memory _name, string memory _symbol, uint8 _decimals) public {\n",
                    "message": "Parameter '_name' of DetailedERC20. (ERC677BridgeTokenRewardableMock.sol#200) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(string memory _name, string memory _symbol, uint8 _decimals) public {\n",
                    "message": "Parameter '_symbol' of DetailedERC20. (ERC677BridgeTokenRewardableMock.sol#200) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(string memory _name, string memory _symbol, uint8 _decimals) public {\n",
                    "message": "Parameter '_decimals' of DetailedERC20. (ERC677BridgeTokenRewardableMock.sol#200) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function transferOwnership(address _newOwner) public onlyOwner {\n",
                    "message": "Parameter '_newOwner' of Ownable.transferOwnership (ERC677BridgeTokenRewardableMock.sol#251) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": 263,
                    "vulnerability_code": "  function _transferOwnership(address _newOwner) internal {\n\n    require(_newOwner != address(0));\n\n    emit OwnershipTransferred(owner, _newOwner);\n\n    owner = _newOwner;\n",
                    "message": "Function 'Ownable._transferOwnership' (ERC677BridgeTokenRewardableMock.sol#259-263) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function _transferOwnership(address _newOwner) internal {\n",
                    "message": "Parameter '_newOwner' of Ownable._transferOwnership (ERC677BridgeTokenRewardableMock.sol#259) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 327,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _owner,\n",
                    "message": "Parameter '_owner' of StandardToken.allowance (ERC677BridgeTokenRewardableMock.sol#327) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _spender\n",
                    "message": "Parameter '_spender' of StandardToken.allowance (ERC677BridgeTokenRewardableMock.sol#328) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _from,\n",
                    "message": "Parameter '_from' of StandardToken.transferFrom (ERC677BridgeTokenRewardableMock.sol#286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _to,\n",
                    "message": "Parameter '_to' of StandardToken.transferFrom (ERC677BridgeTokenRewardableMock.sol#287) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _value\n",
                    "message": "Parameter '_value' of StandardToken.transferFrom (ERC677BridgeTokenRewardableMock.sol#288) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_spender' of StandardToken.approve (ERC677BridgeTokenRewardableMock.sol#314) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_value' of StandardToken.approve (ERC677BridgeTokenRewardableMock.sol#314) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _spender,\n",
                    "message": "Parameter '_spender' of StandardToken.increaseApproval (ERC677BridgeTokenRewardableMock.sol#348) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint _addedValue\n",
                    "message": "Parameter '_addedValue' of StandardToken.increaseApproval (ERC677BridgeTokenRewardableMock.sol#349) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _spender,\n",
                    "message": "Parameter '_spender' of StandardToken.decreaseApproval (ERC677BridgeTokenRewardableMock.sol#370) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint _subtractedValue\n",
                    "message": "Parameter '_subtractedValue' of StandardToken.decreaseApproval (ERC677BridgeTokenRewardableMock.sol#371) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _to,\n",
                    "message": "Parameter '_to' of MintableToken.mint (ERC677BridgeTokenRewardableMock.sol#419) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _amount\n",
                    "message": "Parameter '_amount' of MintableToken.mint (ERC677BridgeTokenRewardableMock.sol#420) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function transfer(address _to, uint256 _value) public returns (bool)\n",
                    "message": "Parameter '_to' of ERC677BridgeToken.transfer (ERC677BridgeTokenRewardableMock.sol#504) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function transfer(address _to, uint256 _value) public returns (bool)\n",
                    "message": "Parameter '_value' of ERC677BridgeToken.transfer (ERC677BridgeTokenRewardableMock.sol#504) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _to,\n",
                    "message": "Parameter '_to' of ERC677BridgeToken.transferAndCall (ERC677BridgeTokenRewardableMock.sol#478) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 479,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint _value,\n",
                    "message": "Parameter '_value' of ERC677BridgeToken.transferAndCall (ERC677BridgeTokenRewardableMock.sol#479) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes calldata _data\n",
                    "message": "Parameter '_data' of ERC677BridgeToken.transferAndCall (ERC677BridgeTokenRewardableMock.sol#480) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function claimTokens(address _token, address payable _to) public onlyOwner {\n",
                    "message": "Parameter '_token' of ERC677BridgeToken.claimTokens (ERC677BridgeTokenRewardableMock.sol#549) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function claimTokens(address _token, address payable _to) public onlyOwner {\n",
                    "message": "Parameter '_to' of ERC677BridgeToken.claimTokens (ERC677BridgeTokenRewardableMock.sol#549) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function setBridgeContract(address _bridgeContract) onlyOwner public {\n",
                    "message": "Parameter '_bridgeContract' of ERC677BridgeToken.setBridgeContract (ERC677BridgeTokenRewardableMock.sol#467) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function superTransfer(address _to, uint256 _value) internal returns(bool)\n",
                    "message": "Parameter '_to' of ERC677BridgeToken.superTransfer (ERC677BridgeTokenRewardableMock.sol#499) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function superTransfer(address _to, uint256 _value) internal returns(bool)\n",
                    "message": "Parameter '_value' of ERC677BridgeToken.superTransfer (ERC677BridgeTokenRewardableMock.sol#499) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address _to,\n",
                    "message": "Parameter '_to' of ERC677BridgeToken.contractFallback (ERC677BridgeTokenRewardableMock.sol#518) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 519,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint _value,\n",
                    "message": "Parameter '_value' of ERC677BridgeToken.contractFallback (ERC677BridgeTokenRewardableMock.sol#519) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes memory _data\n",
                    "message": "Parameter '_data' of ERC677BridgeToken.contractFallback (ERC677BridgeTokenRewardableMock.sol#520) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function transfer(address _to, uint256 _value) public returns(bool) {\n",
                    "message": "Parameter '_to' of ERC677BridgeTokenRewardable.transfer (ERC677BridgeTokenRewardableMock.sol#632) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function transfer(address _to, uint256 _value) public returns(bool) {\n",
                    "message": "Parameter '_value' of ERC677BridgeTokenRewardable.transfer (ERC677BridgeTokenRewardableMock.sol#632) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function transferFrom(address _from, address _to, uint256 _value) public returns(bool) {\n",
                    "message": "Parameter '_from' of ERC677BridgeTokenRewardable.transferFrom (ERC677BridgeTokenRewardableMock.sol#637) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function transferFrom(address _from, address _to, uint256 _value) public returns(bool) {\n",
                    "message": "Parameter '_to' of ERC677BridgeTokenRewardable.transferFrom (ERC677BridgeTokenRewardableMock.sol#637) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function transferFrom(address _from, address _to, uint256 _value) public returns(bool) {\n",
                    "message": "Parameter '_value' of ERC677BridgeTokenRewardable.transferFrom (ERC677BridgeTokenRewardableMock.sol#637) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 590,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function setBlockRewardContract(address _blockRewardContract) onlyOwner public {\n",
                    "message": "Parameter '_blockRewardContract' of ERC677BridgeTokenRewardable.setBlockRewardContract (ERC677BridgeTokenRewardableMock.sol#590) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function setStakingContract(address _stakingContract) onlyOwner public {\n",
                    "message": "Parameter '_stakingContract' of ERC677BridgeTokenRewardable.setStakingContract (ERC677BridgeTokenRewardableMock.sol#595) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 600,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function mintReward(address[] calldata _receivers, uint256[] calldata _rewards) external onlyBlockRewardContract {\n",
                    "message": "Parameter '_receivers' of ERC677BridgeTokenRewardable.mintReward (ERC677BridgeTokenRewardableMock.sol#600) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 600,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function mintReward(address[] calldata _receivers, uint256[] calldata _rewards) external onlyBlockRewardContract {\n",
                    "message": "Parameter '_rewards' of ERC677BridgeTokenRewardable.mintReward (ERC677BridgeTokenRewardableMock.sol#600) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function stake(address _staker, uint256 _amount) external onlyStakingContract {\n",
                    "message": "Parameter '_staker' of ERC677BridgeTokenRewardable.stake (ERC677BridgeTokenRewardableMock.sol#616) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function stake(address _staker, uint256 _amount) external onlyStakingContract {\n",
                    "message": "Parameter '_amount' of ERC677BridgeTokenRewardable.stake (ERC677BridgeTokenRewardableMock.sol#616) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 624,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function withdraw(address _staker, uint256 _amount) external onlyStakingContract {\n",
                    "message": "Parameter '_staker' of ERC677BridgeTokenRewardable.withdraw (ERC677BridgeTokenRewardableMock.sol#624) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 624,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function withdraw(address _staker, uint256 _amount) external onlyStakingContract {\n",
                    "message": "Parameter '_amount' of ERC677BridgeTokenRewardable.withdraw (ERC677BridgeTokenRewardableMock.sol#624) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 601,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < _receivers.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function finishMinting() public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 601,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    for (uint256 i = 0; i < _receivers.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract IBurnableMintableERC677Token is ERC677 {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function setBridgeContract(address _bridgeContract) onlyOwner public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 590,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function setBlockRewardContract(address _blockRewardContract) onlyOwner public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function setStakingContract(address _stakingContract) onlyOwner public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 508,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      if (_to == bridgeContract) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function isContract(address _addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 495,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function getTokenInterfacesVersion() public pure returns(uint64 major, uint64 minor, uint64 patch) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (bool success,) = _to.call(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function claimTokens(address _token, address payable _to) public;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function claimTokens(address _token, address payable _to) public onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  mapping(address => uint256) balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  uint256 totalSupply_;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(_to != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(_to != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    require(_to != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    if (_token == address(0)) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    if (_token == address(0)) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    if (_token == address(0)) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      _to.transfer(address(this).balance);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      _to.transfer(address(this).balance);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      _to.transfer(address(this).balance);\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/test/mockContracts/RandomAuRaMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (applyBlock != 0 && _getCurrentBlockNumber() > applyBlock + collectRoundLength() * 2) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // Check whether each validator didn't reveal their secret\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // during the current collection round\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 363,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            validators = validatorSetContract().getValidators();\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                validator = validators[i];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (!sentReveal(currentRound, validator)) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _incrementRevealSkips(stakingEpoch, validator);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                maxRevealSkipsAllowed--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[keccak256(abi.encode(REVEAL_SKIPS, _stakingEpoch, _miningAddress))]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_103"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner (RandomAuRaMock.sol#55) is never initialized. It is used in:\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": 309,
                    "vulnerability_code": "    function commitHash(bytes32 _secretHash, bytes calldata _cipher) external onlyInitialized {\n\n        address miningAddress = msg.sender;\n\n\n\n        require(commitHashCallable(miningAddress, _secretHash));\n\n        require(_getCoinbase() == miningAddress); // make sure validator node is live\n\n\n\n        uint256 collectRound = currentCollectRound();\n\n\n\n        _setCommit(collectRound, miningAddress, _secretHash);\n\n        _setCipher(collectRound, miningAddress, _cipher);\n\n        _addCommittedValidator(collectRound, miningAddress);\n",
                    "message": "Reentrancy in RandomAuRa.commitHash (RandomAuRaMock.sol#298-309):\n\tExternal calls:\n\t- require(bool)(commitHashCallable(miningAddress,_secretHash)) (RandomAuRaMock.sol#301)\n\tState variables written after the call(s):\n\t- bytes32Storage (RandomAuRaMock.sol#306)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": 399,
                    "vulnerability_code": "    function onFinishCollectRound() external onlyBlockReward {\n\n        if (_getCurrentBlockNumber() % collectRoundLength() != collectRoundLength() - 1) return;\n\n\n\n        // This is the last block of the current collection round\n\n\n\n        address[] memory validators;\n\n        address validator;\n\n        uint256 i;\n\n\n\n        address stakingContract = validatorSetContract().stakingContract();\n\n\n\n        uint256 stakingEpoch = IStaking(stakingContract).stakingEpoch();\n\n        uint256 applyBlock = validatorSetContract().validatorSetApplyBlock();\n\n        uint256 endBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock();\n\n        uint256 currentRound = currentCollectRound();\n\n\n\n        if (applyBlock != 0 && _getCurrentBlockNumber() > applyBlock + collectRoundLength() * 2) {\n\n            // Check whether each validator didn't reveal their secret\n\n            // during the current collection round\n\n            validators = validatorSetContract().getValidators();\n\n            for (i = 0; i < validators.length; i++) {\n\n                validator = validators[i];\n\n                if (!sentReveal(currentRound, validator)) {\n\n                    _incrementRevealSkips(stakingEpoch, validator);\n\n                }\n\n            }\n\n        }\n\n\n\n        // If this is the last collection round in the current staking epoch.\n\n        if (_getCurrentBlockNumber() == endBlock || _getCurrentBlockNumber() + collectRoundLength() > endBlock) {\n\n            uint256 maxRevealSkipsAllowed =\n\n                IStakingAuRa(stakingContract).stakeWithdrawDisallowPeriod() / collectRoundLength();\n\n\n\n            if (maxRevealSkipsAllowed > 0) {\n\n                maxRevealSkipsAllowed--;\n\n            }\n\n\n\n            // Check each validator to see if they didn't reveal\n\n            // their secret during the last full `reveals phase`\n\n            // or if they missed the required number of reveals per staking epoch.\n\n            validators = validatorSetContract().getValidators();\n\n            for (i = 0; i < validators.length; i++) {\n\n                validator = validators[i];\n\n                if (\n\n                    !sentReveal(currentRound, validator) ||\n\n                    revealSkips(stakingEpoch, validator) > maxRevealSkipsAllowed\n\n                ) {\n\n                    // Remove the validator as malicious\n\n                    IValidatorSetAuRa(address(validatorSetContract())).removeMaliciousValidator(validator);\n\n                }\n\n            }\n\n        }\n\n\n\n        // Clear unnecessary info about previous collection round.\n\n        _clearOldCiphers(currentRound);\n",
                    "message": "Reentrancy in RandomAuRa.onFinishCollectRound (RandomAuRaMock.sol#344-399):\n\tExternal calls:\n\t- stakingContract = validatorSetContract().stakingContract() (RandomAuRaMock.sol#353)\n\t- stakingEpoch = IStaking(stakingContract).stakingEpoch() (RandomAuRaMock.sol#355)\n\t- applyBlock = validatorSetContract().validatorSetApplyBlock() (RandomAuRaMock.sol#356)\n\t- endBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock() (RandomAuRaMock.sol#357)\n\t- validators = validatorSetContract().getValidators() (RandomAuRaMock.sol#363)\n\tState variables written after the call(s):\n\t- uintStorage (RandomAuRaMock.sol#367)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 315,
                    "vulnerability_to_line": 323,
                    "vulnerability_code": "    function revealSecret(uint256 _secret) external onlyInitialized {\n\n        address miningAddress = msg.sender;\n\n\n\n        require(revealSecretCallable(miningAddress, _secret));\n\n        require(_getCoinbase() == miningAddress); // make sure validator node is live\n\n\n\n        _setCurrentSeed(_getCurrentSeed() ^ _secret);\n\n        _setSentReveal(currentCollectRound(), miningAddress);\n",
                    "message": "Reentrancy in RandomAuRa.revealSecret (RandomAuRaMock.sol#315-323):\n\tExternal calls:\n\t- require(bool)(revealSecretCallable(miningAddress,_secret)) (RandomAuRaMock.sol#318)\n\tState variables written after the call(s):\n\t- boolStorage (RandomAuRaMock.sol#322)\n\t- uintStorage (RandomAuRaMock.sol#321)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": 309,
                    "vulnerability_code": "    function commitHash(bytes32 _secretHash, bytes calldata _cipher) external onlyInitialized {\n\n        address miningAddress = msg.sender;\n\n\n\n        require(commitHashCallable(miningAddress, _secretHash));\n\n        require(_getCoinbase() == miningAddress); // make sure validator node is live\n\n\n\n        uint256 collectRound = currentCollectRound();\n\n\n\n        _setCommit(collectRound, miningAddress, _secretHash);\n\n        _setCipher(collectRound, miningAddress, _cipher);\n\n        _addCommittedValidator(collectRound, miningAddress);\n",
                    "message": "Reentrancy in RandomAuRa.commitHash (RandomAuRaMock.sol#298-309):\n\tExternal calls:\n\t- require(bool)(commitHashCallable(miningAddress,_secretHash)) (RandomAuRaMock.sol#301)\n\tState variables written after the call(s):\n\t- addressArrayStorage (RandomAuRaMock.sol#308)\n\t- bytesStorage (RandomAuRaMock.sol#307)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": 399,
                    "vulnerability_code": "    function onFinishCollectRound() external onlyBlockReward {\n\n        if (_getCurrentBlockNumber() % collectRoundLength() != collectRoundLength() - 1) return;\n\n\n\n        // This is the last block of the current collection round\n\n\n\n        address[] memory validators;\n\n        address validator;\n\n        uint256 i;\n\n\n\n        address stakingContract = validatorSetContract().stakingContract();\n\n\n\n        uint256 stakingEpoch = IStaking(stakingContract).stakingEpoch();\n\n        uint256 applyBlock = validatorSetContract().validatorSetApplyBlock();\n\n        uint256 endBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock();\n\n        uint256 currentRound = currentCollectRound();\n\n\n\n        if (applyBlock != 0 && _getCurrentBlockNumber() > applyBlock + collectRoundLength() * 2) {\n\n            // Check whether each validator didn't reveal their secret\n\n            // during the current collection round\n\n            validators = validatorSetContract().getValidators();\n\n            for (i = 0; i < validators.length; i++) {\n\n                validator = validators[i];\n\n                if (!sentReveal(currentRound, validator)) {\n\n                    _incrementRevealSkips(stakingEpoch, validator);\n\n                }\n\n            }\n\n        }\n\n\n\n        // If this is the last collection round in the current staking epoch.\n\n        if (_getCurrentBlockNumber() == endBlock || _getCurrentBlockNumber() + collectRoundLength() > endBlock) {\n\n            uint256 maxRevealSkipsAllowed =\n\n                IStakingAuRa(stakingContract).stakeWithdrawDisallowPeriod() / collectRoundLength();\n\n\n\n            if (maxRevealSkipsAllowed > 0) {\n\n                maxRevealSkipsAllowed--;\n\n            }\n\n\n\n            // Check each validator to see if they didn't reveal\n\n            // their secret during the last full `reveals phase`\n\n            // or if they missed the required number of reveals per staking epoch.\n\n            validators = validatorSetContract().getValidators();\n\n            for (i = 0; i < validators.length; i++) {\n\n                validator = validators[i];\n\n                if (\n\n                    !sentReveal(currentRound, validator) ||\n\n                    revealSkips(stakingEpoch, validator) > maxRevealSkipsAllowed\n\n                ) {\n\n                    // Remove the validator as malicious\n\n                    IValidatorSetAuRa(address(validatorSetContract())).removeMaliciousValidator(validator);\n\n                }\n\n            }\n\n        }\n\n\n\n        // Clear unnecessary info about previous collection round.\n\n        _clearOldCiphers(currentRound);\n",
                    "message": "Reentrancy in RandomAuRa.onFinishCollectRound (RandomAuRaMock.sol#344-399):\n\tExternal calls:\n\t- stakingContract = validatorSetContract().stakingContract() (RandomAuRaMock.sol#353)\n\t- stakingEpoch = IStaking(stakingContract).stakingEpoch() (RandomAuRaMock.sol#355)\n\t- applyBlock = validatorSetContract().validatorSetApplyBlock() (RandomAuRaMock.sol#356)\n\t- endBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock() (RandomAuRaMock.sol#357)\n\t- validators = validatorSetContract().getValidators() (RandomAuRaMock.sol#363)\n\t- maxRevealSkipsAllowed = IStakingAuRa(stakingContract).stakeWithdrawDisallowPeriod() / collectRoundLength() (RandomAuRaMock.sol#374-375)\n\t- validators = validatorSetContract().getValidators() (RandomAuRaMock.sol#384)\n\tState variables written after the call(s):\n\t- bytesStorage (RandomAuRaMock.sol#398)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (RandomAuRaMock.sol#55)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": 424,
                    "vulnerability_code": "    function getCipher(uint256 _collectRound, address _miningAddress) public view returns(bytes memory) {\n\n        return bytesStorage[keccak256(abi.encode(CIPHERS, _collectRound, _miningAddress))];\n",
                    "message": "RandomAuRa.getCipher (RandomAuRaMock.sol#422-424) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 599,
                    "vulnerability_to_line": 601,
                    "vulnerability_code": "    function setCoinbase(address _coinbase) public {\n\n        addressStorage[keccak256(\"coinbase\")] = _coinbase;\n",
                    "message": "RandomAuRaMock.setCoinbase (RandomAuRaMock.sol#599-601) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 603,
                    "vulnerability_to_line": 605,
                    "vulnerability_code": "    function setCurrentBlockNumber(uint256 _blockNumber) public {\n\n        uintStorage[keccak256(\"currentBlockNumber\")] = _blockNumber;\n",
                    "message": "RandomAuRaMock.setCurrentBlockNumber (RandomAuRaMock.sol#603-605) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 607,
                    "vulnerability_to_line": 609,
                    "vulnerability_code": "    function showCurrentSeed() public view returns(uint256) {\n\n        return _getCurrentSeed();\n",
                    "message": "RandomAuRaMock.showCurrentSeed (RandomAuRaMock.sol#607-609) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in RandomAuRaMock.sol:\n\t- pragma solidity0.5.9 (RandomAuRaMock.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRaMock.sol#12): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRaMock.sol#47): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRaMock.sol#78): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRaMock.sol#96): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRaMock.sol#135): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRaMock.sol#206): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRaMock.sol#218): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRaMock.sol#228): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRaMock.sol#248): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRaMock.sol#270): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRaMock.sol#593): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (RandomAuRaMock.sol#17) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (RandomAuRaMock.sol#18) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (RandomAuRaMock.sol#19) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (RandomAuRaMock.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (RandomAuRaMock.sol#21) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (RandomAuRaMock.sol#22) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (RandomAuRaMock.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (RandomAuRaMock.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (RandomAuRaMock.sol#32) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (RandomAuRaMock.sol#33) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (RandomAuRaMock.sol#34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (RandomAuRaMock.sol#35) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (RandomAuRaMock.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (RandomAuRaMock.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (RandomAuRaMock.sol#41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (RandomAuRaMock.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": 189,
                    "vulnerability_code": "    function _initialize(address _validatorSet) internal {\n\n        require(!isInitialized());\n\n        require(_validatorSet != address(0));\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSet;\n",
                    "message": "Function 'RandomBase._initialize' (RandomAuRaMock.sol#185-189) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _initialize(address _validatorSet) internal {\n",
                    "message": "Parameter '_validatorSet' of RandomBase._initialize (RandomAuRaMock.sol#185) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": 195,
                    "vulnerability_code": "    function _setCurrentSeed(uint256 _seed) internal {\n\n        uintStorage[CURRENT_SEED] = _seed;\n",
                    "message": "Function 'RandomBase._setCurrentSeed' (RandomAuRaMock.sol#193-195) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCurrentSeed(uint256 _seed) internal {\n",
                    "message": "Parameter '_seed' of RandomBase._setCurrentSeed (RandomAuRaMock.sol#193) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": 200,
                    "vulnerability_code": "    function _getCurrentSeed() internal view returns(uint256) {\n\n        return uintStorage[CURRENT_SEED];\n",
                    "message": "Function 'RandomBase._getCurrentSeed' (RandomAuRaMock.sol#198-200) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(uint256, address) external;\n",
                    "message": "Parameter '' of IRandomAuRa.initialize (RandomAuRaMock.sol#210) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(uint256, address) external;\n",
                    "message": "Parameter '_scope_0' of IRandomAuRa.initialize (RandomAuRaMock.sol#210) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHashCallable(address, bytes32) external view returns(bool);\n",
                    "message": "Parameter '' of IRandomAuRa.commitHashCallable (RandomAuRaMock.sol#212) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHashCallable(address, bytes32) external view returns(bool);\n",
                    "message": "Parameter '_scope_0' of IRandomAuRa.commitHashCallable (RandomAuRaMock.sol#212) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSecretCallable(address, uint256) external view returns(bool);\n",
                    "message": "Parameter '' of IRandomAuRa.revealSecretCallable (RandomAuRaMock.sol#213) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSecretCallable(address, uint256) external view returns(bool);\n",
                    "message": "Parameter '_scope_0' of IRandomAuRa.revealSecretCallable (RandomAuRaMock.sol#213) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeMaliciousValidator(address) external;\n",
                    "message": "Parameter '' of IValidatorSetAuRa.removeMaliciousValidator (RandomAuRaMock.sol#222) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '' of IValidatorSetAuRa.reportMaliciousCallable (RandomAuRaMock.sol#223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '_scope_0' of IValidatorSetAuRa.reportMaliciousCallable (RandomAuRaMock.sol#223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '_scope_1' of IValidatorSetAuRa.reportMaliciousCallable (RandomAuRaMock.sol#223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
                    "message": "Parameter '' of IStaking.clearUnremovableValidator (RandomAuRaMock.sol#232) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address) external;\n",
                    "message": "Parameter '' of IStaking.removePool (RandomAuRaMock.sol#234) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "Parameter '' of IStaking.poolDelegators (RandomAuRaMock.sol#240) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (RandomAuRaMock.sol#241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (RandomAuRaMock.sol#241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (RandomAuRaMock.sol#242) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IStakingAuRa.initialize (RandomAuRaMock.sol#253) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_0' of IStakingAuRa.initialize (RandomAuRaMock.sol#254) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_1' of IStakingAuRa.initialize (RandomAuRaMock.sol#255) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_2' of IStakingAuRa.initialize (RandomAuRaMock.sol#256) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_3' of IStakingAuRa.initialize (RandomAuRaMock.sol#257) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_4' of IStakingAuRa.initialize (RandomAuRaMock.sol#258) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_5' of IStakingAuRa.initialize (RandomAuRaMock.sol#259) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_6' of IStakingAuRa.initialize (RandomAuRaMock.sol#260) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingEpochStartBlock(uint256) external;\n",
                    "message": "Parameter '' of IStakingAuRa.setStakingEpochStartBlock (RandomAuRaMock.sol#262) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _collectRoundLength, // in blocks\n",
                    "message": "Parameter '_collectRoundLength' of RandomAuRa.initialize (RandomAuRaMock.sol#330) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _validatorSet\n",
                    "message": "Parameter '_validatorSet' of RandomAuRa.initialize (RandomAuRaMock.sol#331) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHashCallable(address _miningAddress, bytes32 _secretHash) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa.commitHashCallable (RandomAuRaMock.sol#460) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHashCallable(address _miningAddress, bytes32 _secretHash) public view returns(bool) {\n",
                    "message": "Parameter '_secretHash' of RandomAuRa.commitHashCallable (RandomAuRaMock.sol#460) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 476,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSecretCallable(address _miningAddress, uint256 _secret) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa.revealSecretCallable (RandomAuRaMock.sol#476) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 476,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSecretCallable(address _miningAddress, uint256 _secret) public view returns(bool) {\n",
                    "message": "Parameter '_secret' of RandomAuRa.revealSecretCallable (RandomAuRaMock.sol#476) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHash(bytes32 _secretHash, bytes calldata _cipher) external onlyInitialized {\n",
                    "message": "Parameter '_secretHash' of RandomAuRa.commitHash (RandomAuRaMock.sol#298) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHash(bytes32 _secretHash, bytes calldata _cipher) external onlyInitialized {\n",
                    "message": "Parameter '_cipher' of RandomAuRa.commitHash (RandomAuRaMock.sol#298) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 315,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSecret(uint256 _secret) external onlyInitialized {\n",
                    "message": "Parameter '_secret' of RandomAuRa.revealSecret (RandomAuRaMock.sol#315) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getCipher(uint256 _collectRound, address _miningAddress) public view returns(bytes memory) {\n",
                    "message": "Parameter '_collectRound' of RandomAuRa.getCipher (RandomAuRaMock.sol#422) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getCipher(uint256 _collectRound, address _miningAddress) public view returns(bytes memory) {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa.getCipher (RandomAuRaMock.sol#422) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getCommit(uint256 _collectRound, address _miningAddress) public view returns(bytes32) {\n",
                    "message": "Parameter '_collectRound' of RandomAuRa.getCommit (RandomAuRaMock.sol#430) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getCommit(uint256 _collectRound, address _miningAddress) public view returns(bytes32) {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa.getCommit (RandomAuRaMock.sol#430) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 438,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isCommitted(uint256 _collectRound, address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_collectRound' of RandomAuRa.isCommitted (RandomAuRaMock.sol#438) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 438,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isCommitted(uint256 _collectRound, address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa.isCommitted (RandomAuRaMock.sol#438) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSkips(uint256 _stakingEpoch, address _miningAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingEpoch' of RandomAuRa.revealSkips (RandomAuRaMock.sol#501) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSkips(uint256 _stakingEpoch, address _miningAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa.revealSkips (RandomAuRaMock.sol#501) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sentReveal(uint256 _collectRound, address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_collectRound' of RandomAuRa.sentReveal (RandomAuRaMock.sol#509) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sentReveal(uint256 _collectRound, address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa.sentReveal (RandomAuRaMock.sol#509) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": 528,
                    "vulnerability_code": "    function _addCommittedValidator(uint256 _collectRound, address _miningAddress) private {\n\n        addressArrayStorage[keccak256(abi.encode(COMMITTED_VALIDATORS, _collectRound))].push(_miningAddress);\n",
                    "message": "Function 'RandomAuRa._addCommittedValidator' (RandomAuRaMock.sol#526-528) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addCommittedValidator(uint256 _collectRound, address _miningAddress) private {\n",
                    "message": "Parameter '_collectRound' of RandomAuRa._addCommittedValidator (RandomAuRaMock.sol#526) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addCommittedValidator(uint256 _collectRound, address _miningAddress) private {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa._addCommittedValidator (RandomAuRaMock.sol#526) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 532,
                    "vulnerability_to_line": 544,
                    "vulnerability_code": "    function _clearOldCiphers(uint256 _collectRound) private {\n\n        if (_collectRound == 0) {\n\n            return;\n\n        }\n\n\n\n        uint256 collectRound = _collectRound - 1;\n\n        address[] storage miningAddresses =\n\n            addressArrayStorage[keccak256(abi.encode(COMMITTED_VALIDATORS, collectRound))];\n\n\n\n        for (uint256 i = 0; i < miningAddresses.length; i++) {\n\n            delete bytesStorage[keccak256(abi.encode(CIPHERS, collectRound, miningAddresses[i]))];\n\n        }\n",
                    "message": "Function 'RandomAuRa._clearOldCiphers' (RandomAuRaMock.sol#532-544) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 532,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _clearOldCiphers(uint256 _collectRound) private {\n",
                    "message": "Parameter '_collectRound' of RandomAuRa._clearOldCiphers (RandomAuRaMock.sol#532) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 547,
                    "vulnerability_to_line": 549,
                    "vulnerability_code": "    function _getCoinbase() internal view returns(address) {\n\n        return block.coinbase;\n",
                    "message": "Function 'RandomAuRa._getCoinbase' (RandomAuRaMock.sol#547-549) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": 554,
                    "vulnerability_code": "    function _getCurrentBlockNumber() internal view returns(uint256) {\n\n        return block.number;\n",
                    "message": "Function 'RandomAuRa._getCurrentBlockNumber' (RandomAuRaMock.sol#552-554) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": 562,
                    "vulnerability_code": "    function _incrementRevealSkips(uint256 _stakingEpoch, address _miningAddress) private {\n\n        uintStorage[keccak256(abi.encode(REVEAL_SKIPS, _stakingEpoch, _miningAddress))]++;\n",
                    "message": "Function 'RandomAuRa._incrementRevealSkips' (RandomAuRaMock.sol#560-562) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _incrementRevealSkips(uint256 _stakingEpoch, address _miningAddress) private {\n",
                    "message": "Parameter '_stakingEpoch' of RandomAuRa._incrementRevealSkips (RandomAuRaMock.sol#560) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _incrementRevealSkips(uint256 _stakingEpoch, address _miningAddress) private {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa._incrementRevealSkips (RandomAuRaMock.sol#560) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 569,
                    "vulnerability_to_line": 571,
                    "vulnerability_code": "    function _setCipher(uint256 _collectRound, address _miningAddress, bytes memory _cipher) private {\n\n        bytesStorage[keccak256(abi.encode(CIPHERS, _collectRound, _miningAddress))] = _cipher;\n",
                    "message": "Function 'RandomAuRa._setCipher' (RandomAuRaMock.sol#569-571) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCipher(uint256 _collectRound, address _miningAddress, bytes memory _cipher) private {\n",
                    "message": "Parameter '_collectRound' of RandomAuRa._setCipher (RandomAuRaMock.sol#569) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCipher(uint256 _collectRound, address _miningAddress, bytes memory _cipher) private {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa._setCipher (RandomAuRaMock.sol#569) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCipher(uint256 _collectRound, address _miningAddress, bytes memory _cipher) private {\n",
                    "message": "Parameter '_cipher' of RandomAuRa._setCipher (RandomAuRaMock.sol#569) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": 580,
                    "vulnerability_code": "    function _setCommit(uint256 _collectRound, address _miningAddress, bytes32 _secretHash) private {\n\n        bytes32Storage[keccak256(abi.encode(COMMITS, _collectRound, _miningAddress))] = _secretHash;\n",
                    "message": "Function 'RandomAuRa._setCommit' (RandomAuRaMock.sol#578-580) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCommit(uint256 _collectRound, address _miningAddress, bytes32 _secretHash) private {\n",
                    "message": "Parameter '_collectRound' of RandomAuRa._setCommit (RandomAuRaMock.sol#578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCommit(uint256 _collectRound, address _miningAddress, bytes32 _secretHash) private {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa._setCommit (RandomAuRaMock.sol#578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCommit(uint256 _collectRound, address _miningAddress, bytes32 _secretHash) private {\n",
                    "message": "Parameter '_secretHash' of RandomAuRa._setCommit (RandomAuRaMock.sol#578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": 588,
                    "vulnerability_code": "    function _setSentReveal(uint256 _collectRound, address _miningAddress) private {\n\n        boolStorage[keccak256(abi.encode(SENT_REVEAL, _collectRound, _miningAddress))] = true;\n",
                    "message": "Function 'RandomAuRa._setSentReveal' (RandomAuRaMock.sol#586-588) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setSentReveal(uint256 _collectRound, address _miningAddress) private {\n",
                    "message": "Parameter '_collectRound' of RandomAuRa._setSentReveal (RandomAuRaMock.sol#586) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setSentReveal(uint256 _collectRound, address _miningAddress) private {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa._setSentReveal (RandomAuRaMock.sol#586) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 613,
                    "vulnerability_to_line": 616,
                    "vulnerability_code": "    function _getCoinbase() internal view returns(address) {\n\n        address coinbase = addressStorage[keccak256(\"coinbase\")];\n\n        return coinbase != address(0) ? coinbase : block.coinbase;\n",
                    "message": "Function 'RandomAuRaMock._getCoinbase' (RandomAuRaMock.sol#613-616) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 618,
                    "vulnerability_to_line": 620,
                    "vulnerability_code": "    function _getCurrentBlockNumber() internal view returns(uint256) {\n\n        return uintStorage[keccak256(\"currentBlockNumber\")];\n",
                    "message": "Function 'RandomAuRaMock._getCurrentBlockNumber' (RandomAuRaMock.sol#618-620) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 599,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCoinbase(address _coinbase) public {\n",
                    "message": "Parameter '_coinbase' of RandomAuRaMock.setCoinbase (RandomAuRaMock.sol#599) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 603,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCurrentBlockNumber(uint256 _blockNumber) public {\n",
                    "message": "Parameter '_blockNumber' of RandomAuRaMock.setCurrentBlockNumber (RandomAuRaMock.sol#603) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (RandomAuRaMock.sol#59) is never used in RandomAuRaMock\nEternalStorage.intStorage (RandomAuRaMock.sol#63) is never used in RandomAuRaMock\nEternalStorage.uintArrayStorage (RandomAuRaMock.sol#66) is never used in RandomAuRaMock\nEternalStorage.stringArrayStorage (RandomAuRaMock.sol#67) is never used in RandomAuRaMock\nEternalStorage.bytesArrayStorage (RandomAuRaMock.sol#69) is never used in RandomAuRaMock\nEternalStorage.boolArrayStorage (RandomAuRaMock.sol#70) is never used in RandomAuRaMock\nEternalStorage.intArrayStorage (RandomAuRaMock.sol#71) is never used in RandomAuRaMock\nEternalStorage.bytes32ArrayStorage (RandomAuRaMock.sol#72) is never used in RandomAuRaMock\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/RandomAuRa.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (applyBlock != 0 && _getCurrentBlockNumber() > applyBlock + collectRoundLength() * 2) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // Check whether each validator didn't reveal their secret\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // during the current collection round\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 363,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            validators = validatorSetContract().getValidators();\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                validator = validators[i];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (!sentReveal(currentRound, validator)) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _incrementRevealSkips(stakingEpoch, validator);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                maxRevealSkipsAllowed--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[keccak256(abi.encode(REVEAL_SKIPS, _stakingEpoch, _miningAddress))]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_97"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner (RandomAuRa.sol#55) is never initialized. It is used in:\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": 309,
                    "vulnerability_code": "    function commitHash(bytes32 _secretHash, bytes calldata _cipher) external onlyInitialized {\n\n        address miningAddress = msg.sender;\n\n\n\n        require(commitHashCallable(miningAddress, _secretHash));\n\n        require(_getCoinbase() == miningAddress); // make sure validator node is live\n\n\n\n        uint256 collectRound = currentCollectRound();\n\n\n\n        _setCommit(collectRound, miningAddress, _secretHash);\n\n        _setCipher(collectRound, miningAddress, _cipher);\n\n        _addCommittedValidator(collectRound, miningAddress);\n",
                    "message": "Reentrancy in RandomAuRa.commitHash (RandomAuRa.sol#298-309):\n\tExternal calls:\n\t- require(bool)(commitHashCallable(miningAddress,_secretHash)) (RandomAuRa.sol#301)\n\tState variables written after the call(s):\n\t- bytes32Storage (RandomAuRa.sol#306)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": 399,
                    "vulnerability_code": "    function onFinishCollectRound() external onlyBlockReward {\n\n        if (_getCurrentBlockNumber() % collectRoundLength() != collectRoundLength() - 1) return;\n\n\n\n        // This is the last block of the current collection round\n\n\n\n        address[] memory validators;\n\n        address validator;\n\n        uint256 i;\n\n\n\n        address stakingContract = validatorSetContract().stakingContract();\n\n\n\n        uint256 stakingEpoch = IStaking(stakingContract).stakingEpoch();\n\n        uint256 applyBlock = validatorSetContract().validatorSetApplyBlock();\n\n        uint256 endBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock();\n\n        uint256 currentRound = currentCollectRound();\n\n\n\n        if (applyBlock != 0 && _getCurrentBlockNumber() > applyBlock + collectRoundLength() * 2) {\n\n            // Check whether each validator didn't reveal their secret\n\n            // during the current collection round\n\n            validators = validatorSetContract().getValidators();\n\n            for (i = 0; i < validators.length; i++) {\n\n                validator = validators[i];\n\n                if (!sentReveal(currentRound, validator)) {\n\n                    _incrementRevealSkips(stakingEpoch, validator);\n\n                }\n\n            }\n\n        }\n\n\n\n        // If this is the last collection round in the current staking epoch.\n\n        if (_getCurrentBlockNumber() == endBlock || _getCurrentBlockNumber() + collectRoundLength() > endBlock) {\n\n            uint256 maxRevealSkipsAllowed =\n\n                IStakingAuRa(stakingContract).stakeWithdrawDisallowPeriod() / collectRoundLength();\n\n\n\n            if (maxRevealSkipsAllowed > 0) {\n\n                maxRevealSkipsAllowed--;\n\n            }\n\n\n\n            // Check each validator to see if they didn't reveal\n\n            // their secret during the last full `reveals phase`\n\n            // or if they missed the required number of reveals per staking epoch.\n\n            validators = validatorSetContract().getValidators();\n\n            for (i = 0; i < validators.length; i++) {\n\n                validator = validators[i];\n\n                if (\n\n                    !sentReveal(currentRound, validator) ||\n\n                    revealSkips(stakingEpoch, validator) > maxRevealSkipsAllowed\n\n                ) {\n\n                    // Remove the validator as malicious\n\n                    IValidatorSetAuRa(address(validatorSetContract())).removeMaliciousValidator(validator);\n\n                }\n\n            }\n\n        }\n\n\n\n        // Clear unnecessary info about previous collection round.\n\n        _clearOldCiphers(currentRound);\n",
                    "message": "Reentrancy in RandomAuRa.onFinishCollectRound (RandomAuRa.sol#344-399):\n\tExternal calls:\n\t- stakingContract = validatorSetContract().stakingContract() (RandomAuRa.sol#353)\n\t- stakingEpoch = IStaking(stakingContract).stakingEpoch() (RandomAuRa.sol#355)\n\t- applyBlock = validatorSetContract().validatorSetApplyBlock() (RandomAuRa.sol#356)\n\t- endBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock() (RandomAuRa.sol#357)\n\t- validators = validatorSetContract().getValidators() (RandomAuRa.sol#363)\n\tState variables written after the call(s):\n\t- uintStorage (RandomAuRa.sol#367)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 315,
                    "vulnerability_to_line": 323,
                    "vulnerability_code": "    function revealSecret(uint256 _secret) external onlyInitialized {\n\n        address miningAddress = msg.sender;\n\n\n\n        require(revealSecretCallable(miningAddress, _secret));\n\n        require(_getCoinbase() == miningAddress); // make sure validator node is live\n\n\n\n        _setCurrentSeed(_getCurrentSeed() ^ _secret);\n\n        _setSentReveal(currentCollectRound(), miningAddress);\n",
                    "message": "Reentrancy in RandomAuRa.revealSecret (RandomAuRa.sol#315-323):\n\tExternal calls:\n\t- require(bool)(revealSecretCallable(miningAddress,_secret)) (RandomAuRa.sol#318)\n\tState variables written after the call(s):\n\t- boolStorage (RandomAuRa.sol#322)\n\t- uintStorage (RandomAuRa.sol#321)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 392,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    IValidatorSetAuRa(address(validatorSetContract())).removeMaliciousValidator(validator);\n",
                    "message": "RandomAuRa.onFinishCollectRound has external calls inside a loop:\n\t- IValidatorSetAuRa(address(validatorSetContract())).removeMaliciousValidator(validator) (RandomAuRa.sol#392)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": 309,
                    "vulnerability_code": "    function commitHash(bytes32 _secretHash, bytes calldata _cipher) external onlyInitialized {\n\n        address miningAddress = msg.sender;\n\n\n\n        require(commitHashCallable(miningAddress, _secretHash));\n\n        require(_getCoinbase() == miningAddress); // make sure validator node is live\n\n\n\n        uint256 collectRound = currentCollectRound();\n\n\n\n        _setCommit(collectRound, miningAddress, _secretHash);\n\n        _setCipher(collectRound, miningAddress, _cipher);\n\n        _addCommittedValidator(collectRound, miningAddress);\n",
                    "message": "Reentrancy in RandomAuRa.commitHash (RandomAuRa.sol#298-309):\n\tExternal calls:\n\t- require(bool)(commitHashCallable(miningAddress,_secretHash)) (RandomAuRa.sol#301)\n\tState variables written after the call(s):\n\t- addressArrayStorage (RandomAuRa.sol#308)\n\t- bytesStorage (RandomAuRa.sol#307)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": 399,
                    "vulnerability_code": "    function onFinishCollectRound() external onlyBlockReward {\n\n        if (_getCurrentBlockNumber() % collectRoundLength() != collectRoundLength() - 1) return;\n\n\n\n        // This is the last block of the current collection round\n\n\n\n        address[] memory validators;\n\n        address validator;\n\n        uint256 i;\n\n\n\n        address stakingContract = validatorSetContract().stakingContract();\n\n\n\n        uint256 stakingEpoch = IStaking(stakingContract).stakingEpoch();\n\n        uint256 applyBlock = validatorSetContract().validatorSetApplyBlock();\n\n        uint256 endBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock();\n\n        uint256 currentRound = currentCollectRound();\n\n\n\n        if (applyBlock != 0 && _getCurrentBlockNumber() > applyBlock + collectRoundLength() * 2) {\n\n            // Check whether each validator didn't reveal their secret\n\n            // during the current collection round\n\n            validators = validatorSetContract().getValidators();\n\n            for (i = 0; i < validators.length; i++) {\n\n                validator = validators[i];\n\n                if (!sentReveal(currentRound, validator)) {\n\n                    _incrementRevealSkips(stakingEpoch, validator);\n\n                }\n\n            }\n\n        }\n\n\n\n        // If this is the last collection round in the current staking epoch.\n\n        if (_getCurrentBlockNumber() == endBlock || _getCurrentBlockNumber() + collectRoundLength() > endBlock) {\n\n            uint256 maxRevealSkipsAllowed =\n\n                IStakingAuRa(stakingContract).stakeWithdrawDisallowPeriod() / collectRoundLength();\n\n\n\n            if (maxRevealSkipsAllowed > 0) {\n\n                maxRevealSkipsAllowed--;\n\n            }\n\n\n\n            // Check each validator to see if they didn't reveal\n\n            // their secret during the last full `reveals phase`\n\n            // or if they missed the required number of reveals per staking epoch.\n\n            validators = validatorSetContract().getValidators();\n\n            for (i = 0; i < validators.length; i++) {\n\n                validator = validators[i];\n\n                if (\n\n                    !sentReveal(currentRound, validator) ||\n\n                    revealSkips(stakingEpoch, validator) > maxRevealSkipsAllowed\n\n                ) {\n\n                    // Remove the validator as malicious\n\n                    IValidatorSetAuRa(address(validatorSetContract())).removeMaliciousValidator(validator);\n\n                }\n\n            }\n\n        }\n\n\n\n        // Clear unnecessary info about previous collection round.\n\n        _clearOldCiphers(currentRound);\n",
                    "message": "Reentrancy in RandomAuRa.onFinishCollectRound (RandomAuRa.sol#344-399):\n\tExternal calls:\n\t- stakingContract = validatorSetContract().stakingContract() (RandomAuRa.sol#353)\n\t- stakingEpoch = IStaking(stakingContract).stakingEpoch() (RandomAuRa.sol#355)\n\t- applyBlock = validatorSetContract().validatorSetApplyBlock() (RandomAuRa.sol#356)\n\t- endBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock() (RandomAuRa.sol#357)\n\t- validators = validatorSetContract().getValidators() (RandomAuRa.sol#363)\n\t- maxRevealSkipsAllowed = IStakingAuRa(stakingContract).stakeWithdrawDisallowPeriod() / collectRoundLength() (RandomAuRa.sol#374-375)\n\t- validators = validatorSetContract().getValidators() (RandomAuRa.sol#384)\n\tState variables written after the call(s):\n\t- bytesStorage (RandomAuRa.sol#398)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (RandomAuRa.sol#55)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": 424,
                    "vulnerability_code": "    function getCipher(uint256 _collectRound, address _miningAddress) public view returns(bytes memory) {\n\n        return bytesStorage[keccak256(abi.encode(CIPHERS, _collectRound, _miningAddress))];\n",
                    "message": "RandomAuRa.getCipher (RandomAuRa.sol#422-424) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in RandomAuRa.sol:\n\t- pragma solidity0.5.9 (RandomAuRa.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#12): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#47): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#78): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#96): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#135): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#206): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#218): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#228): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#248): it allows old versions\n\t- pragma solidity0.5.9 (RandomAuRa.sol#270): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (RandomAuRa.sol#17) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (RandomAuRa.sol#18) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (RandomAuRa.sol#19) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (RandomAuRa.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (RandomAuRa.sol#21) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (RandomAuRa.sol#22) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (RandomAuRa.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (RandomAuRa.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (RandomAuRa.sol#32) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (RandomAuRa.sol#33) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (RandomAuRa.sol#34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (RandomAuRa.sol#35) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (RandomAuRa.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (RandomAuRa.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (RandomAuRa.sol#41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (RandomAuRa.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": 189,
                    "vulnerability_code": "    function _initialize(address _validatorSet) internal {\n\n        require(!isInitialized());\n\n        require(_validatorSet != address(0));\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSet;\n",
                    "message": "Function 'RandomBase._initialize' (RandomAuRa.sol#185-189) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _initialize(address _validatorSet) internal {\n",
                    "message": "Parameter '_validatorSet' of RandomBase._initialize (RandomAuRa.sol#185) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": 195,
                    "vulnerability_code": "    function _setCurrentSeed(uint256 _seed) internal {\n\n        uintStorage[CURRENT_SEED] = _seed;\n",
                    "message": "Function 'RandomBase._setCurrentSeed' (RandomAuRa.sol#193-195) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCurrentSeed(uint256 _seed) internal {\n",
                    "message": "Parameter '_seed' of RandomBase._setCurrentSeed (RandomAuRa.sol#193) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": 200,
                    "vulnerability_code": "    function _getCurrentSeed() internal view returns(uint256) {\n\n        return uintStorage[CURRENT_SEED];\n",
                    "message": "Function 'RandomBase._getCurrentSeed' (RandomAuRa.sol#198-200) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(uint256, address) external;\n",
                    "message": "Parameter '' of IRandomAuRa.initialize (RandomAuRa.sol#210) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(uint256, address) external;\n",
                    "message": "Parameter '_scope_0' of IRandomAuRa.initialize (RandomAuRa.sol#210) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHashCallable(address, bytes32) external view returns(bool);\n",
                    "message": "Parameter '' of IRandomAuRa.commitHashCallable (RandomAuRa.sol#212) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHashCallable(address, bytes32) external view returns(bool);\n",
                    "message": "Parameter '_scope_0' of IRandomAuRa.commitHashCallable (RandomAuRa.sol#212) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSecretCallable(address, uint256) external view returns(bool);\n",
                    "message": "Parameter '' of IRandomAuRa.revealSecretCallable (RandomAuRa.sol#213) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSecretCallable(address, uint256) external view returns(bool);\n",
                    "message": "Parameter '_scope_0' of IRandomAuRa.revealSecretCallable (RandomAuRa.sol#213) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeMaliciousValidator(address) external;\n",
                    "message": "Parameter '' of IValidatorSetAuRa.removeMaliciousValidator (RandomAuRa.sol#222) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '' of IValidatorSetAuRa.reportMaliciousCallable (RandomAuRa.sol#223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '_scope_0' of IValidatorSetAuRa.reportMaliciousCallable (RandomAuRa.sol#223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '_scope_1' of IValidatorSetAuRa.reportMaliciousCallable (RandomAuRa.sol#223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
                    "message": "Parameter '' of IStaking.clearUnremovableValidator (RandomAuRa.sol#232) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address) external;\n",
                    "message": "Parameter '' of IStaking.removePool (RandomAuRa.sol#234) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "Parameter '' of IStaking.poolDelegators (RandomAuRa.sol#240) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (RandomAuRa.sol#241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (RandomAuRa.sol#241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (RandomAuRa.sol#242) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IStakingAuRa.initialize (RandomAuRa.sol#253) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_0' of IStakingAuRa.initialize (RandomAuRa.sol#254) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_1' of IStakingAuRa.initialize (RandomAuRa.sol#255) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_2' of IStakingAuRa.initialize (RandomAuRa.sol#256) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_3' of IStakingAuRa.initialize (RandomAuRa.sol#257) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_4' of IStakingAuRa.initialize (RandomAuRa.sol#258) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_5' of IStakingAuRa.initialize (RandomAuRa.sol#259) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_6' of IStakingAuRa.initialize (RandomAuRa.sol#260) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingEpochStartBlock(uint256) external;\n",
                    "message": "Parameter '' of IStakingAuRa.setStakingEpochStartBlock (RandomAuRa.sol#262) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _collectRoundLength, // in blocks\n",
                    "message": "Parameter '_collectRoundLength' of RandomAuRa.initialize (RandomAuRa.sol#330) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _validatorSet\n",
                    "message": "Parameter '_validatorSet' of RandomAuRa.initialize (RandomAuRa.sol#331) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHashCallable(address _miningAddress, bytes32 _secretHash) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa.commitHashCallable (RandomAuRa.sol#460) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHashCallable(address _miningAddress, bytes32 _secretHash) public view returns(bool) {\n",
                    "message": "Parameter '_secretHash' of RandomAuRa.commitHashCallable (RandomAuRa.sol#460) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 476,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSecretCallable(address _miningAddress, uint256 _secret) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa.revealSecretCallable (RandomAuRa.sol#476) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 476,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSecretCallable(address _miningAddress, uint256 _secret) public view returns(bool) {\n",
                    "message": "Parameter '_secret' of RandomAuRa.revealSecretCallable (RandomAuRa.sol#476) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHash(bytes32 _secretHash, bytes calldata _cipher) external onlyInitialized {\n",
                    "message": "Parameter '_secretHash' of RandomAuRa.commitHash (RandomAuRa.sol#298) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHash(bytes32 _secretHash, bytes calldata _cipher) external onlyInitialized {\n",
                    "message": "Parameter '_cipher' of RandomAuRa.commitHash (RandomAuRa.sol#298) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 315,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSecret(uint256 _secret) external onlyInitialized {\n",
                    "message": "Parameter '_secret' of RandomAuRa.revealSecret (RandomAuRa.sol#315) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getCipher(uint256 _collectRound, address _miningAddress) public view returns(bytes memory) {\n",
                    "message": "Parameter '_collectRound' of RandomAuRa.getCipher (RandomAuRa.sol#422) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getCipher(uint256 _collectRound, address _miningAddress) public view returns(bytes memory) {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa.getCipher (RandomAuRa.sol#422) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getCommit(uint256 _collectRound, address _miningAddress) public view returns(bytes32) {\n",
                    "message": "Parameter '_collectRound' of RandomAuRa.getCommit (RandomAuRa.sol#430) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getCommit(uint256 _collectRound, address _miningAddress) public view returns(bytes32) {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa.getCommit (RandomAuRa.sol#430) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 438,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isCommitted(uint256 _collectRound, address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_collectRound' of RandomAuRa.isCommitted (RandomAuRa.sol#438) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 438,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isCommitted(uint256 _collectRound, address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa.isCommitted (RandomAuRa.sol#438) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSkips(uint256 _stakingEpoch, address _miningAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingEpoch' of RandomAuRa.revealSkips (RandomAuRa.sol#501) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSkips(uint256 _stakingEpoch, address _miningAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa.revealSkips (RandomAuRa.sol#501) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sentReveal(uint256 _collectRound, address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_collectRound' of RandomAuRa.sentReveal (RandomAuRa.sol#509) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sentReveal(uint256 _collectRound, address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa.sentReveal (RandomAuRa.sol#509) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": 528,
                    "vulnerability_code": "    function _addCommittedValidator(uint256 _collectRound, address _miningAddress) private {\n\n        addressArrayStorage[keccak256(abi.encode(COMMITTED_VALIDATORS, _collectRound))].push(_miningAddress);\n",
                    "message": "Function 'RandomAuRa._addCommittedValidator' (RandomAuRa.sol#526-528) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addCommittedValidator(uint256 _collectRound, address _miningAddress) private {\n",
                    "message": "Parameter '_collectRound' of RandomAuRa._addCommittedValidator (RandomAuRa.sol#526) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addCommittedValidator(uint256 _collectRound, address _miningAddress) private {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa._addCommittedValidator (RandomAuRa.sol#526) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 532,
                    "vulnerability_to_line": 544,
                    "vulnerability_code": "    function _clearOldCiphers(uint256 _collectRound) private {\n\n        if (_collectRound == 0) {\n\n            return;\n\n        }\n\n\n\n        uint256 collectRound = _collectRound - 1;\n\n        address[] storage miningAddresses =\n\n            addressArrayStorage[keccak256(abi.encode(COMMITTED_VALIDATORS, collectRound))];\n\n\n\n        for (uint256 i = 0; i < miningAddresses.length; i++) {\n\n            delete bytesStorage[keccak256(abi.encode(CIPHERS, collectRound, miningAddresses[i]))];\n\n        }\n",
                    "message": "Function 'RandomAuRa._clearOldCiphers' (RandomAuRa.sol#532-544) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 532,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _clearOldCiphers(uint256 _collectRound) private {\n",
                    "message": "Parameter '_collectRound' of RandomAuRa._clearOldCiphers (RandomAuRa.sol#532) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 547,
                    "vulnerability_to_line": 549,
                    "vulnerability_code": "    function _getCoinbase() internal view returns(address) {\n\n        return block.coinbase;\n",
                    "message": "Function 'RandomAuRa._getCoinbase' (RandomAuRa.sol#547-549) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": 554,
                    "vulnerability_code": "    function _getCurrentBlockNumber() internal view returns(uint256) {\n\n        return block.number;\n",
                    "message": "Function 'RandomAuRa._getCurrentBlockNumber' (RandomAuRa.sol#552-554) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": 562,
                    "vulnerability_code": "    function _incrementRevealSkips(uint256 _stakingEpoch, address _miningAddress) private {\n\n        uintStorage[keccak256(abi.encode(REVEAL_SKIPS, _stakingEpoch, _miningAddress))]++;\n",
                    "message": "Function 'RandomAuRa._incrementRevealSkips' (RandomAuRa.sol#560-562) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _incrementRevealSkips(uint256 _stakingEpoch, address _miningAddress) private {\n",
                    "message": "Parameter '_stakingEpoch' of RandomAuRa._incrementRevealSkips (RandomAuRa.sol#560) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _incrementRevealSkips(uint256 _stakingEpoch, address _miningAddress) private {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa._incrementRevealSkips (RandomAuRa.sol#560) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 569,
                    "vulnerability_to_line": 571,
                    "vulnerability_code": "    function _setCipher(uint256 _collectRound, address _miningAddress, bytes memory _cipher) private {\n\n        bytesStorage[keccak256(abi.encode(CIPHERS, _collectRound, _miningAddress))] = _cipher;\n",
                    "message": "Function 'RandomAuRa._setCipher' (RandomAuRa.sol#569-571) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCipher(uint256 _collectRound, address _miningAddress, bytes memory _cipher) private {\n",
                    "message": "Parameter '_collectRound' of RandomAuRa._setCipher (RandomAuRa.sol#569) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCipher(uint256 _collectRound, address _miningAddress, bytes memory _cipher) private {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa._setCipher (RandomAuRa.sol#569) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCipher(uint256 _collectRound, address _miningAddress, bytes memory _cipher) private {\n",
                    "message": "Parameter '_cipher' of RandomAuRa._setCipher (RandomAuRa.sol#569) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": 580,
                    "vulnerability_code": "    function _setCommit(uint256 _collectRound, address _miningAddress, bytes32 _secretHash) private {\n\n        bytes32Storage[keccak256(abi.encode(COMMITS, _collectRound, _miningAddress))] = _secretHash;\n",
                    "message": "Function 'RandomAuRa._setCommit' (RandomAuRa.sol#578-580) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCommit(uint256 _collectRound, address _miningAddress, bytes32 _secretHash) private {\n",
                    "message": "Parameter '_collectRound' of RandomAuRa._setCommit (RandomAuRa.sol#578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCommit(uint256 _collectRound, address _miningAddress, bytes32 _secretHash) private {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa._setCommit (RandomAuRa.sol#578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCommit(uint256 _collectRound, address _miningAddress, bytes32 _secretHash) private {\n",
                    "message": "Parameter '_secretHash' of RandomAuRa._setCommit (RandomAuRa.sol#578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": 588,
                    "vulnerability_code": "    function _setSentReveal(uint256 _collectRound, address _miningAddress) private {\n\n        boolStorage[keccak256(abi.encode(SENT_REVEAL, _collectRound, _miningAddress))] = true;\n",
                    "message": "Function 'RandomAuRa._setSentReveal' (RandomAuRa.sol#586-588) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setSentReveal(uint256 _collectRound, address _miningAddress) private {\n",
                    "message": "Parameter '_collectRound' of RandomAuRa._setSentReveal (RandomAuRa.sol#586) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setSentReveal(uint256 _collectRound, address _miningAddress) private {\n",
                    "message": "Parameter '_miningAddress' of RandomAuRa._setSentReveal (RandomAuRa.sol#586) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (RandomAuRa.sol#59) is never used in RandomAuRa\nEternalStorage.intStorage (RandomAuRa.sol#63) is never used in RandomAuRa\nEternalStorage.uintArrayStorage (RandomAuRa.sol#66) is never used in RandomAuRa\nEternalStorage.stringArrayStorage (RandomAuRa.sol#67) is never used in RandomAuRa\nEternalStorage.bytesArrayStorage (RandomAuRa.sol#69) is never used in RandomAuRa\nEternalStorage.boolArrayStorage (RandomAuRa.sol#70) is never used in RandomAuRa\nEternalStorage.intArrayStorage (RandomAuRa.sol#71) is never used in RandomAuRa\nEternalStorage.bytes32ArrayStorage (RandomAuRa.sol#72) is never used in RandomAuRa\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/StakingAuRa.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _addPoolToBeRemoved(_poolStakingAddress);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 953,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            intStorage[POOLS_LIKELIHOOD_SUM] -= likelihood[indexToDelete];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 955,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (intStorage[POOLS_LIKELIHOOD_SUM] < 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 956,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                intStorage[POOLS_LIKELIHOOD_SUM] = 0;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 958,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools[indexToDelete] = pools[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            likelihood[indexToDelete] = likelihood[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 960,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolToBeElectedIndex(pools[indexToDelete], indexToDelete);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 961,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolToBeElectedIndex(_stakingAddress, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 975,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools[indexToDelete] = pools[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 976,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolToBeRemovedIndex(pools[indexToDelete], indexToDelete);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolToBeRemovedIndex(_stakingAddress, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 978,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 979,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 988,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 989,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools[indexToRemove] = pools[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 990,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolIndex(pools[indexToRemove], indexToRemove);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 991,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolIndex(_stakingAddress, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 992,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 993,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1009,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1010,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools[indexToRemove] = pools[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1011,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolInactiveIndex(pools[indexToRemove], indexToRemove);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1012,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolInactiveIndex(_stakingAddress, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1013,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1014,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators[indexToRemove] = delegators[delegators.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolDelegatorIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolDelegatorIndex(_poolStakingAddress, _delegator, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators[indexToRemove] = delegators[delegators.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolDelegatorInactiveIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolDelegatorInactiveIndex(_poolStakingAddress, _delegator, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 963,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            likelihood.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 978,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 992,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1013,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[STAKING_EPOCH]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_234"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": 396,
                    "vulnerability_code": "    function withdraw(address _fromPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n\n        address payable staker = msg.sender;\n\n        _withdraw(_fromPoolStakingAddress, staker, _amount);\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, _amount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(_amount);\n\n        }\n\n        emit Withdrawn(_fromPoolStakingAddress, staker, stakingEpoch(), _amount);\n",
                    "message": "StakingBase.withdraw (StakingAuRa.sol#385-396) sends eth to arbitrary user\n\tDangerous calls:\n\t- staker.transfer(_amount) (StakingAuRa.sol#393)\n"
                },
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n        uint256 epoch = stakingEpoch();\n\n        address payable staker = msg.sender;\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(epoch > orderWithdrawEpoch(_poolStakingAddress, staker));\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        uint256 claimAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n        require(claimAmount != 0);\n\n\n\n        uint256 resultingStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(claimAmount);\n\n\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, 0);\n\n        _setOrderedWithdrawAmountTotal(\n\n            _poolStakingAddress,\n\n            orderedWithdrawAmountTotal(_poolStakingAddress).sub(claimAmount)\n\n        );\n\n        _setStakeAmount(_poolStakingAddress, staker, resultingStakeAmount);\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(claimAmount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, claimAmount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(claimAmount);\n\n        }\n\n\n\n        emit Claimed(_poolStakingAddress, staker, epoch, claimAmount);\n",
                    "message": "StakingBase.claimOrderedWithdraw (StakingAuRa.sol#480-517) sends eth to arbitrary user\n\tDangerous calls:\n\t- staker.transfer(claimAmount) (StakingAuRa.sol#513)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner (StakingAuRa.sol#97) is never initialized. It is used in:\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1024,
                    "vulnerability_to_line": 1056,
                    "vulnerability_code": "    function _initialize(\n\n        address _validatorSetContract,\n\n        address[] memory _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        bool _erc20Restricted\n\n    ) internal {\n\n        require(!isInitialized()); // initialization can only be done once\n\n        require(_validatorSetContract != address(0));\n\n        require(_initialStakingAddresses.length > 0);\n\n        require(_delegatorMinStake != 0);\n\n        require(_candidateMinStake != 0);\n\n\n\n        IBlockReward blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract());\n\n        require(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0);\n\n\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSetContract;\n\n\n\n        address unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator();\n\n\n\n        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n\n            require(_initialStakingAddresses[i] != address(0));\n\n            _addPoolActive(_initialStakingAddresses[i], false);\n\n            if (_initialStakingAddresses[i] != unremovableStakingAddress) {\n\n                _addPoolToBeRemoved(_initialStakingAddresses[i]);\n\n            }\n\n        }\n\n\n\n        _setDelegatorMinStake(_delegatorMinStake);\n\n        _setCandidateMinStake(_candidateMinStake);\n\n\n\n        boolStorage[ERC20_RESTRICTED] = _erc20Restricted;\n",
                    "message": "Reentrancy in StakingBase._initialize (StakingAuRa.sol#1024-1056):\n\tExternal calls:\n\t- blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract()) (StakingAuRa.sol#1037)\n\t- require(bool)(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0) (StakingAuRa.sol#1038)\n\tState variables written after the call(s):\n\t- addressStorage (StakingAuRa.sol#1040)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": 1333,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._stake (StakingAuRa.sol#1296-1333):\n\tExternal calls:\n\t- poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress) (StakingAuRa.sol#1298)\n\t- require(bool)(! validatorSet.isValidatorBanned(poolMiningAddress)) (StakingAuRa.sol#1303)\n\t- _addPoolActive(_poolStakingAddress,_poolStakingAddress != validatorSet.unremovableValidator()) (StakingAuRa.sol#1326)\n\tState variables written after the call(s):\n\t- intArrayStorage (StakingAuRa.sol#1332)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": 1370,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n\n\n        // How much can `staker` withdraw from `_poolStakingAddress` at the moment?\n\n        require(_amount <= maxWithdrawAllowed(_poolStakingAddress, _staker));\n\n\n\n        uint256 currentStakeAmount = stakeAmount(_poolStakingAddress, _staker);\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, _staker);\n\n        uint256 resultingStakeAmount = currentStakeAmount.sub(alreadyOrderedAmount).sub(_amount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 minAllowedStake = (_poolStakingAddress == _staker) ? getCandidateMinStake() : getDelegatorMinStake();\n\n        require(resultingStakeAmount == 0 || resultingStakeAmount >= minAllowedStake);\n\n\n\n        _setStakeAmount(_poolStakingAddress, _staker, currentStakeAmount.sub(_amount));\n\n        uint256 amountByEpoch = stakeAmountByCurrentEpoch(_poolStakingAddress, _staker);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            amountByEpoch >= _amount ? amountByEpoch - _amount : 0\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(_amount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._withdraw (StakingAuRa.sol#1340-1370):\n\tExternal calls:\n\t- require(bool)(_amount <= maxWithdrawAllowed(_poolStakingAddress,_staker)) (StakingAuRa.sol#1345)\n\tState variables written after the call(s):\n\t- uintStorage (StakingAuRa.sol#1356)\n\t- uintStorage (StakingAuRa.sol#1363)\n\t- uintStorage (StakingAuRa.sol#1358-1362)\n\t- uintStorage (StakingAuRa.sol#1358-1362)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": 1370,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n\n\n        // How much can `staker` withdraw from `_poolStakingAddress` at the moment?\n\n        require(_amount <= maxWithdrawAllowed(_poolStakingAddress, _staker));\n\n\n\n        uint256 currentStakeAmount = stakeAmount(_poolStakingAddress, _staker);\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, _staker);\n\n        uint256 resultingStakeAmount = currentStakeAmount.sub(alreadyOrderedAmount).sub(_amount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 minAllowedStake = (_poolStakingAddress == _staker) ? getCandidateMinStake() : getDelegatorMinStake();\n\n        require(resultingStakeAmount == 0 || resultingStakeAmount >= minAllowedStake);\n\n\n\n        _setStakeAmount(_poolStakingAddress, _staker, currentStakeAmount.sub(_amount));\n\n        uint256 amountByEpoch = stakeAmountByCurrentEpoch(_poolStakingAddress, _staker);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            amountByEpoch >= _amount ? amountByEpoch - _amount : 0\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(_amount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._withdraw (StakingAuRa.sol#1340-1370):\n\tExternal calls:\n\t- require(bool)(_amount <= maxWithdrawAllowed(_poolStakingAddress,_staker)) (StakingAuRa.sol#1345)\n\t- _withdrawCheckPool(_poolStakingAddress,_staker) (StakingAuRa.sol#1366)\n\tState variables written after the call(s):\n\t- intArrayStorage (StakingAuRa.sol#1369)\n\t- intStorage (StakingAuRa.sol#1369)\n\t- uintStorage (StakingAuRa.sol#1366)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n        uint256 epoch = stakingEpoch();\n\n        address payable staker = msg.sender;\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(epoch > orderWithdrawEpoch(_poolStakingAddress, staker));\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        uint256 claimAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n        require(claimAmount != 0);\n\n\n\n        uint256 resultingStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(claimAmount);\n\n\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, 0);\n\n        _setOrderedWithdrawAmountTotal(\n\n            _poolStakingAddress,\n\n            orderedWithdrawAmountTotal(_poolStakingAddress).sub(claimAmount)\n\n        );\n\n        _setStakeAmount(_poolStakingAddress, staker, resultingStakeAmount);\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(claimAmount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, claimAmount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(claimAmount);\n\n        }\n\n\n\n        emit Claimed(_poolStakingAddress, staker, epoch, claimAmount);\n",
                    "message": "Reentrancy in StakingBase.claimOrderedWithdraw (StakingAuRa.sol#480-517):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingAuRa.sol#487)\n\tState variables written after the call(s):\n\t- uintStorage (StakingAuRa.sol#494)\n\t- uintStorage (StakingAuRa.sol#495-498)\n\t- uintStorage (StakingAuRa.sol#499)\n\t- uintStorage (StakingAuRa.sol#500)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n        uint256 epoch = stakingEpoch();\n\n        address payable staker = msg.sender;\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(epoch > orderWithdrawEpoch(_poolStakingAddress, staker));\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        uint256 claimAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n        require(claimAmount != 0);\n\n\n\n        uint256 resultingStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(claimAmount);\n\n\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, 0);\n\n        _setOrderedWithdrawAmountTotal(\n\n            _poolStakingAddress,\n\n            orderedWithdrawAmountTotal(_poolStakingAddress).sub(claimAmount)\n\n        );\n\n        _setStakeAmount(_poolStakingAddress, staker, resultingStakeAmount);\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(claimAmount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, claimAmount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(claimAmount);\n\n        }\n\n\n\n        emit Claimed(_poolStakingAddress, staker, epoch, claimAmount);\n",
                    "message": "Reentrancy in StakingBase.claimOrderedWithdraw (StakingAuRa.sol#480-517):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingAuRa.sol#487)\n\t- _withdrawCheckPool(_poolStakingAddress,staker) (StakingAuRa.sol#503)\n\tState variables written after the call(s):\n\t- intArrayStorage (StakingAuRa.sol#506)\n\t- intStorage (StakingAuRa.sol#506)\n\t- uintStorage (StakingAuRa.sol#503)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1511,
                    "vulnerability_to_line": 1537,
                    "vulnerability_code": "    function initialize(\n\n        address _validatorSetContract,\n\n        address[] calldata _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        uint256 _stakingEpochDuration,\n\n        uint256 _stakingEpochStartBlock,\n\n        uint256 _stakeWithdrawDisallowPeriod,\n\n        bool _erc20Restricted\n\n    ) external {\n\n        require(_stakingEpochDuration != 0);\n\n        require(_stakingEpochDuration > _stakeWithdrawDisallowPeriod);\n\n        IValidatorSet validatorSet = IValidatorSet(_validatorSetContract);\n\n        IBlockReward blockReward = IBlockReward(validatorSet.blockRewardContract());\n\n        require(_stakingEpochDuration >= validatorSet.MAX_VALIDATORS() * blockReward.DELEGATORS_ALIQUOT() * 2 + 1);\n\n        require(_stakeWithdrawDisallowPeriod != 0);\n\n        super._initialize(\n\n            _validatorSetContract,\n\n            _initialStakingAddresses,\n\n            _delegatorMinStake,\n\n            _candidateMinStake,\n\n            _erc20Restricted\n\n        );\n\n        uintStorage[STAKING_EPOCH_DURATION] = _stakingEpochDuration;\n\n        uintStorage[STAKE_WITHDRAW_DISALLOW_PERIOD] = _stakeWithdrawDisallowPeriod;\n\n        uintStorage[STAKING_EPOCH_START_BLOCK] = _stakingEpochStartBlock;\n",
                    "message": "Reentrancy in StakingAuRa.initialize (StakingAuRa.sol#1511-1537):\n\tExternal calls:\n\t- blockReward = IBlockReward(validatorSet.blockRewardContract()) (StakingAuRa.sol#1524)\n\t- require(bool)(_stakingEpochDuration >= validatorSet.MAX_VALIDATORS() * blockReward.DELEGATORS_ALIQUOT() * 2 + 1) (StakingAuRa.sol#1525)\n\t- super._initialize(_validatorSetContract,_initialStakingAddresses,_delegatorMinStake,_candidateMinStake,_erc20Restricted) (StakingAuRa.sol#1527-1533)\n\tState variables written after the call(s):\n\t- uintStorage (StakingAuRa.sol#1534)\n\t- uintStorage (StakingAuRa.sol#1535)\n\t- uintStorage (StakingAuRa.sol#1536)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": 362,
                    "vulnerability_code": "    function moveStake(\n\n        address _fromPoolStakingAddress,\n\n        address _toPoolStakingAddress,\n\n        uint256 _amount\n\n    ) external gasPriceIsValid onlyInitialized {\n\n        require(_fromPoolStakingAddress != _toPoolStakingAddress);\n\n        address staker = msg.sender;\n\n        _withdraw(_fromPoolStakingAddress, staker, _amount);\n\n        _stake(_toPoolStakingAddress, staker, _amount);\n\n        emit StakeMoved(_fromPoolStakingAddress, _toPoolStakingAddress, staker, stakingEpoch(), _amount);\n",
                    "message": "Reentrancy in StakingBase.moveStake (StakingAuRa.sol#352-362):\n\tExternal calls:\n\t- _withdraw(_fromPoolStakingAddress,staker,_amount) (StakingAuRa.sol#359)\n\t- _stake(_toPoolStakingAddress,staker,_amount) (StakingAuRa.sol#360)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingAuRa.sol#360)\n\t- intArrayStorage (StakingAuRa.sol#360)\n\t- intStorage (StakingAuRa.sol#360)\n\t- uintStorage (StakingAuRa.sol#360)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
                    "message": "Reentrancy in StakingBase.orderWithdraw (StakingAuRa.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingAuRa.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingAuRa.sol#416)\n\tState variables written after the call(s):\n\t- uintStorage (StakingAuRa.sol#428)\n\t- uintStorage (StakingAuRa.sol#450)\n\t- uintStorage (StakingAuRa.sol#453)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
                    "message": "Reentrancy in StakingBase.orderWithdraw (StakingAuRa.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingAuRa.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingAuRa.sol#416)\n\t- unremovableStakingAddress = validatorSetContract.unremovableValidator() (StakingAuRa.sol#436)\n\tState variables written after the call(s):\n\t- uintStorage (StakingAuRa.sol#440)\n\t- uintStorage (StakingAuRa.sol#443)\n\t- uintStorage (StakingAuRa.sol#464)\n\t- uintStorage (StakingAuRa.sol#469)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": 344,
                    "vulnerability_code": "    function removeMyPool() external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address stakingAddress = msg.sender;\n\n        address miningAddress = validatorSet.miningByStakingAddress(stakingAddress);\n\n        // initial validator cannot remove their pool during the initial staking epoch\n\n        require(stakingEpoch() > 0 || !validatorSet.isValidator(miningAddress));\n\n        require(stakingAddress != validatorSet.unremovableValidator());\n\n        _removePool(stakingAddress);\n",
                    "message": "Reentrancy in StakingBase.removeMyPool (StakingAuRa.sol#336-344):\n\tExternal calls:\n\t- miningAddress = validatorSet.miningByStakingAddress(stakingAddress) (StakingAuRa.sol#339)\n\t- require(bool)(stakingEpoch() > 0 || ! validatorSet.isValidator(miningAddress)) (StakingAuRa.sol#341)\n\t- require(bool)(stakingAddress != validatorSet.unremovableValidator()) (StakingAuRa.sol#342)\n\tState variables written after the call(s):\n\t- uintStorage (StakingAuRa.sol#343)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
                    "message": "StakingBase.orderWithdraw.validatorSetContract (local variable @ StakingAuRa.sol#407) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingAuRa.sol#853-855)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
                    "message": "StakingBase.claimOrderedWithdraw.validatorSetContract (local variable @ StakingAuRa.sol#481) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingAuRa.sol#853-855)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 633,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
                    "message": "StakingBase.maxWithdrawAllowed.validatorSetContract (local variable @ StakingAuRa.sol#633) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingAuRa.sol#853-855)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
                    "message": "StakingBase.maxWithdrawOrderAllowed.validatorSetContract (local variable @ StakingAuRa.sol#665) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingAuRa.sol#853-855)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1024,
                    "vulnerability_to_line": 1056,
                    "vulnerability_code": "    function _initialize(\n\n        address _validatorSetContract,\n\n        address[] memory _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        bool _erc20Restricted\n\n    ) internal {\n\n        require(!isInitialized()); // initialization can only be done once\n\n        require(_validatorSetContract != address(0));\n\n        require(_initialStakingAddresses.length > 0);\n\n        require(_delegatorMinStake != 0);\n\n        require(_candidateMinStake != 0);\n\n\n\n        IBlockReward blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract());\n\n        require(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0);\n\n\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSetContract;\n\n\n\n        address unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator();\n\n\n\n        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n\n            require(_initialStakingAddresses[i] != address(0));\n\n            _addPoolActive(_initialStakingAddresses[i], false);\n\n            if (_initialStakingAddresses[i] != unremovableStakingAddress) {\n\n                _addPoolToBeRemoved(_initialStakingAddresses[i]);\n\n            }\n\n        }\n\n\n\n        _setDelegatorMinStake(_delegatorMinStake);\n\n        _setCandidateMinStake(_candidateMinStake);\n\n\n\n        boolStorage[ERC20_RESTRICTED] = _erc20Restricted;\n",
                    "message": "Reentrancy in StakingBase._initialize (StakingAuRa.sol#1024-1056):\n\tExternal calls:\n\t- blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract()) (StakingAuRa.sol#1037)\n\t- require(bool)(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0) (StakingAuRa.sol#1038)\n\t- unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator() (StakingAuRa.sol#1042)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingAuRa.sol#1046)\n\t- addressArrayStorage (StakingAuRa.sol#1048)\n\t- boolStorage (StakingAuRa.sol#1055)\n\t- intArrayStorage (StakingAuRa.sol#1046)\n\t- intArrayStorage (StakingAuRa.sol#1048)\n\t- intStorage (StakingAuRa.sol#1048)\n\t- uintStorage (StakingAuRa.sol#1046)\n\t- uintStorage (StakingAuRa.sol#1048)\n\t- uintStorage (StakingAuRa.sol#1052)\n\t- uintStorage (StakingAuRa.sol#1053)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": 1333,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._stake (StakingAuRa.sol#1296-1333):\n\tExternal calls:\n\t- poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress) (StakingAuRa.sol#1298)\n\t- require(bool)(! validatorSet.isValidatorBanned(poolMiningAddress)) (StakingAuRa.sol#1303)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingAuRa.sol#1329)\n\t- uintStorage (StakingAuRa.sol#1316)\n\t- uintStorage (StakingAuRa.sol#1317-1321)\n\t- uintStorage (StakingAuRa.sol#1322)\n\t- uintStorage (StakingAuRa.sol#1329)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": 1333,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._stake (StakingAuRa.sol#1296-1333):\n\tExternal calls:\n\t- poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress) (StakingAuRa.sol#1298)\n\t- require(bool)(! validatorSet.isValidatorBanned(poolMiningAddress)) (StakingAuRa.sol#1303)\n\t- _addPoolActive(_poolStakingAddress,_poolStakingAddress != validatorSet.unremovableValidator()) (StakingAuRa.sol#1326)\n\tState variables written after the call(s):\n\t- intStorage (StakingAuRa.sol#1332)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": 1391,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n\n        if (_staker == _poolStakingAddress) {\n\n            IValidatorSet validatorSet = validatorSetContract();\n\n            address unremovableStakingAddress = validatorSet.unremovableValidator();\n\n\n\n            if (_poolStakingAddress != unremovableStakingAddress) {\n\n                if (validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress))) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                } else {\n\n                    _removePool(_poolStakingAddress);\n\n                }\n\n            }\n\n        } else {\n\n            _removePoolDelegator(_poolStakingAddress, _staker);\n\n        }\n",
                    "message": "Reentrancy in StakingBase._withdrawCheckPool (StakingAuRa.sol#1376-1391):\n\tExternal calls:\n\t- unremovableStakingAddress = validatorSet.unremovableValidator() (StakingAuRa.sol#1379)\n\t- validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress)) (StakingAuRa.sol#1382-1386)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingAuRa.sol#1383)\n\t- intArrayStorage (StakingAuRa.sol#1383)\n\t- intStorage (StakingAuRa.sol#1383)\n\t- uintStorage (StakingAuRa.sol#1383)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": 1391,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n\n        if (_staker == _poolStakingAddress) {\n\n            IValidatorSet validatorSet = validatorSetContract();\n\n            address unremovableStakingAddress = validatorSet.unremovableValidator();\n\n\n\n            if (_poolStakingAddress != unremovableStakingAddress) {\n\n                if (validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress))) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                } else {\n\n                    _removePool(_poolStakingAddress);\n\n                }\n\n            }\n\n        } else {\n\n            _removePoolDelegator(_poolStakingAddress, _staker);\n\n        }\n",
                    "message": "Reentrancy in StakingBase._withdrawCheckPool (StakingAuRa.sol#1376-1391):\n\tExternal calls:\n\t- unremovableStakingAddress = validatorSet.unremovableValidator() (StakingAuRa.sol#1379)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingAuRa.sol#1385)\n\t- intArrayStorage (StakingAuRa.sol#1385)\n\t- intStorage (StakingAuRa.sol#1385)\n\t- uintStorage (StakingAuRa.sol#1385)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1511,
                    "vulnerability_to_line": 1537,
                    "vulnerability_code": "    function initialize(\n\n        address _validatorSetContract,\n\n        address[] calldata _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        uint256 _stakingEpochDuration,\n\n        uint256 _stakingEpochStartBlock,\n\n        uint256 _stakeWithdrawDisallowPeriod,\n\n        bool _erc20Restricted\n\n    ) external {\n\n        require(_stakingEpochDuration != 0);\n\n        require(_stakingEpochDuration > _stakeWithdrawDisallowPeriod);\n\n        IValidatorSet validatorSet = IValidatorSet(_validatorSetContract);\n\n        IBlockReward blockReward = IBlockReward(validatorSet.blockRewardContract());\n\n        require(_stakingEpochDuration >= validatorSet.MAX_VALIDATORS() * blockReward.DELEGATORS_ALIQUOT() * 2 + 1);\n\n        require(_stakeWithdrawDisallowPeriod != 0);\n\n        super._initialize(\n\n            _validatorSetContract,\n\n            _initialStakingAddresses,\n\n            _delegatorMinStake,\n\n            _candidateMinStake,\n\n            _erc20Restricted\n\n        );\n\n        uintStorage[STAKING_EPOCH_DURATION] = _stakingEpochDuration;\n\n        uintStorage[STAKE_WITHDRAW_DISALLOW_PERIOD] = _stakeWithdrawDisallowPeriod;\n\n        uintStorage[STAKING_EPOCH_START_BLOCK] = _stakingEpochStartBlock;\n",
                    "message": "Reentrancy in StakingAuRa.initialize (StakingAuRa.sol#1511-1537):\n\tExternal calls:\n\t- blockReward = IBlockReward(validatorSet.blockRewardContract()) (StakingAuRa.sol#1524)\n\t- require(bool)(_stakingEpochDuration >= validatorSet.MAX_VALIDATORS() * blockReward.DELEGATORS_ALIQUOT() * 2 + 1) (StakingAuRa.sol#1525)\n\t- super._initialize(_validatorSetContract,_initialStakingAddresses,_delegatorMinStake,_candidateMinStake,_erc20Restricted) (StakingAuRa.sol#1527-1533)\n\tState variables written after the call(s):\n\t- boolStorage (StakingAuRa.sol#1527-1533)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
                    "message": "Reentrancy in StakingBase.orderWithdraw (StakingAuRa.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingAuRa.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingAuRa.sol#416)\n\t- unremovableStakingAddress = validatorSetContract.unremovableValidator() (StakingAuRa.sol#436)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingAuRa.sol#440)\n\t- addressArrayStorage (StakingAuRa.sol#443)\n\t- intArrayStorage (StakingAuRa.sol#440)\n\t- intArrayStorage (StakingAuRa.sol#443)\n\t- intArrayStorage (StakingAuRa.sol#472)\n\t- intStorage (StakingAuRa.sol#440)\n\t- intStorage (StakingAuRa.sol#472)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
                    "message": "Reentrancy in StakingBase.orderWithdraw (StakingAuRa.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingAuRa.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingAuRa.sol#416)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingAuRa.sol#450)\n\t- addressArrayStorage (StakingAuRa.sol#453)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": 344,
                    "vulnerability_code": "    function removeMyPool() external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address stakingAddress = msg.sender;\n\n        address miningAddress = validatorSet.miningByStakingAddress(stakingAddress);\n\n        // initial validator cannot remove their pool during the initial staking epoch\n\n        require(stakingEpoch() > 0 || !validatorSet.isValidator(miningAddress));\n\n        require(stakingAddress != validatorSet.unremovableValidator());\n\n        _removePool(stakingAddress);\n",
                    "message": "Reentrancy in StakingBase.removeMyPool (StakingAuRa.sol#336-344):\n\tExternal calls:\n\t- miningAddress = validatorSet.miningByStakingAddress(stakingAddress) (StakingAuRa.sol#339)\n\t- require(bool)(stakingEpoch() > 0 || ! validatorSet.isValidator(miningAddress)) (StakingAuRa.sol#341)\n\t- require(bool)(stakingAddress != validatorSet.unremovableValidator()) (StakingAuRa.sol#342)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingAuRa.sol#343)\n\t- intArrayStorage (StakingAuRa.sol#343)\n\t- intStorage (StakingAuRa.sol#343)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (StakingAuRa.sol#97)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function erc20Restricted() external view returns(bool);\n",
                    "message": "IStaking.erc20Restricted (StakingAuRa.sol#41) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": 598,
                    "vulnerability_code": "    function erc20Restricted() public view returns(bool) {\n\n        return boolStorage[ERC20_RESTRICTED];\n",
                    "message": "StakingBase.erc20Restricted (StakingAuRa.sol#596-598) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "IStaking.poolDelegators (StakingAuRa.sol#46) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": 735,
                    "vulnerability_code": "    function poolDelegators(address _poolStakingAddress) public view returns(address[] memory) {\n\n        return addressArrayStorage[keccak256(abi.encode(POOL_DELEGATORS, _poolStakingAddress))];\n",
                    "message": "StakingBase.poolDelegators (StakingAuRa.sol#733-735) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": 695,
                    "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n\n        return false;\n",
                    "message": "StakingBase.onTokenTransfer (StakingAuRa.sol#693-695) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 741,
                    "vulnerability_to_line": 743,
                    "vulnerability_code": "    function poolDelegatorsInactive(address _poolStakingAddress) public view returns(address[] memory) {\n\n        return addressArrayStorage[keccak256(abi.encode(POOL_DELEGATORS_INACTIVE, _poolStakingAddress))];\n",
                    "message": "StakingBase.poolDelegatorsInactive (StakingAuRa.sol#741-743) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1574,
                    "vulnerability_to_line": 1577,
                    "vulnerability_code": "    function stakingEpochEndBlock() public view returns(uint256) {\n\n        uint256 startBlock = stakingEpochStartBlock();\n\n        return startBlock + stakingEpochDuration() - (startBlock == 0 ? 0 : 1);\n",
                    "message": "StakingAuRa.stakingEpochEndBlock (StakingAuRa.sol#1574-1577) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingEpochEndBlock() external view returns(uint256);\n",
                    "message": "IStakingAuRa.stakingEpochEndBlock (StakingAuRa.sol#1457) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in StakingAuRa.sol:\n\t- pragma solidity0.5.9 (StakingAuRa.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRa.sol#17): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRa.sol#34): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRa.sol#54): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRa.sol#89): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRa.sol#120): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRa.sol#138): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRa.sol#177): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRa.sol#1440): it allows old versions\n\t- pragma solidity0.5.9 (StakingAuRa.sol#1462): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address) external;\n",
                    "message": "Parameter '' of IBlockReward.initialize (StakingAuRa.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function DELEGATORS_ALIQUOT() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IBlockReward.DELEGATORS_ALIQUOT' (StakingAuRa.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IERC20Minting.balanceOf (StakingAuRa.sol#29) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
                    "message": "Parameter '' of IStaking.clearUnremovableValidator (StakingAuRa.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address) external;\n",
                    "message": "Parameter '' of IStaking.removePool (StakingAuRa.sol#40) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "Parameter '' of IStaking.poolDelegators (StakingAuRa.sol#46) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (StakingAuRa.sol#47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (StakingAuRa.sol#47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (StakingAuRa.sol#48) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (StakingAuRa.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (StakingAuRa.sol#60) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (StakingAuRa.sol#61) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (StakingAuRa.sol#62) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (StakingAuRa.sol#63) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (StakingAuRa.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (StakingAuRa.sol#67) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (StakingAuRa.sol#67) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (StakingAuRa.sol#74) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (StakingAuRa.sol#75) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (StakingAuRa.sol#76) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (StakingAuRa.sol#77) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (StakingAuRa.sol#78) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (StakingAuRa.sol#80) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (StakingAuRa.sol#83) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (StakingAuRa.sol#97) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address _unremovableStakingAddress) external onlyValidatorSetContract {\n",
                    "message": "Parameter '_unremovableStakingAddress' of StakingBase.clearUnremovableValidator (StakingAuRa.sol#308) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address _stakingAddress) external onlyValidatorSetContract {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.removePool (StakingAuRa.sol#328) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address _poolStakingAddress) public view returns(address[] memory) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegators (StakingAuRa.sol#733) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 829,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _poolStakingAddress,\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountMinusOrderedWithdraw (StakingAuRa.sol#829) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 830,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _staker\n",
                    "message": "Parameter '_staker' of StakingBase.stakeAmountMinusOrderedWithdraw (StakingAuRa.sol#830) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 841,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address _poolStakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountTotalMinusOrderedWithdraw (StakingAuRa.sol#841) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _fromPoolStakingAddress,\n",
                    "message": "Parameter '_fromPoolStakingAddress' of StakingBase.moveStake (StakingAuRa.sol#353) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _toPoolStakingAddress,\n",
                    "message": "Parameter '_toPoolStakingAddress' of StakingBase.moveStake (StakingAuRa.sol#354) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _amount\n",
                    "message": "Parameter '_amount' of StakingBase.moveStake (StakingAuRa.sol#355) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stake(address _toPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_toPoolStakingAddress' of StakingBase.stake (StakingAuRa.sol#368) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stake(address _toPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_amount' of StakingBase.stake (StakingAuRa.sol#368) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeNative(address _toPoolStakingAddress) external gasPriceIsValid onlyInitialized payable {\n",
                    "message": "Parameter '_toPoolStakingAddress' of StakingBase.stakeNative (StakingAuRa.sol#375) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function withdraw(address _fromPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_fromPoolStakingAddress' of StakingBase.withdraw (StakingAuRa.sol#385) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function withdraw(address _fromPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_amount' of StakingBase.withdraw (StakingAuRa.sol#385) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.orderWithdraw (StakingAuRa.sol#406) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_amount' of StakingBase.orderWithdraw (StakingAuRa.sol#406) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.claimOrderedWithdraw (StakingAuRa.sol#480) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErc20TokenContract(address _erc20TokenContract) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_erc20TokenContract' of StakingBase.setErc20TokenContract (StakingAuRa.sol#522) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCandidateMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_minStake' of StakingBase.setCandidateMinStake (StakingAuRa.sol#531) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setDelegatorMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_minStake' of StakingBase.setDelegatorMinStake (StakingAuRa.sol#538) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isPoolActive(address _stakingAddress) public view returns(bool) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.isPoolActive (StakingAuRa.sol#623) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function maxWithdrawAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.maxWithdrawAllowed (StakingAuRa.sol#632) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function maxWithdrawAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.maxWithdrawAllowed (StakingAuRa.sol#632) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function maxWithdrawOrderAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.maxWithdrawOrderAllowed (StakingAuRa.sol#664) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function maxWithdrawOrderAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.maxWithdrawOrderAllowed (StakingAuRa.sol#664) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n",
                    "message": "Parameter '' of StakingBase.onTokenTransfer (StakingAuRa.sol#693) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n",
                    "message": "Parameter '_scope_0' of StakingBase.onTokenTransfer (StakingAuRa.sol#693) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n",
                    "message": "Parameter '_scope_1' of StakingBase.onTokenTransfer (StakingAuRa.sol#693) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderedWithdrawAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.orderedWithdrawAmount (StakingAuRa.sol#701) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderedWithdrawAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.orderedWithdrawAmount (StakingAuRa.sol#701) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 708,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderedWithdrawAmountTotal(address _poolStakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.orderedWithdrawAmountTotal (StakingAuRa.sol#708) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderWithdrawEpoch(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.orderWithdrawEpoch (StakingAuRa.sol#717) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderWithdrawEpoch(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.orderWithdrawEpoch (StakingAuRa.sol#717) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 725,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotal(address _poolStakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountTotal (StakingAuRa.sol#725) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 741,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorsInactive(address _poolStakingAddress) public view returns(address[] memory) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegatorsInactive (StakingAuRa.sol#741) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 751,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegatorIndex (StakingAuRa.sol#751) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 751,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
                    "message": "Parameter '_delegator' of StakingBase.poolDelegatorIndex (StakingAuRa.sol#751) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegatorInactiveIndex (StakingAuRa.sol#761) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
                    "message": "Parameter '_delegator' of StakingBase.poolDelegatorInactiveIndex (StakingAuRa.sol#761) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 770,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolIndex(address _stakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.poolIndex (StakingAuRa.sol#770) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolInactiveIndex(address _stakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.poolInactiveIndex (StakingAuRa.sol#777) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolToBeElectedIndex(address _stakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.poolToBeElectedIndex (StakingAuRa.sol#786) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolToBeRemovedIndex(address _stakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.poolToBeRemovedIndex (StakingAuRa.sol#795) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmount (StakingAuRa.sol#804) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.stakeAmount (StakingAuRa.sol#804) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountByCurrentEpoch(address _poolStakingAddress, address _staker)\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountByCurrentEpoch (StakingAuRa.sol#813) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountByCurrentEpoch(address _poolStakingAddress, address _staker)\n",
                    "message": "Parameter '_staker' of StakingBase.stakeAmountByCurrentEpoch (StakingAuRa.sol#813) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 892,
                    "vulnerability_to_line": 903,
                    "vulnerability_code": "    function _addPoolActive(address _stakingAddress, bool _toBeElected) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS];\n\n        if (!isPoolActive(_stakingAddress)) {\n\n            _setPoolIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n            require(pools.length <= _getMaxCandidates());\n\n        }\n\n        _removePoolInactive(_stakingAddress);\n\n        if (_toBeElected) {\n\n            _addPoolToBeElected(_stakingAddress);\n\n        }\n",
                    "message": "Function 'StakingBase._addPoolActive' (StakingAuRa.sol#892-903) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 892,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolActive(address _stakingAddress, bool _toBeElected) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._addPoolActive (StakingAuRa.sol#892) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 892,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolActive(address _stakingAddress, bool _toBeElected) internal {\n",
                    "message": "Parameter '_toBeElected' of StakingBase._addPoolActive (StakingAuRa.sol#892) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 908,
                    "vulnerability_to_line": 915,
                    "vulnerability_code": "    function _addPoolInactive(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_INACTIVE];\n\n        uint256 index = poolInactiveIndex(_stakingAddress);\n\n        if (index >= pools.length || pools[index] != _stakingAddress) {\n\n            _setPoolInactiveIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n        }\n",
                    "message": "Function 'StakingBase._addPoolInactive' (StakingAuRa.sol#908-915) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 908,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolInactive(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._addPoolInactive (StakingAuRa.sol#908) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 929,
                    "vulnerability_code": "    function _addPoolToBeElected(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_ELECTED];\n\n        uint256 index = poolToBeElectedIndex(_stakingAddress);\n\n        if (index >= pools.length || pools[index] != _stakingAddress) {\n\n            _setPoolToBeElectedIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n            intArrayStorage[POOLS_LIKELIHOOD].push(0);\n\n        }\n\n        _deletePoolToBeRemoved(_stakingAddress);\n",
                    "message": "Function 'StakingBase._addPoolToBeElected' (StakingAuRa.sol#920-929) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolToBeElected(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._addPoolToBeElected (StakingAuRa.sol#920) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": 942,
                    "vulnerability_code": "    function _addPoolToBeRemoved(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_REMOVED];\n\n        uint256 index = poolToBeRemovedIndex(_stakingAddress);\n\n        if (index >= pools.length || pools[index] != _stakingAddress) {\n\n            _setPoolToBeRemovedIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n        }\n\n        _deletePoolToBeElected(_stakingAddress);\n",
                    "message": "Function 'StakingBase._addPoolToBeRemoved' (StakingAuRa.sol#934-942) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolToBeRemoved(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._addPoolToBeRemoved (StakingAuRa.sol#934) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 948,
                    "vulnerability_to_line": 965,
                    "vulnerability_code": "    function _deletePoolToBeElected(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_ELECTED];\n\n        int256[] storage likelihood = intArrayStorage[POOLS_LIKELIHOOD];\n\n        if (pools.length != likelihood.length) return;\n\n        uint256 indexToDelete = poolToBeElectedIndex(_stakingAddress);\n\n        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n\n            intStorage[POOLS_LIKELIHOOD_SUM] -= likelihood[indexToDelete];\n\n            if (intStorage[POOLS_LIKELIHOOD_SUM] < 0) {\n\n                intStorage[POOLS_LIKELIHOOD_SUM] = 0;\n\n            }\n\n            pools[indexToDelete] = pools[pools.length - 1];\n\n            likelihood[indexToDelete] = likelihood[pools.length - 1];\n\n            _setPoolToBeElectedIndex(pools[indexToDelete], indexToDelete);\n\n            _setPoolToBeElectedIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n            likelihood.length--;\n\n        }\n",
                    "message": "Function 'StakingBase._deletePoolToBeElected' (StakingAuRa.sol#948-965) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 948,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _deletePoolToBeElected(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._deletePoolToBeElected (StakingAuRa.sol#948) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 971,
                    "vulnerability_to_line": 980,
                    "vulnerability_code": "    function _deletePoolToBeRemoved(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_REMOVED];\n\n        uint256 indexToDelete = poolToBeRemovedIndex(_stakingAddress);\n\n        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n\n            pools[indexToDelete] = pools[pools.length - 1];\n\n            _setPoolToBeRemovedIndex(pools[indexToDelete], indexToDelete);\n\n            _setPoolToBeRemovedIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n        }\n",
                    "message": "Function 'StakingBase._deletePoolToBeRemoved' (StakingAuRa.sol#971-980) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 971,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _deletePoolToBeRemoved(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._deletePoolToBeRemoved (StakingAuRa.sol#971) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 985,
                    "vulnerability_to_line": 1001,
                    "vulnerability_code": "    function _removePool(address _stakingAddress) internal {\n\n        uint256 indexToRemove = poolIndex(_stakingAddress);\n\n        address[] storage pools = addressArrayStorage[POOLS];\n\n        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n\n            pools[indexToRemove] = pools[pools.length - 1];\n\n            _setPoolIndex(pools[indexToRemove], indexToRemove);\n\n            _setPoolIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n        }\n\n        if (stakeAmountTotal(_stakingAddress) != 0) {\n\n            _addPoolInactive(_stakingAddress);\n\n        } else {\n\n            _removePoolInactive(_stakingAddress);\n\n        }\n\n        _deletePoolToBeElected(_stakingAddress);\n\n        _deletePoolToBeRemoved(_stakingAddress);\n",
                    "message": "Function 'StakingBase._removePool' (StakingAuRa.sol#985-1001) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 985,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePool(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._removePool (StakingAuRa.sol#985) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1006,
                    "vulnerability_to_line": 1015,
                    "vulnerability_code": "    function _removePoolInactive(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_INACTIVE];\n\n        uint256 indexToRemove = poolInactiveIndex(_stakingAddress);\n\n        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n\n            pools[indexToRemove] = pools[pools.length - 1];\n\n            _setPoolInactiveIndex(pools[indexToRemove], indexToRemove);\n\n            _setPoolInactiveIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n        }\n",
                    "message": "Function 'StakingBase._removePoolInactive' (StakingAuRa.sol#1006-1015) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1006,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolInactive(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._removePoolInactive (StakingAuRa.sol#1006) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1024,
                    "vulnerability_to_line": 1056,
                    "vulnerability_code": "    function _initialize(\n\n        address _validatorSetContract,\n\n        address[] memory _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        bool _erc20Restricted\n\n    ) internal {\n\n        require(!isInitialized()); // initialization can only be done once\n\n        require(_validatorSetContract != address(0));\n\n        require(_initialStakingAddresses.length > 0);\n\n        require(_delegatorMinStake != 0);\n\n        require(_candidateMinStake != 0);\n\n\n\n        IBlockReward blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract());\n\n        require(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0);\n\n\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSetContract;\n\n\n\n        address unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator();\n\n\n\n        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n\n            require(_initialStakingAddresses[i] != address(0));\n\n            _addPoolActive(_initialStakingAddresses[i], false);\n\n            if (_initialStakingAddresses[i] != unremovableStakingAddress) {\n\n                _addPoolToBeRemoved(_initialStakingAddresses[i]);\n\n            }\n\n        }\n\n\n\n        _setDelegatorMinStake(_delegatorMinStake);\n\n        _setCandidateMinStake(_candidateMinStake);\n\n\n\n        boolStorage[ERC20_RESTRICTED] = _erc20Restricted;\n",
                    "message": "Function 'StakingBase._initialize' (StakingAuRa.sol#1024-1056) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1025,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _validatorSetContract,\n",
                    "message": "Parameter '_validatorSetContract' of StakingBase._initialize (StakingAuRa.sol#1025) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1026,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _initialStakingAddresses,\n",
                    "message": "Parameter '_initialStakingAddresses' of StakingBase._initialize (StakingAuRa.sol#1026) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1027,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _delegatorMinStake,\n",
                    "message": "Parameter '_delegatorMinStake' of StakingBase._initialize (StakingAuRa.sol#1027) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1028,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _candidateMinStake,\n",
                    "message": "Parameter '_candidateMinStake' of StakingBase._initialize (StakingAuRa.sol#1028) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1029,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _erc20Restricted\n",
                    "message": "Parameter '_erc20Restricted' of StakingBase._initialize (StakingAuRa.sol#1029) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": 1067,
                    "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n\n        uintStorage[keccak256(abi.encode(ORDER_WITHDRAW_EPOCH, _poolStakingAddress, _staker))] = _stakingEpoch;\n",
                    "message": "Function 'StakingBase._setOrderWithdrawEpoch' (StakingAuRa.sol#1065-1067) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setOrderWithdrawEpoch (StakingAuRa.sol#1065) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._setOrderWithdrawEpoch (StakingAuRa.sol#1065) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n",
                    "message": "Parameter '_stakingEpoch' of StakingBase._setOrderWithdrawEpoch (StakingAuRa.sol#1065) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": 1076,
                    "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_DELEGATOR_INDEX, _poolStakingAddress, _delegator))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolDelegatorIndex' (StakingAuRa.sol#1074-1076) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setPoolDelegatorIndex (StakingAuRa.sol#1074) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._setPoolDelegatorIndex (StakingAuRa.sol#1074) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolDelegatorIndex (StakingAuRa.sol#1074) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": 1085,
                    "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_DELEGATOR_INACTIVE_INDEX, _poolStakingAddress, _delegator))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolDelegatorInactiveIndex' (StakingAuRa.sol#1083-1085) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setPoolDelegatorInactiveIndex (StakingAuRa.sol#1083) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._setPoolDelegatorInactiveIndex (StakingAuRa.sol#1083) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolDelegatorInactiveIndex (StakingAuRa.sol#1083) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1093,
                    "vulnerability_code": "    function _setPoolIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_INDEX, _stakingAddress))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolIndex' (StakingAuRa.sol#1091-1093) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._setPoolIndex (StakingAuRa.sol#1091) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolIndex (StakingAuRa.sol#1091) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1099,
                    "vulnerability_to_line": 1101,
                    "vulnerability_code": "    function _setPoolInactiveIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_INACTIVE_INDEX, _stakingAddress))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolInactiveIndex' (StakingAuRa.sol#1099-1101) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1099,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolInactiveIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._setPoolInactiveIndex (StakingAuRa.sol#1099) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1099,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolInactiveIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolInactiveIndex (StakingAuRa.sol#1099) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1108,
                    "vulnerability_to_line": 1110,
                    "vulnerability_code": "    function _setPoolToBeElectedIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_TO_BE_ELECTED_INDEX, _stakingAddress))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolToBeElectedIndex' (StakingAuRa.sol#1108-1110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolToBeElectedIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._setPoolToBeElectedIndex (StakingAuRa.sol#1108) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolToBeElectedIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolToBeElectedIndex (StakingAuRa.sol#1108) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1117,
                    "vulnerability_to_line": 1119,
                    "vulnerability_code": "    function _setPoolToBeRemovedIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_TO_BE_REMOVED_INDEX, _stakingAddress))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolToBeRemovedIndex' (StakingAuRa.sol#1117-1119) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolToBeRemovedIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._setPoolToBeRemovedIndex (StakingAuRa.sol#1117) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolToBeRemovedIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolToBeRemovedIndex (StakingAuRa.sol#1117) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": 1135,
                    "vulnerability_code": "    function _addPoolDelegator(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS, _poolStakingAddress))\n\n        ];\n\n        if (delegators.length == 0 || delegators[poolDelegatorIndex(_poolStakingAddress, _delegator)] != _delegator) {\n\n            _setPoolDelegatorIndex(_poolStakingAddress, _delegator, delegators.length);\n\n            delegators.push(_delegator);\n\n            require(delegators.length <= MAX_DELEGATORS_PER_POOL);\n\n        }\n\n        _removePoolDelegatorInactive(_poolStakingAddress, _delegator);\n",
                    "message": "Function 'StakingBase._addPoolDelegator' (StakingAuRa.sol#1125-1135) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._addPoolDelegator (StakingAuRa.sol#1125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._addPoolDelegator (StakingAuRa.sol#1125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1141,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function _addPoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS_INACTIVE, _poolStakingAddress))\n\n        ];\n\n        if (\n\n            delegators.length == 0 ||\n\n            delegators[poolDelegatorInactiveIndex(_poolStakingAddress, _delegator)] != _delegator\n\n        ) {\n\n            _setPoolDelegatorInactiveIndex(_poolStakingAddress, _delegator, delegators.length);\n\n            delegators.push(_delegator);\n\n        }\n",
                    "message": "Function 'StakingBase._addPoolDelegatorInactive' (StakingAuRa.sol#1141-1152) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._addPoolDelegatorInactive (StakingAuRa.sol#1141) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._addPoolDelegatorInactive (StakingAuRa.sol#1141) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": 1174,
                    "vulnerability_code": "    function _removePoolDelegator(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS, _poolStakingAddress))\n\n        ];\n\n        uint256 indexToRemove = poolDelegatorIndex(_poolStakingAddress, _delegator);\n\n        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n\n            delegators[indexToRemove] = delegators[delegators.length - 1];\n\n            _setPoolDelegatorIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n\n            _setPoolDelegatorIndex(_poolStakingAddress, _delegator, 0);\n\n            delegators.length--;\n\n        }\n\n        if (stakeAmount(_poolStakingAddress, _delegator) != 0) {\n\n            _addPoolDelegatorInactive(_poolStakingAddress, _delegator);\n\n        } else {\n\n            _removePoolDelegatorInactive(_poolStakingAddress, _delegator);\n\n        }\n",
                    "message": "Function 'StakingBase._removePoolDelegator' (StakingAuRa.sol#1158-1174) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._removePoolDelegator (StakingAuRa.sol#1158) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._removePoolDelegator (StakingAuRa.sol#1158) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1180,
                    "vulnerability_to_line": 1191,
                    "vulnerability_code": "    function _removePoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS_INACTIVE, _poolStakingAddress))\n\n        ];\n\n        uint256 indexToRemove = poolDelegatorInactiveIndex(_poolStakingAddress, _delegator);\n\n        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n\n            delegators[indexToRemove] = delegators[delegators.length - 1];\n\n            _setPoolDelegatorInactiveIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n\n            _setPoolDelegatorInactiveIndex(_poolStakingAddress, _delegator, 0);\n\n            delegators.length--;\n\n        }\n",
                    "message": "Function 'StakingBase._removePoolDelegatorInactive' (StakingAuRa.sol#1180-1191) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._removePoolDelegatorInactive (StakingAuRa.sol#1180) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._removePoolDelegatorInactive (StakingAuRa.sol#1180) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1197,
                    "vulnerability_to_line": 1207,
                    "vulnerability_code": "    function _setLikelihood(address _poolStakingAddress) internal {\n\n        (bool isToBeElected, uint256 index) = _isPoolToBeElected(_poolStakingAddress);\n\n\n\n        if (!isToBeElected) return;\n\n\n\n        int256 oldValue = intArrayStorage[POOLS_LIKELIHOOD][index];\n\n        int256 newValue = int256(stakeAmountTotalMinusOrderedWithdraw(_poolStakingAddress) * 100 / STAKE_UNIT);\n\n\n\n        intArrayStorage[POOLS_LIKELIHOOD][index] = newValue;\n\n        intStorage[POOLS_LIKELIHOOD_SUM] += newValue - oldValue;\n",
                    "message": "Function 'StakingBase._setLikelihood' (StakingAuRa.sol#1197-1207) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setLikelihood(address _poolStakingAddress) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setLikelihood (StakingAuRa.sol#1197) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1214,
                    "vulnerability_to_line": 1216,
                    "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(ORDERED_WITHDRAW_AMOUNT, _poolStakingAddress, _staker))] = _amount;\n",
                    "message": "Function 'StakingBase._setOrderedWithdrawAmount' (StakingAuRa.sol#1214-1216) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setOrderedWithdrawAmount (StakingAuRa.sol#1214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._setOrderedWithdrawAmount (StakingAuRa.sol#1214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._setOrderedWithdrawAmount (StakingAuRa.sol#1214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1222,
                    "vulnerability_to_line": 1224,
                    "vulnerability_code": "    function _setOrderedWithdrawAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(ORDERED_WITHDRAW_AMOUNT_TOTAL, _poolStakingAddress))] = _amount;\n",
                    "message": "Function 'StakingBase._setOrderedWithdrawAmountTotal' (StakingAuRa.sol#1222-1224) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setOrderedWithdrawAmountTotal (StakingAuRa.sol#1222) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._setOrderedWithdrawAmountTotal (StakingAuRa.sol#1222) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": 1233,
                    "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(STAKE_AMOUNT, _poolStakingAddress, _staker))] = _amount;\n",
                    "message": "Function 'StakingBase._setStakeAmount' (StakingAuRa.sol#1231-1233) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setStakeAmount (StakingAuRa.sol#1231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._setStakeAmount (StakingAuRa.sol#1231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._setStakeAmount (StakingAuRa.sol#1231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1241,
                    "vulnerability_to_line": 1249,
                    "vulnerability_code": "    function _setStakeAmountByCurrentEpoch(\n\n        address _poolStakingAddress,\n\n        address _staker,\n\n        uint256 _amount\n\n    ) internal {\n\n        uintStorage[keccak256(abi.encode(\n\n            STAKE_AMOUNT_BY_EPOCH, _poolStakingAddress, _staker, stakingEpoch()\n\n        ))] = _amount;\n",
                    "message": "Function 'StakingBase._setStakeAmountByCurrentEpoch' (StakingAuRa.sol#1241-1249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _poolStakingAddress,\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setStakeAmountByCurrentEpoch (StakingAuRa.sol#1242) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _staker,\n",
                    "message": "Parameter '_staker' of StakingBase._setStakeAmountByCurrentEpoch (StakingAuRa.sol#1243) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _amount\n",
                    "message": "Parameter '_amount' of StakingBase._setStakeAmountByCurrentEpoch (StakingAuRa.sol#1244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1254,
                    "vulnerability_to_line": 1256,
                    "vulnerability_code": "    function _setStakeAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(STAKE_AMOUNT_TOTAL, _poolStakingAddress))] = _amount;\n",
                    "message": "Function 'StakingBase._setStakeAmountTotal' (StakingAuRa.sol#1254-1256) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setStakeAmountTotal (StakingAuRa.sol#1254) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._setStakeAmountTotal (StakingAuRa.sol#1254) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": 1263,
                    "vulnerability_code": "    function _setDelegatorMinStake(uint256 _minStake) internal {\n\n        uintStorage[DELEGATOR_MIN_STAKE] = _minStake * STAKE_UNIT;\n",
                    "message": "Function 'StakingBase._setDelegatorMinStake' (StakingAuRa.sol#1261-1263) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setDelegatorMinStake(uint256 _minStake) internal {\n",
                    "message": "Parameter '_minStake' of StakingBase._setDelegatorMinStake (StakingAuRa.sol#1261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1268,
                    "vulnerability_to_line": 1270,
                    "vulnerability_code": "    function _setCandidateMinStake(uint256 _minStake) internal {\n\n        uintStorage[CANDIDATE_MIN_STAKE] = _minStake * STAKE_UNIT;\n",
                    "message": "Function 'StakingBase._setCandidateMinStake' (StakingAuRa.sol#1268-1270) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCandidateMinStake(uint256 _minStake) internal {\n",
                    "message": "Parameter '_minStake' of StakingBase._setCandidateMinStake (StakingAuRa.sol#1268) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1276,
                    "vulnerability_to_line": 1289,
                    "vulnerability_code": "    function _stake(address _toPoolStakingAddress, uint256 _amount) internal {\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            require(msg.value == 0);\n\n        }\n\n        address staker = msg.sender;\n\n        _stake(_toPoolStakingAddress, staker, _amount);\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.stake(staker, _amount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n        }\n\n        emit Staked(_toPoolStakingAddress, staker, stakingEpoch(), _amount);\n",
                    "message": "Function 'StakingBase._stake' (StakingAuRa.sol#1276-1289) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _toPoolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_toPoolStakingAddress' of StakingBase._stake (StakingAuRa.sol#1276) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _toPoolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._stake (StakingAuRa.sol#1276) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": 1333,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Function 'StakingBase._stake' (StakingAuRa.sol#1296-1333) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._stake (StakingAuRa.sol#1296) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._stake (StakingAuRa.sol#1296) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._stake (StakingAuRa.sol#1296) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": 1370,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n\n\n        // How much can `staker` withdraw from `_poolStakingAddress` at the moment?\n\n        require(_amount <= maxWithdrawAllowed(_poolStakingAddress, _staker));\n\n\n\n        uint256 currentStakeAmount = stakeAmount(_poolStakingAddress, _staker);\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, _staker);\n\n        uint256 resultingStakeAmount = currentStakeAmount.sub(alreadyOrderedAmount).sub(_amount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 minAllowedStake = (_poolStakingAddress == _staker) ? getCandidateMinStake() : getDelegatorMinStake();\n\n        require(resultingStakeAmount == 0 || resultingStakeAmount >= minAllowedStake);\n\n\n\n        _setStakeAmount(_poolStakingAddress, _staker, currentStakeAmount.sub(_amount));\n\n        uint256 amountByEpoch = stakeAmountByCurrentEpoch(_poolStakingAddress, _staker);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            amountByEpoch >= _amount ? amountByEpoch - _amount : 0\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(_amount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Function 'StakingBase._withdraw' (StakingAuRa.sol#1340-1370) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._withdraw (StakingAuRa.sol#1340) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._withdraw (StakingAuRa.sol#1340) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._withdraw (StakingAuRa.sol#1340) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": 1391,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n\n        if (_staker == _poolStakingAddress) {\n\n            IValidatorSet validatorSet = validatorSetContract();\n\n            address unremovableStakingAddress = validatorSet.unremovableValidator();\n\n\n\n            if (_poolStakingAddress != unremovableStakingAddress) {\n\n                if (validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress))) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                } else {\n\n                    _removePool(_poolStakingAddress);\n\n                }\n\n            }\n\n        } else {\n\n            _removePoolDelegator(_poolStakingAddress, _staker);\n\n        }\n",
                    "message": "Function 'StakingBase._withdrawCheckPool' (StakingAuRa.sol#1376-1391) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._withdrawCheckPool (StakingAuRa.sol#1376) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._withdrawCheckPool (StakingAuRa.sol#1376) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1394,
                    "vulnerability_to_line": 1396,
                    "vulnerability_code": "    function _getCurrentBlockNumber() internal view returns(uint256) {\n\n        return block.number;\n",
                    "message": "Function 'StakingBase._getCurrentBlockNumber' (StakingAuRa.sol#1394-1396) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1400,
                    "vulnerability_to_line": 1402,
                    "vulnerability_code": "    function _getMaxCandidates() internal pure returns(uint256) {\n\n        return MAX_CANDIDATES;\n",
                    "message": "Function 'StakingBase._getMaxCandidates' (StakingAuRa.sol#1400-1402) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1410,
                    "vulnerability_to_line": 1419,
                    "vulnerability_code": "    function _isPoolToBeElected(address _stakingAddress) internal view returns(bool toBeElected, uint256 index) {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_ELECTED];\n\n        if (pools.length != 0) {\n\n            index = poolToBeElectedIndex(_stakingAddress);\n\n            if (pools[index] == _stakingAddress) {\n\n                return (true, index);\n\n            }\n\n        }\n\n        return (false, 0);\n",
                    "message": "Function 'StakingBase._isPoolToBeElected' (StakingAuRa.sol#1410-1419) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isPoolToBeElected(address _stakingAddress) internal view returns(bool toBeElected, uint256 index) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._isPoolToBeElected (StakingAuRa.sol#1410) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": 1435,
                    "vulnerability_code": "    function _isWithdrawAllowed(address _miningAddress) internal view returns(bool) {\n\n        if (validatorSetContract().isValidatorBanned(_miningAddress)) {\n\n            // No one can withdraw from `_poolStakingAddress` until the ban is expired\n\n            return false;\n\n        }\n\n\n\n        if (!areStakeAndWithdrawAllowed()) {\n\n            return false;\n\n        }\n\n\n\n        return true;\n",
                    "message": "Function 'StakingBase._isWithdrawAllowed' (StakingAuRa.sol#1424-1435) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isWithdrawAllowed(address _miningAddress) internal view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of StakingBase._isWithdrawAllowed (StakingAuRa.sol#1424) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1445,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IStakingAuRa.initialize (StakingAuRa.sol#1445) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_0' of IStakingAuRa.initialize (StakingAuRa.sol#1446) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_1' of IStakingAuRa.initialize (StakingAuRa.sol#1447) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1448,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_2' of IStakingAuRa.initialize (StakingAuRa.sol#1448) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1449,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_3' of IStakingAuRa.initialize (StakingAuRa.sol#1449) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_4' of IStakingAuRa.initialize (StakingAuRa.sol#1450) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_5' of IStakingAuRa.initialize (StakingAuRa.sol#1451) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_6' of IStakingAuRa.initialize (StakingAuRa.sol#1452) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingEpochStartBlock(uint256) external;\n",
                    "message": "Parameter '' of IStakingAuRa.setStakingEpochStartBlock (StakingAuRa.sol#1454) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _validatorSetContract,\n",
                    "message": "Parameter '_validatorSetContract' of StakingAuRa.initialize (StakingAuRa.sol#1512) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
                    "message": "Parameter '_initialStakingAddresses' of StakingAuRa.initialize (StakingAuRa.sol#1513) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _delegatorMinStake,\n",
                    "message": "Parameter '_delegatorMinStake' of StakingAuRa.initialize (StakingAuRa.sol#1514) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1515,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _candidateMinStake,\n",
                    "message": "Parameter '_candidateMinStake' of StakingAuRa.initialize (StakingAuRa.sol#1515) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1516,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpochDuration,\n",
                    "message": "Parameter '_stakingEpochDuration' of StakingAuRa.initialize (StakingAuRa.sol#1516) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpochStartBlock,\n",
                    "message": "Parameter '_stakingEpochStartBlock' of StakingAuRa.initialize (StakingAuRa.sol#1517) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakeWithdrawDisallowPeriod,\n",
                    "message": "Parameter '_stakeWithdrawDisallowPeriod' of StakingAuRa.initialize (StakingAuRa.sol#1518) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1519,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _erc20Restricted\n",
                    "message": "Parameter '_erc20Restricted' of StakingAuRa.initialize (StakingAuRa.sol#1519) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingEpochStartBlock(uint256 _blockNumber) external onlyValidatorSetContract {\n",
                    "message": "Parameter '_blockNumber' of StakingAuRa.setStakingEpochStartBlock (StakingAuRa.sol#1542) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addPool(uint256 _amount, address _miningAddress) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_amount' of StakingAuRa.addPool (StakingAuRa.sol#1478) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addPool(uint256 _amount, address _miningAddress) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_miningAddress' of StakingAuRa.addPool (StakingAuRa.sol#1478) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1490,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addPoolNative(address _miningAddress) external gasPriceIsValid onlyInitialized payable {\n",
                    "message": "Parameter '_miningAddress' of StakingAuRa.addPoolNative (StakingAuRa.sol#1490) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (StakingAuRa.sol#101) is never used in StakingAuRa\nEternalStorage.bytesStorage (StakingAuRa.sol#103) is never used in StakingAuRa\nEternalStorage.bytes32Storage (StakingAuRa.sol#106) is never used in StakingAuRa\nEternalStorage.uintArrayStorage (StakingAuRa.sol#108) is never used in StakingAuRa\nEternalStorage.stringArrayStorage (StakingAuRa.sol#109) is never used in StakingAuRa\nEternalStorage.bytesArrayStorage (StakingAuRa.sol#111) is never used in StakingAuRa\nEternalStorage.boolArrayStorage (StakingAuRa.sol#112) is never used in StakingAuRa\nEternalStorage.bytes32ArrayStorage (StakingAuRa.sol#114) is never used in StakingAuRa\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 963,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            likelihood.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 978,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 992,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 1013,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 1167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 1467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract StakingAuRa is IStakingAuRa, StakingBase {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_MSGVALUE_EQUALS_ZERO",
                    "vulnerability_from_line": 1279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(msg.value == 0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErc20TokenContract(address _erc20TokenContract) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCandidateMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setDelegatorMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory likelihoods, int256 sum) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isPoolToBeElected(address _stakingAddress) internal view returns(bool toBeElected, uint256 index) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _delegatorMinStake,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1515,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _candidateMinStake,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1516,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpochDuration,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpochStartBlock,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakeWithdrawDisallowPeriod,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1519,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _erc20Restricted\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1521,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingEpochDuration != 0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingEpochDuration > _stakeWithdrawDisallowPeriod);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingEpochDuration > _stakeWithdrawDisallowPeriod);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSet = IValidatorSet(_validatorSetContract);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IBlockReward blockReward = IBlockReward(validatorSet.blockRewardContract());\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingEpochDuration >= validatorSet.MAX_VALIDATORS() * blockReward.DELEGATORS_ALIQUOT() * 2 + 1);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingEpochDuration >= validatorSet.MAX_VALIDATORS() * blockReward.DELEGATORS_ALIQUOT() * 2 + 1);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingEpochDuration >= validatorSet.MAX_VALIDATORS() * blockReward.DELEGATORS_ALIQUOT() * 2 + 1);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingEpochDuration >= validatorSet.MAX_VALIDATORS() * blockReward.DELEGATORS_ALIQUOT() * 2 + 1);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingEpochDuration >= validatorSet.MAX_VALIDATORS() * blockReward.DELEGATORS_ALIQUOT() * 2 + 1);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1526,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakeWithdrawDisallowPeriod != 0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        super._initialize(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _initialStakingAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _candidateMinStake,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[STAKING_EPOCH_DURATION] = _stakingEpochDuration;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1535,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[STAKE_WITHDRAW_DISALLOW_PERIOD] = _stakeWithdrawDisallowPeriod;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[STAKING_EPOCH_START_BLOCK] = _stakingEpochStartBlock;\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/Certifier.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _certifiedAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _certifiedAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_29"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner (Certifier.sol#55) is never initialized. It is used in:\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (Certifier.sol#55)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in Certifier.sol:\n\t- pragma solidity0.5.9 (Certifier.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (Certifier.sol#12): it allows old versions\n\t- pragma solidity0.5.9 (Certifier.sol#47): it allows old versions\n\t- pragma solidity0.5.9 (Certifier.sol#78): it allows old versions\n\t- pragma solidity0.5.9 (Certifier.sol#96): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address[] calldata, address) external;\n",
                    "message": "Parameter '' of ICertifier.initialize (Certifier.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address[] calldata, address) external;\n",
                    "message": "Parameter '_scope_0' of ICertifier.initialize (Certifier.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (Certifier.sol#17) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (Certifier.sol#18) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (Certifier.sol#19) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (Certifier.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (Certifier.sol#21) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (Certifier.sol#22) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (Certifier.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (Certifier.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (Certifier.sol#32) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (Certifier.sol#33) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (Certifier.sol#34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (Certifier.sol#35) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (Certifier.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (Certifier.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (Certifier.sol#41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (Certifier.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _certifiedAddresses,\n",
                    "message": "Parameter '_certifiedAddresses' of Certifier.initialize (Certifier.sol#131) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _validatorSet\n",
                    "message": "Parameter '_validatorSet' of Certifier.initialize (Certifier.sol#132) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function certify(address _who) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_who' of Certifier.certify (Certifier.sol#145) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revoke(address _who) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_who' of Certifier.revoke (Certifier.sol#153) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function certified(address _who) external view returns(bool) {\n",
                    "message": "Parameter '_who' of Certifier.certified (Certifier.sol#164) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": 191,
                    "vulnerability_code": "    function _certify(address _who) internal {\n\n        require(_who != address(0));\n\n        boolStorage[keccak256(abi.encode(CERTIFIED, _who))] = true;\n",
                    "message": "Function 'Certifier._certify' (Certifier.sol#188-191) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _certify(address _who) internal {\n",
                    "message": "Parameter '_who' of Certifier._certify (Certifier.sol#188) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => uint256) internal uintStorage;\n",
                    "message": "EternalStorage.uintStorage (Certifier.sol#58) is never used in Certifier\nEternalStorage.stringStorage (Certifier.sol#59) is never used in Certifier\nEternalStorage.bytesStorage (Certifier.sol#61) is never used in Certifier\nEternalStorage.intStorage (Certifier.sol#63) is never used in Certifier\nEternalStorage.bytes32Storage (Certifier.sol#64) is never used in Certifier\nEternalStorage.uintArrayStorage (Certifier.sol#66) is never used in Certifier\nEternalStorage.stringArrayStorage (Certifier.sol#67) is never used in Certifier\nEternalStorage.addressArrayStorage (Certifier.sol#68) is never used in Certifier\nEternalStorage.bytesArrayStorage (Certifier.sol#69) is never used in Certifier\nEternalStorage.boolArrayStorage (Certifier.sol#70) is never used in Certifier\nEternalStorage.intArrayStorage (Certifier.sol#71) is never used in Certifier\nEternalStorage.bytes32ArrayStorage (Certifier.sol#72) is never used in Certifier\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _certifiedAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _certifiedAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/ValidatorSetAuRa.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 557,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < prevValidators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _queueValidators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 708,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 711,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                miningAddresses[i] = miningAddresses[miningAddresses.length - 1];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                miningAddresses.length--;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 771,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _stakingAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < poolsToBeRemoved.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 m = 0; m < reportedValidators.length; m++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 708,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 m = 0; m < reportedValidators.length; m++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (validatorSetApplyBlock() == 0 && newStakingEpoch) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // Apply a new validator set formed by the `newValidatorSet` function\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address[] memory previousValidators = getPreviousValidators();\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address[] memory currentValidators = getValidators();\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 i;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // Save the previous validator set\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                _setIsValidatorOnPreviousEpoch(previousValidators[i], false);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 648,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 649,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolsToBeElected.length >= MAX_VALIDATORS &&\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 651,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 653,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 655,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (likelihood.length > 0 && likelihoodSum > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 657,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                address[] memory newValidators = new address[](\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (likelihood.length > 0 && likelihoodSum > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 657,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                address[] memory newValidators = new address[](\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 659,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                );\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 661,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 663,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1076,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (reportsNumber > validatorsNumber * 50 && reportsNumber > averageReportsNumber * 10) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1077,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                return (false, true);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1078,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1086,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (currentBlock > ancientBlocksLimit && _blockNumber < currentBlock - ancientBlocksLimit) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1087,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return (false, false); // avoid reporting about ancient blocks\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1088,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 592,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (int256 i = queueLast; i >= queueFirst; i--) {\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 667,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    poolsToBeElectedLength--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                miningAddresses.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 557,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < prevValidators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _queueValidators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 577,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uintStorage[keccak256(abi.encode(BAN_COUNTER, _miningAddress))]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        queueLast++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 627,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            intStorage[QUEUE_PV_FIRST]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 634,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[CHANGE_REQUEST_COUNT]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 708,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 737,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uintStorage[keccak256(abi.encode(VALIDATOR_COUNTER, _miningAddress))]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 771,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _stakingAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < poolsToBeRemoved.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 858,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 m = 0; m < reportedValidators.length; m++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[keccak256(abi.encode(REPORTING_COUNTER, _reportingMiningAddress, currentStakingEpoch))]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "DOCKER_RECEIVED_SIGNAL_12"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner (ValidatorSetAuRa.sol#89) is never initialized. It is used in:\n\t- clearUnremovableValidator (ValidatorSetAuRa.sol#218-223)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": 1147,
                    "vulnerability_code": "    function _incrementReportingCounter(address _reportingMiningAddress) internal {\n\n        if (!isReportValidatorValid(_reportingMiningAddress)) return;\n\n        uint256 currentStakingEpoch = IStaking(stakingContract()).stakingEpoch();\n\n        uintStorage[keccak256(abi.encode(REPORTING_COUNTER, _reportingMiningAddress, currentStakingEpoch))]++;\n\n        uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))]++;\n",
                    "message": "Reentrancy in ValidatorSetAuRa._incrementReportingCounter (ValidatorSetAuRa.sol#1142-1147):\n\tExternal calls:\n\t- ! isReportValidatorValid(_reportingMiningAddress) (ValidatorSetAuRa.sol#1143)\n\t- currentStakingEpoch = IStaking(stakingContract()).stakingEpoch() (ValidatorSetAuRa.sol#1144)\n\tState variables written after the call(s):\n\t- uintStorage (ValidatorSetAuRa.sol#1145)\n\t- uintStorage (ValidatorSetAuRa.sol#1146)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 642,
                    "vulnerability_to_line": 687,
                    "vulnerability_code": "    function _newValidatorSet() internal returns(uint256) {\n\n        IStaking staking = IStaking(stakingContract());\n\n        address[] memory poolsToBeElected = staking.getPoolsToBeElected();\n\n        address unremovableStakingAddress = unremovableValidator();\n\n\n\n        // Choose new validators\n\n        if (\n\n            poolsToBeElected.length >= MAX_VALIDATORS &&\n\n            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n\n        ) {\n\n            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n\n\n\n            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n\n\n\n            if (likelihood.length > 0 && likelihoodSum > 0) {\n\n                address[] memory newValidators = new address[](\n\n                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n\n                );\n\n\n\n                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n\n                for (uint256 i = 0; i < newValidators.length; i++) {\n\n                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n\n                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n\n                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n\n                    likelihoodSum -= likelihood[randomPoolIndex];\n\n                    poolsToBeElectedLength--;\n\n                    poolsToBeElected[randomPoolIndex] = poolsToBeElected[poolsToBeElectedLength];\n\n                    likelihood[randomPoolIndex] = likelihood[poolsToBeElectedLength];\n\n                }\n\n\n\n                _setPendingValidators(staking, newValidators, unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            _setPendingValidators(staking, poolsToBeElected, unremovableStakingAddress);\n\n        }\n\n\n\n        // From this moment the `getPendingValidators()` will return a new validator set\n\n\n\n        staking.incrementStakingEpoch();\n\n        _setValidatorSetApplyBlock(0);\n\n\n\n        _incrementChangeRequestCount();\n\n        _enqueuePendingValidators(true);\n\n\n\n        return poolsToBeElected.length;\n",
                    "message": "Reentrancy in ValidatorSetBase._newValidatorSet (ValidatorSetAuRa.sol#642-687):\n\tExternal calls:\n\t- poolsToBeElected = staking.getPoolsToBeElected() (ValidatorSetAuRa.sol#644)\n\t- randomNumber = IRandom(randomContract()).getCurrentSeed() (ValidatorSetAuRa.sol#652)\n\t- (likelihood,likelihoodSum) = staking.getPoolsLikelihood() (ValidatorSetAuRa.sol#654)\n\t- _setPendingValidators(staking,newValidators,unremovableStakingAddress) (ValidatorSetAuRa.sol#672)\n\t- _setPendingValidators(staking,poolsToBeElected,unremovableStakingAddress) (ValidatorSetAuRa.sol#675)\n\t- staking.incrementStakingEpoch() (ValidatorSetAuRa.sol#680)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetAuRa.sol#684)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1153,
                    "vulnerability_to_line": 1165,
                    "vulnerability_code": "    function _removeMaliciousValidatorAuRa(address _miningAddress) internal {\n\n        if (isValidatorBanned(_miningAddress)) {\n\n            // The malicious validator is already banned\n\n            return;\n\n        }\n\n\n\n        if (_removeMaliciousValidator(_miningAddress)) {\n\n            // From this moment `getPendingValidators()` will return the new validator set\n\n            _incrementChangeRequestCount();\n\n            _enqueuePendingValidators(false);\n\n            _clearReportingCounter(_miningAddress);\n\n        }\n",
                    "message": "Reentrancy in ValidatorSetAuRa._removeMaliciousValidatorAuRa (ValidatorSetAuRa.sol#1153-1165):\n\tExternal calls:\n\t- _removeMaliciousValidator(_miningAddress) (ValidatorSetAuRa.sol#1159-1164)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetAuRa.sol#1162)\n\t- uintStorage (ValidatorSetAuRa.sol#1161)\n\t- uintStorage (ValidatorSetAuRa.sol#1162)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1153,
                    "vulnerability_to_line": 1165,
                    "vulnerability_code": "    function _removeMaliciousValidatorAuRa(address _miningAddress) internal {\n\n        if (isValidatorBanned(_miningAddress)) {\n\n            // The malicious validator is already banned\n\n            return;\n\n        }\n\n\n\n        if (_removeMaliciousValidator(_miningAddress)) {\n\n            // From this moment `getPendingValidators()` will return the new validator set\n\n            _incrementChangeRequestCount();\n\n            _enqueuePendingValidators(false);\n\n            _clearReportingCounter(_miningAddress);\n\n        }\n",
                    "message": "Reentrancy in ValidatorSetAuRa._removeMaliciousValidatorAuRa (ValidatorSetAuRa.sol#1153-1165):\n\tExternal calls:\n\t- _removeMaliciousValidator(_miningAddress) (ValidatorSetAuRa.sol#1159-1164)\n\t- _clearReportingCounter(_miningAddress) (ValidatorSetAuRa.sol#1163)\n\tState variables written after the call(s):\n\t- uintStorage (ValidatorSetAuRa.sol#1163)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 960,
                    "vulnerability_to_line": 1011,
                    "vulnerability_code": "    function reportMalicious(\n\n        address _maliciousMiningAddress,\n\n        uint256 _blockNumber,\n\n        bytes calldata\n\n    ) external onlyInitialized {\n\n        address reportingMiningAddress = msg.sender;\n\n\n\n        _incrementReportingCounter(reportingMiningAddress);\n\n\n\n        (\n\n            bool callable,\n\n            bool removeReportingValidator\n\n        ) = reportMaliciousCallable(\n\n            reportingMiningAddress,\n\n            _maliciousMiningAddress,\n\n            _blockNumber\n\n        );\n\n\n\n        if (!callable) {\n\n            if (removeReportingValidator) {\n\n                // Reporting validator reported too often, so\n\n                // treat them as a malicious as well\n\n                _removeMaliciousValidatorAuRa(reportingMiningAddress);\n\n            }\n\n            return;\n\n        }\n\n\n\n        address[] storage reportedValidators = addressArrayStorage[keccak256(abi.encode(\n\n            MALICE_REPORTED_FOR_BLOCK, _maliciousMiningAddress, _blockNumber\n\n        ))];\n\n\n\n        reportedValidators.push(reportingMiningAddress);\n\n\n\n        emit ReportedMalicious(reportingMiningAddress, _maliciousMiningAddress, _blockNumber);\n\n\n\n        uint256 validatorsLength = getValidators().length;\n\n        bool remove;\n\n\n\n        if (validatorsLength > 3) {\n\n            // If more than 2/3 of validators reported about malicious validator\n\n            // for the same `blockNumber`\n\n            remove = reportedValidators.length.mul(3) > validatorsLength.mul(2);\n\n        } else {\n\n            // If more than 1/2 of validators reported about malicious validator\n\n            // for the same `blockNumber`\n\n            remove = reportedValidators.length.mul(2) > validatorsLength;\n\n        }\n\n\n\n        if (remove) {\n\n            _removeMaliciousValidatorAuRa(_maliciousMiningAddress);\n\n        }\n",
                    "message": "Reentrancy in ValidatorSetAuRa.reportMalicious (ValidatorSetAuRa.sol#960-1011):\n\tExternal calls:\n\t- _incrementReportingCounter(reportingMiningAddress) (ValidatorSetAuRa.sol#967)\n\t- (callable,removeReportingValidator) = reportMaliciousCallable(reportingMiningAddress,_maliciousMiningAddress,_blockNumber) (ValidatorSetAuRa.sol#969-976)\n\t- _removeMaliciousValidatorAuRa(reportingMiningAddress) (ValidatorSetAuRa.sol#982)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetAuRa.sol#982)\n\t- boolStorage (ValidatorSetAuRa.sol#982)\n\t- uintStorage (ValidatorSetAuRa.sol#982)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 960,
                    "vulnerability_to_line": 1011,
                    "vulnerability_code": "    function reportMalicious(\n\n        address _maliciousMiningAddress,\n\n        uint256 _blockNumber,\n\n        bytes calldata\n\n    ) external onlyInitialized {\n\n        address reportingMiningAddress = msg.sender;\n\n\n\n        _incrementReportingCounter(reportingMiningAddress);\n\n\n\n        (\n\n            bool callable,\n\n            bool removeReportingValidator\n\n        ) = reportMaliciousCallable(\n\n            reportingMiningAddress,\n\n            _maliciousMiningAddress,\n\n            _blockNumber\n\n        );\n\n\n\n        if (!callable) {\n\n            if (removeReportingValidator) {\n\n                // Reporting validator reported too often, so\n\n                // treat them as a malicious as well\n\n                _removeMaliciousValidatorAuRa(reportingMiningAddress);\n\n            }\n\n            return;\n\n        }\n\n\n\n        address[] storage reportedValidators = addressArrayStorage[keccak256(abi.encode(\n\n            MALICE_REPORTED_FOR_BLOCK, _maliciousMiningAddress, _blockNumber\n\n        ))];\n\n\n\n        reportedValidators.push(reportingMiningAddress);\n\n\n\n        emit ReportedMalicious(reportingMiningAddress, _maliciousMiningAddress, _blockNumber);\n\n\n\n        uint256 validatorsLength = getValidators().length;\n\n        bool remove;\n\n\n\n        if (validatorsLength > 3) {\n\n            // If more than 2/3 of validators reported about malicious validator\n\n            // for the same `blockNumber`\n\n            remove = reportedValidators.length.mul(3) > validatorsLength.mul(2);\n\n        } else {\n\n            // If more than 1/2 of validators reported about malicious validator\n\n            // for the same `blockNumber`\n\n            remove = reportedValidators.length.mul(2) > validatorsLength;\n\n        }\n\n\n\n        if (remove) {\n\n            _removeMaliciousValidatorAuRa(_maliciousMiningAddress);\n\n        }\n",
                    "message": "Reentrancy in ValidatorSetAuRa.reportMalicious (ValidatorSetAuRa.sol#960-1011):\n\tExternal calls:\n\t- _incrementReportingCounter(reportingMiningAddress) (ValidatorSetAuRa.sol#967)\n\t- (callable,removeReportingValidator) = reportMaliciousCallable(reportingMiningAddress,_maliciousMiningAddress,_blockNumber) (ValidatorSetAuRa.sol#969-976)\n\t- _removeMaliciousValidatorAuRa(_maliciousMiningAddress) (ValidatorSetAuRa.sol#1009)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetAuRa.sol#1009)\n\t- boolStorage (ValidatorSetAuRa.sol#1009)\n\t- uintStorage (ValidatorSetAuRa.sol#1009)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 941,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IStakingAuRa stakingContract = IStakingAuRa(stakingContract());\n",
                    "message": "ValidatorSetAuRa.newValidatorSet.stakingContract (local variable @ ValidatorSetAuRa.sol#941) shadows:\n\t- ValidatorSetBase.stakingContract (function @ ValidatorSetAuRa.sol#485-487)\n\t- IValidatorSet.stakingContract (function @ ValidatorSetAuRa.sol#73)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1124,
                    "vulnerability_to_line": 1136,
                    "vulnerability_code": "    function _clearReportingCounter(address _miningAddress) internal {\n\n        uint256 currentStakingEpoch = IStaking(stakingContract()).stakingEpoch();\n\n        uint256 total = reportingCounterTotal(currentStakingEpoch);\n\n        uint256 counter = reportingCounter(_miningAddress, currentStakingEpoch);\n\n\n\n        uintStorage[keccak256(abi.encode(REPORTING_COUNTER, _miningAddress, currentStakingEpoch))] = 0;\n\n\n\n        if (total >= counter) {\n\n            uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))] -= counter;\n\n        } else {\n\n            uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))] = 0;\n\n        }\n",
                    "message": "Reentrancy in ValidatorSetAuRa._clearReportingCounter (ValidatorSetAuRa.sol#1124-1136):\n\tExternal calls:\n\t- currentStakingEpoch = IStaking(stakingContract()).stakingEpoch() (ValidatorSetAuRa.sol#1125)\n\tState variables written after the call(s):\n\t- uintStorage (ValidatorSetAuRa.sol#1129)\n\t- uintStorage (ValidatorSetAuRa.sol#1132)\n\t- uintStorage (ValidatorSetAuRa.sol#1134)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 642,
                    "vulnerability_to_line": 687,
                    "vulnerability_code": "    function _newValidatorSet() internal returns(uint256) {\n\n        IStaking staking = IStaking(stakingContract());\n\n        address[] memory poolsToBeElected = staking.getPoolsToBeElected();\n\n        address unremovableStakingAddress = unremovableValidator();\n\n\n\n        // Choose new validators\n\n        if (\n\n            poolsToBeElected.length >= MAX_VALIDATORS &&\n\n            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n\n        ) {\n\n            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n\n\n\n            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n\n\n\n            if (likelihood.length > 0 && likelihoodSum > 0) {\n\n                address[] memory newValidators = new address[](\n\n                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n\n                );\n\n\n\n                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n\n                for (uint256 i = 0; i < newValidators.length; i++) {\n\n                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n\n                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n\n                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n\n                    likelihoodSum -= likelihood[randomPoolIndex];\n\n                    poolsToBeElectedLength--;\n\n                    poolsToBeElected[randomPoolIndex] = poolsToBeElected[poolsToBeElectedLength];\n\n                    likelihood[randomPoolIndex] = likelihood[poolsToBeElectedLength];\n\n                }\n\n\n\n                _setPendingValidators(staking, newValidators, unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            _setPendingValidators(staking, poolsToBeElected, unremovableStakingAddress);\n\n        }\n\n\n\n        // From this moment the `getPendingValidators()` will return a new validator set\n\n\n\n        staking.incrementStakingEpoch();\n\n        _setValidatorSetApplyBlock(0);\n\n\n\n        _incrementChangeRequestCount();\n\n        _enqueuePendingValidators(true);\n\n\n\n        return poolsToBeElected.length;\n",
                    "message": "Reentrancy in ValidatorSetBase._newValidatorSet (ValidatorSetAuRa.sol#642-687):\n\tExternal calls:\n\t- poolsToBeElected = staking.getPoolsToBeElected() (ValidatorSetAuRa.sol#644)\n\t- randomNumber = IRandom(randomContract()).getCurrentSeed() (ValidatorSetAuRa.sol#652)\n\t- (likelihood,likelihoodSum) = staking.getPoolsLikelihood() (ValidatorSetAuRa.sol#654)\n\t- _setPendingValidators(staking,newValidators,unremovableStakingAddress) (ValidatorSetAuRa.sol#672)\n\t- _setPendingValidators(staking,poolsToBeElected,unremovableStakingAddress) (ValidatorSetAuRa.sol#675)\n\t- staking.incrementStakingEpoch() (ValidatorSetAuRa.sol#680)\n\tState variables written after the call(s):\n\t- boolStorage (ValidatorSetAuRa.sol#684)\n\t- intStorage (ValidatorSetAuRa.sol#684)\n\t- uintStorage (ValidatorSetAuRa.sol#681)\n\t- uintStorage (ValidatorSetAuRa.sol#683)\n\t- uintStorage (ValidatorSetAuRa.sol#684)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": 718,
                    "vulnerability_code": "    function _removeMaliciousValidator(address _miningAddress) internal returns(bool) {\n\n        address stakingAddress = stakingByMiningAddress(_miningAddress);\n\n\n\n        if (stakingAddress == unremovableValidator()) {\n\n            return false;\n\n        }\n\n\n\n        // Ban the malicious validator for the next 3 months\n\n        _banValidator(_miningAddress);\n\n\n\n        // Remove malicious validator from the `pools`\n\n        IStaking(stakingContract()).removePool(stakingAddress);\n\n\n\n        address[] storage miningAddresses = addressArrayStorage[PENDING_VALIDATORS];\n\n\n\n        for (uint256 i = 0; i < miningAddresses.length; i++) {\n\n            if (miningAddresses[i] == _miningAddress) {\n\n                // Remove the malicious validator from `pendingValidators`\n\n                miningAddresses[i] = miningAddresses[miningAddresses.length - 1];\n\n                miningAddresses.length--;\n\n                return true;\n\n            }\n\n        }\n\n\n\n        return false;\n",
                    "message": "Reentrancy in ValidatorSetBase._removeMaliciousValidator (ValidatorSetAuRa.sol#693-718):\n\tExternal calls:\n\t- IStaking(stakingContract()).removePool(stakingAddress) (ValidatorSetAuRa.sol#704)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetAuRa.sol#711)\n\t- addressArrayStorage (ValidatorSetAuRa.sol#712)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1153,
                    "vulnerability_to_line": 1165,
                    "vulnerability_code": "    function _removeMaliciousValidatorAuRa(address _miningAddress) internal {\n\n        if (isValidatorBanned(_miningAddress)) {\n\n            // The malicious validator is already banned\n\n            return;\n\n        }\n\n\n\n        if (_removeMaliciousValidator(_miningAddress)) {\n\n            // From this moment `getPendingValidators()` will return the new validator set\n\n            _incrementChangeRequestCount();\n\n            _enqueuePendingValidators(false);\n\n            _clearReportingCounter(_miningAddress);\n\n        }\n",
                    "message": "Reentrancy in ValidatorSetAuRa._removeMaliciousValidatorAuRa (ValidatorSetAuRa.sol#1153-1165):\n\tExternal calls:\n\t- _removeMaliciousValidator(_miningAddress) (ValidatorSetAuRa.sol#1159-1164)\n\tState variables written after the call(s):\n\t- boolStorage (ValidatorSetAuRa.sol#1162)\n\t- intStorage (ValidatorSetAuRa.sol#1162)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (ValidatorSetAuRa.sol#89)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": 367,
                    "vulnerability_code": "    function changeRequestCount() public view returns(uint256) {\n\n        return uintStorage[CHANGE_REQUEST_COUNT];\n",
                    "message": "ValidatorSetBase.changeRequestCount (ValidatorSetAuRa.sol#365-367) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function changeRequestCount() external view returns(uint256);\n",
                    "message": "IValidatorSet.changeRequestCount (ValidatorSetAuRa.sol#61) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": 508,
                    "vulnerability_code": "    function validatorIndex(address _miningAddress) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(VALIDATOR_INDEX, _miningAddress))];\n",
                    "message": "ValidatorSetBase.validatorIndex (ValidatorSetAuRa.sol#506-508) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "IValidatorSet.validatorIndex (ValidatorSetAuRa.sol#75) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": 347,
                    "vulnerability_code": "    function banCounter(address _miningAddress) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(BAN_COUNTER, _miningAddress))];\n",
                    "message": "ValidatorSetBase.banCounter (ValidatorSetAuRa.sol#345-347) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 497,
                    "vulnerability_to_line": 499,
                    "vulnerability_code": "    function validatorCounter(address _miningAddress) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(VALIDATOR_COUNTER, _miningAddress))];\n",
                    "message": "ValidatorSetBase.validatorCounter (ValidatorSetAuRa.sol#497-499) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1019,
                    "vulnerability_to_line": 1026,
                    "vulnerability_code": "    function maliceReportedForBlock(\n\n        address _maliciousMiningAddress,\n\n        uint256 _blockNumber\n\n    ) public view returns(address[] memory) {\n\n        return addressArrayStorage[keccak256(abi.encode(\n\n            MALICE_REPORTED_FOR_BLOCK, _maliciousMiningAddress, _blockNumber\n\n        ))];\n",
                    "message": "ValidatorSetAuRa.maliceReportedForBlock (ValidatorSetAuRa.sol#1019-1026) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in ValidatorSetAuRa.sol:\n\t- pragma solidity0.5.9 (ValidatorSetAuRa.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRa.sol#17): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRa.sol#26): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRa.sol#46): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRa.sol#81): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRa.sol#112): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRa.sol#130): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRa.sol#169): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRa.sol#866): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRa.sol#876): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetAuRa.sol#898): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address) external;\n",
                    "message": "Parameter '' of IBlockReward.initialize (ValidatorSetAuRa.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function DELEGATORS_ALIQUOT() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IBlockReward.DELEGATORS_ALIQUOT' (ValidatorSetAuRa.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
                    "message": "Parameter '' of IStaking.clearUnremovableValidator (ValidatorSetAuRa.sol#30) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address) external;\n",
                    "message": "Parameter '' of IStaking.removePool (ValidatorSetAuRa.sol#32) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "Parameter '' of IStaking.poolDelegators (ValidatorSetAuRa.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (ValidatorSetAuRa.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (ValidatorSetAuRa.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (ValidatorSetAuRa.sol#40) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (ValidatorSetAuRa.sol#51) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (ValidatorSetAuRa.sol#52) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (ValidatorSetAuRa.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (ValidatorSetAuRa.sol#54) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (ValidatorSetAuRa.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (ValidatorSetAuRa.sol#56) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (ValidatorSetAuRa.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (ValidatorSetAuRa.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (ValidatorSetAuRa.sol#66) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (ValidatorSetAuRa.sol#67) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (ValidatorSetAuRa.sol#68) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (ValidatorSetAuRa.sol#69) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (ValidatorSetAuRa.sol#70) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (ValidatorSetAuRa.sol#72) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (ValidatorSetAuRa.sol#75) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (ValidatorSetAuRa.sol#89) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _blockRewardContract,\n",
                    "message": "Parameter '_blockRewardContract' of ValidatorSetBase.initialize (ValidatorSetAuRa.sol#294) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _randomContract,\n",
                    "message": "Parameter '_randomContract' of ValidatorSetBase.initialize (ValidatorSetAuRa.sol#295) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _stakingContract,\n",
                    "message": "Parameter '_stakingContract' of ValidatorSetBase.initialize (ValidatorSetAuRa.sol#296) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialMiningAddresses,\n",
                    "message": "Parameter '_initialMiningAddresses' of ValidatorSetBase.initialize (ValidatorSetAuRa.sol#297) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
                    "message": "Parameter '_initialStakingAddresses' of ValidatorSetBase.initialize (ValidatorSetAuRa.sol#298) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _firstValidatorIsUnremovable\n",
                    "message": "Parameter '_firstValidatorIsUnremovable' of ValidatorSetBase.initialize (ValidatorSetAuRa.sol#299) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address _miningAddress, address _stakingAddress) external onlyStakingContract {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.setStakingAddress (ValidatorSetAuRa.sol#337) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address _miningAddress, address _stakingAddress) external onlyStakingContract {\n",
                    "message": "Parameter '_stakingAddress' of ValidatorSetBase.setStakingAddress (ValidatorSetAuRa.sol#337) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.isReportValidatorValid (ValidatorSetAuRa.sol#428) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.isValidator (ValidatorSetAuRa.sol#447) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.isValidatorBanned (ValidatorSetAuRa.sol#461) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address _stakingAddress) public view returns(address) {\n",
                    "message": "Parameter '_stakingAddress' of ValidatorSetBase.miningByStakingAddress (ValidatorSetAuRa.sol#468) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address _miningAddress) public view returns(address) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.stakingByMiningAddress (ValidatorSetAuRa.sol#480) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address _miningAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.validatorIndex (ValidatorSetAuRa.sol#506) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function banCounter(address _miningAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.banCounter (ValidatorSetAuRa.sol#345) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bannedUntil(address _miningAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.bannedUntil (ValidatorSetAuRa.sol#354) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorOnPreviousEpoch(address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.isValidatorOnPreviousEpoch (ValidatorSetAuRa.sol#454) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 497,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCounter(address _miningAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.validatorCounter (ValidatorSetAuRa.sol#497) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": 569,
                    "vulnerability_code": "    function _applyQueueValidators(address[] memory _queueValidators) internal {\n\n        address[] memory prevValidators = getValidators();\n\n        uint256 i;\n\n\n\n        // Clear indexes for old validator set\n\n        for (i = 0; i < prevValidators.length; i++) {\n\n            _setValidatorIndex(prevValidators[i], 0);\n\n            _setIsValidator(prevValidators[i], false);\n\n        }\n\n\n\n        addressArrayStorage[CURRENT_VALIDATORS] = _queueValidators;\n\n\n\n        // Set indexes for new validator set\n\n        for (i = 0; i < _queueValidators.length; i++) {\n\n            _setValidatorIndex(_queueValidators[i], i);\n\n            _setIsValidator(_queueValidators[i], true);\n\n        }\n",
                    "message": "Function 'ValidatorSetBase._applyQueueValidators' (ValidatorSetAuRa.sol#552-569) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _applyQueueValidators(address[] memory _queueValidators) internal {\n",
                    "message": "Parameter '_queueValidators' of ValidatorSetBase._applyQueueValidators (ValidatorSetAuRa.sol#552) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": 581,
                    "vulnerability_code": "    function _banValidator(address _miningAddress) internal {\n\n        if (_banStart() > bannedUntil(_miningAddress)) {\n\n            uintStorage[keccak256(abi.encode(BAN_COUNTER, _miningAddress))]++;\n\n        }\n\n\n\n        uintStorage[keccak256(abi.encode(BANNED_UNTIL, _miningAddress))] = _banUntil();\n",
                    "message": "Function 'ValidatorSetBase._banValidator' (ValidatorSetAuRa.sol#575-581) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _banValidator(address _miningAddress) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase._banValidator (ValidatorSetAuRa.sol#575) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": 607,
                    "vulnerability_code": "    function _enqueuePendingValidators(bool _newStakingEpoch) internal {\n\n        int256 queueFirst = intStorage[QUEUE_PV_FIRST];\n\n        int256 queueLast = intStorage[QUEUE_PV_LAST];\n\n\n\n        for (int256 i = queueLast; i >= queueFirst; i--) {\n\n            if (uintStorage[keccak256(abi.encode(QUEUE_PV_BLOCK, i))] == _getCurrentBlockNumber()) {\n\n                addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, i))] = getPendingValidators();\n\n                if (_newStakingEpoch) {\n\n                    boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, i))] = true;\n\n                }\n\n                return;\n\n            }\n\n        }\n\n\n\n        queueLast++;\n\n        addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, queueLast))] = getPendingValidators();\n\n        boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, queueLast))] = _newStakingEpoch;\n\n        uintStorage[keccak256(abi.encode(QUEUE_PV_BLOCK, queueLast))] = _getCurrentBlockNumber();\n\n        intStorage[QUEUE_PV_LAST] = queueLast;\n",
                    "message": "Function 'ValidatorSetBase._enqueuePendingValidators' (ValidatorSetAuRa.sol#588-607) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _enqueuePendingValidators(bool _newStakingEpoch) internal {\n",
                    "message": "Parameter '_newStakingEpoch' of ValidatorSetBase._enqueuePendingValidators (ValidatorSetAuRa.sol#588) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 614,
                    "vulnerability_to_line": 629,
                    "vulnerability_code": "    function _dequeuePendingValidators() internal returns(address[] memory newSet, bool newStakingEpoch) {\n\n        int256 queueFirst = intStorage[QUEUE_PV_FIRST];\n\n        int256 queueLast = intStorage[QUEUE_PV_LAST];\n\n\n\n        if (queueLast < queueFirst) {\n\n            newSet = new address[](0);\n\n            newStakingEpoch = false;\n\n        } else {\n\n            newSet = addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, queueFirst))];\n\n            newStakingEpoch = boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, queueFirst))];\n\n            delete addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, queueFirst))];\n\n            delete boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, queueFirst))];\n\n            delete uintStorage[keccak256(abi.encode(QUEUE_PV_BLOCK, queueFirst))];\n\n            intStorage[QUEUE_PV_FIRST]++;\n\n        }\n",
                    "message": "Function 'ValidatorSetBase._dequeuePendingValidators' (ValidatorSetAuRa.sol#614-629) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 633,
                    "vulnerability_to_line": 635,
                    "vulnerability_code": "    function _incrementChangeRequestCount() internal {\n\n        uintStorage[CHANGE_REQUEST_COUNT]++;\n",
                    "message": "Function 'ValidatorSetBase._incrementChangeRequestCount' (ValidatorSetAuRa.sol#633-635) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 642,
                    "vulnerability_to_line": 687,
                    "vulnerability_code": "    function _newValidatorSet() internal returns(uint256) {\n\n        IStaking staking = IStaking(stakingContract());\n\n        address[] memory poolsToBeElected = staking.getPoolsToBeElected();\n\n        address unremovableStakingAddress = unremovableValidator();\n\n\n\n        // Choose new validators\n\n        if (\n\n            poolsToBeElected.length >= MAX_VALIDATORS &&\n\n            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n\n        ) {\n\n            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n\n\n\n            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n\n\n\n            if (likelihood.length > 0 && likelihoodSum > 0) {\n\n                address[] memory newValidators = new address[](\n\n                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n\n                );\n\n\n\n                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n\n                for (uint256 i = 0; i < newValidators.length; i++) {\n\n                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n\n                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n\n                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n\n                    likelihoodSum -= likelihood[randomPoolIndex];\n\n                    poolsToBeElectedLength--;\n\n                    poolsToBeElected[randomPoolIndex] = poolsToBeElected[poolsToBeElectedLength];\n\n                    likelihood[randomPoolIndex] = likelihood[poolsToBeElectedLength];\n\n                }\n\n\n\n                _setPendingValidators(staking, newValidators, unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            _setPendingValidators(staking, poolsToBeElected, unremovableStakingAddress);\n\n        }\n\n\n\n        // From this moment the `getPendingValidators()` will return a new validator set\n\n\n\n        staking.incrementStakingEpoch();\n\n        _setValidatorSetApplyBlock(0);\n\n\n\n        _incrementChangeRequestCount();\n\n        _enqueuePendingValidators(true);\n\n\n\n        return poolsToBeElected.length;\n",
                    "message": "Function 'ValidatorSetBase._newValidatorSet' (ValidatorSetAuRa.sol#642-687) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": 718,
                    "vulnerability_code": "    function _removeMaliciousValidator(address _miningAddress) internal returns(bool) {\n\n        address stakingAddress = stakingByMiningAddress(_miningAddress);\n\n\n\n        if (stakingAddress == unremovableValidator()) {\n\n            return false;\n\n        }\n\n\n\n        // Ban the malicious validator for the next 3 months\n\n        _banValidator(_miningAddress);\n\n\n\n        // Remove malicious validator from the `pools`\n\n        IStaking(stakingContract()).removePool(stakingAddress);\n\n\n\n        address[] storage miningAddresses = addressArrayStorage[PENDING_VALIDATORS];\n\n\n\n        for (uint256 i = 0; i < miningAddresses.length; i++) {\n\n            if (miningAddresses[i] == _miningAddress) {\n\n                // Remove the malicious validator from `pendingValidators`\n\n                miningAddresses[i] = miningAddresses[miningAddresses.length - 1];\n\n                miningAddresses.length--;\n\n                return true;\n\n            }\n\n        }\n\n\n\n        return false;\n",
                    "message": "Function 'ValidatorSetBase._removeMaliciousValidator' (ValidatorSetAuRa.sol#693-718) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeMaliciousValidator(address _miningAddress) internal returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase._removeMaliciousValidator (ValidatorSetAuRa.sol#693) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 724,
                    "vulnerability_to_line": 726,
                    "vulnerability_code": "    function _setInitiateChangeAllowed(bool _allowed) internal {\n\n        boolStorage[INITIATE_CHANGE_ALLOWED] = _allowed;\n",
                    "message": "Function 'ValidatorSetBase._setInitiateChangeAllowed' (ValidatorSetAuRa.sol#724-726) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 724,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setInitiateChangeAllowed(bool _allowed) internal {\n",
                    "message": "Parameter '_allowed' of ValidatorSetBase._setInitiateChangeAllowed (ValidatorSetAuRa.sol#724) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": 739,
                    "vulnerability_code": "    function _setIsValidator(address _miningAddress, bool _isValidator) internal {\n\n        boolStorage[keccak256(abi.encode(IS_VALIDATOR, _miningAddress))] = _isValidator;\n\n\n\n        if (_isValidator) {\n\n            uintStorage[keccak256(abi.encode(VALIDATOR_COUNTER, _miningAddress))]++;\n\n        }\n",
                    "message": "Function 'ValidatorSetBase._setIsValidator' (ValidatorSetAuRa.sol#733-739) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIsValidator(address _miningAddress, bool _isValidator) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase._setIsValidator (ValidatorSetAuRa.sol#733) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIsValidator(address _miningAddress, bool _isValidator) internal {\n",
                    "message": "Parameter '_isValidator' of ValidatorSetBase._setIsValidator (ValidatorSetAuRa.sol#733) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": 747,
                    "vulnerability_code": "    function _setIsValidatorOnPreviousEpoch(address _miningAddress, bool _isValidator) internal {\n\n        boolStorage[keccak256(abi.encode(IS_VALIDATOR_ON_PREVIOUS_EPOCH, _miningAddress))] = _isValidator;\n",
                    "message": "Function 'ValidatorSetBase._setIsValidatorOnPreviousEpoch' (ValidatorSetAuRa.sol#745-747) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIsValidatorOnPreviousEpoch(address _miningAddress, bool _isValidator) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase._setIsValidatorOnPreviousEpoch (ValidatorSetAuRa.sol#745) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIsValidatorOnPreviousEpoch(address _miningAddress, bool _isValidator) internal {\n",
                    "message": "Parameter '_isValidator' of ValidatorSetBase._setIsValidatorOnPreviousEpoch (ValidatorSetAuRa.sol#745) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 756,
                    "vulnerability_to_line": 779,
                    "vulnerability_code": "    function _setPendingValidators(\n\n        IStaking _stakingContract,\n\n        address[] memory _stakingAddresses,\n\n        address _unremovableStakingAddress\n\n    ) internal {\n\n        if (_stakingAddresses.length == 0) return;\n\n\n\n        uint256 i;\n\n\n\n        delete addressArrayStorage[PENDING_VALIDATORS];\n\n\n\n        if (_unremovableStakingAddress != address(0)) {\n\n            addressArrayStorage[PENDING_VALIDATORS].push(miningByStakingAddress(_unremovableStakingAddress));\n\n        }\n\n\n\n        for (i = 0; i < _stakingAddresses.length; i++) {\n\n            addressArrayStorage[PENDING_VALIDATORS].push(miningByStakingAddress(_stakingAddresses[i]));\n\n        }\n\n\n\n        address[] memory poolsToBeRemoved = _stakingContract.getPoolsToBeRemoved();\n\n        for (i = 0; i < poolsToBeRemoved.length; i++) {\n\n            _stakingContract.removePool(poolsToBeRemoved[i]);\n\n        }\n",
                    "message": "Function 'ValidatorSetBase._setPendingValidators' (ValidatorSetAuRa.sol#756-779) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IStaking _stakingContract,\n",
                    "message": "Parameter '_stakingContract' of ValidatorSetBase._setPendingValidators (ValidatorSetAuRa.sol#757) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 758,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _stakingAddresses,\n",
                    "message": "Parameter '_stakingAddresses' of ValidatorSetBase._setPendingValidators (ValidatorSetAuRa.sol#758) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 759,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _unremovableStakingAddress\n",
                    "message": "Parameter '_unremovableStakingAddress' of ValidatorSetBase._setPendingValidators (ValidatorSetAuRa.sol#759) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": 789,
                    "vulnerability_code": "    function _setQueueValidators(address[] memory _miningAddresses, bool _newStakingEpoch) internal {\n\n        addressArrayStorage[QUEUE_VALIDATORS] = _miningAddresses;\n\n        boolStorage[QUEUE_VALIDATORS_NEW_STAKING_EPOCH] = _newStakingEpoch;\n",
                    "message": "Function 'ValidatorSetBase._setQueueValidators' (ValidatorSetAuRa.sol#786-789) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setQueueValidators(address[] memory _miningAddresses, bool _newStakingEpoch) internal {\n",
                    "message": "Parameter '_miningAddresses' of ValidatorSetBase._setQueueValidators (ValidatorSetAuRa.sol#786) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setQueueValidators(address[] memory _miningAddresses, bool _newStakingEpoch) internal {\n",
                    "message": "Parameter '_newStakingEpoch' of ValidatorSetBase._setQueueValidators (ValidatorSetAuRa.sol#786) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": 805,
                    "vulnerability_code": "    function _setStakingAddress(address _miningAddress, address _stakingAddress) internal {\n\n        require(_miningAddress != address(0));\n\n        require(_stakingAddress != address(0));\n\n        require(_miningAddress != _stakingAddress);\n\n        require(miningByStakingAddress(_stakingAddress) == address(0));\n\n        require(miningByStakingAddress(_miningAddress) == address(0));\n\n        require(stakingByMiningAddress(_stakingAddress) == address(0));\n\n        require(stakingByMiningAddress(_miningAddress) == address(0));\n\n        addressStorage[keccak256(abi.encode(MINING_BY_STAKING_ADDRESS, _stakingAddress))] = _miningAddress;\n\n        addressStorage[keccak256(abi.encode(STAKING_BY_MINING_ADDRESS, _miningAddress))] = _stakingAddress;\n",
                    "message": "Function 'ValidatorSetBase._setStakingAddress' (ValidatorSetAuRa.sol#795-805) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakingAddress(address _miningAddress, address _stakingAddress) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase._setStakingAddress (ValidatorSetAuRa.sol#795) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakingAddress(address _miningAddress, address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of ValidatorSetBase._setStakingAddress (ValidatorSetAuRa.sol#795) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 810,
                    "vulnerability_to_line": 812,
                    "vulnerability_code": "    function _setUnremovableValidator(address _stakingAddress) internal {\n\n        addressStorage[UNREMOVABLE_STAKING_ADDRESS] = _stakingAddress;\n",
                    "message": "Function 'ValidatorSetBase._setUnremovableValidator' (ValidatorSetAuRa.sol#810-812) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 810,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setUnremovableValidator(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of ValidatorSetBase._setUnremovableValidator (ValidatorSetAuRa.sol#810) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 818,
                    "vulnerability_to_line": 820,
                    "vulnerability_code": "    function _setValidatorIndex(address _miningAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(VALIDATOR_INDEX, _miningAddress))] = _index;\n",
                    "message": "Function 'ValidatorSetBase._setValidatorIndex' (ValidatorSetAuRa.sol#818-820) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 818,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setValidatorIndex(address _miningAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase._setValidatorIndex (ValidatorSetAuRa.sol#818) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 818,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setValidatorIndex(address _miningAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of ValidatorSetBase._setValidatorIndex (ValidatorSetAuRa.sol#818) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 826,
                    "vulnerability_to_line": 828,
                    "vulnerability_code": "    function _setValidatorSetApplyBlock(uint256 _blockNumber) internal {\n\n        uintStorage[VALIDATOR_SET_APPLY_BLOCK] = _blockNumber;\n",
                    "message": "Function 'ValidatorSetBase._setValidatorSetApplyBlock' (ValidatorSetAuRa.sol#826-828) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 826,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setValidatorSetApplyBlock(uint256 _blockNumber) internal {\n",
                    "message": "Parameter '_blockNumber' of ValidatorSetBase._setValidatorSetApplyBlock (ValidatorSetAuRa.sol#826) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 832,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _banStart() internal view returns(uint256);\n",
                    "message": "Function 'ValidatorSetBase._banStart' (ValidatorSetAuRa.sol#832) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 836,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _banUntil() internal view returns(uint256);\n",
                    "message": "Function 'ValidatorSetBase._banUntil' (ValidatorSetAuRa.sol#836) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 839,
                    "vulnerability_to_line": 841,
                    "vulnerability_code": "    function _getCurrentBlockNumber() internal view returns(uint256) {\n\n        return block.number;\n",
                    "message": "Function 'ValidatorSetBase._getCurrentBlockNumber' (ValidatorSetAuRa.sol#839-841) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 848,
                    "vulnerability_to_line": 861,
                    "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n\n        internal\n\n        pure\n\n        returns(uint256)\n\n    {\n\n        int256 r = int256(_randomNumber % uint256(_likelihoodSum)) + 1;\n\n        uint256 index = 0;\n\n        while (true) {\n\n            r -= _likelihood[index];\n\n            if (r <= 0) break;\n\n            index++;\n\n        }\n\n        return index;\n",
                    "message": "Function 'ValidatorSetBase._getRandomIndex' (ValidatorSetAuRa.sol#848-861) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n",
                    "message": "Parameter '_likelihood' of ValidatorSetBase._getRandomIndex (ValidatorSetAuRa.sol#848) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n",
                    "message": "Parameter '_likelihoodSum' of ValidatorSetBase._getRandomIndex (ValidatorSetAuRa.sol#848) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n",
                    "message": "Parameter '_randomNumber' of ValidatorSetBase._getRandomIndex (ValidatorSetAuRa.sol#848) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 870,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeMaliciousValidator(address) external;\n",
                    "message": "Parameter '' of IValidatorSetAuRa.removeMaliciousValidator (ValidatorSetAuRa.sol#870) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 871,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '' of IValidatorSetAuRa.reportMaliciousCallable (ValidatorSetAuRa.sol#871) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 871,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '_scope_0' of IValidatorSetAuRa.reportMaliciousCallable (ValidatorSetAuRa.sol#871) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 871,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '_scope_1' of IValidatorSetAuRa.reportMaliciousCallable (ValidatorSetAuRa.sol#871) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 881,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IStakingAuRa.initialize (ValidatorSetAuRa.sol#881) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 882,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_0' of IStakingAuRa.initialize (ValidatorSetAuRa.sol#882) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 883,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_1' of IStakingAuRa.initialize (ValidatorSetAuRa.sol#883) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 884,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_2' of IStakingAuRa.initialize (ValidatorSetAuRa.sol#884) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 885,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_3' of IStakingAuRa.initialize (ValidatorSetAuRa.sol#885) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 886,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_4' of IStakingAuRa.initialize (ValidatorSetAuRa.sol#886) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 887,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_5' of IStakingAuRa.initialize (ValidatorSetAuRa.sol#887) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 888,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_6' of IStakingAuRa.initialize (ValidatorSetAuRa.sol#888) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 890,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingEpochStartBlock(uint256) external;\n",
                    "message": "Parameter '' of IStakingAuRa.setStakingEpochStartBlock (ValidatorSetAuRa.sol#890) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 950,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeMaliciousValidator(address _miningAddress) external onlyRandomContract {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetAuRa.removeMaliciousValidator (ValidatorSetAuRa.sol#950) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _reportingMiningAddress,\n",
                    "message": "Parameter '_reportingMiningAddress' of ValidatorSetAuRa.reportMaliciousCallable (ValidatorSetAuRa.sol#1057) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _maliciousMiningAddress,\n",
                    "message": "Parameter '_maliciousMiningAddress' of ValidatorSetAuRa.reportMaliciousCallable (ValidatorSetAuRa.sol#1058) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _blockNumber\n",
                    "message": "Parameter '_blockNumber' of ValidatorSetAuRa.reportMaliciousCallable (ValidatorSetAuRa.sol#1059) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1111,
                    "vulnerability_to_line": 1113,
                    "vulnerability_code": "    function _banStart() internal view returns(uint256) {\n\n        return _getCurrentBlockNumber();\n",
                    "message": "Function 'ValidatorSetAuRa._banStart' (ValidatorSetAuRa.sol#1111-1113) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1116,
                    "vulnerability_to_line": 1118,
                    "vulnerability_code": "    function _banUntil() internal view returns(uint256) {\n\n        return _banStart() + 1555200; // 90 days (for 5 seconds block)\n",
                    "message": "Function 'ValidatorSetAuRa._banUntil' (ValidatorSetAuRa.sol#1116-1118) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 961,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _maliciousMiningAddress,\n",
                    "message": "Parameter '_maliciousMiningAddress' of ValidatorSetAuRa.reportMalicious (ValidatorSetAuRa.sol#961) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _blockNumber,\n",
                    "message": "Parameter '_blockNumber' of ValidatorSetAuRa.reportMalicious (ValidatorSetAuRa.sol#962) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 963,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata\n",
                    "message": "Parameter '' of ValidatorSetAuRa.reportMalicious (ValidatorSetAuRa.sol#963) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1020,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _maliciousMiningAddress,\n",
                    "message": "Parameter '_maliciousMiningAddress' of ValidatorSetAuRa.maliceReportedForBlock (ValidatorSetAuRa.sol#1020) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1021,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _blockNumber\n",
                    "message": "Parameter '_blockNumber' of ValidatorSetAuRa.maliceReportedForBlock (ValidatorSetAuRa.sol#1021) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1032,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportingCounter(address _reportingMiningAddress, uint256 _stakingEpoch) public view returns(uint256) {\n",
                    "message": "Parameter '_reportingMiningAddress' of ValidatorSetAuRa.reportingCounter (ValidatorSetAuRa.sol#1032) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1032,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportingCounter(address _reportingMiningAddress, uint256 _stakingEpoch) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingEpoch' of ValidatorSetAuRa.reportingCounter (ValidatorSetAuRa.sol#1032) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1039,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportingCounterTotal(uint256 _stakingEpoch) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingEpoch' of ValidatorSetAuRa.reportingCounterTotal (ValidatorSetAuRa.sol#1039) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1124,
                    "vulnerability_to_line": 1136,
                    "vulnerability_code": "    function _clearReportingCounter(address _miningAddress) internal {\n\n        uint256 currentStakingEpoch = IStaking(stakingContract()).stakingEpoch();\n\n        uint256 total = reportingCounterTotal(currentStakingEpoch);\n\n        uint256 counter = reportingCounter(_miningAddress, currentStakingEpoch);\n\n\n\n        uintStorage[keccak256(abi.encode(REPORTING_COUNTER, _miningAddress, currentStakingEpoch))] = 0;\n\n\n\n        if (total >= counter) {\n\n            uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))] -= counter;\n\n        } else {\n\n            uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))] = 0;\n\n        }\n",
                    "message": "Function 'ValidatorSetAuRa._clearReportingCounter' (ValidatorSetAuRa.sol#1124-1136) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _clearReportingCounter(address _miningAddress) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetAuRa._clearReportingCounter (ValidatorSetAuRa.sol#1124) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": 1147,
                    "vulnerability_code": "    function _incrementReportingCounter(address _reportingMiningAddress) internal {\n\n        if (!isReportValidatorValid(_reportingMiningAddress)) return;\n\n        uint256 currentStakingEpoch = IStaking(stakingContract()).stakingEpoch();\n\n        uintStorage[keccak256(abi.encode(REPORTING_COUNTER, _reportingMiningAddress, currentStakingEpoch))]++;\n\n        uintStorage[keccak256(abi.encode(REPORTING_COUNTER_TOTAL, currentStakingEpoch))]++;\n",
                    "message": "Function 'ValidatorSetAuRa._incrementReportingCounter' (ValidatorSetAuRa.sol#1142-1147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _incrementReportingCounter(address _reportingMiningAddress) internal {\n",
                    "message": "Parameter '_reportingMiningAddress' of ValidatorSetAuRa._incrementReportingCounter (ValidatorSetAuRa.sol#1142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1153,
                    "vulnerability_to_line": 1165,
                    "vulnerability_code": "    function _removeMaliciousValidatorAuRa(address _miningAddress) internal {\n\n        if (isValidatorBanned(_miningAddress)) {\n\n            // The malicious validator is already banned\n\n            return;\n\n        }\n\n\n\n        if (_removeMaliciousValidator(_miningAddress)) {\n\n            // From this moment `getPendingValidators()` will return the new validator set\n\n            _incrementChangeRequestCount();\n\n            _enqueuePendingValidators(false);\n\n            _clearReportingCounter(_miningAddress);\n\n        }\n",
                    "message": "Function 'ValidatorSetAuRa._removeMaliciousValidatorAuRa' (ValidatorSetAuRa.sol#1153-1165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeMaliciousValidatorAuRa(address _miningAddress) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetAuRa._removeMaliciousValidatorAuRa (ValidatorSetAuRa.sol#1153) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (ValidatorSetAuRa.sol#93) is never used in ValidatorSetAuRa\nEternalStorage.bytesStorage (ValidatorSetAuRa.sol#95) is never used in ValidatorSetAuRa\nEternalStorage.bytes32Storage (ValidatorSetAuRa.sol#98) is never used in ValidatorSetAuRa\nEternalStorage.uintArrayStorage (ValidatorSetAuRa.sol#100) is never used in ValidatorSetAuRa\nEternalStorage.stringArrayStorage (ValidatorSetAuRa.sol#101) is never used in ValidatorSetAuRa\nEternalStorage.bytesArrayStorage (ValidatorSetAuRa.sol#103) is never used in ValidatorSetAuRa\nEternalStorage.boolArrayStorage (ValidatorSetAuRa.sol#104) is never used in ValidatorSetAuRa\nEternalStorage.intArrayStorage (ValidatorSetAuRa.sol#105) is never used in ValidatorSetAuRa\nEternalStorage.bytes32ArrayStorage (ValidatorSetAuRa.sol#106) is never used in ValidatorSetAuRa\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == 0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _setUnremovableValidator(address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 m = 0; m < reportedValidators.length; m++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 m = 0; m < reportedValidators.length; m++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 871,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 939,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external onlyBlockRewardContract returns(bool called, uint256 poolsToBeElectedLength) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) public view returns(bool callable, bool removeReportingValidator) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialMiningAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _firstValidatorIsUnremovable\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isInitialized()); // initialization can only be done once\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isInitialized()); // initialization can only be done once\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_blockRewardContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_blockRewardContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_blockRewardContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_randomContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_randomContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_randomContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_initialMiningAddresses.length > 0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_initialMiningAddresses.length > 0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_initialMiningAddresses.length == _initialStakingAddresses.length);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_initialMiningAddresses.length == _initialStakingAddresses.length);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_initialMiningAddresses.length == _initialStakingAddresses.length);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        addressStorage[BLOCK_REWARD_CONTRACT] = _blockRewardContract;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        addressStorage[RANDOM_CONTRACT] = _randomContract;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        addressStorage[STAKING_CONTRACT] = _stakingContract;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] storage currentValidators = addressArrayStorage[CURRENT_VALIDATORS];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] storage pendingValidators = addressArrayStorage[PENDING_VALIDATORS];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentValidators.push(_initialMiningAddresses[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentValidators.push(_initialMiningAddresses[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pendingValidators.push(_initialMiningAddresses[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pendingValidators.push(_initialMiningAddresses[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setValidatorIndex(_initialMiningAddresses[i], i);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setValidatorIndex(_initialMiningAddresses[i], i);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setValidatorIndex(_initialMiningAddresses[i], i);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setIsValidator(_initialMiningAddresses[i], true);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setIsValidator(_initialMiningAddresses[i], true);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setStakingAddress(_initialMiningAddresses[i], _initialStakingAddresses[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setStakingAddress(_initialMiningAddresses[i], _initialStakingAddresses[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setStakingAddress(_initialMiningAddresses[i], _initialStakingAddresses[i]);\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/InitializerAuRa.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _contracts,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _owner,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _miningAddresses,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _stakingAddresses,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _firstValidatorIsUnremovable,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _delegatorMinStake,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _candidateMinStake,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpochDuration,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpochStartBlock,\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_49"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in InitializerAuRa.sol:\n\t- pragma solidity0.5.9 (InitializerAuRa.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (InitializerAuRa.sol#17): it allows old versions\n\t- pragma solidity0.5.9 (InitializerAuRa.sol#52): it allows old versions\n\t- pragma solidity0.5.9 (InitializerAuRa.sol#74): it allows old versions\n\t- pragma solidity0.5.9 (InitializerAuRa.sol#86): it allows old versions\n\t- pragma solidity0.5.9 (InitializerAuRa.sol#95): it allows old versions\n\t- pragma solidity0.5.9 (InitializerAuRa.sol#104): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address) external;\n",
                    "message": "Parameter '' of IBlockReward.initialize (InitializerAuRa.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function DELEGATORS_ALIQUOT() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IBlockReward.DELEGATORS_ALIQUOT' (InitializerAuRa.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (InitializerAuRa.sol#22) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (InitializerAuRa.sol#23) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (InitializerAuRa.sol#24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (InitializerAuRa.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (InitializerAuRa.sol#26) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (InitializerAuRa.sol#27) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (InitializerAuRa.sol#30) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (InitializerAuRa.sol#30) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (InitializerAuRa.sol#37) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (InitializerAuRa.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (InitializerAuRa.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (InitializerAuRa.sol#40) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (InitializerAuRa.sol#41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (InitializerAuRa.sol#43) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (InitializerAuRa.sol#46) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IStakingAuRa.initialize (InitializerAuRa.sol#57) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_0' of IStakingAuRa.initialize (InitializerAuRa.sol#58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_1' of IStakingAuRa.initialize (InitializerAuRa.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_2' of IStakingAuRa.initialize (InitializerAuRa.sol#60) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_3' of IStakingAuRa.initialize (InitializerAuRa.sol#61) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_4' of IStakingAuRa.initialize (InitializerAuRa.sol#62) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_5' of IStakingAuRa.initialize (InitializerAuRa.sol#63) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_6' of IStakingAuRa.initialize (InitializerAuRa.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingEpochStartBlock(uint256) external;\n",
                    "message": "Parameter '' of IStakingAuRa.setStakingEpochStartBlock (InitializerAuRa.sol#66) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(uint256, address) external;\n",
                    "message": "Parameter '' of IRandomAuRa.initialize (InitializerAuRa.sol#78) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(uint256, address) external;\n",
                    "message": "Parameter '_scope_0' of IRandomAuRa.initialize (InitializerAuRa.sol#78) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHashCallable(address, bytes32) external view returns(bool);\n",
                    "message": "Parameter '' of IRandomAuRa.commitHashCallable (InitializerAuRa.sol#80) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHashCallable(address, bytes32) external view returns(bool);\n",
                    "message": "Parameter '_scope_0' of IRandomAuRa.commitHashCallable (InitializerAuRa.sol#80) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSecretCallable(address, uint256) external view returns(bool);\n",
                    "message": "Parameter '' of IRandomAuRa.revealSecretCallable (InitializerAuRa.sol#81) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSecretCallable(address, uint256) external view returns(bool);\n",
                    "message": "Parameter '_scope_0' of IRandomAuRa.revealSecretCallable (InitializerAuRa.sol#81) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address[] calldata, address) external;\n",
                    "message": "Parameter '' of ITxPermission.initialize (InitializerAuRa.sol#90) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address[] calldata, address) external;\n",
                    "message": "Parameter '_scope_0' of ITxPermission.initialize (InitializerAuRa.sol#90) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address[] calldata, address) external;\n",
                    "message": "Parameter '' of ICertifier.initialize (InitializerAuRa.sol#99) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address[] calldata, address) external;\n",
                    "message": "Parameter '_scope_0' of ICertifier.initialize (InitializerAuRa.sol#99) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _contracts,\n",
                    "message": "Parameter '_contracts' of InitializerAuRa. (InitializerAuRa.sol#143) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _owner,\n",
                    "message": "Parameter '_owner' of InitializerAuRa. (InitializerAuRa.sol#144) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _miningAddresses,\n",
                    "message": "Parameter '_miningAddresses' of InitializerAuRa. (InitializerAuRa.sol#145) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _stakingAddresses,\n",
                    "message": "Parameter '_stakingAddresses' of InitializerAuRa. (InitializerAuRa.sol#146) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _firstValidatorIsUnremovable,\n",
                    "message": "Parameter '_firstValidatorIsUnremovable' of InitializerAuRa. (InitializerAuRa.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _delegatorMinStake,\n",
                    "message": "Parameter '_delegatorMinStake' of InitializerAuRa. (InitializerAuRa.sol#148) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _candidateMinStake,\n",
                    "message": "Parameter '_candidateMinStake' of InitializerAuRa. (InitializerAuRa.sol#149) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpochDuration,\n",
                    "message": "Parameter '_stakingEpochDuration' of InitializerAuRa. (InitializerAuRa.sol#150) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpochStartBlock,\n",
                    "message": "Parameter '_stakingEpochStartBlock' of InitializerAuRa. (InitializerAuRa.sol#151) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakeWithdrawDisallowPeriod,\n",
                    "message": "Parameter '_stakeWithdrawDisallowPeriod' of InitializerAuRa. (InitializerAuRa.sol#152) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _collectRoundLength,\n",
                    "message": "Parameter '_collectRoundLength' of InitializerAuRa. (InitializerAuRa.sol#153) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _erc20Restricted\n",
                    "message": "Parameter '_erc20Restricted' of InitializerAuRa. (InitializerAuRa.sol#154) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/BlockRewardHBBFT.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = extraLength; i < receivers.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = from; i < to; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 641,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (validatorStake != 0 && totalStaked != 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 642,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (validatorHasMore30Per) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 643,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    rewardPercent = REWARD_PERCENT_MULTIPLIER * validatorStake / totalStaked;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    rewardPercent = REWARD_PERCENT_MULTIPLIER * 3 / 10;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < extraLength; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = extraLength; i < receivers.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            j++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 582,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uintStorage[QUEUE_ER_FIRST]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = from; i < to; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_88"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner (BlockRewardHBBFT.sol#80) is never initialized. It is used in:\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => uint256[]) internal uintArrayStorage;\n",
                    "message": "EternalStorage.uintArrayStorage (BlockRewardHBBFT.sol#91) is never initialized. It is used in:\n\t- snapshotRewardPercents (BlockRewardHBBFT.sol#441-445)\n\t- _setSnapshot (BlockRewardHBBFT.sol#621-682)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": 279,
                    "vulnerability_code": "    function migrateMintingStatistics(address _bridge, IBlockReward _prevBlockRewardContract) external onlyOwner {\n\n        require(mintedTotally() == 0);\n\n        uint256 prevMinted = _prevBlockRewardContract.mintedTotally();\n\n        uint256 prevMintedByBridge = _prevBlockRewardContract.mintedTotallyByBridge(_bridge);\n\n        require(prevMinted != 0);\n\n        require(prevMintedByBridge != 0);\n\n        uintStorage[MINTED_TOTALLY] = prevMinted;\n\n        uintStorage[keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))] = prevMintedByBridge;\n",
                    "message": "Reentrancy in BlockRewardBase.migrateMintingStatistics (BlockRewardHBBFT.sol#271-279):\n\tExternal calls:\n\t- prevMinted = _prevBlockRewardContract.mintedTotally() (BlockRewardHBBFT.sol#273)\n\t- prevMintedByBridge = _prevBlockRewardContract.mintedTotallyByBridge(_bridge) (BlockRewardHBBFT.sol#274)\n\tState variables written after the call(s):\n\t- uintStorage (BlockRewardHBBFT.sol#277)\n\t- uintStorage (BlockRewardHBBFT.sol#278)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": 682,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n\n        uint256 validatorStake = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, _stakingAddress);\n\n        uint256 totalStaked = _stakingContract.stakeAmountTotalMinusOrderedWithdraw(_stakingAddress);\n\n        uint256 delegatorsAmount = totalStaked >= validatorStake ? totalStaked - validatorStake : 0;\n\n        bool validatorHasMore30Per = validatorStake * 7 > delegatorsAmount * 3;\n\n\n\n        address[] memory delegators = _stakingContract.poolDelegators(_stakingAddress);\n\n        uint256 rewardPercent;\n\n\n\n        address[] storage stakers = addressArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_STAKERS, _stakingAddress\n\n        ))];\n\n\n\n        uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_REWARD_PERCENTS, _stakingAddress\n\n        ))];\n\n\n\n        if (_offset == 0) {\n\n            // Calculate reward percent for validator\n\n            rewardPercent = 0;\n\n            if (validatorStake != 0 && totalStaked != 0) {\n\n                if (validatorHasMore30Per) {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * validatorStake / totalStaked;\n\n                } else {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * 3 / 10;\n\n                }\n\n            }\n\n            stakers.push(_stakingAddress);\n\n            rewardPercents.push(rewardPercent);\n\n            addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES].push(_stakingAddress);\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] += totalStaked;\n\n        }\n\n\n\n        uint256 from = _offset * delegators.length / DELEGATORS_ALIQUOT;\n\n        uint256 to = (_offset + 1) * delegators.length / DELEGATORS_ALIQUOT;\n\n\n\n        if (_offset == 0) {\n\n            to += delegators.length % DELEGATORS_ALIQUOT;\n\n        } else {\n\n            from += delegators.length % DELEGATORS_ALIQUOT;\n\n        }\n\n\n\n        // Calculate reward percent for each delegator\n\n        for (uint256 i = from; i < to; i++) {\n\n            rewardPercent = 0;\n\n\n\n            if (validatorHasMore30Per) {\n\n                if (totalStaked != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent / totalStaked;\n\n                }\n\n            } else {\n\n                if (delegatorsAmount != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent * 7 / (delegatorsAmount * 10);\n\n                }\n\n            }\n\n\n\n            stakers.push(delegators[i]);\n\n            rewardPercents.push(rewardPercent);\n\n        }\n",
                    "message": "Reentrancy in BlockRewardBase._setSnapshot (BlockRewardHBBFT.sol#621-682):\n\tExternal calls:\n\t- validatorStake = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress,_stakingAddress) (BlockRewardHBBFT.sol#622)\n\t- totalStaked = _stakingContract.stakeAmountTotalMinusOrderedWithdraw(_stakingAddress) (BlockRewardHBBFT.sol#623)\n\t- delegators = _stakingContract.poolDelegators(_stakingAddress) (BlockRewardHBBFT.sol#627)\n\tState variables written after the call(s):\n\t- addressArrayStorage (BlockRewardHBBFT.sol#650)\n\t- uintStorage (BlockRewardHBBFT.sol#651)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (BlockRewardHBBFT.sol#80)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 379,
                    "vulnerability_code": "    function isRewarding() public view returns(bool) {\n\n        return boolStorage[IS_REWARDING];\n",
                    "message": "BlockRewardBase.isRewarding (BlockRewardHBBFT.sol#377-379) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isRewarding() external view returns(bool);\n",
                    "message": "IBlockReward.isRewarding (BlockRewardHBBFT.sol#9) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": 385,
                    "vulnerability_code": "    function isSnapshotting() public view returns(bool) {\n\n        return boolStorage[IS_SNAPSHOTTING];\n",
                    "message": "BlockRewardBase.isSnapshotting (BlockRewardHBBFT.sol#383-385) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isSnapshotting() external view returns(bool);\n",
                    "message": "IBlockReward.isSnapshotting (BlockRewardHBBFT.sol#10) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": 420,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))];\n",
                    "message": "BlockRewardBase.mintedTotallyByBridge (BlockRewardHBBFT.sol#418-420) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) external view returns(uint256);\n",
                    "message": "IBlockReward.mintedTotallyByBridge (BlockRewardHBBFT.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": 341,
                    "vulnerability_code": "    function blockRewardContractId() public pure returns(bytes4) {\n\n        return BLOCK_REWARD_CONTRACT_ID;\n",
                    "message": "BlockRewardBase.blockRewardContractId (BlockRewardHBBFT.sol#339-341) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": 346,
                    "vulnerability_code": "    function ercToErcBridgesAllowed() public view returns(address[] memory) {\n\n        return addressArrayStorage[ERC_TO_ERC_BRIDGES_ALLOWED];\n",
                    "message": "BlockRewardBase.ercToErcBridgesAllowed (BlockRewardHBBFT.sol#344-346) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": 351,
                    "vulnerability_code": "    function ercToNativeBridgesAllowed() public view returns(address[] memory) {\n\n        return addressArrayStorage[ERC_TO_NATIVE_BRIDGES_ALLOWED];\n",
                    "message": "BlockRewardBase.ercToNativeBridgesAllowed (BlockRewardHBBFT.sol#349-351) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": 362,
                    "vulnerability_code": "    function getBridgeNativeFee() public view returns(uint256) {\n\n        return uintStorage[BRIDGE_NATIVE_FEE];\n",
                    "message": "BlockRewardBase.getBridgeNativeFee (BlockRewardHBBFT.sol#360-362) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": 368,
                    "vulnerability_code": "    function getBridgeTokenFee() public view returns(uint256) {\n\n        return uintStorage[BRIDGE_TOKEN_FEE];\n",
                    "message": "BlockRewardBase.getBridgeTokenFee (BlockRewardHBBFT.sol#366-368) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": 392,
                    "vulnerability_code": "    function mintedForAccount(address _account) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(MINTED_FOR_ACCOUNT, _account))];\n",
                    "message": "BlockRewardBase.mintedForAccount (BlockRewardHBBFT.sol#390-392) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": 406,
                    "vulnerability_code": "    function mintedForAccountInBlock(address _account, uint256 _blockNumber)\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        return uintStorage[\n\n            keccak256(abi.encode(MINTED_FOR_ACCOUNT_IN_BLOCK, _account, _blockNumber))\n\n        ];\n",
                    "message": "BlockRewardBase.mintedForAccountInBlock (BlockRewardHBBFT.sol#398-406) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": 413,
                    "vulnerability_code": "    function mintedInBlock(uint256 _blockNumber) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(MINTED_IN_BLOCK, _blockNumber))];\n",
                    "message": "BlockRewardBase.mintedInBlock (BlockRewardHBBFT.sol#411-413) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": 432,
                    "vulnerability_code": "    function nativeToErcBridgesAllowed() public view returns(address[] memory) {\n\n        return addressArrayStorage[NATIVE_TO_ERC_BRIDGES_ALLOWED];\n",
                    "message": "BlockRewardBase.nativeToErcBridgesAllowed (BlockRewardHBBFT.sol#430-432) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": 445,
                    "vulnerability_code": "    function snapshotRewardPercents(address _validatorStakingAddress) public view returns(uint256[] memory) {\n\n        return uintArrayStorage[\n\n            keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, _validatorStakingAddress))\n\n        ];\n",
                    "message": "BlockRewardBase.snapshotRewardPercents (BlockRewardHBBFT.sol#441-445) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": 456,
                    "vulnerability_code": "    function snapshotStakers(address _validatorStakingAddress) public view returns(address[] memory) {\n\n        return addressArrayStorage[\n\n            keccak256(abi.encode(SNAPSHOT_STAKERS, _validatorStakingAddress))\n\n        ];\n",
                    "message": "BlockRewardBase.snapshotStakers (BlockRewardHBBFT.sol#452-456) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 463,
                    "vulnerability_code": "    function snapshotStakingAddresses() public view returns(address[] memory) {\n\n        return addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n",
                    "message": "BlockRewardBase.snapshotStakingAddresses (BlockRewardHBBFT.sol#461-463) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": 470,
                    "vulnerability_code": "    function snapshotTotalStakeAmount() public view returns(uint256) {\n\n        return uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT];\n",
                    "message": "BlockRewardBase.snapshotTotalStakeAmount (BlockRewardHBBFT.sol#468-470) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 473,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function validatorSetContract() public view returns(IValidatorSet) {\n\n        return IValidatorSet(addressStorage[VALIDATOR_SET_CONTRACT]);\n",
                    "message": "BlockRewardBase.validatorSetContract (BlockRewardHBBFT.sol#473-475) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in BlockRewardHBBFT.sol:\n\t- pragma solidity0.5.9 (BlockRewardHBBFT.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardHBBFT.sol#17): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardHBBFT.sol#52): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardHBBFT.sol#72): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardHBBFT.sol#103): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardHBBFT.sol#121): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardHBBFT.sol#160): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardHBBFT.sol#687): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardHBBFT.sol#704): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address) external;\n",
                    "message": "Parameter '' of IBlockReward.initialize (BlockRewardHBBFT.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function DELEGATORS_ALIQUOT() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IBlockReward.DELEGATORS_ALIQUOT' (BlockRewardHBBFT.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (BlockRewardHBBFT.sol#22) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (BlockRewardHBBFT.sol#23) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (BlockRewardHBBFT.sol#24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (BlockRewardHBBFT.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (BlockRewardHBBFT.sol#26) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (BlockRewardHBBFT.sol#27) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (BlockRewardHBBFT.sol#30) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (BlockRewardHBBFT.sol#30) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (BlockRewardHBBFT.sol#37) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (BlockRewardHBBFT.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (BlockRewardHBBFT.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (BlockRewardHBBFT.sol#40) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (BlockRewardHBBFT.sol#41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (BlockRewardHBBFT.sol#43) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (BlockRewardHBBFT.sol#46) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
                    "message": "Parameter '' of IStaking.clearUnremovableValidator (BlockRewardHBBFT.sol#56) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address) external;\n",
                    "message": "Parameter '' of IStaking.removePool (BlockRewardHBBFT.sol#58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "Parameter '' of IStaking.poolDelegators (BlockRewardHBBFT.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (BlockRewardHBBFT.sol#65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (BlockRewardHBBFT.sol#65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (BlockRewardHBBFT.sol#66) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (BlockRewardHBBFT.sol#80) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address _validatorSet) external {\n",
                    "message": "Parameter '_validatorSet' of BlockRewardBase.initialize (BlockRewardHBBFT.sol#260) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256) {\n",
                    "message": "Parameter '_bridge' of BlockRewardBase.mintedTotallyByBridge (BlockRewardHBBFT.sol#418) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addBridgeNativeFeeReceivers(uint256 _amount) external onlyErcToNativeBridge {\n",
                    "message": "Parameter '_amount' of BlockRewardBase.addBridgeNativeFeeReceivers (BlockRewardHBBFT.sol#231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addBridgeTokenFeeReceivers(uint256 _amount) external onlyXToErcBridge {\n",
                    "message": "Parameter '_amount' of BlockRewardBase.addBridgeTokenFeeReceivers (BlockRewardHBBFT.sol#240) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExtraReceiver(uint256 _amount, address _receiver) external onlyErcToNativeBridge {\n",
                    "message": "Parameter '_amount' of BlockRewardBase.addExtraReceiver (BlockRewardHBBFT.sol#249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExtraReceiver(uint256 _amount, address _receiver) external onlyErcToNativeBridge {\n",
                    "message": "Parameter '_receiver' of BlockRewardBase.addExtraReceiver (BlockRewardHBBFT.sol#249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function migrateMintingStatistics(address _bridge, IBlockReward _prevBlockRewardContract) external onlyOwner {\n",
                    "message": "Parameter '_bridge' of BlockRewardBase.migrateMintingStatistics (BlockRewardHBBFT.sol#271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function migrateMintingStatistics(address _bridge, IBlockReward _prevBlockRewardContract) external onlyOwner {\n",
                    "message": "Parameter '_prevBlockRewardContract' of BlockRewardBase.migrateMintingStatistics (BlockRewardHBBFT.sol#271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErcToNativeBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_bridgesAllowed' of BlockRewardBase.setErcToNativeBridgesAllowed (BlockRewardHBBFT.sol#284) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setNativeToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_bridgesAllowed' of BlockRewardBase.setNativeToErcBridgesAllowed (BlockRewardHBBFT.sol#302) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErcToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_bridgesAllowed' of BlockRewardBase.setErcToErcBridgesAllowed (BlockRewardHBBFT.sol#320) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedForAccount(address _account) public view returns(uint256) {\n",
                    "message": "Parameter '_account' of BlockRewardBase.mintedForAccount (BlockRewardHBBFT.sol#390) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedForAccountInBlock(address _account, uint256 _blockNumber)\n",
                    "message": "Parameter '_account' of BlockRewardBase.mintedForAccountInBlock (BlockRewardHBBFT.sol#398) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedForAccountInBlock(address _account, uint256 _blockNumber)\n",
                    "message": "Parameter '_blockNumber' of BlockRewardBase.mintedForAccountInBlock (BlockRewardHBBFT.sol#398) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedInBlock(uint256 _blockNumber) public view returns(uint256) {\n",
                    "message": "Parameter '_blockNumber' of BlockRewardBase.mintedInBlock (BlockRewardHBBFT.sol#411) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function snapshotRewardPercents(address _validatorStakingAddress) public view returns(uint256[] memory) {\n",
                    "message": "Parameter '_validatorStakingAddress' of BlockRewardBase.snapshotRewardPercents (BlockRewardHBBFT.sol#441) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function snapshotStakers(address _validatorStakingAddress) public view returns(address[] memory) {\n",
                    "message": "Parameter '_validatorStakingAddress' of BlockRewardBase.snapshotStakers (BlockRewardHBBFT.sol#452) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": 557,
                    "vulnerability_code": "    function _mintNativeCoins(\n\n        address[] memory _receivers,\n\n        uint256[] memory _rewards,\n\n        uint256 _queueLimit\n\n    )\n\n        internal\n\n        returns(address[] memory receivers, uint256[] memory rewards)\n\n    {\n\n        uint256 extraLength = extraReceiversQueueSize();\n\n\n\n        if (extraLength > _queueLimit) {\n\n            extraLength = _queueLimit;\n\n        }\n\n\n\n        receivers = new address[](extraLength + _receivers.length);\n\n        rewards = new uint256[](receivers.length);\n\n\n\n        uint256 i;\n\n        uint256 j = 0;\n\n\n\n        for (i = 0; i < extraLength; i++) {\n\n            (uint256 amount, address receiver, address bridge) = _dequeueExtraReceiver();\n\n            receivers[i] = receiver;\n\n            rewards[i] = amount;\n\n            _setMinted(amount, receiver, bridge);\n\n        }\n\n\n\n        for (i = extraLength; i < receivers.length; i++) {\n\n            receivers[i] = _receivers[j];\n\n            rewards[i] = _rewards[j];\n\n            j++;\n\n        }\n\n\n\n        emit MintedNative(receivers, rewards);\n\n\n\n        return (receivers, rewards);\n",
                    "message": "Function 'BlockRewardBase._mintNativeCoins' (BlockRewardHBBFT.sol#521-557) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _receivers,\n",
                    "message": "Parameter '_receivers' of BlockRewardBase._mintNativeCoins (BlockRewardHBBFT.sol#522) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] memory _rewards,\n",
                    "message": "Parameter '_rewards' of BlockRewardBase._mintNativeCoins (BlockRewardHBBFT.sol#523) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _queueLimit\n",
                    "message": "Parameter '_queueLimit' of BlockRewardBase._mintNativeCoins (BlockRewardHBBFT.sol#524) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": 584,
                    "vulnerability_code": "    function _dequeueExtraReceiver() internal returns(uint256 amount, address receiver, address bridge) {\n\n        uint256 queueFirst = uintStorage[QUEUE_ER_FIRST];\n\n        uint256 queueLast = uintStorage[QUEUE_ER_LAST];\n\n\n\n        if (queueLast < queueFirst) {\n\n            amount = 0;\n\n            receiver = address(0);\n\n            bridge = address(0);\n\n        } else {\n\n            bytes32 amountHash = keccak256(abi.encode(QUEUE_ER_AMOUNT, queueFirst));\n\n            bytes32 receiverHash = keccak256(abi.encode(QUEUE_ER_RECEIVER, queueFirst));\n\n            bytes32 bridgeHash = keccak256(abi.encode(QUEUE_ER_BRIDGE, queueFirst));\n\n            amount = uintStorage[amountHash];\n\n            receiver = addressStorage[receiverHash];\n\n            bridge = addressStorage[bridgeHash];\n\n            delete uintStorage[amountHash];\n\n            delete addressStorage[receiverHash];\n\n            delete addressStorage[bridgeHash];\n\n            uintStorage[QUEUE_ER_FIRST]++;\n\n        }\n",
                    "message": "Function 'BlockRewardBase._dequeueExtraReceiver' (BlockRewardHBBFT.sol#564-584) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": 597,
                    "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n\n        uint256 queueLast = uintStorage[QUEUE_ER_LAST] + 1;\n\n        uintStorage[keccak256(abi.encode(QUEUE_ER_AMOUNT, queueLast))] = _amount;\n\n        addressStorage[keccak256(abi.encode(QUEUE_ER_RECEIVER, queueLast))] = _receiver;\n\n        addressStorage[keccak256(abi.encode(QUEUE_ER_BRIDGE, queueLast))] = _bridge;\n\n        uintStorage[QUEUE_ER_LAST] = queueLast;\n",
                    "message": "Function 'BlockRewardBase._enqueueExtraReceiver' (BlockRewardHBBFT.sol#591-597) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n",
                    "message": "Parameter '_amount' of BlockRewardBase._enqueueExtraReceiver (BlockRewardHBBFT.sol#591) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n",
                    "message": "Parameter '_receiver' of BlockRewardBase._enqueueExtraReceiver (BlockRewardHBBFT.sol#591) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n",
                    "message": "Parameter '_bridge' of BlockRewardBase._enqueueExtraReceiver (BlockRewardHBBFT.sol#591) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": 610,
                    "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n\n        uintStorage[keccak256(abi.encode(MINTED_FOR_ACCOUNT_IN_BLOCK, _account, block.number))] = _amount;\n\n        uintStorage[keccak256(abi.encode(MINTED_FOR_ACCOUNT, _account))] += _amount;\n\n        uintStorage[keccak256(abi.encode(MINTED_IN_BLOCK, block.number))] += _amount;\n\n        uintStorage[keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))] += _amount;\n\n        uintStorage[MINTED_TOTALLY] += _amount;\n",
                    "message": "Function 'BlockRewardBase._setMinted' (BlockRewardHBBFT.sol#604-610) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n",
                    "message": "Parameter '_amount' of BlockRewardBase._setMinted (BlockRewardHBBFT.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n",
                    "message": "Parameter '_account' of BlockRewardBase._setMinted (BlockRewardHBBFT.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n",
                    "message": "Parameter '_bridge' of BlockRewardBase._setMinted (BlockRewardHBBFT.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": 682,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n\n        uint256 validatorStake = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, _stakingAddress);\n\n        uint256 totalStaked = _stakingContract.stakeAmountTotalMinusOrderedWithdraw(_stakingAddress);\n\n        uint256 delegatorsAmount = totalStaked >= validatorStake ? totalStaked - validatorStake : 0;\n\n        bool validatorHasMore30Per = validatorStake * 7 > delegatorsAmount * 3;\n\n\n\n        address[] memory delegators = _stakingContract.poolDelegators(_stakingAddress);\n\n        uint256 rewardPercent;\n\n\n\n        address[] storage stakers = addressArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_STAKERS, _stakingAddress\n\n        ))];\n\n\n\n        uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_REWARD_PERCENTS, _stakingAddress\n\n        ))];\n\n\n\n        if (_offset == 0) {\n\n            // Calculate reward percent for validator\n\n            rewardPercent = 0;\n\n            if (validatorStake != 0 && totalStaked != 0) {\n\n                if (validatorHasMore30Per) {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * validatorStake / totalStaked;\n\n                } else {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * 3 / 10;\n\n                }\n\n            }\n\n            stakers.push(_stakingAddress);\n\n            rewardPercents.push(rewardPercent);\n\n            addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES].push(_stakingAddress);\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] += totalStaked;\n\n        }\n\n\n\n        uint256 from = _offset * delegators.length / DELEGATORS_ALIQUOT;\n\n        uint256 to = (_offset + 1) * delegators.length / DELEGATORS_ALIQUOT;\n\n\n\n        if (_offset == 0) {\n\n            to += delegators.length % DELEGATORS_ALIQUOT;\n\n        } else {\n\n            from += delegators.length % DELEGATORS_ALIQUOT;\n\n        }\n\n\n\n        // Calculate reward percent for each delegator\n\n        for (uint256 i = from; i < to; i++) {\n\n            rewardPercent = 0;\n\n\n\n            if (validatorHasMore30Per) {\n\n                if (totalStaked != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent / totalStaked;\n\n                }\n\n            } else {\n\n                if (delegatorsAmount != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent * 7 / (delegatorsAmount * 10);\n\n                }\n\n            }\n\n\n\n            stakers.push(delegators[i]);\n\n            rewardPercents.push(rewardPercent);\n\n        }\n",
                    "message": "Function 'BlockRewardBase._setSnapshot' (BlockRewardHBBFT.sol#621-682) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n",
                    "message": "Parameter '_stakingAddress' of BlockRewardBase._setSnapshot (BlockRewardHBBFT.sol#621) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n",
                    "message": "Parameter '_stakingContract' of BlockRewardBase._setSnapshot (BlockRewardHBBFT.sol#621) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n",
                    "message": "Parameter '_offset' of BlockRewardBase._setSnapshot (BlockRewardHBBFT.sol#621) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 699,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IERC20Minting.balanceOf (BlockRewardHBBFT.sol#699) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 721,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reward(address[] calldata, uint16[] calldata)\n",
                    "message": "Parameter '' of BlockRewardHBBFT.reward (BlockRewardHBBFT.sol#721) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 721,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reward(address[] calldata, uint16[] calldata)\n",
                    "message": "Parameter '_scope_0' of BlockRewardHBBFT.reward (BlockRewardHBBFT.sol#721) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (BlockRewardHBBFT.sol#84) is never used in BlockRewardHBBFT\nEternalStorage.bytesStorage (BlockRewardHBBFT.sol#86) is never used in BlockRewardHBBFT\nEternalStorage.intStorage (BlockRewardHBBFT.sol#88) is never used in BlockRewardHBBFT\nEternalStorage.bytes32Storage (BlockRewardHBBFT.sol#89) is never used in BlockRewardHBBFT\nEternalStorage.stringArrayStorage (BlockRewardHBBFT.sol#92) is never used in BlockRewardHBBFT\nEternalStorage.bytesArrayStorage (BlockRewardHBBFT.sol#94) is never used in BlockRewardHBBFT\nEternalStorage.boolArrayStorage (BlockRewardHBBFT.sol#95) is never used in BlockRewardHBBFT\nEternalStorage.intArrayStorage (BlockRewardHBBFT.sol#96) is never used in BlockRewardHBBFT\nEternalStorage.bytes32ArrayStorage (BlockRewardHBBFT.sol#97) is never used in BlockRewardHBBFT\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == 0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 570,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            receiver = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bridge = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = extraLength; i < receivers.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErcToNativeBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setNativeToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErcToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns(address[] memory receivers, uint256[] memory rewards)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _dequeueExtraReceiver() internal returns(uint256 amount, address receiver, address bridge) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 724,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address[] memory, uint256[] memory)\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/Migrations.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": 20,
                    "vulnerability_code": "    function setCompleted(uint completed) public restricted {\n\n        last_completed_migration = completed;\n",
                    "message": "Migrations.setCompleted (Migrations.sol#18-20) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 25,
                    "vulnerability_code": "    function upgrade(address new_address) public restricted { // solhint-disable-line\n\n        Migrations upgraded = Migrations(new_address);\n\n        upgraded.setCompleted(last_completed_migration);\n",
                    "message": "Migrations.upgrade (Migrations.sol#22-25) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in Migrations.sol:\n\t- pragma solidity0.5.9 (Migrations.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgrade(address new_address) public restricted { // solhint-disable-line\n",
                    "message": "Parameter 'new_address' of Migrations.upgrade (Migrations.sol#22) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint public last_completed_migration; // solhint-disable-line\n",
                    "message": "Variable 'Migrations.last_completed_migration' (Migrations.sol#8) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/BlockRewardAuRa.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = extraLength; i < receivers.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 819,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1009,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1020,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1043,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = from; i < to; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 819,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < DELEGATORS_ALIQUOT; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 641,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (validatorStake != 0 && totalStaked != 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 642,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (validatorHasMore30Per) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 643,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    rewardPercent = REWARD_PERCENT_MULTIPLIER * validatorStake / totalStaked;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    rewardPercent = REWARD_PERCENT_MULTIPLIER * 3 / 10;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (stakingEpoch != 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 805,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                // Accumulate blocks producing statistics for each of the\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 806,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                // active validators during the current staking epoch\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 807,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 808,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 809,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 995,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 996,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                totalReward != 0 && _erc20TokenContract != address(0) ||\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 997,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 998,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                _erc20Restricted\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 999,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1000,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                j = 0;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1002,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    ratio[i] = uintStorage[keccak256(abi.encode(\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1003,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1004,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    ))];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < extraLength; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = extraLength; i < receivers.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            j++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 582,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uintStorage[QUEUE_ER_FIRST]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = from; i < to; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 807,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 819,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1009,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1020,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1043,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = range[1]; i < range[2]; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = range[1]; i < range[2]; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uintStorage[QUEUE_V_FIRST]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < DELEGATORS_ALIQUOT; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "DOCKER_RECEIVED_SIGNAL_20"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner (BlockRewardAuRa.sol#80) is never initialized. It is used in:\n"
                },
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": 1138,
                    "vulnerability_code": "    function _distributeRewards(\n\n        IValidatorSet _validatorSetContract,\n\n        address _erc20TokenContract,\n\n        bool _erc20Restricted,\n\n        IStakingAuRa _stakingContract,\n\n        uint256 _stakingEpoch,\n\n        uint256 _rewardPointBlock\n\n    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n\n        uint256 i;\n\n        uint256 j;\n\n\n\n        receivers = new address[](0);\n\n        rewards = new uint256[](0);\n\n        noop = true;\n\n\n\n        if (block.number == _rewardPointBlock - 1) {\n\n            boolStorage[IS_REWARDING] = true;\n\n        } else if (block.number == _rewardPointBlock) {\n\n            address[] memory validators = _validatorSetContract.getValidators();\n\n            uint256[] memory ratio = new uint256[](validators.length);\n\n\n\n            uint256 totalReward;\n\n            bool isRewarding = false;\n\n\n\n            totalReward = uintStorage[BRIDGE_TOKEN_FEE];\n\n\n\n            if (!_erc20Restricted) {\n\n                // Accumulated bridge fee plus token inflation\n\n                uint256 inflationPercent;\n\n                if (_stakingEpoch <= 24) {\n\n                    inflationPercent = 32;\n\n                } else if (_stakingEpoch <= 48) {\n\n                    inflationPercent = 16;\n\n                } else if (_stakingEpoch <= 72) {\n\n                    inflationPercent = 8;\n\n                } else {\n\n                    inflationPercent = 4;\n\n                }\n\n                totalReward += snapshotTotalStakeAmount() * inflationPercent / 4800;\n\n            }\n\n\n\n            if (\n\n                totalReward != 0 && _erc20TokenContract != address(0) ||\n\n                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n\n                _erc20Restricted\n\n            ) {\n\n                j = 0;\n\n                for (i = 0; i < validators.length; i++) {\n\n                    ratio[i] = uintStorage[keccak256(abi.encode(\n\n                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n\n                    ))];\n\n                    j += ratio[i];\n\n                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n\n                }\n\n                if (j != 0) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        ratio[i] = REWARD_PERCENT_MULTIPLIER * ratio[i] / j;\n\n                    }\n\n                }\n\n            }\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_TOKEN_FEE] = 0;\n\n\n\n                totalReward += uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n\n\n\n                if (_erc20TokenContract != address(0)) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        uintStorage[keccak256(abi.encode(\n\n                            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, validators[i]\n\n                        ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    }\n\n                    isRewarding = true;\n\n                }\n\n\n\n                uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            totalReward = uintStorage[BRIDGE_NATIVE_FEE];\n\n\n\n            if (_erc20Restricted) {\n\n                // Accumulated bridge fee plus 2.5% per year coin inflation\n\n                totalReward += _stakingContract.stakingEpochDuration() * 1 ether;\n\n            }\n\n\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_NATIVE_FEE] = 0;\n\n\n\n                totalReward += uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n\n\n\n                for (i = 0; i < validators.length; i++) {\n\n                    uintStorage[keccak256(abi.encode(\n\n                        EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, validators[i]\n\n                    ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                }\n\n                isRewarding = true;\n\n\n\n                uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            if (isRewarding) {\n\n                for (i = 0; i < validators.length; i++) {\n\n                    _enqueueValidator(validators[i]);\n\n                }\n\n                if (validators.length == 0) {\n\n                    boolStorage[IS_REWARDING] = false;\n\n                }\n\n            } else {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            noop = false;\n\n        } else if (block.number > _rewardPointBlock) {\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress == address(0)) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            if (_validatorsQueueSize() == 0) {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            if (_validatorSetContract.isValidatorBanned(_validatorSetContract.miningByStakingAddress(stakingAddress))) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            address[] storage stakers = addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n            uint256[] memory range = new uint256[](3); // array instead of local vars because the stack is too deep\n\n            range[0] = (_validatorsQueueSize() + 1) % DELEGATORS_ALIQUOT; // offset\n\n            range[1] = range[0] * stakers.length / DELEGATORS_ALIQUOT; // from\n\n            range[2] = (range[0] + 1) * stakers.length / DELEGATORS_ALIQUOT; // to\n\n\n\n            if (range[0] == 0) {\n\n                range[2] += stakers.length % DELEGATORS_ALIQUOT;\n\n            } else {\n\n                range[1] += stakers.length % DELEGATORS_ALIQUOT;\n\n            }\n\n\n\n            if (range[1] >= range[2]) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n                SNAPSHOT_REWARD_PERCENTS, stakingAddress\n\n            ))];\n\n            uint256 accrued;\n\n            uint256 poolReward;\n\n\n\n            receivers = new address[](range[2] - range[1]);\n\n            rewards = new uint256[](receivers.length);\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                IERC20Minting(_erc20TokenContract).mintReward(receivers, rewards);\n\n                _subTokenRewardUndistributed(accrued);\n\n                noop = false;\n\n            }\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                _subNativeRewardUndistributed(accrued);\n\n                noop = false;\n\n            } else {\n\n                return (new address[](0), new uint256[](0), noop);\n\n            }\n\n        }\n",
                    "message": "BlockRewardAuRa._distributeRewards (BlockRewardAuRa.sol#954-1138) uses a dangerous strict equality:\n\t- block.number == _rewardPointBlock - 1\n\t- block.number == _rewardPointBlock\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": 1138,
                    "vulnerability_code": "    function _distributeRewards(\n\n        IValidatorSet _validatorSetContract,\n\n        address _erc20TokenContract,\n\n        bool _erc20Restricted,\n\n        IStakingAuRa _stakingContract,\n\n        uint256 _stakingEpoch,\n\n        uint256 _rewardPointBlock\n\n    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n\n        uint256 i;\n\n        uint256 j;\n\n\n\n        receivers = new address[](0);\n\n        rewards = new uint256[](0);\n\n        noop = true;\n\n\n\n        if (block.number == _rewardPointBlock - 1) {\n\n            boolStorage[IS_REWARDING] = true;\n\n        } else if (block.number == _rewardPointBlock) {\n\n            address[] memory validators = _validatorSetContract.getValidators();\n\n            uint256[] memory ratio = new uint256[](validators.length);\n\n\n\n            uint256 totalReward;\n\n            bool isRewarding = false;\n\n\n\n            totalReward = uintStorage[BRIDGE_TOKEN_FEE];\n\n\n\n            if (!_erc20Restricted) {\n\n                // Accumulated bridge fee plus token inflation\n\n                uint256 inflationPercent;\n\n                if (_stakingEpoch <= 24) {\n\n                    inflationPercent = 32;\n\n                } else if (_stakingEpoch <= 48) {\n\n                    inflationPercent = 16;\n\n                } else if (_stakingEpoch <= 72) {\n\n                    inflationPercent = 8;\n\n                } else {\n\n                    inflationPercent = 4;\n\n                }\n\n                totalReward += snapshotTotalStakeAmount() * inflationPercent / 4800;\n\n            }\n\n\n\n            if (\n\n                totalReward != 0 && _erc20TokenContract != address(0) ||\n\n                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n\n                _erc20Restricted\n\n            ) {\n\n                j = 0;\n\n                for (i = 0; i < validators.length; i++) {\n\n                    ratio[i] = uintStorage[keccak256(abi.encode(\n\n                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n\n                    ))];\n\n                    j += ratio[i];\n\n                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n\n                }\n\n                if (j != 0) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        ratio[i] = REWARD_PERCENT_MULTIPLIER * ratio[i] / j;\n\n                    }\n\n                }\n\n            }\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_TOKEN_FEE] = 0;\n\n\n\n                totalReward += uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n\n\n\n                if (_erc20TokenContract != address(0)) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        uintStorage[keccak256(abi.encode(\n\n                            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, validators[i]\n\n                        ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    }\n\n                    isRewarding = true;\n\n                }\n\n\n\n                uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            totalReward = uintStorage[BRIDGE_NATIVE_FEE];\n\n\n\n            if (_erc20Restricted) {\n\n                // Accumulated bridge fee plus 2.5% per year coin inflation\n\n                totalReward += _stakingContract.stakingEpochDuration() * 1 ether;\n\n            }\n\n\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_NATIVE_FEE] = 0;\n\n\n\n                totalReward += uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n\n\n\n                for (i = 0; i < validators.length; i++) {\n\n                    uintStorage[keccak256(abi.encode(\n\n                        EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, validators[i]\n\n                    ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                }\n\n                isRewarding = true;\n\n\n\n                uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            if (isRewarding) {\n\n                for (i = 0; i < validators.length; i++) {\n\n                    _enqueueValidator(validators[i]);\n\n                }\n\n                if (validators.length == 0) {\n\n                    boolStorage[IS_REWARDING] = false;\n\n                }\n\n            } else {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            noop = false;\n\n        } else if (block.number > _rewardPointBlock) {\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress == address(0)) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            if (_validatorsQueueSize() == 0) {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            if (_validatorSetContract.isValidatorBanned(_validatorSetContract.miningByStakingAddress(stakingAddress))) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            address[] storage stakers = addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n            uint256[] memory range = new uint256[](3); // array instead of local vars because the stack is too deep\n\n            range[0] = (_validatorsQueueSize() + 1) % DELEGATORS_ALIQUOT; // offset\n\n            range[1] = range[0] * stakers.length / DELEGATORS_ALIQUOT; // from\n\n            range[2] = (range[0] + 1) * stakers.length / DELEGATORS_ALIQUOT; // to\n\n\n\n            if (range[0] == 0) {\n\n                range[2] += stakers.length % DELEGATORS_ALIQUOT;\n\n            } else {\n\n                range[1] += stakers.length % DELEGATORS_ALIQUOT;\n\n            }\n\n\n\n            if (range[1] >= range[2]) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n                SNAPSHOT_REWARD_PERCENTS, stakingAddress\n\n            ))];\n\n            uint256 accrued;\n\n            uint256 poolReward;\n\n\n\n            receivers = new address[](range[2] - range[1]);\n\n            rewards = new uint256[](receivers.length);\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                IERC20Minting(_erc20TokenContract).mintReward(receivers, rewards);\n\n                _subTokenRewardUndistributed(accrued);\n\n                noop = false;\n\n            }\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                _subNativeRewardUndistributed(accrued);\n\n                noop = false;\n\n            } else {\n\n                return (new address[](0), new uint256[](0), noop);\n\n            }\n\n        }\n",
                    "message": "Reentrancy in BlockRewardAuRa._distributeRewards (BlockRewardAuRa.sol#954-1138):\n\tExternal calls:\n\t- validators = _validatorSetContract.getValidators() (BlockRewardAuRa.sol#972)\n\t- totalReward += _stakingContract.stakingEpochDuration() * 1000000000000000000 (BlockRewardAuRa.sol#1035)\n\tState variables written after the call(s):\n\t- uintStorage (BlockRewardAuRa.sol#1039)\n\t- uintStorage (BlockRewardAuRa.sol#1043-1047)\n\t- uintStorage (BlockRewardAuRa.sol#1044-1046)\n\t- uintStorage (BlockRewardAuRa.sol#1050)\n\t- uintStorage (BlockRewardAuRa.sol#1055)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": 1138,
                    "vulnerability_code": "    function _distributeRewards(\n\n        IValidatorSet _validatorSetContract,\n\n        address _erc20TokenContract,\n\n        bool _erc20Restricted,\n\n        IStakingAuRa _stakingContract,\n\n        uint256 _stakingEpoch,\n\n        uint256 _rewardPointBlock\n\n    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n\n        uint256 i;\n\n        uint256 j;\n\n\n\n        receivers = new address[](0);\n\n        rewards = new uint256[](0);\n\n        noop = true;\n\n\n\n        if (block.number == _rewardPointBlock - 1) {\n\n            boolStorage[IS_REWARDING] = true;\n\n        } else if (block.number == _rewardPointBlock) {\n\n            address[] memory validators = _validatorSetContract.getValidators();\n\n            uint256[] memory ratio = new uint256[](validators.length);\n\n\n\n            uint256 totalReward;\n\n            bool isRewarding = false;\n\n\n\n            totalReward = uintStorage[BRIDGE_TOKEN_FEE];\n\n\n\n            if (!_erc20Restricted) {\n\n                // Accumulated bridge fee plus token inflation\n\n                uint256 inflationPercent;\n\n                if (_stakingEpoch <= 24) {\n\n                    inflationPercent = 32;\n\n                } else if (_stakingEpoch <= 48) {\n\n                    inflationPercent = 16;\n\n                } else if (_stakingEpoch <= 72) {\n\n                    inflationPercent = 8;\n\n                } else {\n\n                    inflationPercent = 4;\n\n                }\n\n                totalReward += snapshotTotalStakeAmount() * inflationPercent / 4800;\n\n            }\n\n\n\n            if (\n\n                totalReward != 0 && _erc20TokenContract != address(0) ||\n\n                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n\n                _erc20Restricted\n\n            ) {\n\n                j = 0;\n\n                for (i = 0; i < validators.length; i++) {\n\n                    ratio[i] = uintStorage[keccak256(abi.encode(\n\n                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n\n                    ))];\n\n                    j += ratio[i];\n\n                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n\n                }\n\n                if (j != 0) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        ratio[i] = REWARD_PERCENT_MULTIPLIER * ratio[i] / j;\n\n                    }\n\n                }\n\n            }\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_TOKEN_FEE] = 0;\n\n\n\n                totalReward += uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n\n\n\n                if (_erc20TokenContract != address(0)) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        uintStorage[keccak256(abi.encode(\n\n                            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, validators[i]\n\n                        ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    }\n\n                    isRewarding = true;\n\n                }\n\n\n\n                uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            totalReward = uintStorage[BRIDGE_NATIVE_FEE];\n\n\n\n            if (_erc20Restricted) {\n\n                // Accumulated bridge fee plus 2.5% per year coin inflation\n\n                totalReward += _stakingContract.stakingEpochDuration() * 1 ether;\n\n            }\n\n\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_NATIVE_FEE] = 0;\n\n\n\n                totalReward += uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n\n\n\n                for (i = 0; i < validators.length; i++) {\n\n                    uintStorage[keccak256(abi.encode(\n\n                        EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, validators[i]\n\n                    ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                }\n\n                isRewarding = true;\n\n\n\n                uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            if (isRewarding) {\n\n                for (i = 0; i < validators.length; i++) {\n\n                    _enqueueValidator(validators[i]);\n\n                }\n\n                if (validators.length == 0) {\n\n                    boolStorage[IS_REWARDING] = false;\n\n                }\n\n            } else {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            noop = false;\n\n        } else if (block.number > _rewardPointBlock) {\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress == address(0)) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            if (_validatorsQueueSize() == 0) {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            if (_validatorSetContract.isValidatorBanned(_validatorSetContract.miningByStakingAddress(stakingAddress))) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            address[] storage stakers = addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n            uint256[] memory range = new uint256[](3); // array instead of local vars because the stack is too deep\n\n            range[0] = (_validatorsQueueSize() + 1) % DELEGATORS_ALIQUOT; // offset\n\n            range[1] = range[0] * stakers.length / DELEGATORS_ALIQUOT; // from\n\n            range[2] = (range[0] + 1) * stakers.length / DELEGATORS_ALIQUOT; // to\n\n\n\n            if (range[0] == 0) {\n\n                range[2] += stakers.length % DELEGATORS_ALIQUOT;\n\n            } else {\n\n                range[1] += stakers.length % DELEGATORS_ALIQUOT;\n\n            }\n\n\n\n            if (range[1] >= range[2]) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n                SNAPSHOT_REWARD_PERCENTS, stakingAddress\n\n            ))];\n\n            uint256 accrued;\n\n            uint256 poolReward;\n\n\n\n            receivers = new address[](range[2] - range[1]);\n\n            rewards = new uint256[](receivers.length);\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                IERC20Minting(_erc20TokenContract).mintReward(receivers, rewards);\n\n                _subTokenRewardUndistributed(accrued);\n\n                noop = false;\n\n            }\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                _subNativeRewardUndistributed(accrued);\n\n                noop = false;\n\n            } else {\n\n                return (new address[](0), new uint256[](0), noop);\n\n            }\n\n        }\n",
                    "message": "Reentrancy in BlockRewardAuRa._distributeRewards (BlockRewardAuRa.sol#954-1138):\n\tExternal calls:\n\t- IERC20Minting(_erc20TokenContract).mintReward(receivers,rewards) (BlockRewardAuRa.sol#1116)\n\tState variables written after the call(s):\n\t- uintStorage (BlockRewardAuRa.sol#1117)\n\t- uintStorage (BlockRewardAuRa.sol#1132)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": 279,
                    "vulnerability_code": "    function migrateMintingStatistics(address _bridge, IBlockReward _prevBlockRewardContract) external onlyOwner {\n\n        require(mintedTotally() == 0);\n\n        uint256 prevMinted = _prevBlockRewardContract.mintedTotally();\n\n        uint256 prevMintedByBridge = _prevBlockRewardContract.mintedTotallyByBridge(_bridge);\n\n        require(prevMinted != 0);\n\n        require(prevMintedByBridge != 0);\n\n        uintStorage[MINTED_TOTALLY] = prevMinted;\n\n        uintStorage[keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))] = prevMintedByBridge;\n",
                    "message": "Reentrancy in BlockRewardBase.migrateMintingStatistics (BlockRewardAuRa.sol#271-279):\n\tExternal calls:\n\t- prevMinted = _prevBlockRewardContract.mintedTotally() (BlockRewardAuRa.sol#273)\n\t- prevMintedByBridge = _prevBlockRewardContract.mintedTotallyByBridge(_bridge) (BlockRewardAuRa.sol#274)\n\tState variables written after the call(s):\n\t- uintStorage (BlockRewardAuRa.sol#277)\n\t- uintStorage (BlockRewardAuRa.sol#278)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": 872,
                    "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
                    "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRa.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRa.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRa.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRa.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRa.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRa.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRa.sol#803-809)\n\t- (newStakingEpochHasBegun,poolsToBeElectedLength) = validatorSet.newValidatorSet() (BlockRewardAuRa.sol#812)\n\t- newValidatorSet = validatorSet.getPendingValidators() (BlockRewardAuRa.sol#817)\n\t- stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]) (BlockRewardAuRa.sol#820)\n\tState variables written after the call(s):\n\t- addressArrayStorage (BlockRewardAuRa.sol#824)\n\t- addressStorage (BlockRewardAuRa.sol#822)\n\t- boolStorage (BlockRewardAuRa.sol#830)\n\t- uintArrayStorage (BlockRewardAuRa.sol#825)\n\t- uintStorage (BlockRewardAuRa.sol#822)\n\t- uintStorage (BlockRewardAuRa.sol#829)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": 872,
                    "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
                    "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRa.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRa.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRa.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRa.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRa.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRa.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRa.sol#803-809)\n\t- (newStakingEpochHasBegun,poolsToBeElectedLength) = validatorSet.newValidatorSet() (BlockRewardAuRa.sol#812)\n\tState variables written after the call(s):\n\t- addressStorage (BlockRewardAuRa.sol#842)\n\t- uintStorage (BlockRewardAuRa.sol#842)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": 872,
                    "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
                    "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRa.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRa.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRa.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRa.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRa.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRa.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRa.sol#803-809)\n\t- (newStakingEpochHasBegun,poolsToBeElectedLength) = validatorSet.newValidatorSet() (BlockRewardAuRa.sol#812)\n\t- _setSnapshot(stakingAddress_scope_0,stakingContract,(validatorsQueueSize + 1) % DELEGATORS_ALIQUOT) (BlockRewardAuRa.sol#846)\n\tState variables written after the call(s):\n\t- boolStorage (BlockRewardAuRa.sol#849)\n\t- uintStorage (BlockRewardAuRa.sol#846)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": 872,
                    "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
                    "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRa.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRa.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRa.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRa.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRa.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRa.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRa.sol#803-809)\n\t- (newStakingEpochHasBegun,poolsToBeElectedLength) = validatorSet.newValidatorSet() (BlockRewardAuRa.sol#812)\n\t- (receiversNative,rewardsNative,noop) = _distributeRewards(validatorSet,stakingContract.erc20TokenContract(),stakingContract.erc20Restricted(),IStakingAuRa(address(stakingContract)),stakingEpoch,rewardPointBlock) (BlockRewardAuRa.sol#857-864)\n\tState variables written after the call(s):\n\t- addressStorage (BlockRewardAuRa.sol#857-864)\n\t- boolStorage (BlockRewardAuRa.sol#857-864)\n\t- uintStorage (BlockRewardAuRa.sol#857-864)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": 872,
                    "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
                    "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRa.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRa.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRa.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRa.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRa.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRa.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRa.sol#803-809)\n\t- (newStakingEpochHasBegun,poolsToBeElectedLength) = validatorSet.newValidatorSet() (BlockRewardAuRa.sol#812)\n\t- newValidatorSet = validatorSet.getPendingValidators() (BlockRewardAuRa.sol#817)\n\t- stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]) (BlockRewardAuRa.sol#820)\n\t- _setSnapshot(stakingAddress_scope_0,stakingContract,(validatorsQueueSize + 1) % DELEGATORS_ALIQUOT) (BlockRewardAuRa.sol#846)\n\t- (receiversNative,rewardsNative,noop) = _distributeRewards(validatorSet,stakingContract.erc20TokenContract(),stakingContract.erc20Restricted(),IStakingAuRa(address(stakingContract)),stakingEpoch,rewardPointBlock) (BlockRewardAuRa.sol#857-864)\n\tState variables written after the call(s):\n\t- addressStorage (BlockRewardAuRa.sol#871)\n\t- uintStorage (BlockRewardAuRa.sol#871)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 960,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _rewardPointBlock\n",
                    "message": "BlockRewardAuRa._distributeRewards._rewardPointBlock (local variable @ BlockRewardAuRa.sol#960) shadows:\n\t- BlockRewardAuRa._rewardPointBlock (function @ BlockRewardAuRa.sol#1195-1200)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 976,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bool isRewarding = false;\n",
                    "message": "BlockRewardAuRa._distributeRewards.isRewarding (local variable @ BlockRewardAuRa.sol#976) shadows:\n\t- BlockRewardBase.isRewarding (function @ BlockRewardAuRa.sol#377-379)\n\t- IBlockReward.isRewarding (function @ BlockRewardAuRa.sol#9)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n",
                    "message": "BlockRewardAuRa.reward has external calls inside a loop:\n\t- stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]) (BlockRewardAuRa.sol#820)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 1006,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n",
                    "message": "BlockRewardAuRa._distributeRewards has external calls inside a loop:\n\t- validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]) (BlockRewardAuRa.sol#1006)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": 1138,
                    "vulnerability_code": "    function _distributeRewards(\n\n        IValidatorSet _validatorSetContract,\n\n        address _erc20TokenContract,\n\n        bool _erc20Restricted,\n\n        IStakingAuRa _stakingContract,\n\n        uint256 _stakingEpoch,\n\n        uint256 _rewardPointBlock\n\n    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n\n        uint256 i;\n\n        uint256 j;\n\n\n\n        receivers = new address[](0);\n\n        rewards = new uint256[](0);\n\n        noop = true;\n\n\n\n        if (block.number == _rewardPointBlock - 1) {\n\n            boolStorage[IS_REWARDING] = true;\n\n        } else if (block.number == _rewardPointBlock) {\n\n            address[] memory validators = _validatorSetContract.getValidators();\n\n            uint256[] memory ratio = new uint256[](validators.length);\n\n\n\n            uint256 totalReward;\n\n            bool isRewarding = false;\n\n\n\n            totalReward = uintStorage[BRIDGE_TOKEN_FEE];\n\n\n\n            if (!_erc20Restricted) {\n\n                // Accumulated bridge fee plus token inflation\n\n                uint256 inflationPercent;\n\n                if (_stakingEpoch <= 24) {\n\n                    inflationPercent = 32;\n\n                } else if (_stakingEpoch <= 48) {\n\n                    inflationPercent = 16;\n\n                } else if (_stakingEpoch <= 72) {\n\n                    inflationPercent = 8;\n\n                } else {\n\n                    inflationPercent = 4;\n\n                }\n\n                totalReward += snapshotTotalStakeAmount() * inflationPercent / 4800;\n\n            }\n\n\n\n            if (\n\n                totalReward != 0 && _erc20TokenContract != address(0) ||\n\n                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n\n                _erc20Restricted\n\n            ) {\n\n                j = 0;\n\n                for (i = 0; i < validators.length; i++) {\n\n                    ratio[i] = uintStorage[keccak256(abi.encode(\n\n                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n\n                    ))];\n\n                    j += ratio[i];\n\n                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n\n                }\n\n                if (j != 0) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        ratio[i] = REWARD_PERCENT_MULTIPLIER * ratio[i] / j;\n\n                    }\n\n                }\n\n            }\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_TOKEN_FEE] = 0;\n\n\n\n                totalReward += uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n\n\n\n                if (_erc20TokenContract != address(0)) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        uintStorage[keccak256(abi.encode(\n\n                            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, validators[i]\n\n                        ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    }\n\n                    isRewarding = true;\n\n                }\n\n\n\n                uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            totalReward = uintStorage[BRIDGE_NATIVE_FEE];\n\n\n\n            if (_erc20Restricted) {\n\n                // Accumulated bridge fee plus 2.5% per year coin inflation\n\n                totalReward += _stakingContract.stakingEpochDuration() * 1 ether;\n\n            }\n\n\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_NATIVE_FEE] = 0;\n\n\n\n                totalReward += uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n\n\n\n                for (i = 0; i < validators.length; i++) {\n\n                    uintStorage[keccak256(abi.encode(\n\n                        EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, validators[i]\n\n                    ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                }\n\n                isRewarding = true;\n\n\n\n                uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            if (isRewarding) {\n\n                for (i = 0; i < validators.length; i++) {\n\n                    _enqueueValidator(validators[i]);\n\n                }\n\n                if (validators.length == 0) {\n\n                    boolStorage[IS_REWARDING] = false;\n\n                }\n\n            } else {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            noop = false;\n\n        } else if (block.number > _rewardPointBlock) {\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress == address(0)) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            if (_validatorsQueueSize() == 0) {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            if (_validatorSetContract.isValidatorBanned(_validatorSetContract.miningByStakingAddress(stakingAddress))) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            address[] storage stakers = addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n            uint256[] memory range = new uint256[](3); // array instead of local vars because the stack is too deep\n\n            range[0] = (_validatorsQueueSize() + 1) % DELEGATORS_ALIQUOT; // offset\n\n            range[1] = range[0] * stakers.length / DELEGATORS_ALIQUOT; // from\n\n            range[2] = (range[0] + 1) * stakers.length / DELEGATORS_ALIQUOT; // to\n\n\n\n            if (range[0] == 0) {\n\n                range[2] += stakers.length % DELEGATORS_ALIQUOT;\n\n            } else {\n\n                range[1] += stakers.length % DELEGATORS_ALIQUOT;\n\n            }\n\n\n\n            if (range[1] >= range[2]) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n                SNAPSHOT_REWARD_PERCENTS, stakingAddress\n\n            ))];\n\n            uint256 accrued;\n\n            uint256 poolReward;\n\n\n\n            receivers = new address[](range[2] - range[1]);\n\n            rewards = new uint256[](receivers.length);\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                IERC20Minting(_erc20TokenContract).mintReward(receivers, rewards);\n\n                _subTokenRewardUndistributed(accrued);\n\n                noop = false;\n\n            }\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                _subNativeRewardUndistributed(accrued);\n\n                noop = false;\n\n            } else {\n\n                return (new address[](0), new uint256[](0), noop);\n\n            }\n\n        }\n",
                    "message": "Reentrancy in BlockRewardAuRa._distributeRewards (BlockRewardAuRa.sol#954-1138):\n\tExternal calls:\n\t- validators = _validatorSetContract.getValidators() (BlockRewardAuRa.sol#972)\n\tState variables written after the call(s):\n\t- uintStorage (BlockRewardAuRa.sol#1015)\n\t- uintStorage (BlockRewardAuRa.sol#1020-1024)\n\t- uintStorage (BlockRewardAuRa.sol#1021-1023)\n\t- uintStorage (BlockRewardAuRa.sol#1028)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": 1138,
                    "vulnerability_code": "    function _distributeRewards(\n\n        IValidatorSet _validatorSetContract,\n\n        address _erc20TokenContract,\n\n        bool _erc20Restricted,\n\n        IStakingAuRa _stakingContract,\n\n        uint256 _stakingEpoch,\n\n        uint256 _rewardPointBlock\n\n    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n\n        uint256 i;\n\n        uint256 j;\n\n\n\n        receivers = new address[](0);\n\n        rewards = new uint256[](0);\n\n        noop = true;\n\n\n\n        if (block.number == _rewardPointBlock - 1) {\n\n            boolStorage[IS_REWARDING] = true;\n\n        } else if (block.number == _rewardPointBlock) {\n\n            address[] memory validators = _validatorSetContract.getValidators();\n\n            uint256[] memory ratio = new uint256[](validators.length);\n\n\n\n            uint256 totalReward;\n\n            bool isRewarding = false;\n\n\n\n            totalReward = uintStorage[BRIDGE_TOKEN_FEE];\n\n\n\n            if (!_erc20Restricted) {\n\n                // Accumulated bridge fee plus token inflation\n\n                uint256 inflationPercent;\n\n                if (_stakingEpoch <= 24) {\n\n                    inflationPercent = 32;\n\n                } else if (_stakingEpoch <= 48) {\n\n                    inflationPercent = 16;\n\n                } else if (_stakingEpoch <= 72) {\n\n                    inflationPercent = 8;\n\n                } else {\n\n                    inflationPercent = 4;\n\n                }\n\n                totalReward += snapshotTotalStakeAmount() * inflationPercent / 4800;\n\n            }\n\n\n\n            if (\n\n                totalReward != 0 && _erc20TokenContract != address(0) ||\n\n                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n\n                _erc20Restricted\n\n            ) {\n\n                j = 0;\n\n                for (i = 0; i < validators.length; i++) {\n\n                    ratio[i] = uintStorage[keccak256(abi.encode(\n\n                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n\n                    ))];\n\n                    j += ratio[i];\n\n                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n\n                }\n\n                if (j != 0) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        ratio[i] = REWARD_PERCENT_MULTIPLIER * ratio[i] / j;\n\n                    }\n\n                }\n\n            }\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_TOKEN_FEE] = 0;\n\n\n\n                totalReward += uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n\n\n\n                if (_erc20TokenContract != address(0)) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        uintStorage[keccak256(abi.encode(\n\n                            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, validators[i]\n\n                        ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    }\n\n                    isRewarding = true;\n\n                }\n\n\n\n                uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            totalReward = uintStorage[BRIDGE_NATIVE_FEE];\n\n\n\n            if (_erc20Restricted) {\n\n                // Accumulated bridge fee plus 2.5% per year coin inflation\n\n                totalReward += _stakingContract.stakingEpochDuration() * 1 ether;\n\n            }\n\n\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_NATIVE_FEE] = 0;\n\n\n\n                totalReward += uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n\n\n\n                for (i = 0; i < validators.length; i++) {\n\n                    uintStorage[keccak256(abi.encode(\n\n                        EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, validators[i]\n\n                    ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                }\n\n                isRewarding = true;\n\n\n\n                uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            if (isRewarding) {\n\n                for (i = 0; i < validators.length; i++) {\n\n                    _enqueueValidator(validators[i]);\n\n                }\n\n                if (validators.length == 0) {\n\n                    boolStorage[IS_REWARDING] = false;\n\n                }\n\n            } else {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            noop = false;\n\n        } else if (block.number > _rewardPointBlock) {\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress == address(0)) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            if (_validatorsQueueSize() == 0) {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            if (_validatorSetContract.isValidatorBanned(_validatorSetContract.miningByStakingAddress(stakingAddress))) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            address[] storage stakers = addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n            uint256[] memory range = new uint256[](3); // array instead of local vars because the stack is too deep\n\n            range[0] = (_validatorsQueueSize() + 1) % DELEGATORS_ALIQUOT; // offset\n\n            range[1] = range[0] * stakers.length / DELEGATORS_ALIQUOT; // from\n\n            range[2] = (range[0] + 1) * stakers.length / DELEGATORS_ALIQUOT; // to\n\n\n\n            if (range[0] == 0) {\n\n                range[2] += stakers.length % DELEGATORS_ALIQUOT;\n\n            } else {\n\n                range[1] += stakers.length % DELEGATORS_ALIQUOT;\n\n            }\n\n\n\n            if (range[1] >= range[2]) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n                SNAPSHOT_REWARD_PERCENTS, stakingAddress\n\n            ))];\n\n            uint256 accrued;\n\n            uint256 poolReward;\n\n\n\n            receivers = new address[](range[2] - range[1]);\n\n            rewards = new uint256[](receivers.length);\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                IERC20Minting(_erc20TokenContract).mintReward(receivers, rewards);\n\n                _subTokenRewardUndistributed(accrued);\n\n                noop = false;\n\n            }\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                _subNativeRewardUndistributed(accrued);\n\n                noop = false;\n\n            } else {\n\n                return (new address[](0), new uint256[](0), noop);\n\n            }\n\n        }\n",
                    "message": "Reentrancy in BlockRewardAuRa._distributeRewards (BlockRewardAuRa.sol#954-1138):\n\tExternal calls:\n\t- validators = _validatorSetContract.getValidators() (BlockRewardAuRa.sol#972)\n\t- totalReward += _stakingContract.stakingEpochDuration() * 1000000000000000000 (BlockRewardAuRa.sol#1035)\n\tState variables written after the call(s):\n\t- addressStorage (BlockRewardAuRa.sol#1055)\n\t- boolStorage (BlockRewardAuRa.sol#1058)\n\t- boolStorage (BlockRewardAuRa.sol#1061)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": 682,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n\n        uint256 validatorStake = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, _stakingAddress);\n\n        uint256 totalStaked = _stakingContract.stakeAmountTotalMinusOrderedWithdraw(_stakingAddress);\n\n        uint256 delegatorsAmount = totalStaked >= validatorStake ? totalStaked - validatorStake : 0;\n\n        bool validatorHasMore30Per = validatorStake * 7 > delegatorsAmount * 3;\n\n\n\n        address[] memory delegators = _stakingContract.poolDelegators(_stakingAddress);\n\n        uint256 rewardPercent;\n\n\n\n        address[] storage stakers = addressArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_STAKERS, _stakingAddress\n\n        ))];\n\n\n\n        uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_REWARD_PERCENTS, _stakingAddress\n\n        ))];\n\n\n\n        if (_offset == 0) {\n\n            // Calculate reward percent for validator\n\n            rewardPercent = 0;\n\n            if (validatorStake != 0 && totalStaked != 0) {\n\n                if (validatorHasMore30Per) {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * validatorStake / totalStaked;\n\n                } else {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * 3 / 10;\n\n                }\n\n            }\n\n            stakers.push(_stakingAddress);\n\n            rewardPercents.push(rewardPercent);\n\n            addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES].push(_stakingAddress);\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] += totalStaked;\n\n        }\n\n\n\n        uint256 from = _offset * delegators.length / DELEGATORS_ALIQUOT;\n\n        uint256 to = (_offset + 1) * delegators.length / DELEGATORS_ALIQUOT;\n\n\n\n        if (_offset == 0) {\n\n            to += delegators.length % DELEGATORS_ALIQUOT;\n\n        } else {\n\n            from += delegators.length % DELEGATORS_ALIQUOT;\n\n        }\n\n\n\n        // Calculate reward percent for each delegator\n\n        for (uint256 i = from; i < to; i++) {\n\n            rewardPercent = 0;\n\n\n\n            if (validatorHasMore30Per) {\n\n                if (totalStaked != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent / totalStaked;\n\n                }\n\n            } else {\n\n                if (delegatorsAmount != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent * 7 / (delegatorsAmount * 10);\n\n                }\n\n            }\n\n\n\n            stakers.push(delegators[i]);\n\n            rewardPercents.push(rewardPercent);\n\n        }\n",
                    "message": "Reentrancy in BlockRewardBase._setSnapshot (BlockRewardAuRa.sol#621-682):\n\tExternal calls:\n\t- validatorStake = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress,_stakingAddress) (BlockRewardAuRa.sol#622)\n\t- totalStaked = _stakingContract.stakeAmountTotalMinusOrderedWithdraw(_stakingAddress) (BlockRewardAuRa.sol#623)\n\t- delegators = _stakingContract.poolDelegators(_stakingAddress) (BlockRewardAuRa.sol#627)\n\tState variables written after the call(s):\n\t- addressArrayStorage (BlockRewardAuRa.sol#650)\n\t- uintStorage (BlockRewardAuRa.sol#651)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": 872,
                    "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
                    "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRa.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRa.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRa.sol#784)\n\tState variables written after the call(s):\n\t- boolStorage (BlockRewardAuRa.sol#790)\n\t- boolStorage (BlockRewardAuRa.sol#795)\n\t- uintStorage (BlockRewardAuRa.sol#788)\n\t- uintStorage (BlockRewardAuRa.sol#789)\n\t- uintStorage (BlockRewardAuRa.sol#793)\n\t- uintStorage (BlockRewardAuRa.sol#794)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": 872,
                    "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
                    "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRa.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRa.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRa.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRa.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRa.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRa.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRa.sol#803-809)\n\tState variables written after the call(s):\n\t- uintStorage (BlockRewardAuRa.sol#807)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": 872,
                    "vulnerability_code": "    function reward(address[] calldata benefactors, uint16[] calldata kind)\n\n        external\n\n        onlySystem\n\n        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n\n    {\n\n        if (benefactors.length != kind.length || benefactors.length != 1 || kind[0] != 0) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n\n\n        // Check if the validator is existed\n\n        if (!validatorSet.isValidator(benefactors[0])) {\n\n            return (new address[](0), new uint256[](0));\n\n        }\n\n\n\n        receiversNative = new address[](0);\n\n        rewardsNative = new uint256[](0);\n\n\n\n        // Check the current validators at the end of each collection round whether\n\n        // they revealed their secrets, and remove a validator as a malicious if needed\n\n        IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound();\n\n\n\n        // Initialize queues\n\n        if (!boolStorage[QUEUE_V_INITIALIZED]) {\n\n            uintStorage[QUEUE_V_FIRST] = 1;\n\n            uintStorage[QUEUE_V_LAST] = 0;\n\n            boolStorage[QUEUE_V_INITIALIZED] = true;\n\n        }\n\n        if (!boolStorage[QUEUE_ER_INITIALIZED]) {\n\n            uintStorage[QUEUE_ER_FIRST] = 1;\n\n            uintStorage[QUEUE_ER_LAST] = 0;\n\n            boolStorage[QUEUE_ER_INITIALIZED] = true;\n\n        }\n\n\n\n        IStaking stakingContract = IStaking(validatorSet.stakingContract());\n\n        uint256 bridgeQueueLimit = 100;\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)), validatorSet);\n\n\n\n        if (validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock) {\n\n            if (stakingEpoch != 0) {\n\n                // Accumulate blocks producing statistics for each of the\n\n                // active validators during the current staking epoch\n\n                uintStorage[keccak256(abi.encode(BLOCKS_CREATED, stakingEpoch, benefactors[0]))]++;\n\n            }\n\n        }\n\n\n\n        // Start a new staking epoch every `stakingEpochDuration()` blocks\n\n        (bool newStakingEpochHasBegun, uint256 poolsToBeElectedLength) = validatorSet.newValidatorSet();\n\n\n\n        if (newStakingEpochHasBegun) {\n\n            // A new staking epoch has begun, so prepare for reward coefficients snapshotting\n\n            // process which begins right from the following block\n\n            address[] memory newValidatorSet = validatorSet.getPendingValidators();\n\n\n\n            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n\n                address stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]);\n\n\n\n                _enqueueValidator(stakingAddress);\n\n\n\n                delete addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n                delete uintArrayStorage[keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, stakingAddress))];\n\n            }\n\n\n\n            delete addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] = 0;\n\n            boolStorage[IS_SNAPSHOTTING] = (newValidatorSet.length != 0);\n\n\n\n            if (poolsToBeElectedLength > 2000) {\n\n                bridgeQueueLimit = 0;\n\n            } else if (poolsToBeElectedLength > 1000) {\n\n                bridgeQueueLimit = 30;\n\n            } else {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (boolStorage[IS_SNAPSHOTTING]) {\n\n            // Snapshot reward coefficients for each new validator and their delegators\n\n            // during the very first blocks of a new staking epoch\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress != address(0)) {\n\n                uint256 validatorsQueueSize = _validatorsQueueSize();\n\n                _setSnapshot(stakingAddress, stakingContract, (validatorsQueueSize + 1) % DELEGATORS_ALIQUOT);\n\n                if (validatorsQueueSize == 0) {\n\n                    // Snapshotting process has been finished\n\n                    boolStorage[IS_SNAPSHOTTING] = false;\n\n                }\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        } else if (stakingEpoch != 0) {\n\n            // Distribute rewards at the end of staking epoch during the last\n\n            // MAX_VALIDATORS * DELEGATORS_ALIQUOT blocks\n\n            bool noop;\n\n            (receiversNative, rewardsNative, noop) = _distributeRewards(\n\n                validatorSet,\n\n                stakingContract.erc20TokenContract(),\n\n                stakingContract.erc20Restricted(),\n\n                IStakingAuRa(address(stakingContract)),\n\n                stakingEpoch,\n\n                rewardPointBlock\n\n            );\n\n            if (!noop) {\n\n                bridgeQueueLimit = 50;\n\n            }\n\n        }\n\n\n\n        // Mint native coins if needed\n\n        return _mintNativeCoins(receiversNative, rewardsNative, bridgeQueueLimit);\n",
                    "message": "Reentrancy in BlockRewardAuRa.reward (BlockRewardAuRa.sol#763-872):\n\tExternal calls:\n\t- ! validatorSet.isValidator(benefactors[0]) (BlockRewardAuRa.sol#775-777)\n\t- IRandomAuRa(validatorSet.randomContract()).onFinishCollectRound() (BlockRewardAuRa.sol#784)\n\t- stakingContract = IStaking(validatorSet.stakingContract()) (BlockRewardAuRa.sol#798)\n\t- stakingEpoch = stakingContract.stakingEpoch() (BlockRewardAuRa.sol#800)\n\t- rewardPointBlock = _rewardPointBlock(IStakingAuRa(address(stakingContract)),validatorSet) (BlockRewardAuRa.sol#801)\n\t- validatorSet.validatorSetApplyBlock() != 0 && block.number <= rewardPointBlock (BlockRewardAuRa.sol#803-809)\n\t- (newStakingEpochHasBegun,poolsToBeElectedLength) = validatorSet.newValidatorSet() (BlockRewardAuRa.sol#812)\n\t- newValidatorSet = validatorSet.getPendingValidators() (BlockRewardAuRa.sol#817)\n\t- stakingAddress = validatorSet.stakingByMiningAddress(newValidatorSet[i]) (BlockRewardAuRa.sol#820)\n\tState variables written after the call(s):\n\t- addressArrayStorage (BlockRewardAuRa.sol#828)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (BlockRewardAuRa.sol#80)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isRewarding() external view returns(bool);\n",
                    "message": "IBlockReward.isRewarding (BlockRewardAuRa.sol#9) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 379,
                    "vulnerability_code": "    function isRewarding() public view returns(bool) {\n\n        return boolStorage[IS_REWARDING];\n",
                    "message": "BlockRewardBase.isRewarding (BlockRewardAuRa.sol#377-379) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isSnapshotting() external view returns(bool);\n",
                    "message": "IBlockReward.isSnapshotting (BlockRewardAuRa.sol#10) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": 385,
                    "vulnerability_code": "    function isSnapshotting() public view returns(bool) {\n\n        return boolStorage[IS_SNAPSHOTTING];\n",
                    "message": "BlockRewardBase.isSnapshotting (BlockRewardAuRa.sol#383-385) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) external view returns(uint256);\n",
                    "message": "IBlockReward.mintedTotallyByBridge (BlockRewardAuRa.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": 420,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))];\n",
                    "message": "BlockRewardBase.mintedTotallyByBridge (BlockRewardAuRa.sol#418-420) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": 341,
                    "vulnerability_code": "    function blockRewardContractId() public pure returns(bytes4) {\n\n        return BLOCK_REWARD_CONTRACT_ID;\n",
                    "message": "BlockRewardBase.blockRewardContractId (BlockRewardAuRa.sol#339-341) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": 346,
                    "vulnerability_code": "    function ercToErcBridgesAllowed() public view returns(address[] memory) {\n\n        return addressArrayStorage[ERC_TO_ERC_BRIDGES_ALLOWED];\n",
                    "message": "BlockRewardBase.ercToErcBridgesAllowed (BlockRewardAuRa.sol#344-346) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": 351,
                    "vulnerability_code": "    function ercToNativeBridgesAllowed() public view returns(address[] memory) {\n\n        return addressArrayStorage[ERC_TO_NATIVE_BRIDGES_ALLOWED];\n",
                    "message": "BlockRewardBase.ercToNativeBridgesAllowed (BlockRewardAuRa.sol#349-351) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": 362,
                    "vulnerability_code": "    function getBridgeNativeFee() public view returns(uint256) {\n\n        return uintStorage[BRIDGE_NATIVE_FEE];\n",
                    "message": "BlockRewardBase.getBridgeNativeFee (BlockRewardAuRa.sol#360-362) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": 368,
                    "vulnerability_code": "    function getBridgeTokenFee() public view returns(uint256) {\n\n        return uintStorage[BRIDGE_TOKEN_FEE];\n",
                    "message": "BlockRewardBase.getBridgeTokenFee (BlockRewardAuRa.sol#366-368) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": 392,
                    "vulnerability_code": "    function mintedForAccount(address _account) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(MINTED_FOR_ACCOUNT, _account))];\n",
                    "message": "BlockRewardBase.mintedForAccount (BlockRewardAuRa.sol#390-392) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": 406,
                    "vulnerability_code": "    function mintedForAccountInBlock(address _account, uint256 _blockNumber)\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        return uintStorage[\n\n            keccak256(abi.encode(MINTED_FOR_ACCOUNT_IN_BLOCK, _account, _blockNumber))\n\n        ];\n",
                    "message": "BlockRewardBase.mintedForAccountInBlock (BlockRewardAuRa.sol#398-406) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": 413,
                    "vulnerability_code": "    function mintedInBlock(uint256 _blockNumber) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(MINTED_IN_BLOCK, _blockNumber))];\n",
                    "message": "BlockRewardBase.mintedInBlock (BlockRewardAuRa.sol#411-413) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": 432,
                    "vulnerability_code": "    function nativeToErcBridgesAllowed() public view returns(address[] memory) {\n\n        return addressArrayStorage[NATIVE_TO_ERC_BRIDGES_ALLOWED];\n",
                    "message": "BlockRewardBase.nativeToErcBridgesAllowed (BlockRewardAuRa.sol#430-432) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": 445,
                    "vulnerability_code": "    function snapshotRewardPercents(address _validatorStakingAddress) public view returns(uint256[] memory) {\n\n        return uintArrayStorage[\n\n            keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, _validatorStakingAddress))\n\n        ];\n",
                    "message": "BlockRewardBase.snapshotRewardPercents (BlockRewardAuRa.sol#441-445) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": 456,
                    "vulnerability_code": "    function snapshotStakers(address _validatorStakingAddress) public view returns(address[] memory) {\n\n        return addressArrayStorage[\n\n            keccak256(abi.encode(SNAPSHOT_STAKERS, _validatorStakingAddress))\n\n        ];\n",
                    "message": "BlockRewardBase.snapshotStakers (BlockRewardAuRa.sol#452-456) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 463,
                    "vulnerability_code": "    function snapshotStakingAddresses() public view returns(address[] memory) {\n\n        return addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n",
                    "message": "BlockRewardBase.snapshotStakingAddresses (BlockRewardAuRa.sol#461-463) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 882,
                    "vulnerability_to_line": 887,
                    "vulnerability_code": "    function getBlocksCreated(\n\n        uint256 _stakingEpoch,\n\n        address _validatorMiningAddress\n\n    ) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(BLOCKS_CREATED, _stakingEpoch, _validatorMiningAddress))];\n",
                    "message": "BlockRewardAuRa.getBlocksCreated (BlockRewardAuRa.sol#882-887) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 893,
                    "vulnerability_to_line": 900,
                    "vulnerability_code": "    function getEpochPoolNativeReward(\n\n        uint256 _stakingEpoch,\n\n        address _poolStakingAddress\n\n    ) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(\n\n            EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, _poolStakingAddress\n\n        ))];\n",
                    "message": "BlockRewardAuRa.getEpochPoolNativeReward (BlockRewardAuRa.sol#893-900) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 906,
                    "vulnerability_to_line": 913,
                    "vulnerability_code": "    function getEpochPoolTokenReward(\n\n        uint256 _stakingEpoch,\n\n        address _poolStakingAddress\n\n    ) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(\n\n            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, _poolStakingAddress\n\n        ))];\n",
                    "message": "BlockRewardAuRa.getEpochPoolTokenReward (BlockRewardAuRa.sol#906-913) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": 918,
                    "vulnerability_code": "    function getNativeRewardUndistributed() public view returns(uint256) {\n\n        return uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n",
                    "message": "BlockRewardAuRa.getNativeRewardUndistributed (BlockRewardAuRa.sol#916-918) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 921,
                    "vulnerability_to_line": 923,
                    "vulnerability_code": "    function getTokenRewardUndistributed() public view returns(uint256) {\n\n        return uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n",
                    "message": "BlockRewardAuRa.getTokenRewardUndistributed (BlockRewardAuRa.sol#921-923) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in BlockRewardAuRa.sol:\n\t- pragma solidity0.5.9 (BlockRewardAuRa.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRa.sol#17): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRa.sol#52): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRa.sol#72): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRa.sol#103): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRa.sol#121): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRa.sol#160): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRa.sol#687): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRa.sol#704): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRa.sol#716): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRa.sol#738): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardAuRa.sol#748): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address) external;\n",
                    "message": "Parameter '' of IBlockReward.initialize (BlockRewardAuRa.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function DELEGATORS_ALIQUOT() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IBlockReward.DELEGATORS_ALIQUOT' (BlockRewardAuRa.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (BlockRewardAuRa.sol#22) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (BlockRewardAuRa.sol#23) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (BlockRewardAuRa.sol#24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (BlockRewardAuRa.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (BlockRewardAuRa.sol#26) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (BlockRewardAuRa.sol#27) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (BlockRewardAuRa.sol#30) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (BlockRewardAuRa.sol#30) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (BlockRewardAuRa.sol#37) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (BlockRewardAuRa.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (BlockRewardAuRa.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (BlockRewardAuRa.sol#40) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (BlockRewardAuRa.sol#41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (BlockRewardAuRa.sol#43) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (BlockRewardAuRa.sol#46) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
                    "message": "Parameter '' of IStaking.clearUnremovableValidator (BlockRewardAuRa.sol#56) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address) external;\n",
                    "message": "Parameter '' of IStaking.removePool (BlockRewardAuRa.sol#58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "Parameter '' of IStaking.poolDelegators (BlockRewardAuRa.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (BlockRewardAuRa.sol#65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (BlockRewardAuRa.sol#65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (BlockRewardAuRa.sol#66) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (BlockRewardAuRa.sol#80) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address _validatorSet) external {\n",
                    "message": "Parameter '_validatorSet' of BlockRewardBase.initialize (BlockRewardAuRa.sol#260) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256) {\n",
                    "message": "Parameter '_bridge' of BlockRewardBase.mintedTotallyByBridge (BlockRewardAuRa.sol#418) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addBridgeNativeFeeReceivers(uint256 _amount) external onlyErcToNativeBridge {\n",
                    "message": "Parameter '_amount' of BlockRewardBase.addBridgeNativeFeeReceivers (BlockRewardAuRa.sol#231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addBridgeTokenFeeReceivers(uint256 _amount) external onlyXToErcBridge {\n",
                    "message": "Parameter '_amount' of BlockRewardBase.addBridgeTokenFeeReceivers (BlockRewardAuRa.sol#240) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExtraReceiver(uint256 _amount, address _receiver) external onlyErcToNativeBridge {\n",
                    "message": "Parameter '_amount' of BlockRewardBase.addExtraReceiver (BlockRewardAuRa.sol#249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExtraReceiver(uint256 _amount, address _receiver) external onlyErcToNativeBridge {\n",
                    "message": "Parameter '_receiver' of BlockRewardBase.addExtraReceiver (BlockRewardAuRa.sol#249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function migrateMintingStatistics(address _bridge, IBlockReward _prevBlockRewardContract) external onlyOwner {\n",
                    "message": "Parameter '_bridge' of BlockRewardBase.migrateMintingStatistics (BlockRewardAuRa.sol#271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function migrateMintingStatistics(address _bridge, IBlockReward _prevBlockRewardContract) external onlyOwner {\n",
                    "message": "Parameter '_prevBlockRewardContract' of BlockRewardBase.migrateMintingStatistics (BlockRewardAuRa.sol#271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErcToNativeBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_bridgesAllowed' of BlockRewardBase.setErcToNativeBridgesAllowed (BlockRewardAuRa.sol#284) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setNativeToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_bridgesAllowed' of BlockRewardBase.setNativeToErcBridgesAllowed (BlockRewardAuRa.sol#302) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErcToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_bridgesAllowed' of BlockRewardBase.setErcToErcBridgesAllowed (BlockRewardAuRa.sol#320) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedForAccount(address _account) public view returns(uint256) {\n",
                    "message": "Parameter '_account' of BlockRewardBase.mintedForAccount (BlockRewardAuRa.sol#390) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedForAccountInBlock(address _account, uint256 _blockNumber)\n",
                    "message": "Parameter '_account' of BlockRewardBase.mintedForAccountInBlock (BlockRewardAuRa.sol#398) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedForAccountInBlock(address _account, uint256 _blockNumber)\n",
                    "message": "Parameter '_blockNumber' of BlockRewardBase.mintedForAccountInBlock (BlockRewardAuRa.sol#398) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedInBlock(uint256 _blockNumber) public view returns(uint256) {\n",
                    "message": "Parameter '_blockNumber' of BlockRewardBase.mintedInBlock (BlockRewardAuRa.sol#411) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function snapshotRewardPercents(address _validatorStakingAddress) public view returns(uint256[] memory) {\n",
                    "message": "Parameter '_validatorStakingAddress' of BlockRewardBase.snapshotRewardPercents (BlockRewardAuRa.sol#441) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function snapshotStakers(address _validatorStakingAddress) public view returns(address[] memory) {\n",
                    "message": "Parameter '_validatorStakingAddress' of BlockRewardBase.snapshotStakers (BlockRewardAuRa.sol#452) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": 557,
                    "vulnerability_code": "    function _mintNativeCoins(\n\n        address[] memory _receivers,\n\n        uint256[] memory _rewards,\n\n        uint256 _queueLimit\n\n    )\n\n        internal\n\n        returns(address[] memory receivers, uint256[] memory rewards)\n\n    {\n\n        uint256 extraLength = extraReceiversQueueSize();\n\n\n\n        if (extraLength > _queueLimit) {\n\n            extraLength = _queueLimit;\n\n        }\n\n\n\n        receivers = new address[](extraLength + _receivers.length);\n\n        rewards = new uint256[](receivers.length);\n\n\n\n        uint256 i;\n\n        uint256 j = 0;\n\n\n\n        for (i = 0; i < extraLength; i++) {\n\n            (uint256 amount, address receiver, address bridge) = _dequeueExtraReceiver();\n\n            receivers[i] = receiver;\n\n            rewards[i] = amount;\n\n            _setMinted(amount, receiver, bridge);\n\n        }\n\n\n\n        for (i = extraLength; i < receivers.length; i++) {\n\n            receivers[i] = _receivers[j];\n\n            rewards[i] = _rewards[j];\n\n            j++;\n\n        }\n\n\n\n        emit MintedNative(receivers, rewards);\n\n\n\n        return (receivers, rewards);\n",
                    "message": "Function 'BlockRewardBase._mintNativeCoins' (BlockRewardAuRa.sol#521-557) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _receivers,\n",
                    "message": "Parameter '_receivers' of BlockRewardBase._mintNativeCoins (BlockRewardAuRa.sol#522) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] memory _rewards,\n",
                    "message": "Parameter '_rewards' of BlockRewardBase._mintNativeCoins (BlockRewardAuRa.sol#523) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _queueLimit\n",
                    "message": "Parameter '_queueLimit' of BlockRewardBase._mintNativeCoins (BlockRewardAuRa.sol#524) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": 584,
                    "vulnerability_code": "    function _dequeueExtraReceiver() internal returns(uint256 amount, address receiver, address bridge) {\n\n        uint256 queueFirst = uintStorage[QUEUE_ER_FIRST];\n\n        uint256 queueLast = uintStorage[QUEUE_ER_LAST];\n\n\n\n        if (queueLast < queueFirst) {\n\n            amount = 0;\n\n            receiver = address(0);\n\n            bridge = address(0);\n\n        } else {\n\n            bytes32 amountHash = keccak256(abi.encode(QUEUE_ER_AMOUNT, queueFirst));\n\n            bytes32 receiverHash = keccak256(abi.encode(QUEUE_ER_RECEIVER, queueFirst));\n\n            bytes32 bridgeHash = keccak256(abi.encode(QUEUE_ER_BRIDGE, queueFirst));\n\n            amount = uintStorage[amountHash];\n\n            receiver = addressStorage[receiverHash];\n\n            bridge = addressStorage[bridgeHash];\n\n            delete uintStorage[amountHash];\n\n            delete addressStorage[receiverHash];\n\n            delete addressStorage[bridgeHash];\n\n            uintStorage[QUEUE_ER_FIRST]++;\n\n        }\n",
                    "message": "Function 'BlockRewardBase._dequeueExtraReceiver' (BlockRewardAuRa.sol#564-584) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": 597,
                    "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n\n        uint256 queueLast = uintStorage[QUEUE_ER_LAST] + 1;\n\n        uintStorage[keccak256(abi.encode(QUEUE_ER_AMOUNT, queueLast))] = _amount;\n\n        addressStorage[keccak256(abi.encode(QUEUE_ER_RECEIVER, queueLast))] = _receiver;\n\n        addressStorage[keccak256(abi.encode(QUEUE_ER_BRIDGE, queueLast))] = _bridge;\n\n        uintStorage[QUEUE_ER_LAST] = queueLast;\n",
                    "message": "Function 'BlockRewardBase._enqueueExtraReceiver' (BlockRewardAuRa.sol#591-597) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n",
                    "message": "Parameter '_amount' of BlockRewardBase._enqueueExtraReceiver (BlockRewardAuRa.sol#591) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n",
                    "message": "Parameter '_receiver' of BlockRewardBase._enqueueExtraReceiver (BlockRewardAuRa.sol#591) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n",
                    "message": "Parameter '_bridge' of BlockRewardBase._enqueueExtraReceiver (BlockRewardAuRa.sol#591) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": 610,
                    "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n\n        uintStorage[keccak256(abi.encode(MINTED_FOR_ACCOUNT_IN_BLOCK, _account, block.number))] = _amount;\n\n        uintStorage[keccak256(abi.encode(MINTED_FOR_ACCOUNT, _account))] += _amount;\n\n        uintStorage[keccak256(abi.encode(MINTED_IN_BLOCK, block.number))] += _amount;\n\n        uintStorage[keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))] += _amount;\n\n        uintStorage[MINTED_TOTALLY] += _amount;\n",
                    "message": "Function 'BlockRewardBase._setMinted' (BlockRewardAuRa.sol#604-610) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n",
                    "message": "Parameter '_amount' of BlockRewardBase._setMinted (BlockRewardAuRa.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n",
                    "message": "Parameter '_account' of BlockRewardBase._setMinted (BlockRewardAuRa.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n",
                    "message": "Parameter '_bridge' of BlockRewardBase._setMinted (BlockRewardAuRa.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": 682,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n\n        uint256 validatorStake = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, _stakingAddress);\n\n        uint256 totalStaked = _stakingContract.stakeAmountTotalMinusOrderedWithdraw(_stakingAddress);\n\n        uint256 delegatorsAmount = totalStaked >= validatorStake ? totalStaked - validatorStake : 0;\n\n        bool validatorHasMore30Per = validatorStake * 7 > delegatorsAmount * 3;\n\n\n\n        address[] memory delegators = _stakingContract.poolDelegators(_stakingAddress);\n\n        uint256 rewardPercent;\n\n\n\n        address[] storage stakers = addressArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_STAKERS, _stakingAddress\n\n        ))];\n\n\n\n        uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_REWARD_PERCENTS, _stakingAddress\n\n        ))];\n\n\n\n        if (_offset == 0) {\n\n            // Calculate reward percent for validator\n\n            rewardPercent = 0;\n\n            if (validatorStake != 0 && totalStaked != 0) {\n\n                if (validatorHasMore30Per) {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * validatorStake / totalStaked;\n\n                } else {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * 3 / 10;\n\n                }\n\n            }\n\n            stakers.push(_stakingAddress);\n\n            rewardPercents.push(rewardPercent);\n\n            addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES].push(_stakingAddress);\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] += totalStaked;\n\n        }\n\n\n\n        uint256 from = _offset * delegators.length / DELEGATORS_ALIQUOT;\n\n        uint256 to = (_offset + 1) * delegators.length / DELEGATORS_ALIQUOT;\n\n\n\n        if (_offset == 0) {\n\n            to += delegators.length % DELEGATORS_ALIQUOT;\n\n        } else {\n\n            from += delegators.length % DELEGATORS_ALIQUOT;\n\n        }\n\n\n\n        // Calculate reward percent for each delegator\n\n        for (uint256 i = from; i < to; i++) {\n\n            rewardPercent = 0;\n\n\n\n            if (validatorHasMore30Per) {\n\n                if (totalStaked != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent / totalStaked;\n\n                }\n\n            } else {\n\n                if (delegatorsAmount != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent * 7 / (delegatorsAmount * 10);\n\n                }\n\n            }\n\n\n\n            stakers.push(delegators[i]);\n\n            rewardPercents.push(rewardPercent);\n\n        }\n",
                    "message": "Function 'BlockRewardBase._setSnapshot' (BlockRewardAuRa.sol#621-682) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n",
                    "message": "Parameter '_stakingAddress' of BlockRewardBase._setSnapshot (BlockRewardAuRa.sol#621) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n",
                    "message": "Parameter '_stakingContract' of BlockRewardBase._setSnapshot (BlockRewardAuRa.sol#621) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n",
                    "message": "Parameter '_offset' of BlockRewardBase._setSnapshot (BlockRewardAuRa.sol#621) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 699,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IERC20Minting.balanceOf (BlockRewardAuRa.sol#699) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 708,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(uint256, address) external;\n",
                    "message": "Parameter '' of IRandomAuRa.initialize (BlockRewardAuRa.sol#708) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 708,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(uint256, address) external;\n",
                    "message": "Parameter '_scope_0' of IRandomAuRa.initialize (BlockRewardAuRa.sol#708) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHashCallable(address, bytes32) external view returns(bool);\n",
                    "message": "Parameter '' of IRandomAuRa.commitHashCallable (BlockRewardAuRa.sol#710) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHashCallable(address, bytes32) external view returns(bool);\n",
                    "message": "Parameter '_scope_0' of IRandomAuRa.commitHashCallable (BlockRewardAuRa.sol#710) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 711,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSecretCallable(address, uint256) external view returns(bool);\n",
                    "message": "Parameter '' of IRandomAuRa.revealSecretCallable (BlockRewardAuRa.sol#711) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 711,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSecretCallable(address, uint256) external view returns(bool);\n",
                    "message": "Parameter '_scope_0' of IRandomAuRa.revealSecretCallable (BlockRewardAuRa.sol#711) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 721,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IStakingAuRa.initialize (BlockRewardAuRa.sol#721) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_0' of IStakingAuRa.initialize (BlockRewardAuRa.sol#722) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 723,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_1' of IStakingAuRa.initialize (BlockRewardAuRa.sol#723) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 724,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_2' of IStakingAuRa.initialize (BlockRewardAuRa.sol#724) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 725,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_3' of IStakingAuRa.initialize (BlockRewardAuRa.sol#725) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_4' of IStakingAuRa.initialize (BlockRewardAuRa.sol#726) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_5' of IStakingAuRa.initialize (BlockRewardAuRa.sol#727) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 728,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_6' of IStakingAuRa.initialize (BlockRewardAuRa.sol#728) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 730,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingEpochStartBlock(uint256) external;\n",
                    "message": "Parameter '' of IStakingAuRa.setStakingEpochStartBlock (BlockRewardAuRa.sol#730) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 742,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeMaliciousValidator(address) external;\n",
                    "message": "Parameter '' of IValidatorSetAuRa.removeMaliciousValidator (BlockRewardAuRa.sol#742) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 743,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '' of IValidatorSetAuRa.reportMaliciousCallable (BlockRewardAuRa.sol#743) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 743,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '_scope_0' of IValidatorSetAuRa.reportMaliciousCallable (BlockRewardAuRa.sol#743) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 743,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '_scope_1' of IValidatorSetAuRa.reportMaliciousCallable (BlockRewardAuRa.sol#743) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 883,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpoch,\n",
                    "message": "Parameter '_stakingEpoch' of BlockRewardAuRa.getBlocksCreated (BlockRewardAuRa.sol#883) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 884,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _validatorMiningAddress\n",
                    "message": "Parameter '_validatorMiningAddress' of BlockRewardAuRa.getBlocksCreated (BlockRewardAuRa.sol#884) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpoch,\n",
                    "message": "Parameter '_stakingEpoch' of BlockRewardAuRa.getEpochPoolNativeReward (BlockRewardAuRa.sol#894) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 895,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _poolStakingAddress\n",
                    "message": "Parameter '_poolStakingAddress' of BlockRewardAuRa.getEpochPoolNativeReward (BlockRewardAuRa.sol#895) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 907,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpoch,\n",
                    "message": "Parameter '_stakingEpoch' of BlockRewardAuRa.getEpochPoolTokenReward (BlockRewardAuRa.sol#907) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 908,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _poolStakingAddress\n",
                    "message": "Parameter '_poolStakingAddress' of BlockRewardAuRa.getEpochPoolTokenReward (BlockRewardAuRa.sol#908) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": 1138,
                    "vulnerability_code": "    function _distributeRewards(\n\n        IValidatorSet _validatorSetContract,\n\n        address _erc20TokenContract,\n\n        bool _erc20Restricted,\n\n        IStakingAuRa _stakingContract,\n\n        uint256 _stakingEpoch,\n\n        uint256 _rewardPointBlock\n\n    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n\n        uint256 i;\n\n        uint256 j;\n\n\n\n        receivers = new address[](0);\n\n        rewards = new uint256[](0);\n\n        noop = true;\n\n\n\n        if (block.number == _rewardPointBlock - 1) {\n\n            boolStorage[IS_REWARDING] = true;\n\n        } else if (block.number == _rewardPointBlock) {\n\n            address[] memory validators = _validatorSetContract.getValidators();\n\n            uint256[] memory ratio = new uint256[](validators.length);\n\n\n\n            uint256 totalReward;\n\n            bool isRewarding = false;\n\n\n\n            totalReward = uintStorage[BRIDGE_TOKEN_FEE];\n\n\n\n            if (!_erc20Restricted) {\n\n                // Accumulated bridge fee plus token inflation\n\n                uint256 inflationPercent;\n\n                if (_stakingEpoch <= 24) {\n\n                    inflationPercent = 32;\n\n                } else if (_stakingEpoch <= 48) {\n\n                    inflationPercent = 16;\n\n                } else if (_stakingEpoch <= 72) {\n\n                    inflationPercent = 8;\n\n                } else {\n\n                    inflationPercent = 4;\n\n                }\n\n                totalReward += snapshotTotalStakeAmount() * inflationPercent / 4800;\n\n            }\n\n\n\n            if (\n\n                totalReward != 0 && _erc20TokenContract != address(0) ||\n\n                uintStorage[BRIDGE_NATIVE_FEE] != 0 ||\n\n                _erc20Restricted\n\n            ) {\n\n                j = 0;\n\n                for (i = 0; i < validators.length; i++) {\n\n                    ratio[i] = uintStorage[keccak256(abi.encode(\n\n                        BLOCKS_CREATED, _stakingEpoch, validators[i]\n\n                    ))];\n\n                    j += ratio[i];\n\n                    validators[i] = _validatorSetContract.stakingByMiningAddress(validators[i]);\n\n                }\n\n                if (j != 0) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        ratio[i] = REWARD_PERCENT_MULTIPLIER * ratio[i] / j;\n\n                    }\n\n                }\n\n            }\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_TOKEN_FEE] = 0;\n\n\n\n                totalReward += uintStorage[TOKEN_REWARD_UNDISTRIBUTED];\n\n\n\n                if (_erc20TokenContract != address(0)) {\n\n                    for (i = 0; i < validators.length; i++) {\n\n                        uintStorage[keccak256(abi.encode(\n\n                            EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, validators[i]\n\n                        ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    }\n\n                    isRewarding = true;\n\n                }\n\n\n\n                uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            totalReward = uintStorage[BRIDGE_NATIVE_FEE];\n\n\n\n            if (_erc20Restricted) {\n\n                // Accumulated bridge fee plus 2.5% per year coin inflation\n\n                totalReward += _stakingContract.stakingEpochDuration() * 1 ether;\n\n            }\n\n\n\n            if (totalReward != 0) {\n\n                uintStorage[BRIDGE_NATIVE_FEE] = 0;\n\n\n\n                totalReward += uintStorage[NATIVE_REWARD_UNDISTRIBUTED];\n\n\n\n                for (i = 0; i < validators.length; i++) {\n\n                    uintStorage[keccak256(abi.encode(\n\n                        EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, validators[i]\n\n                    ))] = totalReward * ratio[i] / REWARD_PERCENT_MULTIPLIER;\n\n                }\n\n                isRewarding = true;\n\n\n\n                uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = totalReward;\n\n            }\n\n\n\n            if (isRewarding) {\n\n                for (i = 0; i < validators.length; i++) {\n\n                    _enqueueValidator(validators[i]);\n\n                }\n\n                if (validators.length == 0) {\n\n                    boolStorage[IS_REWARDING] = false;\n\n                }\n\n            } else {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            noop = false;\n\n        } else if (block.number > _rewardPointBlock) {\n\n            address stakingAddress = _dequeueValidator();\n\n\n\n            if (stakingAddress == address(0)) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            if (_validatorsQueueSize() == 0) {\n\n                boolStorage[IS_REWARDING] = false;\n\n            }\n\n\n\n            if (_validatorSetContract.isValidatorBanned(_validatorSetContract.miningByStakingAddress(stakingAddress))) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            address[] storage stakers = addressArrayStorage[keccak256(abi.encode(SNAPSHOT_STAKERS, stakingAddress))];\n\n            uint256[] memory range = new uint256[](3); // array instead of local vars because the stack is too deep\n\n            range[0] = (_validatorsQueueSize() + 1) % DELEGATORS_ALIQUOT; // offset\n\n            range[1] = range[0] * stakers.length / DELEGATORS_ALIQUOT; // from\n\n            range[2] = (range[0] + 1) * stakers.length / DELEGATORS_ALIQUOT; // to\n\n\n\n            if (range[0] == 0) {\n\n                range[2] += stakers.length % DELEGATORS_ALIQUOT;\n\n            } else {\n\n                range[1] += stakers.length % DELEGATORS_ALIQUOT;\n\n            }\n\n\n\n            if (range[1] >= range[2]) {\n\n                return (receivers, rewards, true);\n\n            }\n\n\n\n            uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n                SNAPSHOT_REWARD_PERCENTS, stakingAddress\n\n            ))];\n\n            uint256 accrued;\n\n            uint256 poolReward;\n\n\n\n            receivers = new address[](range[2] - range[1]);\n\n            rewards = new uint256[](receivers.length);\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_TOKEN_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                IERC20Minting(_erc20TokenContract).mintReward(receivers, rewards);\n\n                _subTokenRewardUndistributed(accrued);\n\n                noop = false;\n\n            }\n\n\n\n            poolReward = uintStorage[keccak256(abi.encode(\n\n                EPOCH_POOL_NATIVE_REWARD, _stakingEpoch, stakingAddress\n\n            ))];\n\n            if (poolReward != 0) {\n\n                accrued = 0;\n\n                for (i = range[1]; i < range[2]; i++) {\n\n                    j = i - range[1];\n\n                    receivers[j] = stakers[i];\n\n                    rewards[j] = poolReward * rewardPercents[i] / REWARD_PERCENT_MULTIPLIER;\n\n                    accrued += rewards[j];\n\n                }\n\n                _subNativeRewardUndistributed(accrued);\n\n                noop = false;\n\n            } else {\n\n                return (new address[](0), new uint256[](0), noop);\n\n            }\n\n        }\n",
                    "message": "Function 'BlockRewardAuRa._distributeRewards' (BlockRewardAuRa.sol#954-1138) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 955,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet _validatorSetContract,\n",
                    "message": "Parameter '_validatorSetContract' of BlockRewardAuRa._distributeRewards (BlockRewardAuRa.sol#955) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 956,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _erc20TokenContract,\n",
                    "message": "Parameter '_erc20TokenContract' of BlockRewardAuRa._distributeRewards (BlockRewardAuRa.sol#956) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _erc20Restricted,\n",
                    "message": "Parameter '_erc20Restricted' of BlockRewardAuRa._distributeRewards (BlockRewardAuRa.sol#957) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 958,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IStakingAuRa _stakingContract,\n",
                    "message": "Parameter '_stakingContract' of BlockRewardAuRa._distributeRewards (BlockRewardAuRa.sol#958) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _stakingEpoch,\n",
                    "message": "Parameter '_stakingEpoch' of BlockRewardAuRa._distributeRewards (BlockRewardAuRa.sol#959) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 960,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _rewardPointBlock\n",
                    "message": "Parameter '_rewardPointBlock' of BlockRewardAuRa._distributeRewards (BlockRewardAuRa.sol#960) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1143,
                    "vulnerability_to_line": 1155,
                    "vulnerability_code": "    function _dequeueValidator() internal returns(address validatorStakingAddress) {\n\n        uint256 queueFirst = uintStorage[QUEUE_V_FIRST];\n\n        uint256 queueLast = uintStorage[QUEUE_V_LAST];\n\n\n\n        if (queueLast < queueFirst) {\n\n            validatorStakingAddress = address(0);\n\n        } else {\n\n            bytes32 hash = keccak256(abi.encode(QUEUE_V_LIST, queueFirst));\n\n            validatorStakingAddress = addressStorage[hash];\n\n            delete addressStorage[hash];\n\n            uintStorage[QUEUE_V_FIRST]++;\n\n        }\n",
                    "message": "Function 'BlockRewardAuRa._dequeueValidator' (BlockRewardAuRa.sol#1143-1155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1160,
                    "vulnerability_to_line": 1166,
                    "vulnerability_code": "    function _enqueueValidator(address _validatorStakingAddress) internal {\n\n        uint256 queueLast = uintStorage[QUEUE_V_LAST];\n\n        for (uint256 i = 0; i < DELEGATORS_ALIQUOT; i++) {\n\n            addressStorage[keccak256(abi.encode(QUEUE_V_LIST, ++queueLast))] = _validatorStakingAddress;\n\n        }\n\n        uintStorage[QUEUE_V_LAST] = queueLast;\n",
                    "message": "Function 'BlockRewardAuRa._enqueueValidator' (BlockRewardAuRa.sol#1160-1166) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _enqueueValidator(address _validatorStakingAddress) internal {\n",
                    "message": "Parameter '_validatorStakingAddress' of BlockRewardAuRa._enqueueValidator (BlockRewardAuRa.sol#1160) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1171,
                    "vulnerability_to_line": 1177,
                    "vulnerability_code": "    function _subNativeRewardUndistributed(uint256 _minus) internal {\n\n        if (uintStorage[NATIVE_REWARD_UNDISTRIBUTED] < _minus) {\n\n            uintStorage[NATIVE_REWARD_UNDISTRIBUTED] = 0;\n\n        } else {\n\n            uintStorage[NATIVE_REWARD_UNDISTRIBUTED] -= _minus;\n\n        }\n",
                    "message": "Function 'BlockRewardAuRa._subNativeRewardUndistributed' (BlockRewardAuRa.sol#1171-1177) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _subNativeRewardUndistributed(uint256 _minus) internal {\n",
                    "message": "Parameter '_minus' of BlockRewardAuRa._subNativeRewardUndistributed (BlockRewardAuRa.sol#1171) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": 1188,
                    "vulnerability_code": "    function _subTokenRewardUndistributed(uint256 _minus) internal {\n\n        if (uintStorage[TOKEN_REWARD_UNDISTRIBUTED] < _minus) {\n\n            uintStorage[TOKEN_REWARD_UNDISTRIBUTED] = 0;\n\n        } else {\n\n            uintStorage[TOKEN_REWARD_UNDISTRIBUTED] -= _minus;\n\n        }\n",
                    "message": "Function 'BlockRewardAuRa._subTokenRewardUndistributed' (BlockRewardAuRa.sol#1182-1188) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _subTokenRewardUndistributed(uint256 _minus) internal {\n",
                    "message": "Parameter '_minus' of BlockRewardAuRa._subTokenRewardUndistributed (BlockRewardAuRa.sol#1182) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1195,
                    "vulnerability_to_line": 1200,
                    "vulnerability_code": "    function _rewardPointBlock(\n\n        IStakingAuRa _stakingContract,\n\n        IValidatorSet _validatorSetContract\n\n    ) internal view returns(uint256) {\n\n        return _stakingContract.stakingEpochEndBlock() - _validatorSetContract.MAX_VALIDATORS()*DELEGATORS_ALIQUOT - 1;\n",
                    "message": "Function 'BlockRewardAuRa._rewardPointBlock' (BlockRewardAuRa.sol#1195-1200) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IStakingAuRa _stakingContract,\n",
                    "message": "Parameter '_stakingContract' of BlockRewardAuRa._rewardPointBlock (BlockRewardAuRa.sol#1196) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet _validatorSetContract\n",
                    "message": "Parameter '_validatorSetContract' of BlockRewardAuRa._rewardPointBlock (BlockRewardAuRa.sol#1197) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1205,
                    "vulnerability_to_line": 1207,
                    "vulnerability_code": "    function _validatorsQueueSize() internal view returns(uint256) {\n\n        return uintStorage[QUEUE_V_LAST] + 1 - uintStorage[QUEUE_V_FIRST];\n",
                    "message": "Function 'BlockRewardAuRa._validatorsQueueSize' (BlockRewardAuRa.sol#1205-1207) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (BlockRewardAuRa.sol#84) is never used in BlockRewardAuRa\nEternalStorage.bytesStorage (BlockRewardAuRa.sol#86) is never used in BlockRewardAuRa\nEternalStorage.intStorage (BlockRewardAuRa.sol#88) is never used in BlockRewardAuRa\nEternalStorage.bytes32Storage (BlockRewardAuRa.sol#89) is never used in BlockRewardAuRa\nEternalStorage.stringArrayStorage (BlockRewardAuRa.sol#92) is never used in BlockRewardAuRa\nEternalStorage.bytesArrayStorage (BlockRewardAuRa.sol#94) is never used in BlockRewardAuRa\nEternalStorage.boolArrayStorage (BlockRewardAuRa.sol#95) is never used in BlockRewardAuRa\nEternalStorage.intArrayStorage (BlockRewardAuRa.sol#96) is never used in BlockRewardAuRa\nEternalStorage.bytes32ArrayStorage (BlockRewardAuRa.sol#97) is never used in BlockRewardAuRa\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == 0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 570,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            receiver = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bridge = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            validatorStakingAddress = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = extraLength; i < receivers.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 819,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1009,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1020,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1043,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 819,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint256 i = 0; i < newValidatorSet.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1009,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1020,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1043,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < validators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErcToNativeBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setNativeToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErcToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns(address[] memory receivers, uint256[] memory rewards)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _dequeueExtraReceiver() internal returns(uint256 amount, address receiver, address bridge) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 743,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 766,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns(address[] memory receiversNative, uint256[] memory rewardsNative)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 961,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) internal returns(address[] memory receivers, uint256[] memory rewards, bool noop) {\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/KeyGenHistory.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_38"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner (KeyGenHistory.sol#66) is never initialized. It is used in:\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": 199,
                    "vulnerability_code": "    function writePart(bytes memory _part) public onlyValidator {\n\n        IValidatorSet validatorSetContract = validatorSet();\n\n        IStaking stakingContract = IStaking(validatorSetContract.stakingContract());\n\n\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 changeRequestCount = validatorSetContract.changeRequestCount();\n\n\n\n        require(!validatorWrotePart(changeRequestCount, msg.sender));\n\n\n\n        _setValidatorWrotePart(changeRequestCount, msg.sender);\n\n\n\n        emit PartWritten(msg.sender, _part, stakingEpoch, changeRequestCount);\n",
                    "message": "Reentrancy in KeyGenHistory.writePart (KeyGenHistory.sol#187-199):\n\tExternal calls:\n\t- stakingContract = IStaking(validatorSetContract.stakingContract()) (KeyGenHistory.sol#189)\n\t- stakingEpoch = stakingContract.stakingEpoch() (KeyGenHistory.sol#191)\n\t- changeRequestCount = validatorSetContract.changeRequestCount() (KeyGenHistory.sol#192)\n\tState variables written after the call(s):\n\t- boolStorage (KeyGenHistory.sol#196)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (KeyGenHistory.sol#66)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": 183,
                    "vulnerability_code": "    function setValidatorSetContract(IValidatorSet _validatorSet) public onlyOwner {\n\n        require(address(validatorSet()) == address(0));\n\n        require(address(_validatorSet) != address(0));\n\n        addressStorage[VALIDATOR_SET] = address(_validatorSet);\n",
                    "message": "KeyGenHistory.setValidatorSetContract (KeyGenHistory.sol#179-183) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": 199,
                    "vulnerability_code": "    function writePart(bytes memory _part) public onlyValidator {\n\n        IValidatorSet validatorSetContract = validatorSet();\n\n        IStaking stakingContract = IStaking(validatorSetContract.stakingContract());\n\n\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 changeRequestCount = validatorSetContract.changeRequestCount();\n\n\n\n        require(!validatorWrotePart(changeRequestCount, msg.sender));\n\n\n\n        _setValidatorWrotePart(changeRequestCount, msg.sender);\n\n\n\n        emit PartWritten(msg.sender, _part, stakingEpoch, changeRequestCount);\n",
                    "message": "KeyGenHistory.writePart (KeyGenHistory.sol#187-199) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 211,
                    "vulnerability_code": "    function writeAck(bytes memory _ack) public onlyValidator {\n\n        IValidatorSet validatorSetContract = validatorSet();\n\n        IStaking stakingContract = IStaking(validatorSetContract.stakingContract());\n\n\n\n        uint256 stakingEpoch = stakingContract.stakingEpoch();\n\n        uint256 changeRequestCount = validatorSetContract.changeRequestCount();\n\n\n\n        emit AckWritten(msg.sender, _ack, stakingEpoch, changeRequestCount);\n",
                    "message": "KeyGenHistory.writeAck (KeyGenHistory.sol#203-211) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in KeyGenHistory.sol:\n\t- pragma solidity0.5.9 (KeyGenHistory.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (KeyGenHistory.sol#38): it allows old versions\n\t- pragma solidity0.5.9 (KeyGenHistory.sol#58): it allows old versions\n\t- pragma solidity0.5.9 (KeyGenHistory.sol#89): it allows old versions\n\t- pragma solidity0.5.9 (KeyGenHistory.sol#107): it allows old versions\n\t- pragma solidity0.5.9 (KeyGenHistory.sol#146): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (KeyGenHistory.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (KeyGenHistory.sol#9) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (KeyGenHistory.sol#10) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (KeyGenHistory.sol#11) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (KeyGenHistory.sol#12) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (KeyGenHistory.sol#13) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (KeyGenHistory.sol#16) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (KeyGenHistory.sol#16) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (KeyGenHistory.sol#23) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (KeyGenHistory.sol#24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (KeyGenHistory.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (KeyGenHistory.sol#26) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (KeyGenHistory.sol#27) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (KeyGenHistory.sol#29) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (KeyGenHistory.sol#32) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
                    "message": "Parameter '' of IStaking.clearUnremovableValidator (KeyGenHistory.sol#42) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address) external;\n",
                    "message": "Parameter '' of IStaking.removePool (KeyGenHistory.sol#44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "Parameter '' of IStaking.poolDelegators (KeyGenHistory.sol#50) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (KeyGenHistory.sol#51) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (KeyGenHistory.sol#51) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (KeyGenHistory.sol#52) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (KeyGenHistory.sol#66) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setValidatorSetContract(IValidatorSet _validatorSet) public onlyOwner {\n",
                    "message": "Parameter '_validatorSet' of KeyGenHistory.setValidatorSetContract (KeyGenHistory.sol#179) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writePart(bytes memory _part) public onlyValidator {\n",
                    "message": "Parameter '_part' of KeyGenHistory.writePart (KeyGenHistory.sol#187) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAck(bytes memory _ack) public onlyValidator {\n",
                    "message": "Parameter '_ack' of KeyGenHistory.writeAck (KeyGenHistory.sol#203) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorWrotePart(uint256 _changeRequestCount, address _validator) public view returns(bool) {\n",
                    "message": "Parameter '_changeRequestCount' of KeyGenHistory.validatorWrotePart (KeyGenHistory.sol#219) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorWrotePart(uint256 _changeRequestCount, address _validator) public view returns(bool) {\n",
                    "message": "Parameter '_validator' of KeyGenHistory.validatorWrotePart (KeyGenHistory.sol#219) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": 234,
                    "vulnerability_code": "    function _setValidatorWrotePart(uint256 _changeRequestCount, address _validator) internal {\n\n        boolStorage[\n\n            keccak256(abi.encode(VALIDATOR_WROTE_PART, _changeRequestCount, _validator))\n\n        ] = true;\n",
                    "message": "Function 'KeyGenHistory._setValidatorWrotePart' (KeyGenHistory.sol#230-234) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setValidatorWrotePart(uint256 _changeRequestCount, address _validator) internal {\n",
                    "message": "Parameter '_changeRequestCount' of KeyGenHistory._setValidatorWrotePart (KeyGenHistory.sol#230) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setValidatorWrotePart(uint256 _changeRequestCount, address _validator) internal {\n",
                    "message": "Parameter '_validator' of KeyGenHistory._setValidatorWrotePart (KeyGenHistory.sol#230) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => uint256) internal uintStorage;\n",
                    "message": "EternalStorage.uintStorage (KeyGenHistory.sol#69) is never used in KeyGenHistory\nEternalStorage.stringStorage (KeyGenHistory.sol#70) is never used in KeyGenHistory\nEternalStorage.bytesStorage (KeyGenHistory.sol#72) is never used in KeyGenHistory\nEternalStorage.intStorage (KeyGenHistory.sol#74) is never used in KeyGenHistory\nEternalStorage.bytes32Storage (KeyGenHistory.sol#75) is never used in KeyGenHistory\nEternalStorage.uintArrayStorage (KeyGenHistory.sol#77) is never used in KeyGenHistory\nEternalStorage.stringArrayStorage (KeyGenHistory.sol#78) is never used in KeyGenHistory\nEternalStorage.addressArrayStorage (KeyGenHistory.sol#79) is never used in KeyGenHistory\nEternalStorage.bytesArrayStorage (KeyGenHistory.sol#80) is never used in KeyGenHistory\nEternalStorage.boolArrayStorage (KeyGenHistory.sol#81) is never used in KeyGenHistory\nEternalStorage.intArrayStorage (KeyGenHistory.sol#82) is never used in KeyGenHistory\nEternalStorage.bytes32ArrayStorage (KeyGenHistory.sol#83) is never used in KeyGenHistory\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setValidatorSetContract(IValidatorSet _validatorSet) public onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/Registry.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _certifierContract, address _owner) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_certifierContract != address(0));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes32 serviceTransactionChecker = keccak256(\"service_transaction_checker\");\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        entries[serviceTransactionChecker].data[\"A\"] = bytes20(_certifierContract);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (_owner != address(0)) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner = _owner;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            entries[serviceTransactionChecker].owner = _owner;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            entries[serviceTransactionChecker].owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!entries[_name].deleted && entries[_name].owner == address(0));\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !entries[keccak256(bytes(_name))].deleted &&\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            entries[keccak256(bytes(_name))].owner != address(0)\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !entries[_name].deleted &&\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            entries[_name].owner != address(0)\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            entries[sha3Name].reverse != address(0) &&\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(reverses[entries[sha3Name].reverse])) == sha3Name\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delete reverses[entries[sha3Name].reverse];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            emit ReverseRemoved(_name, entries[sha3Name].reverse);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_35"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in Registry.sol:\n\t- pragma solidity0.5.9 (Registry.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (Registry.sol#27): it allows old versions\n\t- pragma solidity0.5.9 (Registry.sol#43): it allows old versions\n\t- pragma solidity0.5.9 (Registry.sol#73): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setOwner(address _new) external onlyOwner {\n",
                    "message": "Parameter '_new' of Owned.setOwner (Registry.sol#87) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getData(bytes32 _name, string calldata _key)\n",
                    "message": "Parameter '_name' of Registry.getData (Registry.sol#309) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getData(bytes32 _name, string calldata _key)\n",
                    "message": "Parameter '_key' of Registry.getData (Registry.sol#309) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAddress(bytes32 _name, string calldata _key)\n",
                    "message": "Parameter '_name' of Registry.getAddress (Registry.sol#318) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAddress(bytes32 _name, string calldata _key)\n",
                    "message": "Parameter '_key' of Registry.getAddress (Registry.sol#318) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 327,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getUint(bytes32 _name, string calldata _key)\n",
                    "message": "Parameter '_name' of Registry.getUint (Registry.sol#327) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 327,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getUint(bytes32 _name, string calldata _key)\n",
                    "message": "Parameter '_key' of Registry.getUint (Registry.sol#327) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getOwner(bytes32 _name)\n",
                    "message": "Parameter '_name' of Registry.getOwner (Registry.sol#337) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hasReverse(bytes32 _name)\n",
                    "message": "Parameter '_name' of Registry.hasReverse (Registry.sol#347) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getReverse(bytes32 _name)\n",
                    "message": "Parameter '_name' of Registry.getReverse (Registry.sol#356) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function canReverse(address _data)\n",
                    "message": "Parameter '_data' of Registry.canReverse (Registry.sol#365) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 373,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reverse(address _data)\n",
                    "message": "Parameter '_data' of Registry.reverse (Registry.sol#373) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _certifierContract, address _owner) public {\n",
                    "message": "Parameter '_certifierContract' of Registry. (Registry.sol#151) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _certifierContract, address _owner) public {\n",
                    "message": "Parameter '_owner' of Registry. (Registry.sol#151) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reserve(bytes32 _name)\n",
                    "message": "Parameter '_name' of Registry.reserve (Registry.sol#164) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(bytes32 _name, address _to)\n",
                    "message": "Parameter '_name' of Registry.transfer (Registry.sol#176) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(bytes32 _name, address _to)\n",
                    "message": "Parameter '_to' of Registry.transfer (Registry.sol#176) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function drop(bytes32 _name)\n",
                    "message": "Parameter '_name' of Registry.drop (Registry.sol#187) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setData(bytes32 _name, string calldata _key, bytes32 _value)\n",
                    "message": "Parameter '_name' of Registry.setData (Registry.sol#203) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setData(bytes32 _name, string calldata _key, bytes32 _value)\n",
                    "message": "Parameter '_key' of Registry.setData (Registry.sol#203) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setData(bytes32 _name, string calldata _key, bytes32 _value)\n",
                    "message": "Parameter '_value' of Registry.setData (Registry.sol#203) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setAddress(bytes32 _name, string calldata _key, address _value)\n",
                    "message": "Parameter '_name' of Registry.setAddress (Registry.sol#214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setAddress(bytes32 _name, string calldata _key, address _value)\n",
                    "message": "Parameter '_key' of Registry.setAddress (Registry.sol#214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setAddress(bytes32 _name, string calldata _key, address _value)\n",
                    "message": "Parameter '_value' of Registry.setAddress (Registry.sol#214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setUint(bytes32 _name, string calldata _key, uint _value)\n",
                    "message": "Parameter '_name' of Registry.setUint (Registry.sol#225) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setUint(bytes32 _name, string calldata _key, uint _value)\n",
                    "message": "Parameter '_key' of Registry.setUint (Registry.sol#225) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setUint(bytes32 _name, string calldata _key, uint _value)\n",
                    "message": "Parameter '_value' of Registry.setUint (Registry.sol#225) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function proposeReverse(string calldata _name, address _who)\n",
                    "message": "Parameter '_name' of Registry.proposeReverse (Registry.sol#237) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function proposeReverse(string calldata _name, address _who)\n",
                    "message": "Parameter '_who' of Registry.proposeReverse (Registry.sol#237) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function confirmReverse(string calldata _name)\n",
                    "message": "Parameter '_name' of Registry.confirmReverse (Registry.sol#256) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function confirmReverseAs(string calldata _name, address _who)\n",
                    "message": "Parameter '_name' of Registry.confirmReverseAs (Registry.sol#267) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function confirmReverseAs(string calldata _name, address _who)\n",
                    "message": "Parameter '_who' of Registry.confirmReverseAs (Registry.sol#267) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setFee(uint _amount)\n",
                    "message": "Parameter '_amount' of Registry.setFee (Registry.sol#288) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reserved(bytes32 _name)\n",
                    "message": "Parameter '_name' of Registry.reserved (Registry.sol#381) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Registry is Owned, IMetadataRegistry, IOwnerRegistry, IReverseRegistry {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setOwner(address _new) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setData(bytes32 _name, string calldata _key, bytes32 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setData(bytes32 _name, string calldata _key, bytes32 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setData(bytes32 _name, string calldata _key, bytes32 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        whenEntryRaw(_name)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        onlyOwnerOf(_name)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 207,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bool success)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        entries[_name].data[_key] = _value;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        entries[_name].data[_key] = _value;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit DataChanged(_name, _key, _key);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit DataChanged(_name, _key, _key);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit DataChanged(_name, _key, _key);\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/TxPermission.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                addressArrayStorage[ALLOWED_SENDERS].length--;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; _data.length >= 4 && i < 4; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < abiParams.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < abiParams.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _allowedSenders.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < allowedSendersLength; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < allowedSendersLength; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (validatorSet.isValidator(_sender) && _gasPrice > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // Let the validator's mining address send their accumulated tx fees to some wallet\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return (_sender.balance > 0 ? BASIC : NONE, false);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                addressArrayStorage[ALLOWED_SENDERS].length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _allowedSenders.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < allowedSendersLength; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; _data.length >= 4 && i < 4; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < abiParams.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < abiParams.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < allowedSendersLength; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": false,
            "errors": [
                "EXIT_CODE_255",
                "error parsing results: file could not be opened successfully:\n- method gz: ReadError('empty file')\n- method bz2: ReadError('not a bzip2 file')\n- method xz: ReadError('not an lzma file')\n- method tar: ReadError('empty file')"
            ],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return 0xfffffffffffffffe;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint32 internal constant ALL = 0xffffffff;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint32 internal constant BASIC = 0x01;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint32 internal constant CALL = 0x02;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint32 internal constant CREATE = 0x04;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint32 internal constant PRIVATE = 0x08;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                addressArrayStorage[ALLOWED_SENDERS].length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _allowedSenders.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; _data.length >= 4 && i < 4; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < abiParams.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < abiParams.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _allowedSenders.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < allowedSendersLength; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < abiParams.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (i = 0; i < abiParams.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < allowedSendersLength; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns(uint32 typesMask, bool cache)\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/StakingHBBFT.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _addPoolToBeRemoved(_poolStakingAddress);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 953,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            intStorage[POOLS_LIKELIHOOD_SUM] -= likelihood[indexToDelete];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 955,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (intStorage[POOLS_LIKELIHOOD_SUM] < 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 956,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                intStorage[POOLS_LIKELIHOOD_SUM] = 0;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 958,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools[indexToDelete] = pools[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            likelihood[indexToDelete] = likelihood[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 960,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolToBeElectedIndex(pools[indexToDelete], indexToDelete);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 961,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolToBeElectedIndex(_stakingAddress, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 975,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools[indexToDelete] = pools[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 976,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolToBeRemovedIndex(pools[indexToDelete], indexToDelete);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolToBeRemovedIndex(_stakingAddress, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 978,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 979,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 988,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 989,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools[indexToRemove] = pools[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 990,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolIndex(pools[indexToRemove], indexToRemove);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 991,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolIndex(_stakingAddress, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 992,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 993,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1009,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1010,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools[indexToRemove] = pools[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1011,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolInactiveIndex(pools[indexToRemove], indexToRemove);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1012,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolInactiveIndex(_stakingAddress, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1013,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1014,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators[indexToRemove] = delegators[delegators.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolDelegatorIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolDelegatorIndex(_poolStakingAddress, _delegator, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators[indexToRemove] = delegators[delegators.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolDelegatorInactiveIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolDelegatorInactiveIndex(_poolStakingAddress, _delegator, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 963,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            likelihood.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 978,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 992,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1013,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[STAKING_EPOCH]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_233"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": 396,
                    "vulnerability_code": "    function withdraw(address _fromPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n\n        address payable staker = msg.sender;\n\n        _withdraw(_fromPoolStakingAddress, staker, _amount);\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, _amount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(_amount);\n\n        }\n\n        emit Withdrawn(_fromPoolStakingAddress, staker, stakingEpoch(), _amount);\n",
                    "message": "StakingBase.withdraw (StakingHBBFT.sol#385-396) sends eth to arbitrary user\n\tDangerous calls:\n\t- staker.transfer(_amount) (StakingHBBFT.sol#393)\n"
                },
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n        uint256 epoch = stakingEpoch();\n\n        address payable staker = msg.sender;\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(epoch > orderWithdrawEpoch(_poolStakingAddress, staker));\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        uint256 claimAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n        require(claimAmount != 0);\n\n\n\n        uint256 resultingStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(claimAmount);\n\n\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, 0);\n\n        _setOrderedWithdrawAmountTotal(\n\n            _poolStakingAddress,\n\n            orderedWithdrawAmountTotal(_poolStakingAddress).sub(claimAmount)\n\n        );\n\n        _setStakeAmount(_poolStakingAddress, staker, resultingStakeAmount);\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(claimAmount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, claimAmount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(claimAmount);\n\n        }\n\n\n\n        emit Claimed(_poolStakingAddress, staker, epoch, claimAmount);\n",
                    "message": "StakingBase.claimOrderedWithdraw (StakingHBBFT.sol#480-517) sends eth to arbitrary user\n\tDangerous calls:\n\t- staker.transfer(claimAmount) (StakingHBBFT.sol#513)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner (StakingHBBFT.sol#97) is never initialized. It is used in:\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1024,
                    "vulnerability_to_line": 1056,
                    "vulnerability_code": "    function _initialize(\n\n        address _validatorSetContract,\n\n        address[] memory _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        bool _erc20Restricted\n\n    ) internal {\n\n        require(!isInitialized()); // initialization can only be done once\n\n        require(_validatorSetContract != address(0));\n\n        require(_initialStakingAddresses.length > 0);\n\n        require(_delegatorMinStake != 0);\n\n        require(_candidateMinStake != 0);\n\n\n\n        IBlockReward blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract());\n\n        require(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0);\n\n\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSetContract;\n\n\n\n        address unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator();\n\n\n\n        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n\n            require(_initialStakingAddresses[i] != address(0));\n\n            _addPoolActive(_initialStakingAddresses[i], false);\n\n            if (_initialStakingAddresses[i] != unremovableStakingAddress) {\n\n                _addPoolToBeRemoved(_initialStakingAddresses[i]);\n\n            }\n\n        }\n\n\n\n        _setDelegatorMinStake(_delegatorMinStake);\n\n        _setCandidateMinStake(_candidateMinStake);\n\n\n\n        boolStorage[ERC20_RESTRICTED] = _erc20Restricted;\n",
                    "message": "Reentrancy in StakingBase._initialize (StakingHBBFT.sol#1024-1056):\n\tExternal calls:\n\t- blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract()) (StakingHBBFT.sol#1037)\n\t- require(bool)(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0) (StakingHBBFT.sol#1038)\n\tState variables written after the call(s):\n\t- addressStorage (StakingHBBFT.sol#1040)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": 1333,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._stake (StakingHBBFT.sol#1296-1333):\n\tExternal calls:\n\t- poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress) (StakingHBBFT.sol#1298)\n\t- require(bool)(! validatorSet.isValidatorBanned(poolMiningAddress)) (StakingHBBFT.sol#1303)\n\t- _addPoolActive(_poolStakingAddress,_poolStakingAddress != validatorSet.unremovableValidator()) (StakingHBBFT.sol#1326)\n\tState variables written after the call(s):\n\t- intArrayStorage (StakingHBBFT.sol#1332)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": 1370,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n\n\n        // How much can `staker` withdraw from `_poolStakingAddress` at the moment?\n\n        require(_amount <= maxWithdrawAllowed(_poolStakingAddress, _staker));\n\n\n\n        uint256 currentStakeAmount = stakeAmount(_poolStakingAddress, _staker);\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, _staker);\n\n        uint256 resultingStakeAmount = currentStakeAmount.sub(alreadyOrderedAmount).sub(_amount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 minAllowedStake = (_poolStakingAddress == _staker) ? getCandidateMinStake() : getDelegatorMinStake();\n\n        require(resultingStakeAmount == 0 || resultingStakeAmount >= minAllowedStake);\n\n\n\n        _setStakeAmount(_poolStakingAddress, _staker, currentStakeAmount.sub(_amount));\n\n        uint256 amountByEpoch = stakeAmountByCurrentEpoch(_poolStakingAddress, _staker);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            amountByEpoch >= _amount ? amountByEpoch - _amount : 0\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(_amount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._withdraw (StakingHBBFT.sol#1340-1370):\n\tExternal calls:\n\t- require(bool)(_amount <= maxWithdrawAllowed(_poolStakingAddress,_staker)) (StakingHBBFT.sol#1345)\n\tState variables written after the call(s):\n\t- uintStorage (StakingHBBFT.sol#1356)\n\t- uintStorage (StakingHBBFT.sol#1363)\n\t- uintStorage (StakingHBBFT.sol#1358-1362)\n\t- uintStorage (StakingHBBFT.sol#1358-1362)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": 1370,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n\n\n        // How much can `staker` withdraw from `_poolStakingAddress` at the moment?\n\n        require(_amount <= maxWithdrawAllowed(_poolStakingAddress, _staker));\n\n\n\n        uint256 currentStakeAmount = stakeAmount(_poolStakingAddress, _staker);\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, _staker);\n\n        uint256 resultingStakeAmount = currentStakeAmount.sub(alreadyOrderedAmount).sub(_amount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 minAllowedStake = (_poolStakingAddress == _staker) ? getCandidateMinStake() : getDelegatorMinStake();\n\n        require(resultingStakeAmount == 0 || resultingStakeAmount >= minAllowedStake);\n\n\n\n        _setStakeAmount(_poolStakingAddress, _staker, currentStakeAmount.sub(_amount));\n\n        uint256 amountByEpoch = stakeAmountByCurrentEpoch(_poolStakingAddress, _staker);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            amountByEpoch >= _amount ? amountByEpoch - _amount : 0\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(_amount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._withdraw (StakingHBBFT.sol#1340-1370):\n\tExternal calls:\n\t- require(bool)(_amount <= maxWithdrawAllowed(_poolStakingAddress,_staker)) (StakingHBBFT.sol#1345)\n\t- _withdrawCheckPool(_poolStakingAddress,_staker) (StakingHBBFT.sol#1366)\n\tState variables written after the call(s):\n\t- intArrayStorage (StakingHBBFT.sol#1369)\n\t- intStorage (StakingHBBFT.sol#1369)\n\t- uintStorage (StakingHBBFT.sol#1366)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n        uint256 epoch = stakingEpoch();\n\n        address payable staker = msg.sender;\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(epoch > orderWithdrawEpoch(_poolStakingAddress, staker));\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        uint256 claimAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n        require(claimAmount != 0);\n\n\n\n        uint256 resultingStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(claimAmount);\n\n\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, 0);\n\n        _setOrderedWithdrawAmountTotal(\n\n            _poolStakingAddress,\n\n            orderedWithdrawAmountTotal(_poolStakingAddress).sub(claimAmount)\n\n        );\n\n        _setStakeAmount(_poolStakingAddress, staker, resultingStakeAmount);\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(claimAmount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, claimAmount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(claimAmount);\n\n        }\n\n\n\n        emit Claimed(_poolStakingAddress, staker, epoch, claimAmount);\n",
                    "message": "Reentrancy in StakingBase.claimOrderedWithdraw (StakingHBBFT.sol#480-517):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingHBBFT.sol#487)\n\tState variables written after the call(s):\n\t- uintStorage (StakingHBBFT.sol#494)\n\t- uintStorage (StakingHBBFT.sol#495-498)\n\t- uintStorage (StakingHBBFT.sol#499)\n\t- uintStorage (StakingHBBFT.sol#500)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n        uint256 epoch = stakingEpoch();\n\n        address payable staker = msg.sender;\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(epoch > orderWithdrawEpoch(_poolStakingAddress, staker));\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        uint256 claimAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n        require(claimAmount != 0);\n\n\n\n        uint256 resultingStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(claimAmount);\n\n\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, 0);\n\n        _setOrderedWithdrawAmountTotal(\n\n            _poolStakingAddress,\n\n            orderedWithdrawAmountTotal(_poolStakingAddress).sub(claimAmount)\n\n        );\n\n        _setStakeAmount(_poolStakingAddress, staker, resultingStakeAmount);\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(claimAmount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, claimAmount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(claimAmount);\n\n        }\n\n\n\n        emit Claimed(_poolStakingAddress, staker, epoch, claimAmount);\n",
                    "message": "Reentrancy in StakingBase.claimOrderedWithdraw (StakingHBBFT.sol#480-517):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingHBBFT.sol#487)\n\t- _withdrawCheckPool(_poolStakingAddress,staker) (StakingHBBFT.sol#503)\n\tState variables written after the call(s):\n\t- intArrayStorage (StakingHBBFT.sol#506)\n\t- intStorage (StakingHBBFT.sol#506)\n\t- uintStorage (StakingHBBFT.sol#503)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": 362,
                    "vulnerability_code": "    function moveStake(\n\n        address _fromPoolStakingAddress,\n\n        address _toPoolStakingAddress,\n\n        uint256 _amount\n\n    ) external gasPriceIsValid onlyInitialized {\n\n        require(_fromPoolStakingAddress != _toPoolStakingAddress);\n\n        address staker = msg.sender;\n\n        _withdraw(_fromPoolStakingAddress, staker, _amount);\n\n        _stake(_toPoolStakingAddress, staker, _amount);\n\n        emit StakeMoved(_fromPoolStakingAddress, _toPoolStakingAddress, staker, stakingEpoch(), _amount);\n",
                    "message": "Reentrancy in StakingBase.moveStake (StakingHBBFT.sol#352-362):\n\tExternal calls:\n\t- _withdraw(_fromPoolStakingAddress,staker,_amount) (StakingHBBFT.sol#359)\n\t- _stake(_toPoolStakingAddress,staker,_amount) (StakingHBBFT.sol#360)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingHBBFT.sol#360)\n\t- intArrayStorage (StakingHBBFT.sol#360)\n\t- intStorage (StakingHBBFT.sol#360)\n\t- uintStorage (StakingHBBFT.sol#360)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
                    "message": "Reentrancy in StakingBase.orderWithdraw (StakingHBBFT.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingHBBFT.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingHBBFT.sol#416)\n\tState variables written after the call(s):\n\t- uintStorage (StakingHBBFT.sol#428)\n\t- uintStorage (StakingHBBFT.sol#450)\n\t- uintStorage (StakingHBBFT.sol#453)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
                    "message": "Reentrancy in StakingBase.orderWithdraw (StakingHBBFT.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingHBBFT.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingHBBFT.sol#416)\n\t- unremovableStakingAddress = validatorSetContract.unremovableValidator() (StakingHBBFT.sol#436)\n\tState variables written after the call(s):\n\t- uintStorage (StakingHBBFT.sol#440)\n\t- uintStorage (StakingHBBFT.sol#443)\n\t- uintStorage (StakingHBBFT.sol#464)\n\t- uintStorage (StakingHBBFT.sol#469)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": 344,
                    "vulnerability_code": "    function removeMyPool() external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address stakingAddress = msg.sender;\n\n        address miningAddress = validatorSet.miningByStakingAddress(stakingAddress);\n\n        // initial validator cannot remove their pool during the initial staking epoch\n\n        require(stakingEpoch() > 0 || !validatorSet.isValidator(miningAddress));\n\n        require(stakingAddress != validatorSet.unremovableValidator());\n\n        _removePool(stakingAddress);\n",
                    "message": "Reentrancy in StakingBase.removeMyPool (StakingHBBFT.sol#336-344):\n\tExternal calls:\n\t- miningAddress = validatorSet.miningByStakingAddress(stakingAddress) (StakingHBBFT.sol#339)\n\t- require(bool)(stakingEpoch() > 0 || ! validatorSet.isValidator(miningAddress)) (StakingHBBFT.sol#341)\n\t- require(bool)(stakingAddress != validatorSet.unremovableValidator()) (StakingHBBFT.sol#342)\n\tState variables written after the call(s):\n\t- uintStorage (StakingHBBFT.sol#343)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
                    "message": "StakingBase.orderWithdraw.validatorSetContract (local variable @ StakingHBBFT.sol#407) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingHBBFT.sol#853-855)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
                    "message": "StakingBase.claimOrderedWithdraw.validatorSetContract (local variable @ StakingHBBFT.sol#481) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingHBBFT.sol#853-855)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 633,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
                    "message": "StakingBase.maxWithdrawAllowed.validatorSetContract (local variable @ StakingHBBFT.sol#633) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingHBBFT.sol#853-855)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
                    "message": "StakingBase.maxWithdrawOrderAllowed.validatorSetContract (local variable @ StakingHBBFT.sol#665) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingHBBFT.sol#853-855)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 1536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
                    "message": "StakingHBBFT._addPoolActive.validatorSetContract (local variable @ StakingHBBFT.sol#1536) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingHBBFT.sol#853-855)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1024,
                    "vulnerability_to_line": 1056,
                    "vulnerability_code": "    function _initialize(\n\n        address _validatorSetContract,\n\n        address[] memory _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        bool _erc20Restricted\n\n    ) internal {\n\n        require(!isInitialized()); // initialization can only be done once\n\n        require(_validatorSetContract != address(0));\n\n        require(_initialStakingAddresses.length > 0);\n\n        require(_delegatorMinStake != 0);\n\n        require(_candidateMinStake != 0);\n\n\n\n        IBlockReward blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract());\n\n        require(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0);\n\n\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSetContract;\n\n\n\n        address unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator();\n\n\n\n        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n\n            require(_initialStakingAddresses[i] != address(0));\n\n            _addPoolActive(_initialStakingAddresses[i], false);\n\n            if (_initialStakingAddresses[i] != unremovableStakingAddress) {\n\n                _addPoolToBeRemoved(_initialStakingAddresses[i]);\n\n            }\n\n        }\n\n\n\n        _setDelegatorMinStake(_delegatorMinStake);\n\n        _setCandidateMinStake(_candidateMinStake);\n\n\n\n        boolStorage[ERC20_RESTRICTED] = _erc20Restricted;\n",
                    "message": "Reentrancy in StakingBase._initialize (StakingHBBFT.sol#1024-1056):\n\tExternal calls:\n\t- blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract()) (StakingHBBFT.sol#1037)\n\t- require(bool)(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0) (StakingHBBFT.sol#1038)\n\t- unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator() (StakingHBBFT.sol#1042)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingHBBFT.sol#1046)\n\t- addressArrayStorage (StakingHBBFT.sol#1048)\n\t- boolStorage (StakingHBBFT.sol#1055)\n\t- intArrayStorage (StakingHBBFT.sol#1046)\n\t- intArrayStorage (StakingHBBFT.sol#1048)\n\t- intStorage (StakingHBBFT.sol#1048)\n\t- uintStorage (StakingHBBFT.sol#1046)\n\t- uintStorage (StakingHBBFT.sol#1048)\n\t- uintStorage (StakingHBBFT.sol#1052)\n\t- uintStorage (StakingHBBFT.sol#1053)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": 1333,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._stake (StakingHBBFT.sol#1296-1333):\n\tExternal calls:\n\t- poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress) (StakingHBBFT.sol#1298)\n\t- require(bool)(! validatorSet.isValidatorBanned(poolMiningAddress)) (StakingHBBFT.sol#1303)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingHBBFT.sol#1329)\n\t- uintStorage (StakingHBBFT.sol#1316)\n\t- uintStorage (StakingHBBFT.sol#1317-1321)\n\t- uintStorage (StakingHBBFT.sol#1322)\n\t- uintStorage (StakingHBBFT.sol#1329)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": 1333,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._stake (StakingHBBFT.sol#1296-1333):\n\tExternal calls:\n\t- poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress) (StakingHBBFT.sol#1298)\n\t- require(bool)(! validatorSet.isValidatorBanned(poolMiningAddress)) (StakingHBBFT.sol#1303)\n\t- _addPoolActive(_poolStakingAddress,_poolStakingAddress != validatorSet.unremovableValidator()) (StakingHBBFT.sol#1326)\n\tState variables written after the call(s):\n\t- intStorage (StakingHBBFT.sol#1332)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": 1391,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n\n        if (_staker == _poolStakingAddress) {\n\n            IValidatorSet validatorSet = validatorSetContract();\n\n            address unremovableStakingAddress = validatorSet.unremovableValidator();\n\n\n\n            if (_poolStakingAddress != unremovableStakingAddress) {\n\n                if (validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress))) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                } else {\n\n                    _removePool(_poolStakingAddress);\n\n                }\n\n            }\n\n        } else {\n\n            _removePoolDelegator(_poolStakingAddress, _staker);\n\n        }\n",
                    "message": "Reentrancy in StakingBase._withdrawCheckPool (StakingHBBFT.sol#1376-1391):\n\tExternal calls:\n\t- unremovableStakingAddress = validatorSet.unremovableValidator() (StakingHBBFT.sol#1379)\n\t- validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress)) (StakingHBBFT.sol#1382-1386)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingHBBFT.sol#1383)\n\t- intArrayStorage (StakingHBBFT.sol#1383)\n\t- intStorage (StakingHBBFT.sol#1383)\n\t- uintStorage (StakingHBBFT.sol#1383)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": 1391,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n\n        if (_staker == _poolStakingAddress) {\n\n            IValidatorSet validatorSet = validatorSetContract();\n\n            address unremovableStakingAddress = validatorSet.unremovableValidator();\n\n\n\n            if (_poolStakingAddress != unremovableStakingAddress) {\n\n                if (validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress))) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                } else {\n\n                    _removePool(_poolStakingAddress);\n\n                }\n\n            }\n\n        } else {\n\n            _removePoolDelegator(_poolStakingAddress, _staker);\n\n        }\n",
                    "message": "Reentrancy in StakingBase._withdrawCheckPool (StakingHBBFT.sol#1376-1391):\n\tExternal calls:\n\t- unremovableStakingAddress = validatorSet.unremovableValidator() (StakingHBBFT.sol#1379)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingHBBFT.sol#1385)\n\t- intArrayStorage (StakingHBBFT.sol#1385)\n\t- intStorage (StakingHBBFT.sol#1385)\n\t- uintStorage (StakingHBBFT.sol#1385)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
                    "message": "Reentrancy in StakingBase.orderWithdraw (StakingHBBFT.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingHBBFT.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingHBBFT.sol#416)\n\t- unremovableStakingAddress = validatorSetContract.unremovableValidator() (StakingHBBFT.sol#436)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingHBBFT.sol#440)\n\t- addressArrayStorage (StakingHBBFT.sol#443)\n\t- intArrayStorage (StakingHBBFT.sol#440)\n\t- intArrayStorage (StakingHBBFT.sol#443)\n\t- intArrayStorage (StakingHBBFT.sol#472)\n\t- intStorage (StakingHBBFT.sol#440)\n\t- intStorage (StakingHBBFT.sol#472)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
                    "message": "Reentrancy in StakingBase.orderWithdraw (StakingHBBFT.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingHBBFT.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingHBBFT.sol#416)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingHBBFT.sol#450)\n\t- addressArrayStorage (StakingHBBFT.sol#453)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": 344,
                    "vulnerability_code": "    function removeMyPool() external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address stakingAddress = msg.sender;\n\n        address miningAddress = validatorSet.miningByStakingAddress(stakingAddress);\n\n        // initial validator cannot remove their pool during the initial staking epoch\n\n        require(stakingEpoch() > 0 || !validatorSet.isValidator(miningAddress));\n\n        require(stakingAddress != validatorSet.unremovableValidator());\n\n        _removePool(stakingAddress);\n",
                    "message": "Reentrancy in StakingBase.removeMyPool (StakingHBBFT.sol#336-344):\n\tExternal calls:\n\t- miningAddress = validatorSet.miningByStakingAddress(stakingAddress) (StakingHBBFT.sol#339)\n\t- require(bool)(stakingEpoch() > 0 || ! validatorSet.isValidator(miningAddress)) (StakingHBBFT.sol#341)\n\t- require(bool)(stakingAddress != validatorSet.unremovableValidator()) (StakingHBBFT.sol#342)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingHBBFT.sol#343)\n\t- intArrayStorage (StakingHBBFT.sol#343)\n\t- intStorage (StakingHBBFT.sol#343)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (StakingHBBFT.sol#97)\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Different versions of Solidity is used in StakingHBBFT.sol:\n\t- Version used: ['0.5.9', 'ABIEncoderV2']\n\t- StakingHBBFT.sol#3 declares pragma solidity0.5.9\n\t- StakingHBBFT.sol#17 declares pragma solidity0.5.9\n\t- StakingHBBFT.sol#34 declares pragma solidity0.5.9\n\t- StakingHBBFT.sol#54 declares pragma solidity0.5.9\n\t- StakingHBBFT.sol#89 declares pragma solidity0.5.9\n\t- StakingHBBFT.sol#120 declares pragma solidity0.5.9\n\t- StakingHBBFT.sol#138 declares pragma solidity0.5.9\n\t- StakingHBBFT.sol#177 declares pragma solidity0.5.9\n\t- StakingHBBFT.sol#1440 declares pragma solidity0.5.9\n\t- StakingHBBFT.sol#1441 declares pragma experimentalABIEncoderV2\n\t- StakingHBBFT.sol#1452 declares pragma solidity0.5.9\n\t- StakingHBBFT.sol#1467 declares pragma solidity0.5.9\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": 598,
                    "vulnerability_code": "    function erc20Restricted() public view returns(bool) {\n\n        return boolStorage[ERC20_RESTRICTED];\n",
                    "message": "StakingBase.erc20Restricted (StakingHBBFT.sol#596-598) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function erc20Restricted() external view returns(bool);\n",
                    "message": "IStaking.erc20Restricted (StakingHBBFT.sol#41) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": 735,
                    "vulnerability_code": "    function poolDelegators(address _poolStakingAddress) public view returns(address[] memory) {\n\n        return addressArrayStorage[keccak256(abi.encode(POOL_DELEGATORS, _poolStakingAddress))];\n",
                    "message": "StakingBase.poolDelegators (StakingHBBFT.sol#733-735) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "IStaking.poolDelegators (StakingHBBFT.sol#46) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": 695,
                    "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n\n        return false;\n",
                    "message": "StakingBase.onTokenTransfer (StakingHBBFT.sol#693-695) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 741,
                    "vulnerability_to_line": 743,
                    "vulnerability_code": "    function poolDelegatorsInactive(address _poolStakingAddress) public view returns(address[] memory) {\n\n        return addressArrayStorage[keccak256(abi.encode(POOL_DELEGATORS_INACTIVE, _poolStakingAddress))];\n",
                    "message": "StakingBase.poolDelegatorsInactive (StakingHBBFT.sol#741-743) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in StakingHBBFT.sol:\n\t- pragma solidity0.5.9 (StakingHBBFT.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (StakingHBBFT.sol#17): it allows old versions\n\t- pragma solidity0.5.9 (StakingHBBFT.sol#34): it allows old versions\n\t- pragma solidity0.5.9 (StakingHBBFT.sol#54): it allows old versions\n\t- pragma solidity0.5.9 (StakingHBBFT.sol#89): it allows old versions\n\t- pragma solidity0.5.9 (StakingHBBFT.sol#120): it allows old versions\n\t- pragma solidity0.5.9 (StakingHBBFT.sol#138): it allows old versions\n\t- pragma solidity0.5.9 (StakingHBBFT.sol#177): it allows old versions\n\t- pragma solidity0.5.9 (StakingHBBFT.sol#1440): it allows old versions\n\t- pragma solidity0.5.9 (StakingHBBFT.sol#1452): it allows old versions\n\t- pragma solidity0.5.9 (StakingHBBFT.sol#1467): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address) external;\n",
                    "message": "Parameter '' of IBlockReward.initialize (StakingHBBFT.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function DELEGATORS_ALIQUOT() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IBlockReward.DELEGATORS_ALIQUOT' (StakingHBBFT.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IERC20Minting.balanceOf (StakingHBBFT.sol#29) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
                    "message": "Parameter '' of IStaking.clearUnremovableValidator (StakingHBBFT.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address) external;\n",
                    "message": "Parameter '' of IStaking.removePool (StakingHBBFT.sol#40) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "Parameter '' of IStaking.poolDelegators (StakingHBBFT.sol#46) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (StakingHBBFT.sol#47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (StakingHBBFT.sol#47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (StakingHBBFT.sol#48) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (StakingHBBFT.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (StakingHBBFT.sol#60) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (StakingHBBFT.sol#61) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (StakingHBBFT.sol#62) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (StakingHBBFT.sol#63) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (StakingHBBFT.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (StakingHBBFT.sol#67) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (StakingHBBFT.sol#67) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (StakingHBBFT.sol#74) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (StakingHBBFT.sol#75) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (StakingHBBFT.sol#76) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (StakingHBBFT.sol#77) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (StakingHBBFT.sol#78) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (StakingHBBFT.sol#80) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (StakingHBBFT.sol#83) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (StakingHBBFT.sol#97) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address _unremovableStakingAddress) external onlyValidatorSetContract {\n",
                    "message": "Parameter '_unremovableStakingAddress' of StakingBase.clearUnremovableValidator (StakingHBBFT.sol#308) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address _stakingAddress) external onlyValidatorSetContract {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.removePool (StakingHBBFT.sol#328) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address _poolStakingAddress) public view returns(address[] memory) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegators (StakingHBBFT.sol#733) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 829,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _poolStakingAddress,\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountMinusOrderedWithdraw (StakingHBBFT.sol#829) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 830,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _staker\n",
                    "message": "Parameter '_staker' of StakingBase.stakeAmountMinusOrderedWithdraw (StakingHBBFT.sol#830) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 841,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address _poolStakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountTotalMinusOrderedWithdraw (StakingHBBFT.sol#841) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _fromPoolStakingAddress,\n",
                    "message": "Parameter '_fromPoolStakingAddress' of StakingBase.moveStake (StakingHBBFT.sol#353) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _toPoolStakingAddress,\n",
                    "message": "Parameter '_toPoolStakingAddress' of StakingBase.moveStake (StakingHBBFT.sol#354) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _amount\n",
                    "message": "Parameter '_amount' of StakingBase.moveStake (StakingHBBFT.sol#355) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stake(address _toPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_toPoolStakingAddress' of StakingBase.stake (StakingHBBFT.sol#368) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stake(address _toPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_amount' of StakingBase.stake (StakingHBBFT.sol#368) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeNative(address _toPoolStakingAddress) external gasPriceIsValid onlyInitialized payable {\n",
                    "message": "Parameter '_toPoolStakingAddress' of StakingBase.stakeNative (StakingHBBFT.sol#375) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function withdraw(address _fromPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_fromPoolStakingAddress' of StakingBase.withdraw (StakingHBBFT.sol#385) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function withdraw(address _fromPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_amount' of StakingBase.withdraw (StakingHBBFT.sol#385) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.orderWithdraw (StakingHBBFT.sol#406) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_amount' of StakingBase.orderWithdraw (StakingHBBFT.sol#406) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.claimOrderedWithdraw (StakingHBBFT.sol#480) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErc20TokenContract(address _erc20TokenContract) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_erc20TokenContract' of StakingBase.setErc20TokenContract (StakingHBBFT.sol#522) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCandidateMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_minStake' of StakingBase.setCandidateMinStake (StakingHBBFT.sol#531) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setDelegatorMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_minStake' of StakingBase.setDelegatorMinStake (StakingHBBFT.sol#538) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isPoolActive(address _stakingAddress) public view returns(bool) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.isPoolActive (StakingHBBFT.sol#623) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function maxWithdrawAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.maxWithdrawAllowed (StakingHBBFT.sol#632) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function maxWithdrawAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.maxWithdrawAllowed (StakingHBBFT.sol#632) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function maxWithdrawOrderAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.maxWithdrawOrderAllowed (StakingHBBFT.sol#664) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function maxWithdrawOrderAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.maxWithdrawOrderAllowed (StakingHBBFT.sol#664) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n",
                    "message": "Parameter '' of StakingBase.onTokenTransfer (StakingHBBFT.sol#693) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n",
                    "message": "Parameter '_scope_0' of StakingBase.onTokenTransfer (StakingHBBFT.sol#693) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n",
                    "message": "Parameter '_scope_1' of StakingBase.onTokenTransfer (StakingHBBFT.sol#693) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderedWithdrawAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.orderedWithdrawAmount (StakingHBBFT.sol#701) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderedWithdrawAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.orderedWithdrawAmount (StakingHBBFT.sol#701) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 708,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderedWithdrawAmountTotal(address _poolStakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.orderedWithdrawAmountTotal (StakingHBBFT.sol#708) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderWithdrawEpoch(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.orderWithdrawEpoch (StakingHBBFT.sol#717) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderWithdrawEpoch(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.orderWithdrawEpoch (StakingHBBFT.sol#717) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 725,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotal(address _poolStakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountTotal (StakingHBBFT.sol#725) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 741,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorsInactive(address _poolStakingAddress) public view returns(address[] memory) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegatorsInactive (StakingHBBFT.sol#741) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 751,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegatorIndex (StakingHBBFT.sol#751) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 751,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
                    "message": "Parameter '_delegator' of StakingBase.poolDelegatorIndex (StakingHBBFT.sol#751) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegatorInactiveIndex (StakingHBBFT.sol#761) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
                    "message": "Parameter '_delegator' of StakingBase.poolDelegatorInactiveIndex (StakingHBBFT.sol#761) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 770,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolIndex(address _stakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.poolIndex (StakingHBBFT.sol#770) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolInactiveIndex(address _stakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.poolInactiveIndex (StakingHBBFT.sol#777) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolToBeElectedIndex(address _stakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.poolToBeElectedIndex (StakingHBBFT.sol#786) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolToBeRemovedIndex(address _stakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.poolToBeRemovedIndex (StakingHBBFT.sol#795) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmount (StakingHBBFT.sol#804) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.stakeAmount (StakingHBBFT.sol#804) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountByCurrentEpoch(address _poolStakingAddress, address _staker)\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountByCurrentEpoch (StakingHBBFT.sol#813) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountByCurrentEpoch(address _poolStakingAddress, address _staker)\n",
                    "message": "Parameter '_staker' of StakingBase.stakeAmountByCurrentEpoch (StakingHBBFT.sol#813) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 892,
                    "vulnerability_to_line": 903,
                    "vulnerability_code": "    function _addPoolActive(address _stakingAddress, bool _toBeElected) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS];\n\n        if (!isPoolActive(_stakingAddress)) {\n\n            _setPoolIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n            require(pools.length <= _getMaxCandidates());\n\n        }\n\n        _removePoolInactive(_stakingAddress);\n\n        if (_toBeElected) {\n\n            _addPoolToBeElected(_stakingAddress);\n\n        }\n",
                    "message": "Function 'StakingBase._addPoolActive' (StakingHBBFT.sol#892-903) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 892,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolActive(address _stakingAddress, bool _toBeElected) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._addPoolActive (StakingHBBFT.sol#892) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 892,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolActive(address _stakingAddress, bool _toBeElected) internal {\n",
                    "message": "Parameter '_toBeElected' of StakingBase._addPoolActive (StakingHBBFT.sol#892) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 908,
                    "vulnerability_to_line": 915,
                    "vulnerability_code": "    function _addPoolInactive(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_INACTIVE];\n\n        uint256 index = poolInactiveIndex(_stakingAddress);\n\n        if (index >= pools.length || pools[index] != _stakingAddress) {\n\n            _setPoolInactiveIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n        }\n",
                    "message": "Function 'StakingBase._addPoolInactive' (StakingHBBFT.sol#908-915) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 908,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolInactive(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._addPoolInactive (StakingHBBFT.sol#908) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 929,
                    "vulnerability_code": "    function _addPoolToBeElected(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_ELECTED];\n\n        uint256 index = poolToBeElectedIndex(_stakingAddress);\n\n        if (index >= pools.length || pools[index] != _stakingAddress) {\n\n            _setPoolToBeElectedIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n            intArrayStorage[POOLS_LIKELIHOOD].push(0);\n\n        }\n\n        _deletePoolToBeRemoved(_stakingAddress);\n",
                    "message": "Function 'StakingBase._addPoolToBeElected' (StakingHBBFT.sol#920-929) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolToBeElected(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._addPoolToBeElected (StakingHBBFT.sol#920) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": 942,
                    "vulnerability_code": "    function _addPoolToBeRemoved(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_REMOVED];\n\n        uint256 index = poolToBeRemovedIndex(_stakingAddress);\n\n        if (index >= pools.length || pools[index] != _stakingAddress) {\n\n            _setPoolToBeRemovedIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n        }\n\n        _deletePoolToBeElected(_stakingAddress);\n",
                    "message": "Function 'StakingBase._addPoolToBeRemoved' (StakingHBBFT.sol#934-942) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolToBeRemoved(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._addPoolToBeRemoved (StakingHBBFT.sol#934) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 948,
                    "vulnerability_to_line": 965,
                    "vulnerability_code": "    function _deletePoolToBeElected(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_ELECTED];\n\n        int256[] storage likelihood = intArrayStorage[POOLS_LIKELIHOOD];\n\n        if (pools.length != likelihood.length) return;\n\n        uint256 indexToDelete = poolToBeElectedIndex(_stakingAddress);\n\n        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n\n            intStorage[POOLS_LIKELIHOOD_SUM] -= likelihood[indexToDelete];\n\n            if (intStorage[POOLS_LIKELIHOOD_SUM] < 0) {\n\n                intStorage[POOLS_LIKELIHOOD_SUM] = 0;\n\n            }\n\n            pools[indexToDelete] = pools[pools.length - 1];\n\n            likelihood[indexToDelete] = likelihood[pools.length - 1];\n\n            _setPoolToBeElectedIndex(pools[indexToDelete], indexToDelete);\n\n            _setPoolToBeElectedIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n            likelihood.length--;\n\n        }\n",
                    "message": "Function 'StakingBase._deletePoolToBeElected' (StakingHBBFT.sol#948-965) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 948,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _deletePoolToBeElected(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._deletePoolToBeElected (StakingHBBFT.sol#948) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 971,
                    "vulnerability_to_line": 980,
                    "vulnerability_code": "    function _deletePoolToBeRemoved(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_REMOVED];\n\n        uint256 indexToDelete = poolToBeRemovedIndex(_stakingAddress);\n\n        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n\n            pools[indexToDelete] = pools[pools.length - 1];\n\n            _setPoolToBeRemovedIndex(pools[indexToDelete], indexToDelete);\n\n            _setPoolToBeRemovedIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n        }\n",
                    "message": "Function 'StakingBase._deletePoolToBeRemoved' (StakingHBBFT.sol#971-980) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 971,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _deletePoolToBeRemoved(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._deletePoolToBeRemoved (StakingHBBFT.sol#971) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 985,
                    "vulnerability_to_line": 1001,
                    "vulnerability_code": "    function _removePool(address _stakingAddress) internal {\n\n        uint256 indexToRemove = poolIndex(_stakingAddress);\n\n        address[] storage pools = addressArrayStorage[POOLS];\n\n        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n\n            pools[indexToRemove] = pools[pools.length - 1];\n\n            _setPoolIndex(pools[indexToRemove], indexToRemove);\n\n            _setPoolIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n        }\n\n        if (stakeAmountTotal(_stakingAddress) != 0) {\n\n            _addPoolInactive(_stakingAddress);\n\n        } else {\n\n            _removePoolInactive(_stakingAddress);\n\n        }\n\n        _deletePoolToBeElected(_stakingAddress);\n\n        _deletePoolToBeRemoved(_stakingAddress);\n",
                    "message": "Function 'StakingBase._removePool' (StakingHBBFT.sol#985-1001) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 985,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePool(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._removePool (StakingHBBFT.sol#985) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1006,
                    "vulnerability_to_line": 1015,
                    "vulnerability_code": "    function _removePoolInactive(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_INACTIVE];\n\n        uint256 indexToRemove = poolInactiveIndex(_stakingAddress);\n\n        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n\n            pools[indexToRemove] = pools[pools.length - 1];\n\n            _setPoolInactiveIndex(pools[indexToRemove], indexToRemove);\n\n            _setPoolInactiveIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n        }\n",
                    "message": "Function 'StakingBase._removePoolInactive' (StakingHBBFT.sol#1006-1015) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1006,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolInactive(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._removePoolInactive (StakingHBBFT.sol#1006) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1024,
                    "vulnerability_to_line": 1056,
                    "vulnerability_code": "    function _initialize(\n\n        address _validatorSetContract,\n\n        address[] memory _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        bool _erc20Restricted\n\n    ) internal {\n\n        require(!isInitialized()); // initialization can only be done once\n\n        require(_validatorSetContract != address(0));\n\n        require(_initialStakingAddresses.length > 0);\n\n        require(_delegatorMinStake != 0);\n\n        require(_candidateMinStake != 0);\n\n\n\n        IBlockReward blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract());\n\n        require(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0);\n\n\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSetContract;\n\n\n\n        address unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator();\n\n\n\n        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n\n            require(_initialStakingAddresses[i] != address(0));\n\n            _addPoolActive(_initialStakingAddresses[i], false);\n\n            if (_initialStakingAddresses[i] != unremovableStakingAddress) {\n\n                _addPoolToBeRemoved(_initialStakingAddresses[i]);\n\n            }\n\n        }\n\n\n\n        _setDelegatorMinStake(_delegatorMinStake);\n\n        _setCandidateMinStake(_candidateMinStake);\n\n\n\n        boolStorage[ERC20_RESTRICTED] = _erc20Restricted;\n",
                    "message": "Function 'StakingBase._initialize' (StakingHBBFT.sol#1024-1056) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1025,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _validatorSetContract,\n",
                    "message": "Parameter '_validatorSetContract' of StakingBase._initialize (StakingHBBFT.sol#1025) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1026,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _initialStakingAddresses,\n",
                    "message": "Parameter '_initialStakingAddresses' of StakingBase._initialize (StakingHBBFT.sol#1026) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1027,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _delegatorMinStake,\n",
                    "message": "Parameter '_delegatorMinStake' of StakingBase._initialize (StakingHBBFT.sol#1027) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1028,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _candidateMinStake,\n",
                    "message": "Parameter '_candidateMinStake' of StakingBase._initialize (StakingHBBFT.sol#1028) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1029,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _erc20Restricted\n",
                    "message": "Parameter '_erc20Restricted' of StakingBase._initialize (StakingHBBFT.sol#1029) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": 1067,
                    "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n\n        uintStorage[keccak256(abi.encode(ORDER_WITHDRAW_EPOCH, _poolStakingAddress, _staker))] = _stakingEpoch;\n",
                    "message": "Function 'StakingBase._setOrderWithdrawEpoch' (StakingHBBFT.sol#1065-1067) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setOrderWithdrawEpoch (StakingHBBFT.sol#1065) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._setOrderWithdrawEpoch (StakingHBBFT.sol#1065) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n",
                    "message": "Parameter '_stakingEpoch' of StakingBase._setOrderWithdrawEpoch (StakingHBBFT.sol#1065) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": 1076,
                    "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_DELEGATOR_INDEX, _poolStakingAddress, _delegator))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolDelegatorIndex' (StakingHBBFT.sol#1074-1076) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setPoolDelegatorIndex (StakingHBBFT.sol#1074) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._setPoolDelegatorIndex (StakingHBBFT.sol#1074) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolDelegatorIndex (StakingHBBFT.sol#1074) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": 1085,
                    "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_DELEGATOR_INACTIVE_INDEX, _poolStakingAddress, _delegator))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolDelegatorInactiveIndex' (StakingHBBFT.sol#1083-1085) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setPoolDelegatorInactiveIndex (StakingHBBFT.sol#1083) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._setPoolDelegatorInactiveIndex (StakingHBBFT.sol#1083) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolDelegatorInactiveIndex (StakingHBBFT.sol#1083) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1093,
                    "vulnerability_code": "    function _setPoolIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_INDEX, _stakingAddress))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolIndex' (StakingHBBFT.sol#1091-1093) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._setPoolIndex (StakingHBBFT.sol#1091) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolIndex (StakingHBBFT.sol#1091) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1099,
                    "vulnerability_to_line": 1101,
                    "vulnerability_code": "    function _setPoolInactiveIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_INACTIVE_INDEX, _stakingAddress))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolInactiveIndex' (StakingHBBFT.sol#1099-1101) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1099,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolInactiveIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._setPoolInactiveIndex (StakingHBBFT.sol#1099) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1099,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolInactiveIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolInactiveIndex (StakingHBBFT.sol#1099) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1108,
                    "vulnerability_to_line": 1110,
                    "vulnerability_code": "    function _setPoolToBeElectedIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_TO_BE_ELECTED_INDEX, _stakingAddress))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolToBeElectedIndex' (StakingHBBFT.sol#1108-1110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolToBeElectedIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._setPoolToBeElectedIndex (StakingHBBFT.sol#1108) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolToBeElectedIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolToBeElectedIndex (StakingHBBFT.sol#1108) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1117,
                    "vulnerability_to_line": 1119,
                    "vulnerability_code": "    function _setPoolToBeRemovedIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_TO_BE_REMOVED_INDEX, _stakingAddress))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolToBeRemovedIndex' (StakingHBBFT.sol#1117-1119) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolToBeRemovedIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._setPoolToBeRemovedIndex (StakingHBBFT.sol#1117) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolToBeRemovedIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolToBeRemovedIndex (StakingHBBFT.sol#1117) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": 1135,
                    "vulnerability_code": "    function _addPoolDelegator(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS, _poolStakingAddress))\n\n        ];\n\n        if (delegators.length == 0 || delegators[poolDelegatorIndex(_poolStakingAddress, _delegator)] != _delegator) {\n\n            _setPoolDelegatorIndex(_poolStakingAddress, _delegator, delegators.length);\n\n            delegators.push(_delegator);\n\n            require(delegators.length <= MAX_DELEGATORS_PER_POOL);\n\n        }\n\n        _removePoolDelegatorInactive(_poolStakingAddress, _delegator);\n",
                    "message": "Function 'StakingBase._addPoolDelegator' (StakingHBBFT.sol#1125-1135) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._addPoolDelegator (StakingHBBFT.sol#1125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._addPoolDelegator (StakingHBBFT.sol#1125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1141,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function _addPoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS_INACTIVE, _poolStakingAddress))\n\n        ];\n\n        if (\n\n            delegators.length == 0 ||\n\n            delegators[poolDelegatorInactiveIndex(_poolStakingAddress, _delegator)] != _delegator\n\n        ) {\n\n            _setPoolDelegatorInactiveIndex(_poolStakingAddress, _delegator, delegators.length);\n\n            delegators.push(_delegator);\n\n        }\n",
                    "message": "Function 'StakingBase._addPoolDelegatorInactive' (StakingHBBFT.sol#1141-1152) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._addPoolDelegatorInactive (StakingHBBFT.sol#1141) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._addPoolDelegatorInactive (StakingHBBFT.sol#1141) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": 1174,
                    "vulnerability_code": "    function _removePoolDelegator(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS, _poolStakingAddress))\n\n        ];\n\n        uint256 indexToRemove = poolDelegatorIndex(_poolStakingAddress, _delegator);\n\n        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n\n            delegators[indexToRemove] = delegators[delegators.length - 1];\n\n            _setPoolDelegatorIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n\n            _setPoolDelegatorIndex(_poolStakingAddress, _delegator, 0);\n\n            delegators.length--;\n\n        }\n\n        if (stakeAmount(_poolStakingAddress, _delegator) != 0) {\n\n            _addPoolDelegatorInactive(_poolStakingAddress, _delegator);\n\n        } else {\n\n            _removePoolDelegatorInactive(_poolStakingAddress, _delegator);\n\n        }\n",
                    "message": "Function 'StakingBase._removePoolDelegator' (StakingHBBFT.sol#1158-1174) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._removePoolDelegator (StakingHBBFT.sol#1158) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._removePoolDelegator (StakingHBBFT.sol#1158) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1180,
                    "vulnerability_to_line": 1191,
                    "vulnerability_code": "    function _removePoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS_INACTIVE, _poolStakingAddress))\n\n        ];\n\n        uint256 indexToRemove = poolDelegatorInactiveIndex(_poolStakingAddress, _delegator);\n\n        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n\n            delegators[indexToRemove] = delegators[delegators.length - 1];\n\n            _setPoolDelegatorInactiveIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n\n            _setPoolDelegatorInactiveIndex(_poolStakingAddress, _delegator, 0);\n\n            delegators.length--;\n\n        }\n",
                    "message": "Function 'StakingBase._removePoolDelegatorInactive' (StakingHBBFT.sol#1180-1191) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._removePoolDelegatorInactive (StakingHBBFT.sol#1180) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._removePoolDelegatorInactive (StakingHBBFT.sol#1180) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1197,
                    "vulnerability_to_line": 1207,
                    "vulnerability_code": "    function _setLikelihood(address _poolStakingAddress) internal {\n\n        (bool isToBeElected, uint256 index) = _isPoolToBeElected(_poolStakingAddress);\n\n\n\n        if (!isToBeElected) return;\n\n\n\n        int256 oldValue = intArrayStorage[POOLS_LIKELIHOOD][index];\n\n        int256 newValue = int256(stakeAmountTotalMinusOrderedWithdraw(_poolStakingAddress) * 100 / STAKE_UNIT);\n\n\n\n        intArrayStorage[POOLS_LIKELIHOOD][index] = newValue;\n\n        intStorage[POOLS_LIKELIHOOD_SUM] += newValue - oldValue;\n",
                    "message": "Function 'StakingBase._setLikelihood' (StakingHBBFT.sol#1197-1207) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setLikelihood(address _poolStakingAddress) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setLikelihood (StakingHBBFT.sol#1197) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1214,
                    "vulnerability_to_line": 1216,
                    "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(ORDERED_WITHDRAW_AMOUNT, _poolStakingAddress, _staker))] = _amount;\n",
                    "message": "Function 'StakingBase._setOrderedWithdrawAmount' (StakingHBBFT.sol#1214-1216) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setOrderedWithdrawAmount (StakingHBBFT.sol#1214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._setOrderedWithdrawAmount (StakingHBBFT.sol#1214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._setOrderedWithdrawAmount (StakingHBBFT.sol#1214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1222,
                    "vulnerability_to_line": 1224,
                    "vulnerability_code": "    function _setOrderedWithdrawAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(ORDERED_WITHDRAW_AMOUNT_TOTAL, _poolStakingAddress))] = _amount;\n",
                    "message": "Function 'StakingBase._setOrderedWithdrawAmountTotal' (StakingHBBFT.sol#1222-1224) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setOrderedWithdrawAmountTotal (StakingHBBFT.sol#1222) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._setOrderedWithdrawAmountTotal (StakingHBBFT.sol#1222) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": 1233,
                    "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(STAKE_AMOUNT, _poolStakingAddress, _staker))] = _amount;\n",
                    "message": "Function 'StakingBase._setStakeAmount' (StakingHBBFT.sol#1231-1233) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setStakeAmount (StakingHBBFT.sol#1231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._setStakeAmount (StakingHBBFT.sol#1231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._setStakeAmount (StakingHBBFT.sol#1231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1241,
                    "vulnerability_to_line": 1249,
                    "vulnerability_code": "    function _setStakeAmountByCurrentEpoch(\n\n        address _poolStakingAddress,\n\n        address _staker,\n\n        uint256 _amount\n\n    ) internal {\n\n        uintStorage[keccak256(abi.encode(\n\n            STAKE_AMOUNT_BY_EPOCH, _poolStakingAddress, _staker, stakingEpoch()\n\n        ))] = _amount;\n",
                    "message": "Function 'StakingBase._setStakeAmountByCurrentEpoch' (StakingHBBFT.sol#1241-1249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _poolStakingAddress,\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setStakeAmountByCurrentEpoch (StakingHBBFT.sol#1242) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _staker,\n",
                    "message": "Parameter '_staker' of StakingBase._setStakeAmountByCurrentEpoch (StakingHBBFT.sol#1243) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _amount\n",
                    "message": "Parameter '_amount' of StakingBase._setStakeAmountByCurrentEpoch (StakingHBBFT.sol#1244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1254,
                    "vulnerability_to_line": 1256,
                    "vulnerability_code": "    function _setStakeAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(STAKE_AMOUNT_TOTAL, _poolStakingAddress))] = _amount;\n",
                    "message": "Function 'StakingBase._setStakeAmountTotal' (StakingHBBFT.sol#1254-1256) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setStakeAmountTotal (StakingHBBFT.sol#1254) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._setStakeAmountTotal (StakingHBBFT.sol#1254) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": 1263,
                    "vulnerability_code": "    function _setDelegatorMinStake(uint256 _minStake) internal {\n\n        uintStorage[DELEGATOR_MIN_STAKE] = _minStake * STAKE_UNIT;\n",
                    "message": "Function 'StakingBase._setDelegatorMinStake' (StakingHBBFT.sol#1261-1263) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setDelegatorMinStake(uint256 _minStake) internal {\n",
                    "message": "Parameter '_minStake' of StakingBase._setDelegatorMinStake (StakingHBBFT.sol#1261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1268,
                    "vulnerability_to_line": 1270,
                    "vulnerability_code": "    function _setCandidateMinStake(uint256 _minStake) internal {\n\n        uintStorage[CANDIDATE_MIN_STAKE] = _minStake * STAKE_UNIT;\n",
                    "message": "Function 'StakingBase._setCandidateMinStake' (StakingHBBFT.sol#1268-1270) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCandidateMinStake(uint256 _minStake) internal {\n",
                    "message": "Parameter '_minStake' of StakingBase._setCandidateMinStake (StakingHBBFT.sol#1268) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1276,
                    "vulnerability_to_line": 1289,
                    "vulnerability_code": "    function _stake(address _toPoolStakingAddress, uint256 _amount) internal {\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            require(msg.value == 0);\n\n        }\n\n        address staker = msg.sender;\n\n        _stake(_toPoolStakingAddress, staker, _amount);\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.stake(staker, _amount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n        }\n\n        emit Staked(_toPoolStakingAddress, staker, stakingEpoch(), _amount);\n",
                    "message": "Function 'StakingBase._stake' (StakingHBBFT.sol#1276-1289) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _toPoolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_toPoolStakingAddress' of StakingBase._stake (StakingHBBFT.sol#1276) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _toPoolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._stake (StakingHBBFT.sol#1276) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": 1333,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Function 'StakingBase._stake' (StakingHBBFT.sol#1296-1333) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._stake (StakingHBBFT.sol#1296) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._stake (StakingHBBFT.sol#1296) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._stake (StakingHBBFT.sol#1296) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": 1370,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n\n\n        // How much can `staker` withdraw from `_poolStakingAddress` at the moment?\n\n        require(_amount <= maxWithdrawAllowed(_poolStakingAddress, _staker));\n\n\n\n        uint256 currentStakeAmount = stakeAmount(_poolStakingAddress, _staker);\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, _staker);\n\n        uint256 resultingStakeAmount = currentStakeAmount.sub(alreadyOrderedAmount).sub(_amount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 minAllowedStake = (_poolStakingAddress == _staker) ? getCandidateMinStake() : getDelegatorMinStake();\n\n        require(resultingStakeAmount == 0 || resultingStakeAmount >= minAllowedStake);\n\n\n\n        _setStakeAmount(_poolStakingAddress, _staker, currentStakeAmount.sub(_amount));\n\n        uint256 amountByEpoch = stakeAmountByCurrentEpoch(_poolStakingAddress, _staker);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            amountByEpoch >= _amount ? amountByEpoch - _amount : 0\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(_amount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Function 'StakingBase._withdraw' (StakingHBBFT.sol#1340-1370) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._withdraw (StakingHBBFT.sol#1340) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._withdraw (StakingHBBFT.sol#1340) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._withdraw (StakingHBBFT.sol#1340) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": 1391,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n\n        if (_staker == _poolStakingAddress) {\n\n            IValidatorSet validatorSet = validatorSetContract();\n\n            address unremovableStakingAddress = validatorSet.unremovableValidator();\n\n\n\n            if (_poolStakingAddress != unremovableStakingAddress) {\n\n                if (validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress))) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                } else {\n\n                    _removePool(_poolStakingAddress);\n\n                }\n\n            }\n\n        } else {\n\n            _removePoolDelegator(_poolStakingAddress, _staker);\n\n        }\n",
                    "message": "Function 'StakingBase._withdrawCheckPool' (StakingHBBFT.sol#1376-1391) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._withdrawCheckPool (StakingHBBFT.sol#1376) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._withdrawCheckPool (StakingHBBFT.sol#1376) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1394,
                    "vulnerability_to_line": 1396,
                    "vulnerability_code": "    function _getCurrentBlockNumber() internal view returns(uint256) {\n\n        return block.number;\n",
                    "message": "Function 'StakingBase._getCurrentBlockNumber' (StakingHBBFT.sol#1394-1396) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1400,
                    "vulnerability_to_line": 1402,
                    "vulnerability_code": "    function _getMaxCandidates() internal pure returns(uint256) {\n\n        return MAX_CANDIDATES;\n",
                    "message": "Function 'StakingBase._getMaxCandidates' (StakingHBBFT.sol#1400-1402) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1410,
                    "vulnerability_to_line": 1419,
                    "vulnerability_code": "    function _isPoolToBeElected(address _stakingAddress) internal view returns(bool toBeElected, uint256 index) {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_ELECTED];\n\n        if (pools.length != 0) {\n\n            index = poolToBeElectedIndex(_stakingAddress);\n\n            if (pools[index] == _stakingAddress) {\n\n                return (true, index);\n\n            }\n\n        }\n\n        return (false, 0);\n",
                    "message": "Function 'StakingBase._isPoolToBeElected' (StakingHBBFT.sol#1410-1419) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isPoolToBeElected(address _stakingAddress) internal view returns(bool toBeElected, uint256 index) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._isPoolToBeElected (StakingHBBFT.sol#1410) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": 1435,
                    "vulnerability_code": "    function _isWithdrawAllowed(address _miningAddress) internal view returns(bool) {\n\n        if (validatorSetContract().isValidatorBanned(_miningAddress)) {\n\n            // No one can withdraw from `_poolStakingAddress` until the ban is expired\n\n            return false;\n\n        }\n\n\n\n        if (!areStakeAndWithdrawAllowed()) {\n\n            return false;\n\n        }\n\n\n\n        return true;\n",
                    "message": "Function 'StakingBase._isWithdrawAllowed' (StakingHBBFT.sol#1424-1435) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isWithdrawAllowed(address _miningAddress) internal view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of StakingBase._isWithdrawAllowed (StakingHBBFT.sol#1424) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1445,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearMaliceReported(address) external;\n",
                    "message": "Parameter '' of IValidatorSetHBBFT.clearMaliceReported (StakingHBBFT.sol#1445) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initializePublicKeys(bytes[] calldata) external;\n",
                    "message": "Parameter '' of IValidatorSetHBBFT.initializePublicKeys (StakingHBBFT.sol#1446) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function savePublicKey(address, bytes calldata) external;\n",
                    "message": "Parameter '' of IValidatorSetHBBFT.savePublicKey (StakingHBBFT.sol#1447) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function savePublicKey(address, bytes calldata) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSetHBBFT.savePublicKey (StakingHBBFT.sol#1447) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IStakingHBBFT.initialize (StakingHBBFT.sol#1457) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_0' of IStakingHBBFT.initialize (StakingHBBFT.sol#1458) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1459,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_1' of IStakingHBBFT.initialize (StakingHBBFT.sol#1459) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_2' of IStakingHBBFT.initialize (StakingHBBFT.sol#1460) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_3' of IStakingHBBFT.initialize (StakingHBBFT.sol#1461) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _validatorSetContract,\n",
                    "message": "Parameter '_validatorSetContract' of StakingHBBFT.initialize (StakingHBBFT.sol#1510) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
                    "message": "Parameter '_initialStakingAddresses' of StakingHBBFT.initialize (StakingHBBFT.sol#1511) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _delegatorMinStake,\n",
                    "message": "Parameter '_delegatorMinStake' of StakingHBBFT.initialize (StakingHBBFT.sol#1512) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _candidateMinStake,\n",
                    "message": "Parameter '_candidateMinStake' of StakingHBBFT.initialize (StakingHBBFT.sol#1513) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _erc20Restricted\n",
                    "message": "Parameter '_erc20Restricted' of StakingHBBFT.initialize (StakingHBBFT.sol#1514) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1534,
                    "vulnerability_to_line": 1540,
                    "vulnerability_code": "    function _addPoolActive(address _stakingAddress, bool _toBeElected) internal {\n\n        super._addPoolActive(_stakingAddress, _toBeElected);\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n        IValidatorSetHBBFT(address(validatorSetContract)).clearMaliceReported(\n\n            validatorSetContract.miningByStakingAddress(_stakingAddress)\n\n        );\n",
                    "message": "Function 'StakingHBBFT._addPoolActive' (StakingHBBFT.sol#1534-1540) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolActive(address _stakingAddress, bool _toBeElected) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingHBBFT._addPoolActive (StakingHBBFT.sol#1534) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolActive(address _stakingAddress, bool _toBeElected) internal {\n",
                    "message": "Parameter '_toBeElected' of StakingHBBFT._addPoolActive (StakingHBBFT.sol#1534) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata _publicKey,\n",
                    "message": "Parameter '_publicKey' of StakingHBBFT.addPool (StakingHBBFT.sol#1478) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1479,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _amount,\n",
                    "message": "Parameter '_amount' of StakingHBBFT.addPool (StakingHBBFT.sol#1479) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1480,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _miningAddress\n",
                    "message": "Parameter '_miningAddress' of StakingHBBFT.addPool (StakingHBBFT.sol#1480) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata _publicKey,\n",
                    "message": "Parameter '_publicKey' of StakingHBBFT.addPoolNative (StakingHBBFT.sol#1493) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1494,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _miningAddress\n",
                    "message": "Parameter '_miningAddress' of StakingHBBFT.addPoolNative (StakingHBBFT.sol#1494) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (StakingHBBFT.sol#101) is never used in StakingHBBFT\nEternalStorage.bytesStorage (StakingHBBFT.sol#103) is never used in StakingHBBFT\nEternalStorage.bytes32Storage (StakingHBBFT.sol#106) is never used in StakingHBBFT\nEternalStorage.uintArrayStorage (StakingHBBFT.sol#108) is never used in StakingHBBFT\nEternalStorage.stringArrayStorage (StakingHBBFT.sol#109) is never used in StakingHBBFT\nEternalStorage.bytesArrayStorage (StakingHBBFT.sol#111) is never used in StakingHBBFT\nEternalStorage.boolArrayStorage (StakingHBBFT.sol#112) is never used in StakingHBBFT\nEternalStorage.bytes32ArrayStorage (StakingHBBFT.sol#114) is never used in StakingHBBFT\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 963,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            likelihood.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 978,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 992,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 1013,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 1167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 1471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract StakingHBBFT is IStakingHBBFT, StakingBase {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_MSGVALUE_EQUALS_ZERO",
                    "vulnerability_from_line": 1279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(msg.value == 0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErc20TokenContract(address _erc20TokenContract) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCandidateMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setDelegatorMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory likelihoods, int256 sum) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isPoolToBeElected(address _stakingAddress) internal view returns(bool toBeElected, uint256 index) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _delegatorMinStake,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _candidateMinStake,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _erc20Restricted\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1516,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        super._initialize(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _initialStakingAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _candidateMinStake,\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/RandomHBBFT.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _random.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _random.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _random.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_28"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner (RandomHBBFT.sol#55) is never initialized. It is used in:\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (RandomHBBFT.sol#55)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": 226,
                    "vulnerability_code": "    function storeRandom(uint256[] memory _random) public onlySystem onlyInitialized {\n\n        for (uint256 i = 0; i < _random.length; i++) {\n\n            _setCurrentSeed(_getCurrentSeed() ^ _random[i]);\n\n        }\n",
                    "message": "RandomHBBFT.storeRandom (RandomHBBFT.sol#222-226) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in RandomHBBFT.sol:\n\t- pragma solidity0.5.9 (RandomHBBFT.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (RandomHBBFT.sol#12): it allows old versions\n\t- pragma solidity0.5.9 (RandomHBBFT.sol#47): it allows old versions\n\t- pragma solidity0.5.9 (RandomHBBFT.sol#78): it allows old versions\n\t- pragma solidity0.5.9 (RandomHBBFT.sol#96): it allows old versions\n\t- pragma solidity0.5.9 (RandomHBBFT.sol#135): it allows old versions\n\t- pragma solidity0.5.9 (RandomHBBFT.sol#206): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (RandomHBBFT.sol#17) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (RandomHBBFT.sol#18) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (RandomHBBFT.sol#19) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (RandomHBBFT.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (RandomHBBFT.sol#21) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (RandomHBBFT.sol#22) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (RandomHBBFT.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (RandomHBBFT.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (RandomHBBFT.sol#32) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (RandomHBBFT.sol#33) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (RandomHBBFT.sol#34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (RandomHBBFT.sol#35) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (RandomHBBFT.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (RandomHBBFT.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (RandomHBBFT.sol#41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (RandomHBBFT.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": 189,
                    "vulnerability_code": "    function _initialize(address _validatorSet) internal {\n\n        require(!isInitialized());\n\n        require(_validatorSet != address(0));\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSet;\n",
                    "message": "Function 'RandomBase._initialize' (RandomHBBFT.sol#185-189) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _initialize(address _validatorSet) internal {\n",
                    "message": "Parameter '_validatorSet' of RandomBase._initialize (RandomHBBFT.sol#185) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": 195,
                    "vulnerability_code": "    function _setCurrentSeed(uint256 _seed) internal {\n\n        uintStorage[CURRENT_SEED] = _seed;\n",
                    "message": "Function 'RandomBase._setCurrentSeed' (RandomHBBFT.sol#193-195) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCurrentSeed(uint256 _seed) internal {\n",
                    "message": "Parameter '_seed' of RandomBase._setCurrentSeed (RandomHBBFT.sol#193) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": 200,
                    "vulnerability_code": "    function _getCurrentSeed() internal view returns(uint256) {\n\n        return uintStorage[CURRENT_SEED];\n",
                    "message": "Function 'RandomBase._getCurrentSeed' (RandomHBBFT.sol#198-200) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address _validatorSet) external {\n",
                    "message": "Parameter '_validatorSet' of RandomHBBFT.initialize (RandomHBBFT.sol#218) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function storeRandom(uint256[] memory _random) public onlySystem onlyInitialized {\n",
                    "message": "Parameter '_random' of RandomHBBFT.storeRandom (RandomHBBFT.sol#222) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (RandomHBBFT.sol#59) is never used in RandomHBBFT\nEternalStorage.bytesStorage (RandomHBBFT.sol#61) is never used in RandomHBBFT\nEternalStorage.boolStorage (RandomHBBFT.sol#62) is never used in RandomHBBFT\nEternalStorage.intStorage (RandomHBBFT.sol#63) is never used in RandomHBBFT\nEternalStorage.bytes32Storage (RandomHBBFT.sol#64) is never used in RandomHBBFT\nEternalStorage.uintArrayStorage (RandomHBBFT.sol#66) is never used in RandomHBBFT\nEternalStorage.stringArrayStorage (RandomHBBFT.sol#67) is never used in RandomHBBFT\nEternalStorage.addressArrayStorage (RandomHBBFT.sol#68) is never used in RandomHBBFT\nEternalStorage.bytesArrayStorage (RandomHBBFT.sol#69) is never used in RandomHBBFT\nEternalStorage.boolArrayStorage (RandomHBBFT.sol#70) is never used in RandomHBBFT\nEternalStorage.intArrayStorage (RandomHBBFT.sol#71) is never used in RandomHBBFT\nEternalStorage.bytes32ArrayStorage (RandomHBBFT.sol#72) is never used in RandomHBBFT\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == 0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _random.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _random.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/eternal-storage/EternalStorageProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _implementationAddress, address _ownerAddress) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (_implementationAddress != address(0)) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_isContract(_implementationAddress));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setImplementation(_implementationAddress);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (_ownerAddress != address(0)) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _owner = _ownerAddress;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            newVersion++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_17"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": 183,
                    "vulnerability_code": "    function _isContract(address _addr) private view returns(bool) {\n\n        uint256 size;\n\n        assembly { size := extcodesize(_addr) } // solhint-disable-line no-inline-assembly\n\n        return size != 0;\n",
                    "message": "EternalStorageProxy._isContract (EternalStorageProxy.sol#179-183) is declared view but contains assembly code\n"
                },
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 122,
                    "vulnerability_code": "    function() external payable {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n\n\n        assembly {\n\n            // Copy `msg.data`. We take full control of memory in this inline assembly\n\n            // block because it will not return to Solidity code. We overwrite the\n\n            // Solidity scratch pad at memory position 0\n\n            calldatacopy(0, 0, calldatasize)\n\n\n\n            // Call the implementation. Out and outsize are 0 because we don't know the size yet\n\n            let result := delegatecall(gas, _impl, 0, calldatasize, 0, 0)\n\n\n\n            // Copy the returned data\n\n            returndatacopy(0, 0, returndatasize)\n\n\n\n            switch result\n\n            // delegatecall returns 0 on error\n\n            case 0 { revert(0, returndatasize) }\n\n            default { return(0, returndatasize) }\n\n        }\n",
                    "message": "Contract locking ether found in EternalStorageProxy.sol:\n\tContract EternalStorageProxy has payable functions:\n\t - fallback (EternalStorageProxy.sol#101-122)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 122,
                    "vulnerability_code": "    function() external payable {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n\n\n        assembly {\n\n            // Copy `msg.data`. We take full control of memory in this inline assembly\n\n            // block because it will not return to Solidity code. We overwrite the\n\n            // Solidity scratch pad at memory position 0\n\n            calldatacopy(0, 0, calldatasize)\n\n\n\n            // Call the implementation. Out and outsize are 0 because we don't know the size yet\n\n            let result := delegatecall(gas, _impl, 0, calldatasize, 0, 0)\n\n\n\n            // Copy the returned data\n\n            returndatacopy(0, 0, returndatasize)\n\n\n\n            switch result\n\n            // delegatecall returns 0 on error\n\n            case 0 { revert(0, returndatasize) }\n\n            default { return(0, returndatasize) }\n\n        }\n",
                    "message": "EternalStorageProxy.fallback uses assembly (EternalStorageProxy.sol#101-122)\n\t- EternalStorageProxy.sol#105-121\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": 183,
                    "vulnerability_code": "    function _isContract(address _addr) private view returns(bool) {\n\n        uint256 size;\n\n        assembly { size := extcodesize(_addr) } // solhint-disable-line no-inline-assembly\n\n        return size != 0;\n",
                    "message": "EternalStorageProxy._isContract uses assembly (EternalStorageProxy.sol#179-183)\n\t- EternalStorageProxy.sol#181\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in EternalStorageProxy.sol:\n\t- pragma solidity0.5.9 (EternalStorageProxy.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (EternalStorageProxy.sol#34): it allows old versions\n\t- pragma solidity0.5.9 (EternalStorageProxy.sol#52): it allows old versions\n\t- pragma solidity0.5.9 (EternalStorageProxy.sol#61): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (EternalStorageProxy.sol#11) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeTo(address) external returns(bool);\n",
                    "message": "Parameter '' of IEternalStorageProxy.upgradeTo (EternalStorageProxy.sol#56) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeTo(address _newImplementation) external onlyOwner returns(bool) {\n",
                    "message": "Parameter '_newImplementation' of EternalStorageProxy.upgradeTo (EternalStorageProxy.sol#135) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _implementationAddress, address _ownerAddress) public {\n",
                    "message": "Parameter '_implementationAddress' of EternalStorageProxy. (EternalStorageProxy.sol#86) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _implementationAddress, address _ownerAddress) public {\n",
                    "message": "Parameter '_ownerAddress' of EternalStorageProxy. (EternalStorageProxy.sol#86) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address _newOwner) external onlyOwner {\n",
                    "message": "Parameter '_newOwner' of EternalStorageProxy.transferOwnership (EternalStorageProxy.sol#127) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": 183,
                    "vulnerability_code": "    function _isContract(address _addr) private view returns(bool) {\n\n        uint256 size;\n\n        assembly { size := extcodesize(_addr) } // solhint-disable-line no-inline-assembly\n\n        return size != 0;\n",
                    "message": "Function 'EternalStorageProxy._isContract' (EternalStorageProxy.sol#179-183) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": 189,
                    "vulnerability_code": "    function _setImplementation(address _implementationAddress) private {\n\n        addressStorage[IMPLEMENTATION] = _implementationAddress;\n",
                    "message": "Function 'EternalStorageProxy._setImplementation' (EternalStorageProxy.sol#187-189) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setImplementation(address _implementationAddress) private {\n",
                    "message": "Parameter '_implementationAddress' of EternalStorageProxy._setImplementation (EternalStorageProxy.sol#187) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": 195,
                    "vulnerability_code": "    function _setVersion(uint256 _newVersion) private {\n\n        uintStorage[VERSION] = _newVersion;\n",
                    "message": "Function 'EternalStorageProxy._setVersion' (EternalStorageProxy.sol#193-195) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setVersion(uint256 _newVersion) private {\n",
                    "message": "Parameter '_newVersion' of EternalStorageProxy._setVersion (EternalStorageProxy.sol#193) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (EternalStorageProxy.sol#15) is never used in EternalStorageProxy\nEternalStorage.bytesStorage (EternalStorageProxy.sol#17) is never used in EternalStorageProxy\nEternalStorage.boolStorage (EternalStorageProxy.sol#18) is never used in EternalStorageProxy\nEternalStorage.intStorage (EternalStorageProxy.sol#19) is never used in EternalStorageProxy\nEternalStorage.bytes32Storage (EternalStorageProxy.sol#20) is never used in EternalStorageProxy\nEternalStorage.uintArrayStorage (EternalStorageProxy.sol#22) is never used in EternalStorageProxy\nEternalStorage.stringArrayStorage (EternalStorageProxy.sol#23) is never used in EternalStorageProxy\nEternalStorage.addressArrayStorage (EternalStorageProxy.sol#24) is never used in EternalStorageProxy\nEternalStorage.bytesArrayStorage (EternalStorageProxy.sol#25) is never used in EternalStorageProxy\nEternalStorage.boolArrayStorage (EternalStorageProxy.sol#26) is never used in EternalStorageProxy\nEternalStorage.intArrayStorage (EternalStorageProxy.sol#27) is never used in EternalStorageProxy\nEternalStorage.bytes32ArrayStorage (EternalStorageProxy.sol#28) is never used in EternalStorageProxy\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract EternalStorageProxy is OwnedEternalStorage, IEternalStorageProxy {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isContract(address _addr) private view returns(bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/eternal-storage/OwnedEternalStorage.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner (OwnedEternalStorage.sol#11) is never initialized. It is used in:\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (OwnedEternalStorage.sol#11)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in OwnedEternalStorage.sol:\n\t- pragma solidity0.5.9 (OwnedEternalStorage.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (OwnedEternalStorage.sol#34): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (OwnedEternalStorage.sol#11) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/eternal-storage/EternalStorage.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (EternalStorage.sol#11)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in EternalStorage.sol:\n\t- pragma solidity0.5.9 (EternalStorage.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (EternalStorage.sol#11) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/libs/SafeMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in SafeMath.sol:\n\t- pragma solidity0.5.9 (SafeMath.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/abstracts/StakingBase.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _addPoolToBeRemoved(_poolStakingAddress);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 953,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            intStorage[POOLS_LIKELIHOOD_SUM] -= likelihood[indexToDelete];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 955,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (intStorage[POOLS_LIKELIHOOD_SUM] < 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 956,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                intStorage[POOLS_LIKELIHOOD_SUM] = 0;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 958,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools[indexToDelete] = pools[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            likelihood[indexToDelete] = likelihood[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 960,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolToBeElectedIndex(pools[indexToDelete], indexToDelete);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 961,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolToBeElectedIndex(_stakingAddress, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 975,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools[indexToDelete] = pools[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 976,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolToBeRemovedIndex(pools[indexToDelete], indexToDelete);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolToBeRemovedIndex(_stakingAddress, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 978,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 979,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 988,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 989,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools[indexToRemove] = pools[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 990,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolIndex(pools[indexToRemove], indexToRemove);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 991,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolIndex(_stakingAddress, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 992,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 993,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1009,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1010,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools[indexToRemove] = pools[pools.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1011,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolInactiveIndex(pools[indexToRemove], indexToRemove);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1012,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolInactiveIndex(_stakingAddress, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1013,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1014,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators[indexToRemove] = delegators[delegators.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolDelegatorIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolDelegatorIndex(_poolStakingAddress, _delegator, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators[indexToRemove] = delegators[delegators.length - 1];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolDelegatorInactiveIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setPoolDelegatorInactiveIndex(_poolStakingAddress, _delegator, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 963,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            likelihood.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 978,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 992,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1013,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[STAKING_EPOCH]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_209"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": 396,
                    "vulnerability_code": "    function withdraw(address _fromPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n\n        address payable staker = msg.sender;\n\n        _withdraw(_fromPoolStakingAddress, staker, _amount);\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, _amount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(_amount);\n\n        }\n\n        emit Withdrawn(_fromPoolStakingAddress, staker, stakingEpoch(), _amount);\n",
                    "message": "StakingBase.withdraw (StakingBase.sol#385-396) sends eth to arbitrary user\n\tDangerous calls:\n\t- staker.transfer(_amount) (StakingBase.sol#393)\n"
                },
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n        uint256 epoch = stakingEpoch();\n\n        address payable staker = msg.sender;\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(epoch > orderWithdrawEpoch(_poolStakingAddress, staker));\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        uint256 claimAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n        require(claimAmount != 0);\n\n\n\n        uint256 resultingStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(claimAmount);\n\n\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, 0);\n\n        _setOrderedWithdrawAmountTotal(\n\n            _poolStakingAddress,\n\n            orderedWithdrawAmountTotal(_poolStakingAddress).sub(claimAmount)\n\n        );\n\n        _setStakeAmount(_poolStakingAddress, staker, resultingStakeAmount);\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(claimAmount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, claimAmount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(claimAmount);\n\n        }\n\n\n\n        emit Claimed(_poolStakingAddress, staker, epoch, claimAmount);\n",
                    "message": "StakingBase.claimOrderedWithdraw (StakingBase.sol#480-517) sends eth to arbitrary user\n\tDangerous calls:\n\t- staker.transfer(claimAmount) (StakingBase.sol#513)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner (StakingBase.sol#97) is never initialized. It is used in:\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1024,
                    "vulnerability_to_line": 1056,
                    "vulnerability_code": "    function _initialize(\n\n        address _validatorSetContract,\n\n        address[] memory _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        bool _erc20Restricted\n\n    ) internal {\n\n        require(!isInitialized()); // initialization can only be done once\n\n        require(_validatorSetContract != address(0));\n\n        require(_initialStakingAddresses.length > 0);\n\n        require(_delegatorMinStake != 0);\n\n        require(_candidateMinStake != 0);\n\n\n\n        IBlockReward blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract());\n\n        require(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0);\n\n\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSetContract;\n\n\n\n        address unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator();\n\n\n\n        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n\n            require(_initialStakingAddresses[i] != address(0));\n\n            _addPoolActive(_initialStakingAddresses[i], false);\n\n            if (_initialStakingAddresses[i] != unremovableStakingAddress) {\n\n                _addPoolToBeRemoved(_initialStakingAddresses[i]);\n\n            }\n\n        }\n\n\n\n        _setDelegatorMinStake(_delegatorMinStake);\n\n        _setCandidateMinStake(_candidateMinStake);\n\n\n\n        boolStorage[ERC20_RESTRICTED] = _erc20Restricted;\n",
                    "message": "Reentrancy in StakingBase._initialize (StakingBase.sol#1024-1056):\n\tExternal calls:\n\t- blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract()) (StakingBase.sol#1037)\n\t- require(bool)(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0) (StakingBase.sol#1038)\n\tState variables written after the call(s):\n\t- addressStorage (StakingBase.sol#1040)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": 1333,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._stake (StakingBase.sol#1296-1333):\n\tExternal calls:\n\t- poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress) (StakingBase.sol#1298)\n\t- require(bool)(! validatorSet.isValidatorBanned(poolMiningAddress)) (StakingBase.sol#1303)\n\t- _addPoolActive(_poolStakingAddress,_poolStakingAddress != validatorSet.unremovableValidator()) (StakingBase.sol#1326)\n\tState variables written after the call(s):\n\t- intArrayStorage (StakingBase.sol#1332)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": 1370,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n\n\n        // How much can `staker` withdraw from `_poolStakingAddress` at the moment?\n\n        require(_amount <= maxWithdrawAllowed(_poolStakingAddress, _staker));\n\n\n\n        uint256 currentStakeAmount = stakeAmount(_poolStakingAddress, _staker);\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, _staker);\n\n        uint256 resultingStakeAmount = currentStakeAmount.sub(alreadyOrderedAmount).sub(_amount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 minAllowedStake = (_poolStakingAddress == _staker) ? getCandidateMinStake() : getDelegatorMinStake();\n\n        require(resultingStakeAmount == 0 || resultingStakeAmount >= minAllowedStake);\n\n\n\n        _setStakeAmount(_poolStakingAddress, _staker, currentStakeAmount.sub(_amount));\n\n        uint256 amountByEpoch = stakeAmountByCurrentEpoch(_poolStakingAddress, _staker);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            amountByEpoch >= _amount ? amountByEpoch - _amount : 0\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(_amount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._withdraw (StakingBase.sol#1340-1370):\n\tExternal calls:\n\t- require(bool)(_amount <= maxWithdrawAllowed(_poolStakingAddress,_staker)) (StakingBase.sol#1345)\n\tState variables written after the call(s):\n\t- uintStorage (StakingBase.sol#1356)\n\t- uintStorage (StakingBase.sol#1363)\n\t- uintStorage (StakingBase.sol#1358-1362)\n\t- uintStorage (StakingBase.sol#1358-1362)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": 1370,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n\n\n        // How much can `staker` withdraw from `_poolStakingAddress` at the moment?\n\n        require(_amount <= maxWithdrawAllowed(_poolStakingAddress, _staker));\n\n\n\n        uint256 currentStakeAmount = stakeAmount(_poolStakingAddress, _staker);\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, _staker);\n\n        uint256 resultingStakeAmount = currentStakeAmount.sub(alreadyOrderedAmount).sub(_amount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 minAllowedStake = (_poolStakingAddress == _staker) ? getCandidateMinStake() : getDelegatorMinStake();\n\n        require(resultingStakeAmount == 0 || resultingStakeAmount >= minAllowedStake);\n\n\n\n        _setStakeAmount(_poolStakingAddress, _staker, currentStakeAmount.sub(_amount));\n\n        uint256 amountByEpoch = stakeAmountByCurrentEpoch(_poolStakingAddress, _staker);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            amountByEpoch >= _amount ? amountByEpoch - _amount : 0\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(_amount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._withdraw (StakingBase.sol#1340-1370):\n\tExternal calls:\n\t- require(bool)(_amount <= maxWithdrawAllowed(_poolStakingAddress,_staker)) (StakingBase.sol#1345)\n\t- _withdrawCheckPool(_poolStakingAddress,_staker) (StakingBase.sol#1366)\n\tState variables written after the call(s):\n\t- intArrayStorage (StakingBase.sol#1369)\n\t- intStorage (StakingBase.sol#1369)\n\t- uintStorage (StakingBase.sol#1366)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n        uint256 epoch = stakingEpoch();\n\n        address payable staker = msg.sender;\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(epoch > orderWithdrawEpoch(_poolStakingAddress, staker));\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        uint256 claimAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n        require(claimAmount != 0);\n\n\n\n        uint256 resultingStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(claimAmount);\n\n\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, 0);\n\n        _setOrderedWithdrawAmountTotal(\n\n            _poolStakingAddress,\n\n            orderedWithdrawAmountTotal(_poolStakingAddress).sub(claimAmount)\n\n        );\n\n        _setStakeAmount(_poolStakingAddress, staker, resultingStakeAmount);\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(claimAmount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, claimAmount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(claimAmount);\n\n        }\n\n\n\n        emit Claimed(_poolStakingAddress, staker, epoch, claimAmount);\n",
                    "message": "Reentrancy in StakingBase.claimOrderedWithdraw (StakingBase.sol#480-517):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingBase.sol#487)\n\tState variables written after the call(s):\n\t- uintStorage (StakingBase.sol#494)\n\t- uintStorage (StakingBase.sol#495-498)\n\t- uintStorage (StakingBase.sol#499)\n\t- uintStorage (StakingBase.sol#500)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n        uint256 epoch = stakingEpoch();\n\n        address payable staker = msg.sender;\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(epoch > orderWithdrawEpoch(_poolStakingAddress, staker));\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        uint256 claimAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n        require(claimAmount != 0);\n\n\n\n        uint256 resultingStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(claimAmount);\n\n\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, 0);\n\n        _setOrderedWithdrawAmountTotal(\n\n            _poolStakingAddress,\n\n            orderedWithdrawAmountTotal(_poolStakingAddress).sub(claimAmount)\n\n        );\n\n        _setStakeAmount(_poolStakingAddress, staker, resultingStakeAmount);\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(claimAmount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.withdraw(staker, claimAmount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n            staker.transfer(claimAmount);\n\n        }\n\n\n\n        emit Claimed(_poolStakingAddress, staker, epoch, claimAmount);\n",
                    "message": "Reentrancy in StakingBase.claimOrderedWithdraw (StakingBase.sol#480-517):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingBase.sol#487)\n\t- _withdrawCheckPool(_poolStakingAddress,staker) (StakingBase.sol#503)\n\tState variables written after the call(s):\n\t- intArrayStorage (StakingBase.sol#506)\n\t- intStorage (StakingBase.sol#506)\n\t- uintStorage (StakingBase.sol#503)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": 362,
                    "vulnerability_code": "    function moveStake(\n\n        address _fromPoolStakingAddress,\n\n        address _toPoolStakingAddress,\n\n        uint256 _amount\n\n    ) external gasPriceIsValid onlyInitialized {\n\n        require(_fromPoolStakingAddress != _toPoolStakingAddress);\n\n        address staker = msg.sender;\n\n        _withdraw(_fromPoolStakingAddress, staker, _amount);\n\n        _stake(_toPoolStakingAddress, staker, _amount);\n\n        emit StakeMoved(_fromPoolStakingAddress, _toPoolStakingAddress, staker, stakingEpoch(), _amount);\n",
                    "message": "Reentrancy in StakingBase.moveStake (StakingBase.sol#352-362):\n\tExternal calls:\n\t- _withdraw(_fromPoolStakingAddress,staker,_amount) (StakingBase.sol#359)\n\t- _stake(_toPoolStakingAddress,staker,_amount) (StakingBase.sol#360)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingBase.sol#360)\n\t- intArrayStorage (StakingBase.sol#360)\n\t- intStorage (StakingBase.sol#360)\n\t- uintStorage (StakingBase.sol#360)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
                    "message": "Reentrancy in StakingBase.orderWithdraw (StakingBase.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingBase.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingBase.sol#416)\n\tState variables written after the call(s):\n\t- uintStorage (StakingBase.sol#428)\n\t- uintStorage (StakingBase.sol#450)\n\t- uintStorage (StakingBase.sol#453)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
                    "message": "Reentrancy in StakingBase.orderWithdraw (StakingBase.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingBase.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingBase.sol#416)\n\t- unremovableStakingAddress = validatorSetContract.unremovableValidator() (StakingBase.sol#436)\n\tState variables written after the call(s):\n\t- uintStorage (StakingBase.sol#440)\n\t- uintStorage (StakingBase.sol#443)\n\t- uintStorage (StakingBase.sol#464)\n\t- uintStorage (StakingBase.sol#469)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": 344,
                    "vulnerability_code": "    function removeMyPool() external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address stakingAddress = msg.sender;\n\n        address miningAddress = validatorSet.miningByStakingAddress(stakingAddress);\n\n        // initial validator cannot remove their pool during the initial staking epoch\n\n        require(stakingEpoch() > 0 || !validatorSet.isValidator(miningAddress));\n\n        require(stakingAddress != validatorSet.unremovableValidator());\n\n        _removePool(stakingAddress);\n",
                    "message": "Reentrancy in StakingBase.removeMyPool (StakingBase.sol#336-344):\n\tExternal calls:\n\t- miningAddress = validatorSet.miningByStakingAddress(stakingAddress) (StakingBase.sol#339)\n\t- require(bool)(stakingEpoch() > 0 || ! validatorSet.isValidator(miningAddress)) (StakingBase.sol#341)\n\t- require(bool)(stakingAddress != validatorSet.unremovableValidator()) (StakingBase.sol#342)\n\tState variables written after the call(s):\n\t- uintStorage (StakingBase.sol#343)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
                    "message": "StakingBase.orderWithdraw.validatorSetContract (local variable @ StakingBase.sol#407) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingBase.sol#853-855)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
                    "message": "StakingBase.claimOrderedWithdraw.validatorSetContract (local variable @ StakingBase.sol#481) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingBase.sol#853-855)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 633,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
                    "message": "StakingBase.maxWithdrawAllowed.validatorSetContract (local variable @ StakingBase.sol#633) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingBase.sol#853-855)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IValidatorSet validatorSetContract = validatorSetContract();\n",
                    "message": "StakingBase.maxWithdrawOrderAllowed.validatorSetContract (local variable @ StakingBase.sol#665) shadows:\n\t- StakingBase.validatorSetContract (function @ StakingBase.sol#853-855)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1024,
                    "vulnerability_to_line": 1056,
                    "vulnerability_code": "    function _initialize(\n\n        address _validatorSetContract,\n\n        address[] memory _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        bool _erc20Restricted\n\n    ) internal {\n\n        require(!isInitialized()); // initialization can only be done once\n\n        require(_validatorSetContract != address(0));\n\n        require(_initialStakingAddresses.length > 0);\n\n        require(_delegatorMinStake != 0);\n\n        require(_candidateMinStake != 0);\n\n\n\n        IBlockReward blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract());\n\n        require(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0);\n\n\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSetContract;\n\n\n\n        address unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator();\n\n\n\n        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n\n            require(_initialStakingAddresses[i] != address(0));\n\n            _addPoolActive(_initialStakingAddresses[i], false);\n\n            if (_initialStakingAddresses[i] != unremovableStakingAddress) {\n\n                _addPoolToBeRemoved(_initialStakingAddresses[i]);\n\n            }\n\n        }\n\n\n\n        _setDelegatorMinStake(_delegatorMinStake);\n\n        _setCandidateMinStake(_candidateMinStake);\n\n\n\n        boolStorage[ERC20_RESTRICTED] = _erc20Restricted;\n",
                    "message": "Reentrancy in StakingBase._initialize (StakingBase.sol#1024-1056):\n\tExternal calls:\n\t- blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract()) (StakingBase.sol#1037)\n\t- require(bool)(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0) (StakingBase.sol#1038)\n\t- unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator() (StakingBase.sol#1042)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingBase.sol#1046)\n\t- addressArrayStorage (StakingBase.sol#1048)\n\t- boolStorage (StakingBase.sol#1055)\n\t- intArrayStorage (StakingBase.sol#1046)\n\t- intArrayStorage (StakingBase.sol#1048)\n\t- intStorage (StakingBase.sol#1048)\n\t- uintStorage (StakingBase.sol#1046)\n\t- uintStorage (StakingBase.sol#1048)\n\t- uintStorage (StakingBase.sol#1052)\n\t- uintStorage (StakingBase.sol#1053)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": 1333,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._stake (StakingBase.sol#1296-1333):\n\tExternal calls:\n\t- poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress) (StakingBase.sol#1298)\n\t- require(bool)(! validatorSet.isValidatorBanned(poolMiningAddress)) (StakingBase.sol#1303)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingBase.sol#1329)\n\t- uintStorage (StakingBase.sol#1316)\n\t- uintStorage (StakingBase.sol#1317-1321)\n\t- uintStorage (StakingBase.sol#1322)\n\t- uintStorage (StakingBase.sol#1329)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": 1333,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Reentrancy in StakingBase._stake (StakingBase.sol#1296-1333):\n\tExternal calls:\n\t- poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress) (StakingBase.sol#1298)\n\t- require(bool)(! validatorSet.isValidatorBanned(poolMiningAddress)) (StakingBase.sol#1303)\n\t- _addPoolActive(_poolStakingAddress,_poolStakingAddress != validatorSet.unremovableValidator()) (StakingBase.sol#1326)\n\tState variables written after the call(s):\n\t- intStorage (StakingBase.sol#1332)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": 1391,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n\n        if (_staker == _poolStakingAddress) {\n\n            IValidatorSet validatorSet = validatorSetContract();\n\n            address unremovableStakingAddress = validatorSet.unremovableValidator();\n\n\n\n            if (_poolStakingAddress != unremovableStakingAddress) {\n\n                if (validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress))) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                } else {\n\n                    _removePool(_poolStakingAddress);\n\n                }\n\n            }\n\n        } else {\n\n            _removePoolDelegator(_poolStakingAddress, _staker);\n\n        }\n",
                    "message": "Reentrancy in StakingBase._withdrawCheckPool (StakingBase.sol#1376-1391):\n\tExternal calls:\n\t- unremovableStakingAddress = validatorSet.unremovableValidator() (StakingBase.sol#1379)\n\t- validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress)) (StakingBase.sol#1382-1386)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingBase.sol#1383)\n\t- intArrayStorage (StakingBase.sol#1383)\n\t- intStorage (StakingBase.sol#1383)\n\t- uintStorage (StakingBase.sol#1383)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": 1391,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n\n        if (_staker == _poolStakingAddress) {\n\n            IValidatorSet validatorSet = validatorSetContract();\n\n            address unremovableStakingAddress = validatorSet.unremovableValidator();\n\n\n\n            if (_poolStakingAddress != unremovableStakingAddress) {\n\n                if (validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress))) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                } else {\n\n                    _removePool(_poolStakingAddress);\n\n                }\n\n            }\n\n        } else {\n\n            _removePoolDelegator(_poolStakingAddress, _staker);\n\n        }\n",
                    "message": "Reentrancy in StakingBase._withdrawCheckPool (StakingBase.sol#1376-1391):\n\tExternal calls:\n\t- unremovableStakingAddress = validatorSet.unremovableValidator() (StakingBase.sol#1379)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingBase.sol#1385)\n\t- intArrayStorage (StakingBase.sol#1385)\n\t- intStorage (StakingBase.sol#1385)\n\t- uintStorage (StakingBase.sol#1385)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
                    "message": "Reentrancy in StakingBase.orderWithdraw (StakingBase.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingBase.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingBase.sol#416)\n\t- unremovableStakingAddress = validatorSetContract.unremovableValidator() (StakingBase.sol#436)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingBase.sol#440)\n\t- addressArrayStorage (StakingBase.sol#443)\n\t- intArrayStorage (StakingBase.sol#440)\n\t- intArrayStorage (StakingBase.sol#443)\n\t- intArrayStorage (StakingBase.sol#472)\n\t- intStorage (StakingBase.sol#440)\n\t- intStorage (StakingBase.sol#472)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSetContract = validatorSetContract();\n\n\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress)));\n\n\n\n        address staker = msg.sender;\n\n\n\n        // How much can `staker` order for withdrawal from `_poolStakingAddress` at the moment?\n\n        require(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress, staker));\n\n\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, staker);\n\n\n\n        require(_amount > 0 || uint256(-_amount) <= alreadyOrderedAmount);\n\n\n\n        uint256 newOrderedAmount;\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmount(_poolStakingAddress, staker, newOrderedAmount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, staker).sub(newOrderedAmount);\n\n        if (staker == _poolStakingAddress) {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getCandidateMinStake());\n\n\n\n            address unremovableStakingAddress = validatorSetContract.unremovableValidator();\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0 && _poolStakingAddress != unremovableStakingAddress) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                }\n\n            } else {\n\n                _addPoolActive(_poolStakingAddress, _poolStakingAddress != unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            require(newStakeAmount == 0 || newStakeAmount >= getDelegatorMinStake());\n\n\n\n            if (_amount > 0) {\n\n                if (newStakeAmount == 0) {\n\n                    _removePoolDelegator(_poolStakingAddress, staker);\n\n                }\n\n            } else {\n\n                _addPoolDelegator(_poolStakingAddress, staker);\n\n            }\n\n        }\n\n\n\n        // Set total ordered amount for this pool\n\n        alreadyOrderedAmount = orderedWithdrawAmountTotal(_poolStakingAddress);\n\n        if (_amount > 0) {\n\n            newOrderedAmount = alreadyOrderedAmount.add(uint256(_amount));\n\n        } else {\n\n            newOrderedAmount = alreadyOrderedAmount.sub(uint256(-_amount));\n\n        }\n\n        _setOrderedWithdrawAmountTotal(_poolStakingAddress, newOrderedAmount);\n\n\n\n        uint256 epoch = stakingEpoch();\n\n\n\n        if (_amount > 0) {\n\n            _setOrderWithdrawEpoch(_poolStakingAddress, staker, epoch);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n\n\n\n        emit WithdrawalOrdered(_poolStakingAddress, staker, epoch, _amount);\n",
                    "message": "Reentrancy in StakingBase.orderWithdraw (StakingBase.sol#406-475):\n\tExternal calls:\n\t- require(bool)(_isWithdrawAllowed(validatorSetContract.miningByStakingAddress(_poolStakingAddress))) (StakingBase.sol#411)\n\t- require(bool)(_amount < 0 || uint256(_amount) <= maxWithdrawOrderAllowed(_poolStakingAddress,staker)) (StakingBase.sol#416)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingBase.sol#450)\n\t- addressArrayStorage (StakingBase.sol#453)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": 344,
                    "vulnerability_code": "    function removeMyPool() external gasPriceIsValid onlyInitialized {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address stakingAddress = msg.sender;\n\n        address miningAddress = validatorSet.miningByStakingAddress(stakingAddress);\n\n        // initial validator cannot remove their pool during the initial staking epoch\n\n        require(stakingEpoch() > 0 || !validatorSet.isValidator(miningAddress));\n\n        require(stakingAddress != validatorSet.unremovableValidator());\n\n        _removePool(stakingAddress);\n",
                    "message": "Reentrancy in StakingBase.removeMyPool (StakingBase.sol#336-344):\n\tExternal calls:\n\t- miningAddress = validatorSet.miningByStakingAddress(stakingAddress) (StakingBase.sol#339)\n\t- require(bool)(stakingEpoch() > 0 || ! validatorSet.isValidator(miningAddress)) (StakingBase.sol#341)\n\t- require(bool)(stakingAddress != validatorSet.unremovableValidator()) (StakingBase.sol#342)\n\tState variables written after the call(s):\n\t- addressArrayStorage (StakingBase.sol#343)\n\t- intArrayStorage (StakingBase.sol#343)\n\t- intStorage (StakingBase.sol#343)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (StakingBase.sol#97)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function erc20Restricted() external view returns(bool);\n",
                    "message": "IStaking.erc20Restricted (StakingBase.sol#41) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": 598,
                    "vulnerability_code": "    function erc20Restricted() public view returns(bool) {\n\n        return boolStorage[ERC20_RESTRICTED];\n",
                    "message": "StakingBase.erc20Restricted (StakingBase.sol#596-598) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "IStaking.poolDelegators (StakingBase.sol#46) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": 735,
                    "vulnerability_code": "    function poolDelegators(address _poolStakingAddress) public view returns(address[] memory) {\n\n        return addressArrayStorage[keccak256(abi.encode(POOL_DELEGATORS, _poolStakingAddress))];\n",
                    "message": "StakingBase.poolDelegators (StakingBase.sol#733-735) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": 695,
                    "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n\n        return false;\n",
                    "message": "StakingBase.onTokenTransfer (StakingBase.sol#693-695) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 741,
                    "vulnerability_to_line": 743,
                    "vulnerability_code": "    function poolDelegatorsInactive(address _poolStakingAddress) public view returns(address[] memory) {\n\n        return addressArrayStorage[keccak256(abi.encode(POOL_DELEGATORS_INACTIVE, _poolStakingAddress))];\n",
                    "message": "StakingBase.poolDelegatorsInactive (StakingBase.sol#741-743) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in StakingBase.sol:\n\t- pragma solidity0.5.9 (StakingBase.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (StakingBase.sol#17): it allows old versions\n\t- pragma solidity0.5.9 (StakingBase.sol#34): it allows old versions\n\t- pragma solidity0.5.9 (StakingBase.sol#54): it allows old versions\n\t- pragma solidity0.5.9 (StakingBase.sol#89): it allows old versions\n\t- pragma solidity0.5.9 (StakingBase.sol#120): it allows old versions\n\t- pragma solidity0.5.9 (StakingBase.sol#138): it allows old versions\n\t- pragma solidity0.5.9 (StakingBase.sol#177): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address) external;\n",
                    "message": "Parameter '' of IBlockReward.initialize (StakingBase.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function DELEGATORS_ALIQUOT() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IBlockReward.DELEGATORS_ALIQUOT' (StakingBase.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IERC20Minting.balanceOf (StakingBase.sol#29) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
                    "message": "Parameter '' of IStaking.clearUnremovableValidator (StakingBase.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address) external;\n",
                    "message": "Parameter '' of IStaking.removePool (StakingBase.sol#40) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "Parameter '' of IStaking.poolDelegators (StakingBase.sol#46) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (StakingBase.sol#47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (StakingBase.sol#47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (StakingBase.sol#48) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (StakingBase.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (StakingBase.sol#60) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (StakingBase.sol#61) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (StakingBase.sol#62) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (StakingBase.sol#63) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (StakingBase.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (StakingBase.sol#67) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (StakingBase.sol#67) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (StakingBase.sol#74) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (StakingBase.sol#75) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (StakingBase.sol#76) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (StakingBase.sol#77) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (StakingBase.sol#78) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (StakingBase.sol#80) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (StakingBase.sol#83) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (StakingBase.sol#97) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address _unremovableStakingAddress) external onlyValidatorSetContract {\n",
                    "message": "Parameter '_unremovableStakingAddress' of StakingBase.clearUnremovableValidator (StakingBase.sol#308) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address _stakingAddress) external onlyValidatorSetContract {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.removePool (StakingBase.sol#328) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address _poolStakingAddress) public view returns(address[] memory) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegators (StakingBase.sol#733) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 829,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _poolStakingAddress,\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountMinusOrderedWithdraw (StakingBase.sol#829) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 830,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _staker\n",
                    "message": "Parameter '_staker' of StakingBase.stakeAmountMinusOrderedWithdraw (StakingBase.sol#830) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 841,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address _poolStakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountTotalMinusOrderedWithdraw (StakingBase.sol#841) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _fromPoolStakingAddress,\n",
                    "message": "Parameter '_fromPoolStakingAddress' of StakingBase.moveStake (StakingBase.sol#353) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _toPoolStakingAddress,\n",
                    "message": "Parameter '_toPoolStakingAddress' of StakingBase.moveStake (StakingBase.sol#354) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _amount\n",
                    "message": "Parameter '_amount' of StakingBase.moveStake (StakingBase.sol#355) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stake(address _toPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_toPoolStakingAddress' of StakingBase.stake (StakingBase.sol#368) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stake(address _toPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_amount' of StakingBase.stake (StakingBase.sol#368) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeNative(address _toPoolStakingAddress) external gasPriceIsValid onlyInitialized payable {\n",
                    "message": "Parameter '_toPoolStakingAddress' of StakingBase.stakeNative (StakingBase.sol#375) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function withdraw(address _fromPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_fromPoolStakingAddress' of StakingBase.withdraw (StakingBase.sol#385) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function withdraw(address _fromPoolStakingAddress, uint256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_amount' of StakingBase.withdraw (StakingBase.sol#385) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.orderWithdraw (StakingBase.sol#406) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderWithdraw(address _poolStakingAddress, int256 _amount) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_amount' of StakingBase.orderWithdraw (StakingBase.sol#406) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claimOrderedWithdraw(address _poolStakingAddress) external gasPriceIsValid onlyInitialized {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.claimOrderedWithdraw (StakingBase.sol#480) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErc20TokenContract(address _erc20TokenContract) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_erc20TokenContract' of StakingBase.setErc20TokenContract (StakingBase.sol#522) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCandidateMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_minStake' of StakingBase.setCandidateMinStake (StakingBase.sol#531) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setDelegatorMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_minStake' of StakingBase.setDelegatorMinStake (StakingBase.sol#538) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isPoolActive(address _stakingAddress) public view returns(bool) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.isPoolActive (StakingBase.sol#623) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function maxWithdrawAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.maxWithdrawAllowed (StakingBase.sol#632) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function maxWithdrawAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.maxWithdrawAllowed (StakingBase.sol#632) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function maxWithdrawOrderAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.maxWithdrawOrderAllowed (StakingBase.sol#664) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function maxWithdrawOrderAllowed(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.maxWithdrawOrderAllowed (StakingBase.sol#664) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n",
                    "message": "Parameter '' of StakingBase.onTokenTransfer (StakingBase.sol#693) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n",
                    "message": "Parameter '_scope_0' of StakingBase.onTokenTransfer (StakingBase.sol#693) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onTokenTransfer(address, uint256, bytes memory) public pure returns(bool) {\n",
                    "message": "Parameter '_scope_1' of StakingBase.onTokenTransfer (StakingBase.sol#693) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderedWithdrawAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.orderedWithdrawAmount (StakingBase.sol#701) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderedWithdrawAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.orderedWithdrawAmount (StakingBase.sol#701) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 708,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderedWithdrawAmountTotal(address _poolStakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.orderedWithdrawAmountTotal (StakingBase.sol#708) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderWithdrawEpoch(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.orderWithdrawEpoch (StakingBase.sol#717) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function orderWithdrawEpoch(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.orderWithdrawEpoch (StakingBase.sol#717) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 725,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotal(address _poolStakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountTotal (StakingBase.sol#725) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 741,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorsInactive(address _poolStakingAddress) public view returns(address[] memory) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegatorsInactive (StakingBase.sol#741) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 751,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegatorIndex (StakingBase.sol#751) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 751,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
                    "message": "Parameter '_delegator' of StakingBase.poolDelegatorIndex (StakingBase.sol#751) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.poolDelegatorInactiveIndex (StakingBase.sol#761) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator) public view returns(uint256) {\n",
                    "message": "Parameter '_delegator' of StakingBase.poolDelegatorInactiveIndex (StakingBase.sol#761) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 770,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolIndex(address _stakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.poolIndex (StakingBase.sol#770) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolInactiveIndex(address _stakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.poolInactiveIndex (StakingBase.sol#777) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolToBeElectedIndex(address _stakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.poolToBeElectedIndex (StakingBase.sol#786) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolToBeRemovedIndex(address _stakingAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase.poolToBeRemovedIndex (StakingBase.sol#795) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmount (StakingBase.sol#804) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmount(address _poolStakingAddress, address _staker) public view returns(uint256) {\n",
                    "message": "Parameter '_staker' of StakingBase.stakeAmount (StakingBase.sol#804) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountByCurrentEpoch(address _poolStakingAddress, address _staker)\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase.stakeAmountByCurrentEpoch (StakingBase.sol#813) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountByCurrentEpoch(address _poolStakingAddress, address _staker)\n",
                    "message": "Parameter '_staker' of StakingBase.stakeAmountByCurrentEpoch (StakingBase.sol#813) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 892,
                    "vulnerability_to_line": 903,
                    "vulnerability_code": "    function _addPoolActive(address _stakingAddress, bool _toBeElected) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS];\n\n        if (!isPoolActive(_stakingAddress)) {\n\n            _setPoolIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n            require(pools.length <= _getMaxCandidates());\n\n        }\n\n        _removePoolInactive(_stakingAddress);\n\n        if (_toBeElected) {\n\n            _addPoolToBeElected(_stakingAddress);\n\n        }\n",
                    "message": "Function 'StakingBase._addPoolActive' (StakingBase.sol#892-903) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 892,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolActive(address _stakingAddress, bool _toBeElected) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._addPoolActive (StakingBase.sol#892) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 892,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolActive(address _stakingAddress, bool _toBeElected) internal {\n",
                    "message": "Parameter '_toBeElected' of StakingBase._addPoolActive (StakingBase.sol#892) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 908,
                    "vulnerability_to_line": 915,
                    "vulnerability_code": "    function _addPoolInactive(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_INACTIVE];\n\n        uint256 index = poolInactiveIndex(_stakingAddress);\n\n        if (index >= pools.length || pools[index] != _stakingAddress) {\n\n            _setPoolInactiveIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n        }\n",
                    "message": "Function 'StakingBase._addPoolInactive' (StakingBase.sol#908-915) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 908,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolInactive(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._addPoolInactive (StakingBase.sol#908) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 929,
                    "vulnerability_code": "    function _addPoolToBeElected(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_ELECTED];\n\n        uint256 index = poolToBeElectedIndex(_stakingAddress);\n\n        if (index >= pools.length || pools[index] != _stakingAddress) {\n\n            _setPoolToBeElectedIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n            intArrayStorage[POOLS_LIKELIHOOD].push(0);\n\n        }\n\n        _deletePoolToBeRemoved(_stakingAddress);\n",
                    "message": "Function 'StakingBase._addPoolToBeElected' (StakingBase.sol#920-929) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolToBeElected(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._addPoolToBeElected (StakingBase.sol#920) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": 942,
                    "vulnerability_code": "    function _addPoolToBeRemoved(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_REMOVED];\n\n        uint256 index = poolToBeRemovedIndex(_stakingAddress);\n\n        if (index >= pools.length || pools[index] != _stakingAddress) {\n\n            _setPoolToBeRemovedIndex(_stakingAddress, pools.length);\n\n            pools.push(_stakingAddress);\n\n        }\n\n        _deletePoolToBeElected(_stakingAddress);\n",
                    "message": "Function 'StakingBase._addPoolToBeRemoved' (StakingBase.sol#934-942) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolToBeRemoved(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._addPoolToBeRemoved (StakingBase.sol#934) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 948,
                    "vulnerability_to_line": 965,
                    "vulnerability_code": "    function _deletePoolToBeElected(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_ELECTED];\n\n        int256[] storage likelihood = intArrayStorage[POOLS_LIKELIHOOD];\n\n        if (pools.length != likelihood.length) return;\n\n        uint256 indexToDelete = poolToBeElectedIndex(_stakingAddress);\n\n        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n\n            intStorage[POOLS_LIKELIHOOD_SUM] -= likelihood[indexToDelete];\n\n            if (intStorage[POOLS_LIKELIHOOD_SUM] < 0) {\n\n                intStorage[POOLS_LIKELIHOOD_SUM] = 0;\n\n            }\n\n            pools[indexToDelete] = pools[pools.length - 1];\n\n            likelihood[indexToDelete] = likelihood[pools.length - 1];\n\n            _setPoolToBeElectedIndex(pools[indexToDelete], indexToDelete);\n\n            _setPoolToBeElectedIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n            likelihood.length--;\n\n        }\n",
                    "message": "Function 'StakingBase._deletePoolToBeElected' (StakingBase.sol#948-965) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 948,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _deletePoolToBeElected(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._deletePoolToBeElected (StakingBase.sol#948) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 971,
                    "vulnerability_to_line": 980,
                    "vulnerability_code": "    function _deletePoolToBeRemoved(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_REMOVED];\n\n        uint256 indexToDelete = poolToBeRemovedIndex(_stakingAddress);\n\n        if (pools.length > indexToDelete && pools[indexToDelete] == _stakingAddress) {\n\n            pools[indexToDelete] = pools[pools.length - 1];\n\n            _setPoolToBeRemovedIndex(pools[indexToDelete], indexToDelete);\n\n            _setPoolToBeRemovedIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n        }\n",
                    "message": "Function 'StakingBase._deletePoolToBeRemoved' (StakingBase.sol#971-980) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 971,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _deletePoolToBeRemoved(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._deletePoolToBeRemoved (StakingBase.sol#971) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 985,
                    "vulnerability_to_line": 1001,
                    "vulnerability_code": "    function _removePool(address _stakingAddress) internal {\n\n        uint256 indexToRemove = poolIndex(_stakingAddress);\n\n        address[] storage pools = addressArrayStorage[POOLS];\n\n        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n\n            pools[indexToRemove] = pools[pools.length - 1];\n\n            _setPoolIndex(pools[indexToRemove], indexToRemove);\n\n            _setPoolIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n        }\n\n        if (stakeAmountTotal(_stakingAddress) != 0) {\n\n            _addPoolInactive(_stakingAddress);\n\n        } else {\n\n            _removePoolInactive(_stakingAddress);\n\n        }\n\n        _deletePoolToBeElected(_stakingAddress);\n\n        _deletePoolToBeRemoved(_stakingAddress);\n",
                    "message": "Function 'StakingBase._removePool' (StakingBase.sol#985-1001) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 985,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePool(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._removePool (StakingBase.sol#985) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1006,
                    "vulnerability_to_line": 1015,
                    "vulnerability_code": "    function _removePoolInactive(address _stakingAddress) internal {\n\n        address[] storage pools = addressArrayStorage[POOLS_INACTIVE];\n\n        uint256 indexToRemove = poolInactiveIndex(_stakingAddress);\n\n        if (pools.length > indexToRemove && pools[indexToRemove] == _stakingAddress) {\n\n            pools[indexToRemove] = pools[pools.length - 1];\n\n            _setPoolInactiveIndex(pools[indexToRemove], indexToRemove);\n\n            _setPoolInactiveIndex(_stakingAddress, 0);\n\n            pools.length--;\n\n        }\n",
                    "message": "Function 'StakingBase._removePoolInactive' (StakingBase.sol#1006-1015) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1006,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolInactive(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._removePoolInactive (StakingBase.sol#1006) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1024,
                    "vulnerability_to_line": 1056,
                    "vulnerability_code": "    function _initialize(\n\n        address _validatorSetContract,\n\n        address[] memory _initialStakingAddresses,\n\n        uint256 _delegatorMinStake,\n\n        uint256 _candidateMinStake,\n\n        bool _erc20Restricted\n\n    ) internal {\n\n        require(!isInitialized()); // initialization can only be done once\n\n        require(_validatorSetContract != address(0));\n\n        require(_initialStakingAddresses.length > 0);\n\n        require(_delegatorMinStake != 0);\n\n        require(_candidateMinStake != 0);\n\n\n\n        IBlockReward blockRewardContract = IBlockReward(IValidatorSet(_validatorSetContract).blockRewardContract());\n\n        require(MAX_DELEGATORS_PER_POOL % blockRewardContract.DELEGATORS_ALIQUOT() == 0);\n\n\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSetContract;\n\n\n\n        address unremovableStakingAddress = IValidatorSet(_validatorSetContract).unremovableValidator();\n\n\n\n        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n\n            require(_initialStakingAddresses[i] != address(0));\n\n            _addPoolActive(_initialStakingAddresses[i], false);\n\n            if (_initialStakingAddresses[i] != unremovableStakingAddress) {\n\n                _addPoolToBeRemoved(_initialStakingAddresses[i]);\n\n            }\n\n        }\n\n\n\n        _setDelegatorMinStake(_delegatorMinStake);\n\n        _setCandidateMinStake(_candidateMinStake);\n\n\n\n        boolStorage[ERC20_RESTRICTED] = _erc20Restricted;\n",
                    "message": "Function 'StakingBase._initialize' (StakingBase.sol#1024-1056) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1025,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _validatorSetContract,\n",
                    "message": "Parameter '_validatorSetContract' of StakingBase._initialize (StakingBase.sol#1025) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1026,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _initialStakingAddresses,\n",
                    "message": "Parameter '_initialStakingAddresses' of StakingBase._initialize (StakingBase.sol#1026) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1027,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _delegatorMinStake,\n",
                    "message": "Parameter '_delegatorMinStake' of StakingBase._initialize (StakingBase.sol#1027) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1028,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _candidateMinStake,\n",
                    "message": "Parameter '_candidateMinStake' of StakingBase._initialize (StakingBase.sol#1028) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1029,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _erc20Restricted\n",
                    "message": "Parameter '_erc20Restricted' of StakingBase._initialize (StakingBase.sol#1029) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": 1067,
                    "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n\n        uintStorage[keccak256(abi.encode(ORDER_WITHDRAW_EPOCH, _poolStakingAddress, _staker))] = _stakingEpoch;\n",
                    "message": "Function 'StakingBase._setOrderWithdrawEpoch' (StakingBase.sol#1065-1067) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setOrderWithdrawEpoch (StakingBase.sol#1065) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._setOrderWithdrawEpoch (StakingBase.sol#1065) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderWithdrawEpoch(address _poolStakingAddress, address _staker, uint256 _stakingEpoch) internal {\n",
                    "message": "Parameter '_stakingEpoch' of StakingBase._setOrderWithdrawEpoch (StakingBase.sol#1065) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": 1076,
                    "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_DELEGATOR_INDEX, _poolStakingAddress, _delegator))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolDelegatorIndex' (StakingBase.sol#1074-1076) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setPoolDelegatorIndex (StakingBase.sol#1074) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._setPoolDelegatorIndex (StakingBase.sol#1074) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolDelegatorIndex (StakingBase.sol#1074) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": 1085,
                    "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_DELEGATOR_INACTIVE_INDEX, _poolStakingAddress, _delegator))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolDelegatorInactiveIndex' (StakingBase.sol#1083-1085) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setPoolDelegatorInactiveIndex (StakingBase.sol#1083) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._setPoolDelegatorInactiveIndex (StakingBase.sol#1083) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolDelegatorInactiveIndex(address _poolStakingAddress, address _delegator, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolDelegatorInactiveIndex (StakingBase.sol#1083) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1093,
                    "vulnerability_code": "    function _setPoolIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_INDEX, _stakingAddress))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolIndex' (StakingBase.sol#1091-1093) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._setPoolIndex (StakingBase.sol#1091) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolIndex (StakingBase.sol#1091) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1099,
                    "vulnerability_to_line": 1101,
                    "vulnerability_code": "    function _setPoolInactiveIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_INACTIVE_INDEX, _stakingAddress))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolInactiveIndex' (StakingBase.sol#1099-1101) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1099,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolInactiveIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._setPoolInactiveIndex (StakingBase.sol#1099) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1099,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolInactiveIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolInactiveIndex (StakingBase.sol#1099) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1108,
                    "vulnerability_to_line": 1110,
                    "vulnerability_code": "    function _setPoolToBeElectedIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_TO_BE_ELECTED_INDEX, _stakingAddress))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolToBeElectedIndex' (StakingBase.sol#1108-1110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolToBeElectedIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._setPoolToBeElectedIndex (StakingBase.sol#1108) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolToBeElectedIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolToBeElectedIndex (StakingBase.sol#1108) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1117,
                    "vulnerability_to_line": 1119,
                    "vulnerability_code": "    function _setPoolToBeRemovedIndex(address _stakingAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(POOL_TO_BE_REMOVED_INDEX, _stakingAddress))] = _index;\n",
                    "message": "Function 'StakingBase._setPoolToBeRemovedIndex' (StakingBase.sol#1117-1119) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolToBeRemovedIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._setPoolToBeRemovedIndex (StakingBase.sol#1117) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPoolToBeRemovedIndex(address _stakingAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of StakingBase._setPoolToBeRemovedIndex (StakingBase.sol#1117) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": 1135,
                    "vulnerability_code": "    function _addPoolDelegator(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS, _poolStakingAddress))\n\n        ];\n\n        if (delegators.length == 0 || delegators[poolDelegatorIndex(_poolStakingAddress, _delegator)] != _delegator) {\n\n            _setPoolDelegatorIndex(_poolStakingAddress, _delegator, delegators.length);\n\n            delegators.push(_delegator);\n\n            require(delegators.length <= MAX_DELEGATORS_PER_POOL);\n\n        }\n\n        _removePoolDelegatorInactive(_poolStakingAddress, _delegator);\n",
                    "message": "Function 'StakingBase._addPoolDelegator' (StakingBase.sol#1125-1135) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._addPoolDelegator (StakingBase.sol#1125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._addPoolDelegator (StakingBase.sol#1125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1141,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function _addPoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS_INACTIVE, _poolStakingAddress))\n\n        ];\n\n        if (\n\n            delegators.length == 0 ||\n\n            delegators[poolDelegatorInactiveIndex(_poolStakingAddress, _delegator)] != _delegator\n\n        ) {\n\n            _setPoolDelegatorInactiveIndex(_poolStakingAddress, _delegator, delegators.length);\n\n            delegators.push(_delegator);\n\n        }\n",
                    "message": "Function 'StakingBase._addPoolDelegatorInactive' (StakingBase.sol#1141-1152) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._addPoolDelegatorInactive (StakingBase.sol#1141) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addPoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._addPoolDelegatorInactive (StakingBase.sol#1141) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": 1174,
                    "vulnerability_code": "    function _removePoolDelegator(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS, _poolStakingAddress))\n\n        ];\n\n        uint256 indexToRemove = poolDelegatorIndex(_poolStakingAddress, _delegator);\n\n        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n\n            delegators[indexToRemove] = delegators[delegators.length - 1];\n\n            _setPoolDelegatorIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n\n            _setPoolDelegatorIndex(_poolStakingAddress, _delegator, 0);\n\n            delegators.length--;\n\n        }\n\n        if (stakeAmount(_poolStakingAddress, _delegator) != 0) {\n\n            _addPoolDelegatorInactive(_poolStakingAddress, _delegator);\n\n        } else {\n\n            _removePoolDelegatorInactive(_poolStakingAddress, _delegator);\n\n        }\n",
                    "message": "Function 'StakingBase._removePoolDelegator' (StakingBase.sol#1158-1174) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._removePoolDelegator (StakingBase.sol#1158) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolDelegator(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._removePoolDelegator (StakingBase.sol#1158) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1180,
                    "vulnerability_to_line": 1191,
                    "vulnerability_code": "    function _removePoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n\n        address[] storage delegators = addressArrayStorage[\n\n            keccak256(abi.encode(POOL_DELEGATORS_INACTIVE, _poolStakingAddress))\n\n        ];\n\n        uint256 indexToRemove = poolDelegatorInactiveIndex(_poolStakingAddress, _delegator);\n\n        if (delegators.length != 0 && delegators[indexToRemove] == _delegator) {\n\n            delegators[indexToRemove] = delegators[delegators.length - 1];\n\n            _setPoolDelegatorInactiveIndex(_poolStakingAddress, delegators[indexToRemove], indexToRemove);\n\n            _setPoolDelegatorInactiveIndex(_poolStakingAddress, _delegator, 0);\n\n            delegators.length--;\n\n        }\n",
                    "message": "Function 'StakingBase._removePoolDelegatorInactive' (StakingBase.sol#1180-1191) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._removePoolDelegatorInactive (StakingBase.sol#1180) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removePoolDelegatorInactive(address _poolStakingAddress, address _delegator) internal {\n",
                    "message": "Parameter '_delegator' of StakingBase._removePoolDelegatorInactive (StakingBase.sol#1180) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1197,
                    "vulnerability_to_line": 1207,
                    "vulnerability_code": "    function _setLikelihood(address _poolStakingAddress) internal {\n\n        (bool isToBeElected, uint256 index) = _isPoolToBeElected(_poolStakingAddress);\n\n\n\n        if (!isToBeElected) return;\n\n\n\n        int256 oldValue = intArrayStorage[POOLS_LIKELIHOOD][index];\n\n        int256 newValue = int256(stakeAmountTotalMinusOrderedWithdraw(_poolStakingAddress) * 100 / STAKE_UNIT);\n\n\n\n        intArrayStorage[POOLS_LIKELIHOOD][index] = newValue;\n\n        intStorage[POOLS_LIKELIHOOD_SUM] += newValue - oldValue;\n",
                    "message": "Function 'StakingBase._setLikelihood' (StakingBase.sol#1197-1207) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setLikelihood(address _poolStakingAddress) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setLikelihood (StakingBase.sol#1197) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1214,
                    "vulnerability_to_line": 1216,
                    "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(ORDERED_WITHDRAW_AMOUNT, _poolStakingAddress, _staker))] = _amount;\n",
                    "message": "Function 'StakingBase._setOrderedWithdrawAmount' (StakingBase.sol#1214-1216) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setOrderedWithdrawAmount (StakingBase.sol#1214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._setOrderedWithdrawAmount (StakingBase.sol#1214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._setOrderedWithdrawAmount (StakingBase.sol#1214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1222,
                    "vulnerability_to_line": 1224,
                    "vulnerability_code": "    function _setOrderedWithdrawAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(ORDERED_WITHDRAW_AMOUNT_TOTAL, _poolStakingAddress))] = _amount;\n",
                    "message": "Function 'StakingBase._setOrderedWithdrawAmountTotal' (StakingBase.sol#1222-1224) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setOrderedWithdrawAmountTotal (StakingBase.sol#1222) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setOrderedWithdrawAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._setOrderedWithdrawAmountTotal (StakingBase.sol#1222) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": 1233,
                    "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(STAKE_AMOUNT, _poolStakingAddress, _staker))] = _amount;\n",
                    "message": "Function 'StakingBase._setStakeAmount' (StakingBase.sol#1231-1233) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setStakeAmount (StakingBase.sol#1231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._setStakeAmount (StakingBase.sol#1231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmount(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._setStakeAmount (StakingBase.sol#1231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1241,
                    "vulnerability_to_line": 1249,
                    "vulnerability_code": "    function _setStakeAmountByCurrentEpoch(\n\n        address _poolStakingAddress,\n\n        address _staker,\n\n        uint256 _amount\n\n    ) internal {\n\n        uintStorage[keccak256(abi.encode(\n\n            STAKE_AMOUNT_BY_EPOCH, _poolStakingAddress, _staker, stakingEpoch()\n\n        ))] = _amount;\n",
                    "message": "Function 'StakingBase._setStakeAmountByCurrentEpoch' (StakingBase.sol#1241-1249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _poolStakingAddress,\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setStakeAmountByCurrentEpoch (StakingBase.sol#1242) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _staker,\n",
                    "message": "Parameter '_staker' of StakingBase._setStakeAmountByCurrentEpoch (StakingBase.sol#1243) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _amount\n",
                    "message": "Parameter '_amount' of StakingBase._setStakeAmountByCurrentEpoch (StakingBase.sol#1244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1254,
                    "vulnerability_to_line": 1256,
                    "vulnerability_code": "    function _setStakeAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n\n        uintStorage[keccak256(abi.encode(STAKE_AMOUNT_TOTAL, _poolStakingAddress))] = _amount;\n",
                    "message": "Function 'StakingBase._setStakeAmountTotal' (StakingBase.sol#1254-1256) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._setStakeAmountTotal (StakingBase.sol#1254) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakeAmountTotal(address _poolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._setStakeAmountTotal (StakingBase.sol#1254) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": 1263,
                    "vulnerability_code": "    function _setDelegatorMinStake(uint256 _minStake) internal {\n\n        uintStorage[DELEGATOR_MIN_STAKE] = _minStake * STAKE_UNIT;\n",
                    "message": "Function 'StakingBase._setDelegatorMinStake' (StakingBase.sol#1261-1263) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setDelegatorMinStake(uint256 _minStake) internal {\n",
                    "message": "Parameter '_minStake' of StakingBase._setDelegatorMinStake (StakingBase.sol#1261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1268,
                    "vulnerability_to_line": 1270,
                    "vulnerability_code": "    function _setCandidateMinStake(uint256 _minStake) internal {\n\n        uintStorage[CANDIDATE_MIN_STAKE] = _minStake * STAKE_UNIT;\n",
                    "message": "Function 'StakingBase._setCandidateMinStake' (StakingBase.sol#1268-1270) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCandidateMinStake(uint256 _minStake) internal {\n",
                    "message": "Parameter '_minStake' of StakingBase._setCandidateMinStake (StakingBase.sol#1268) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1276,
                    "vulnerability_to_line": 1289,
                    "vulnerability_code": "    function _stake(address _toPoolStakingAddress, uint256 _amount) internal {\n\n        IERC20Minting tokenContract = IERC20Minting(erc20TokenContract());\n\n        if (address(tokenContract) != address(0)) {\n\n            require(msg.value == 0);\n\n        }\n\n        address staker = msg.sender;\n\n        _stake(_toPoolStakingAddress, staker, _amount);\n\n        if (address(tokenContract) != address(0)) {\n\n            tokenContract.stake(staker, _amount);\n\n        } else {\n\n            require(boolStorage[ERC20_RESTRICTED]);\n\n        }\n\n        emit Staked(_toPoolStakingAddress, staker, stakingEpoch(), _amount);\n",
                    "message": "Function 'StakingBase._stake' (StakingBase.sol#1276-1289) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _toPoolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_toPoolStakingAddress' of StakingBase._stake (StakingBase.sol#1276) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _toPoolStakingAddress, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._stake (StakingBase.sol#1276) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": 1333,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        IValidatorSet validatorSet = validatorSetContract();\n\n        address poolMiningAddress = validatorSet.miningByStakingAddress(_poolStakingAddress);\n\n\n\n        require(poolMiningAddress != address(0));\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n        require(!validatorSet.isValidatorBanned(poolMiningAddress));\n\n        require(areStakeAndWithdrawAllowed());\n\n\n\n        uint256 newStakeAmount = stakeAmount(_poolStakingAddress, _staker).add(_amount);\n\n        if (_staker == _poolStakingAddress) {\n\n            require(newStakeAmount >= getCandidateMinStake()); // the staked amount must be at least CANDIDATE_MIN_STAKE\n\n        } else {\n\n            require(newStakeAmount >= getDelegatorMinStake()); // the staked amount must be at least DELEGATOR_MIN_STAKE\n\n\n\n            // The delegator cannot stake into the pool of the candidate which hasn't self-staked.\n\n            // Also, that candidate shouldn't want to withdraw all his funds.\n\n            require(stakeAmountMinusOrderedWithdraw(_poolStakingAddress, _poolStakingAddress) != 0);\n\n        }\n\n        _setStakeAmount(_poolStakingAddress, _staker, newStakeAmount);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            stakeAmountByCurrentEpoch(_poolStakingAddress, _staker).add(_amount)\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).add(_amount));\n\n\n\n        if (_staker == _poolStakingAddress) { // `staker` makes a stake for himself and becomes a candidate\n\n            // Add `_poolStakingAddress` to the array of pools\n\n            _addPoolActive(_poolStakingAddress, _poolStakingAddress != validatorSet.unremovableValidator());\n\n        } else {\n\n            // Add `_staker` to the array of pool's delegators\n\n            _addPoolDelegator(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Function 'StakingBase._stake' (StakingBase.sol#1296-1333) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._stake (StakingBase.sol#1296) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._stake (StakingBase.sol#1296) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _stake(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._stake (StakingBase.sol#1296) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": 1370,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n\n        require(_poolStakingAddress != address(0));\n\n        require(_amount != 0);\n\n\n\n        // How much can `staker` withdraw from `_poolStakingAddress` at the moment?\n\n        require(_amount <= maxWithdrawAllowed(_poolStakingAddress, _staker));\n\n\n\n        uint256 currentStakeAmount = stakeAmount(_poolStakingAddress, _staker);\n\n        uint256 alreadyOrderedAmount = orderedWithdrawAmount(_poolStakingAddress, _staker);\n\n        uint256 resultingStakeAmount = currentStakeAmount.sub(alreadyOrderedAmount).sub(_amount);\n\n\n\n        // The amount to be withdrawn must be the whole staked amount or\n\n        // must not exceed the diff between the entire amount and MIN_STAKE\n\n        uint256 minAllowedStake = (_poolStakingAddress == _staker) ? getCandidateMinStake() : getDelegatorMinStake();\n\n        require(resultingStakeAmount == 0 || resultingStakeAmount >= minAllowedStake);\n\n\n\n        _setStakeAmount(_poolStakingAddress, _staker, currentStakeAmount.sub(_amount));\n\n        uint256 amountByEpoch = stakeAmountByCurrentEpoch(_poolStakingAddress, _staker);\n\n        _setStakeAmountByCurrentEpoch(\n\n            _poolStakingAddress,\n\n            _staker,\n\n            amountByEpoch >= _amount ? amountByEpoch - _amount : 0\n\n        );\n\n        _setStakeAmountTotal(_poolStakingAddress, stakeAmountTotal(_poolStakingAddress).sub(_amount));\n\n\n\n        if (resultingStakeAmount == 0) {\n\n            _withdrawCheckPool(_poolStakingAddress, _staker);\n\n        }\n\n\n\n        _setLikelihood(_poolStakingAddress);\n",
                    "message": "Function 'StakingBase._withdraw' (StakingBase.sol#1340-1370) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._withdraw (StakingBase.sol#1340) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._withdraw (StakingBase.sol#1340) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdraw(address _poolStakingAddress, address _staker, uint256 _amount) internal {\n",
                    "message": "Parameter '_amount' of StakingBase._withdraw (StakingBase.sol#1340) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": 1391,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n\n        if (_staker == _poolStakingAddress) {\n\n            IValidatorSet validatorSet = validatorSetContract();\n\n            address unremovableStakingAddress = validatorSet.unremovableValidator();\n\n\n\n            if (_poolStakingAddress != unremovableStakingAddress) {\n\n                if (validatorSet.isValidator(validatorSet.miningByStakingAddress(_poolStakingAddress))) {\n\n                    _addPoolToBeRemoved(_poolStakingAddress);\n\n                } else {\n\n                    _removePool(_poolStakingAddress);\n\n                }\n\n            }\n\n        } else {\n\n            _removePoolDelegator(_poolStakingAddress, _staker);\n\n        }\n",
                    "message": "Function 'StakingBase._withdrawCheckPool' (StakingBase.sol#1376-1391) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n",
                    "message": "Parameter '_poolStakingAddress' of StakingBase._withdrawCheckPool (StakingBase.sol#1376) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _withdrawCheckPool(address _poolStakingAddress, address _staker) internal {\n",
                    "message": "Parameter '_staker' of StakingBase._withdrawCheckPool (StakingBase.sol#1376) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1394,
                    "vulnerability_to_line": 1396,
                    "vulnerability_code": "    function _getCurrentBlockNumber() internal view returns(uint256) {\n\n        return block.number;\n",
                    "message": "Function 'StakingBase._getCurrentBlockNumber' (StakingBase.sol#1394-1396) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1400,
                    "vulnerability_to_line": 1402,
                    "vulnerability_code": "    function _getMaxCandidates() internal pure returns(uint256) {\n\n        return MAX_CANDIDATES;\n",
                    "message": "Function 'StakingBase._getMaxCandidates' (StakingBase.sol#1400-1402) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1410,
                    "vulnerability_to_line": 1419,
                    "vulnerability_code": "    function _isPoolToBeElected(address _stakingAddress) internal view returns(bool toBeElected, uint256 index) {\n\n        address[] storage pools = addressArrayStorage[POOLS_TO_BE_ELECTED];\n\n        if (pools.length != 0) {\n\n            index = poolToBeElectedIndex(_stakingAddress);\n\n            if (pools[index] == _stakingAddress) {\n\n                return (true, index);\n\n            }\n\n        }\n\n        return (false, 0);\n",
                    "message": "Function 'StakingBase._isPoolToBeElected' (StakingBase.sol#1410-1419) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isPoolToBeElected(address _stakingAddress) internal view returns(bool toBeElected, uint256 index) {\n",
                    "message": "Parameter '_stakingAddress' of StakingBase._isPoolToBeElected (StakingBase.sol#1410) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": 1435,
                    "vulnerability_code": "    function _isWithdrawAllowed(address _miningAddress) internal view returns(bool) {\n\n        if (validatorSetContract().isValidatorBanned(_miningAddress)) {\n\n            // No one can withdraw from `_poolStakingAddress` until the ban is expired\n\n            return false;\n\n        }\n\n\n\n        if (!areStakeAndWithdrawAllowed()) {\n\n            return false;\n\n        }\n\n\n\n        return true;\n",
                    "message": "Function 'StakingBase._isWithdrawAllowed' (StakingBase.sol#1424-1435) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isWithdrawAllowed(address _miningAddress) internal view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of StakingBase._isWithdrawAllowed (StakingBase.sol#1424) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (StakingBase.sol#101) is never used in StakingBase\nEternalStorage.bytesStorage (StakingBase.sol#103) is never used in StakingBase\nEternalStorage.bytes32Storage (StakingBase.sol#106) is never used in StakingBase\nEternalStorage.uintArrayStorage (StakingBase.sol#108) is never used in StakingBase\nEternalStorage.stringArrayStorage (StakingBase.sol#109) is never used in StakingBase\nEternalStorage.bytesArrayStorage (StakingBase.sol#111) is never used in StakingBase\nEternalStorage.boolArrayStorage (StakingBase.sol#112) is never used in StakingBase\nEternalStorage.bytes32ArrayStorage (StakingBase.sol#114) is never used in StakingBase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 963,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            likelihood.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 978,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 992,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 1013,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pools.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 1167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delegators.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialStakingAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_MSGVALUE_EQUALS_ZERO",
                    "vulnerability_from_line": 1279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(msg.value == 0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErc20TokenContract(address _erc20TokenContract) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCandidateMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setDelegatorMinStake(uint256 _minStake) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory likelihoods, int256 sum) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isPoolToBeElected(address _stakingAddress) internal view returns(bool toBeElected, uint256 index) {\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/abstracts/RandomBase.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_25"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner (RandomBase.sol#55) is never initialized. It is used in:\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (RandomBase.sol#55)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in RandomBase.sol:\n\t- pragma solidity0.5.9 (RandomBase.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (RandomBase.sol#12): it allows old versions\n\t- pragma solidity0.5.9 (RandomBase.sol#47): it allows old versions\n\t- pragma solidity0.5.9 (RandomBase.sol#78): it allows old versions\n\t- pragma solidity0.5.9 (RandomBase.sol#96): it allows old versions\n\t- pragma solidity0.5.9 (RandomBase.sol#135): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (RandomBase.sol#17) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (RandomBase.sol#18) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (RandomBase.sol#19) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (RandomBase.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (RandomBase.sol#21) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (RandomBase.sol#22) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (RandomBase.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (RandomBase.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (RandomBase.sol#32) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (RandomBase.sol#33) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (RandomBase.sol#34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (RandomBase.sol#35) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (RandomBase.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (RandomBase.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (RandomBase.sol#41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (RandomBase.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": 189,
                    "vulnerability_code": "    function _initialize(address _validatorSet) internal {\n\n        require(!isInitialized());\n\n        require(_validatorSet != address(0));\n\n        addressStorage[VALIDATOR_SET_CONTRACT] = _validatorSet;\n",
                    "message": "Function 'RandomBase._initialize' (RandomBase.sol#185-189) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _initialize(address _validatorSet) internal {\n",
                    "message": "Parameter '_validatorSet' of RandomBase._initialize (RandomBase.sol#185) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": 195,
                    "vulnerability_code": "    function _setCurrentSeed(uint256 _seed) internal {\n\n        uintStorage[CURRENT_SEED] = _seed;\n",
                    "message": "Function 'RandomBase._setCurrentSeed' (RandomBase.sol#193-195) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setCurrentSeed(uint256 _seed) internal {\n",
                    "message": "Parameter '_seed' of RandomBase._setCurrentSeed (RandomBase.sol#193) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": 200,
                    "vulnerability_code": "    function _getCurrentSeed() internal view returns(uint256) {\n\n        return uintStorage[CURRENT_SEED];\n",
                    "message": "Function 'RandomBase._getCurrentSeed' (RandomBase.sol#198-200) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (RandomBase.sol#59) is never used in RandomBase\nEternalStorage.bytesStorage (RandomBase.sol#61) is never used in RandomBase\nEternalStorage.boolStorage (RandomBase.sol#62) is never used in RandomBase\nEternalStorage.intStorage (RandomBase.sol#63) is never used in RandomBase\nEternalStorage.bytes32Storage (RandomBase.sol#64) is never used in RandomBase\nEternalStorage.uintArrayStorage (RandomBase.sol#66) is never used in RandomBase\nEternalStorage.stringArrayStorage (RandomBase.sol#67) is never used in RandomBase\nEternalStorage.addressArrayStorage (RandomBase.sol#68) is never used in RandomBase\nEternalStorage.bytesArrayStorage (RandomBase.sol#69) is never used in RandomBase\nEternalStorage.boolArrayStorage (RandomBase.sol#70) is never used in RandomBase\nEternalStorage.intArrayStorage (RandomBase.sol#71) is never used in RandomBase\nEternalStorage.bytes32ArrayStorage (RandomBase.sol#72) is never used in RandomBase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/abstracts/ValidatorSetBase.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 557,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < prevValidators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _queueValidators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 708,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 711,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                miningAddresses[i] = miningAddresses[miningAddresses.length - 1];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                miningAddresses.length--;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 771,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _stakingAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < poolsToBeRemoved.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 708,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (validatorSetApplyBlock() == 0 && newStakingEpoch) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // Apply a new validator set formed by the `newValidatorSet` function\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address[] memory previousValidators = getPreviousValidators();\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address[] memory currentValidators = getValidators();\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 i;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // Save the previous validator set\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                _setIsValidatorOnPreviousEpoch(previousValidators[i], false);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 648,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 649,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolsToBeElected.length >= MAX_VALIDATORS &&\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 651,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 653,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 655,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (likelihood.length > 0 && likelihoodSum > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 657,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                address[] memory newValidators = new address[](\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (likelihood.length > 0 && likelihoodSum > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 657,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                address[] memory newValidators = new address[](\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 659,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                );\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 661,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 663,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 592,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (int256 i = queueLast; i >= queueFirst; i--) {\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 667,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    poolsToBeElectedLength--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                miningAddresses.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 557,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < prevValidators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _queueValidators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 577,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uintStorage[keccak256(abi.encode(BAN_COUNTER, _miningAddress))]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        queueLast++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 627,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            intStorage[QUEUE_PV_FIRST]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 634,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uintStorage[CHANGE_REQUEST_COUNT]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint256 i = 0; i < newValidators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 708,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < miningAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 737,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uintStorage[keccak256(abi.encode(VALIDATOR_COUNTER, _miningAddress))]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 771,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _stakingAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < poolsToBeRemoved.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 858,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_103"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner (ValidatorSetBase.sol#89) is never initialized. It is used in:\n\t- clearUnremovableValidator (ValidatorSetBase.sol#218-223)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 642,
                    "vulnerability_to_line": 687,
                    "vulnerability_code": "    function _newValidatorSet() internal returns(uint256) {\n\n        IStaking staking = IStaking(stakingContract());\n\n        address[] memory poolsToBeElected = staking.getPoolsToBeElected();\n\n        address unremovableStakingAddress = unremovableValidator();\n\n\n\n        // Choose new validators\n\n        if (\n\n            poolsToBeElected.length >= MAX_VALIDATORS &&\n\n            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n\n        ) {\n\n            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n\n\n\n            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n\n\n\n            if (likelihood.length > 0 && likelihoodSum > 0) {\n\n                address[] memory newValidators = new address[](\n\n                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n\n                );\n\n\n\n                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n\n                for (uint256 i = 0; i < newValidators.length; i++) {\n\n                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n\n                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n\n                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n\n                    likelihoodSum -= likelihood[randomPoolIndex];\n\n                    poolsToBeElectedLength--;\n\n                    poolsToBeElected[randomPoolIndex] = poolsToBeElected[poolsToBeElectedLength];\n\n                    likelihood[randomPoolIndex] = likelihood[poolsToBeElectedLength];\n\n                }\n\n\n\n                _setPendingValidators(staking, newValidators, unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            _setPendingValidators(staking, poolsToBeElected, unremovableStakingAddress);\n\n        }\n\n\n\n        // From this moment the `getPendingValidators()` will return a new validator set\n\n\n\n        staking.incrementStakingEpoch();\n\n        _setValidatorSetApplyBlock(0);\n\n\n\n        _incrementChangeRequestCount();\n\n        _enqueuePendingValidators(true);\n\n\n\n        return poolsToBeElected.length;\n",
                    "message": "Reentrancy in ValidatorSetBase._newValidatorSet (ValidatorSetBase.sol#642-687):\n\tExternal calls:\n\t- poolsToBeElected = staking.getPoolsToBeElected() (ValidatorSetBase.sol#644)\n\t- randomNumber = IRandom(randomContract()).getCurrentSeed() (ValidatorSetBase.sol#652)\n\t- (likelihood,likelihoodSum) = staking.getPoolsLikelihood() (ValidatorSetBase.sol#654)\n\t- _setPendingValidators(staking,newValidators,unremovableStakingAddress) (ValidatorSetBase.sol#672)\n\t- _setPendingValidators(staking,poolsToBeElected,unremovableStakingAddress) (ValidatorSetBase.sol#675)\n\t- staking.incrementStakingEpoch() (ValidatorSetBase.sol#680)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetBase.sol#684)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _stakingContract.removePool(poolsToBeRemoved[i]);\n",
                    "message": "ValidatorSetBase._setPendingValidators has external calls inside a loop:\n\t- _stakingContract.removePool(poolsToBeRemoved[i]) (ValidatorSetBase.sol#777)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 642,
                    "vulnerability_to_line": 687,
                    "vulnerability_code": "    function _newValidatorSet() internal returns(uint256) {\n\n        IStaking staking = IStaking(stakingContract());\n\n        address[] memory poolsToBeElected = staking.getPoolsToBeElected();\n\n        address unremovableStakingAddress = unremovableValidator();\n\n\n\n        // Choose new validators\n\n        if (\n\n            poolsToBeElected.length >= MAX_VALIDATORS &&\n\n            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n\n        ) {\n\n            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n\n\n\n            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n\n\n\n            if (likelihood.length > 0 && likelihoodSum > 0) {\n\n                address[] memory newValidators = new address[](\n\n                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n\n                );\n\n\n\n                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n\n                for (uint256 i = 0; i < newValidators.length; i++) {\n\n                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n\n                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n\n                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n\n                    likelihoodSum -= likelihood[randomPoolIndex];\n\n                    poolsToBeElectedLength--;\n\n                    poolsToBeElected[randomPoolIndex] = poolsToBeElected[poolsToBeElectedLength];\n\n                    likelihood[randomPoolIndex] = likelihood[poolsToBeElectedLength];\n\n                }\n\n\n\n                _setPendingValidators(staking, newValidators, unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            _setPendingValidators(staking, poolsToBeElected, unremovableStakingAddress);\n\n        }\n\n\n\n        // From this moment the `getPendingValidators()` will return a new validator set\n\n\n\n        staking.incrementStakingEpoch();\n\n        _setValidatorSetApplyBlock(0);\n\n\n\n        _incrementChangeRequestCount();\n\n        _enqueuePendingValidators(true);\n\n\n\n        return poolsToBeElected.length;\n",
                    "message": "Reentrancy in ValidatorSetBase._newValidatorSet (ValidatorSetBase.sol#642-687):\n\tExternal calls:\n\t- poolsToBeElected = staking.getPoolsToBeElected() (ValidatorSetBase.sol#644)\n\t- randomNumber = IRandom(randomContract()).getCurrentSeed() (ValidatorSetBase.sol#652)\n\t- (likelihood,likelihoodSum) = staking.getPoolsLikelihood() (ValidatorSetBase.sol#654)\n\t- _setPendingValidators(staking,newValidators,unremovableStakingAddress) (ValidatorSetBase.sol#672)\n\t- _setPendingValidators(staking,poolsToBeElected,unremovableStakingAddress) (ValidatorSetBase.sol#675)\n\t- staking.incrementStakingEpoch() (ValidatorSetBase.sol#680)\n\tState variables written after the call(s):\n\t- boolStorage (ValidatorSetBase.sol#684)\n\t- intStorage (ValidatorSetBase.sol#684)\n\t- uintStorage (ValidatorSetBase.sol#681)\n\t- uintStorage (ValidatorSetBase.sol#683)\n\t- uintStorage (ValidatorSetBase.sol#684)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": 718,
                    "vulnerability_code": "    function _removeMaliciousValidator(address _miningAddress) internal returns(bool) {\n\n        address stakingAddress = stakingByMiningAddress(_miningAddress);\n\n\n\n        if (stakingAddress == unremovableValidator()) {\n\n            return false;\n\n        }\n\n\n\n        // Ban the malicious validator for the next 3 months\n\n        _banValidator(_miningAddress);\n\n\n\n        // Remove malicious validator from the `pools`\n\n        IStaking(stakingContract()).removePool(stakingAddress);\n\n\n\n        address[] storage miningAddresses = addressArrayStorage[PENDING_VALIDATORS];\n\n\n\n        for (uint256 i = 0; i < miningAddresses.length; i++) {\n\n            if (miningAddresses[i] == _miningAddress) {\n\n                // Remove the malicious validator from `pendingValidators`\n\n                miningAddresses[i] = miningAddresses[miningAddresses.length - 1];\n\n                miningAddresses.length--;\n\n                return true;\n\n            }\n\n        }\n\n\n\n        return false;\n",
                    "message": "Reentrancy in ValidatorSetBase._removeMaliciousValidator (ValidatorSetBase.sol#693-718):\n\tExternal calls:\n\t- IStaking(stakingContract()).removePool(stakingAddress) (ValidatorSetBase.sol#704)\n\tState variables written after the call(s):\n\t- addressArrayStorage (ValidatorSetBase.sol#711)\n\t- addressArrayStorage (ValidatorSetBase.sol#712)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (ValidatorSetBase.sol#89)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function blockRewardContract() external view returns(address);\n",
                    "message": "IValidatorSet.blockRewardContract (ValidatorSetBase.sol#60) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": 361,
                    "vulnerability_code": "    function blockRewardContract() public view returns(address) {\n\n        return addressStorage[BLOCK_REWARD_CONTRACT];\n",
                    "message": "ValidatorSetBase.blockRewardContract (ValidatorSetBase.sol#359-361) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": 367,
                    "vulnerability_code": "    function changeRequestCount() public view returns(uint256) {\n\n        return uintStorage[CHANGE_REQUEST_COUNT];\n",
                    "message": "ValidatorSetBase.changeRequestCount (ValidatorSetBase.sol#365-367) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function changeRequestCount() external view returns(uint256);\n",
                    "message": "IValidatorSet.changeRequestCount (ValidatorSetBase.sol#61) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 442,
                    "vulnerability_code": "    function isReportValidatorValid(address _miningAddress) public view returns(bool) {\n\n        bool isValid = isValidator(_miningAddress) && !isValidatorBanned(_miningAddress);\n\n        if (IStaking(stakingContract()).stakingEpoch() == 0 || validatorSetApplyBlock() == 0) {\n\n            return isValid;\n\n        }\n\n        if (_getCurrentBlockNumber() - validatorSetApplyBlock() <= 20) {\n\n            // The current validator set was finalized by the engine,\n\n            // but we should let the previous validators finish\n\n            // reporting malicious validator within a few blocks\n\n            bool previousEpochValidator =\n\n                isValidatorOnPreviousEpoch(_miningAddress) && !isValidatorBanned(_miningAddress);\n\n            return isValid || previousEpochValidator;\n\n        }\n\n        return isValid;\n",
                    "message": "ValidatorSetBase.isReportValidatorValid (ValidatorSetBase.sol#428-442) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "IValidatorSet.isReportValidatorValid (ValidatorSetBase.sol#66) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": 508,
                    "vulnerability_code": "    function validatorIndex(address _miningAddress) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(VALIDATOR_INDEX, _miningAddress))];\n",
                    "message": "ValidatorSetBase.validatorIndex (ValidatorSetBase.sol#506-508) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "IValidatorSet.validatorIndex (ValidatorSetBase.sol#75) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": 347,
                    "vulnerability_code": "    function banCounter(address _miningAddress) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(BAN_COUNTER, _miningAddress))];\n",
                    "message": "ValidatorSetBase.banCounter (ValidatorSetBase.sol#345-347) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 497,
                    "vulnerability_to_line": 499,
                    "vulnerability_code": "    function validatorCounter(address _miningAddress) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(VALIDATOR_COUNTER, _miningAddress))];\n",
                    "message": "ValidatorSetBase.validatorCounter (ValidatorSetBase.sol#497-499) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in ValidatorSetBase.sol:\n\t- pragma solidity0.5.9 (ValidatorSetBase.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetBase.sol#17): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetBase.sol#26): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetBase.sol#46): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetBase.sol#81): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetBase.sol#112): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetBase.sol#130): it allows old versions\n\t- pragma solidity0.5.9 (ValidatorSetBase.sol#169): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address) external;\n",
                    "message": "Parameter '' of IBlockReward.initialize (ValidatorSetBase.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function DELEGATORS_ALIQUOT() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IBlockReward.DELEGATORS_ALIQUOT' (ValidatorSetBase.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
                    "message": "Parameter '' of IStaking.clearUnremovableValidator (ValidatorSetBase.sol#30) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address) external;\n",
                    "message": "Parameter '' of IStaking.removePool (ValidatorSetBase.sol#32) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "Parameter '' of IStaking.poolDelegators (ValidatorSetBase.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (ValidatorSetBase.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (ValidatorSetBase.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (ValidatorSetBase.sol#40) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (ValidatorSetBase.sol#51) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (ValidatorSetBase.sol#52) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (ValidatorSetBase.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (ValidatorSetBase.sol#54) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (ValidatorSetBase.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (ValidatorSetBase.sol#56) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (ValidatorSetBase.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (ValidatorSetBase.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (ValidatorSetBase.sol#66) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (ValidatorSetBase.sol#67) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (ValidatorSetBase.sol#68) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (ValidatorSetBase.sol#69) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (ValidatorSetBase.sol#70) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (ValidatorSetBase.sol#72) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (ValidatorSetBase.sol#75) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (ValidatorSetBase.sol#89) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _blockRewardContract,\n",
                    "message": "Parameter '_blockRewardContract' of ValidatorSetBase.initialize (ValidatorSetBase.sol#294) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _randomContract,\n",
                    "message": "Parameter '_randomContract' of ValidatorSetBase.initialize (ValidatorSetBase.sol#295) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _stakingContract,\n",
                    "message": "Parameter '_stakingContract' of ValidatorSetBase.initialize (ValidatorSetBase.sol#296) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialMiningAddresses,\n",
                    "message": "Parameter '_initialMiningAddresses' of ValidatorSetBase.initialize (ValidatorSetBase.sol#297) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
                    "message": "Parameter '_initialStakingAddresses' of ValidatorSetBase.initialize (ValidatorSetBase.sol#298) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _firstValidatorIsUnremovable\n",
                    "message": "Parameter '_firstValidatorIsUnremovable' of ValidatorSetBase.initialize (ValidatorSetBase.sol#299) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address _miningAddress, address _stakingAddress) external onlyStakingContract {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.setStakingAddress (ValidatorSetBase.sol#337) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address _miningAddress, address _stakingAddress) external onlyStakingContract {\n",
                    "message": "Parameter '_stakingAddress' of ValidatorSetBase.setStakingAddress (ValidatorSetBase.sol#337) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.isReportValidatorValid (ValidatorSetBase.sol#428) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.isValidator (ValidatorSetBase.sol#447) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.isValidatorBanned (ValidatorSetBase.sol#461) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address _stakingAddress) public view returns(address) {\n",
                    "message": "Parameter '_stakingAddress' of ValidatorSetBase.miningByStakingAddress (ValidatorSetBase.sol#468) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address _miningAddress) public view returns(address) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.stakingByMiningAddress (ValidatorSetBase.sol#480) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address _miningAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.validatorIndex (ValidatorSetBase.sol#506) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function banCounter(address _miningAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.banCounter (ValidatorSetBase.sol#345) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bannedUntil(address _miningAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.bannedUntil (ValidatorSetBase.sol#354) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorOnPreviousEpoch(address _miningAddress) public view returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.isValidatorOnPreviousEpoch (ValidatorSetBase.sol#454) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 497,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCounter(address _miningAddress) public view returns(uint256) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase.validatorCounter (ValidatorSetBase.sol#497) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": 569,
                    "vulnerability_code": "    function _applyQueueValidators(address[] memory _queueValidators) internal {\n\n        address[] memory prevValidators = getValidators();\n\n        uint256 i;\n\n\n\n        // Clear indexes for old validator set\n\n        for (i = 0; i < prevValidators.length; i++) {\n\n            _setValidatorIndex(prevValidators[i], 0);\n\n            _setIsValidator(prevValidators[i], false);\n\n        }\n\n\n\n        addressArrayStorage[CURRENT_VALIDATORS] = _queueValidators;\n\n\n\n        // Set indexes for new validator set\n\n        for (i = 0; i < _queueValidators.length; i++) {\n\n            _setValidatorIndex(_queueValidators[i], i);\n\n            _setIsValidator(_queueValidators[i], true);\n\n        }\n",
                    "message": "Function 'ValidatorSetBase._applyQueueValidators' (ValidatorSetBase.sol#552-569) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _applyQueueValidators(address[] memory _queueValidators) internal {\n",
                    "message": "Parameter '_queueValidators' of ValidatorSetBase._applyQueueValidators (ValidatorSetBase.sol#552) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": 581,
                    "vulnerability_code": "    function _banValidator(address _miningAddress) internal {\n\n        if (_banStart() > bannedUntil(_miningAddress)) {\n\n            uintStorage[keccak256(abi.encode(BAN_COUNTER, _miningAddress))]++;\n\n        }\n\n\n\n        uintStorage[keccak256(abi.encode(BANNED_UNTIL, _miningAddress))] = _banUntil();\n",
                    "message": "Function 'ValidatorSetBase._banValidator' (ValidatorSetBase.sol#575-581) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _banValidator(address _miningAddress) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase._banValidator (ValidatorSetBase.sol#575) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": 607,
                    "vulnerability_code": "    function _enqueuePendingValidators(bool _newStakingEpoch) internal {\n\n        int256 queueFirst = intStorage[QUEUE_PV_FIRST];\n\n        int256 queueLast = intStorage[QUEUE_PV_LAST];\n\n\n\n        for (int256 i = queueLast; i >= queueFirst; i--) {\n\n            if (uintStorage[keccak256(abi.encode(QUEUE_PV_BLOCK, i))] == _getCurrentBlockNumber()) {\n\n                addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, i))] = getPendingValidators();\n\n                if (_newStakingEpoch) {\n\n                    boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, i))] = true;\n\n                }\n\n                return;\n\n            }\n\n        }\n\n\n\n        queueLast++;\n\n        addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, queueLast))] = getPendingValidators();\n\n        boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, queueLast))] = _newStakingEpoch;\n\n        uintStorage[keccak256(abi.encode(QUEUE_PV_BLOCK, queueLast))] = _getCurrentBlockNumber();\n\n        intStorage[QUEUE_PV_LAST] = queueLast;\n",
                    "message": "Function 'ValidatorSetBase._enqueuePendingValidators' (ValidatorSetBase.sol#588-607) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _enqueuePendingValidators(bool _newStakingEpoch) internal {\n",
                    "message": "Parameter '_newStakingEpoch' of ValidatorSetBase._enqueuePendingValidators (ValidatorSetBase.sol#588) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 614,
                    "vulnerability_to_line": 629,
                    "vulnerability_code": "    function _dequeuePendingValidators() internal returns(address[] memory newSet, bool newStakingEpoch) {\n\n        int256 queueFirst = intStorage[QUEUE_PV_FIRST];\n\n        int256 queueLast = intStorage[QUEUE_PV_LAST];\n\n\n\n        if (queueLast < queueFirst) {\n\n            newSet = new address[](0);\n\n            newStakingEpoch = false;\n\n        } else {\n\n            newSet = addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, queueFirst))];\n\n            newStakingEpoch = boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, queueFirst))];\n\n            delete addressArrayStorage[keccak256(abi.encode(QUEUE_PV_LIST, queueFirst))];\n\n            delete boolStorage[keccak256(abi.encode(QUEUE_PV_NEW_EPOCH, queueFirst))];\n\n            delete uintStorage[keccak256(abi.encode(QUEUE_PV_BLOCK, queueFirst))];\n\n            intStorage[QUEUE_PV_FIRST]++;\n\n        }\n",
                    "message": "Function 'ValidatorSetBase._dequeuePendingValidators' (ValidatorSetBase.sol#614-629) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 633,
                    "vulnerability_to_line": 635,
                    "vulnerability_code": "    function _incrementChangeRequestCount() internal {\n\n        uintStorage[CHANGE_REQUEST_COUNT]++;\n",
                    "message": "Function 'ValidatorSetBase._incrementChangeRequestCount' (ValidatorSetBase.sol#633-635) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 642,
                    "vulnerability_to_line": 687,
                    "vulnerability_code": "    function _newValidatorSet() internal returns(uint256) {\n\n        IStaking staking = IStaking(stakingContract());\n\n        address[] memory poolsToBeElected = staking.getPoolsToBeElected();\n\n        address unremovableStakingAddress = unremovableValidator();\n\n\n\n        // Choose new validators\n\n        if (\n\n            poolsToBeElected.length >= MAX_VALIDATORS &&\n\n            (poolsToBeElected.length != MAX_VALIDATORS || unremovableStakingAddress != address(0))\n\n        ) {\n\n            uint256 randomNumber = IRandom(randomContract()).getCurrentSeed();\n\n\n\n            (int256[] memory likelihood, int256 likelihoodSum) = staking.getPoolsLikelihood();\n\n\n\n            if (likelihood.length > 0 && likelihoodSum > 0) {\n\n                address[] memory newValidators = new address[](\n\n                    unremovableStakingAddress == address(0) ? MAX_VALIDATORS : MAX_VALIDATORS - 1\n\n                );\n\n\n\n                uint256 poolsToBeElectedLength = poolsToBeElected.length;\n\n                for (uint256 i = 0; i < newValidators.length; i++) {\n\n                    randomNumber = uint256(keccak256(abi.encode(randomNumber)));\n\n                    uint256 randomPoolIndex = _getRandomIndex(likelihood, likelihoodSum, randomNumber);\n\n                    newValidators[i] = poolsToBeElected[randomPoolIndex];\n\n                    likelihoodSum -= likelihood[randomPoolIndex];\n\n                    poolsToBeElectedLength--;\n\n                    poolsToBeElected[randomPoolIndex] = poolsToBeElected[poolsToBeElectedLength];\n\n                    likelihood[randomPoolIndex] = likelihood[poolsToBeElectedLength];\n\n                }\n\n\n\n                _setPendingValidators(staking, newValidators, unremovableStakingAddress);\n\n            }\n\n        } else {\n\n            _setPendingValidators(staking, poolsToBeElected, unremovableStakingAddress);\n\n        }\n\n\n\n        // From this moment the `getPendingValidators()` will return a new validator set\n\n\n\n        staking.incrementStakingEpoch();\n\n        _setValidatorSetApplyBlock(0);\n\n\n\n        _incrementChangeRequestCount();\n\n        _enqueuePendingValidators(true);\n\n\n\n        return poolsToBeElected.length;\n",
                    "message": "Function 'ValidatorSetBase._newValidatorSet' (ValidatorSetBase.sol#642-687) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": 718,
                    "vulnerability_code": "    function _removeMaliciousValidator(address _miningAddress) internal returns(bool) {\n\n        address stakingAddress = stakingByMiningAddress(_miningAddress);\n\n\n\n        if (stakingAddress == unremovableValidator()) {\n\n            return false;\n\n        }\n\n\n\n        // Ban the malicious validator for the next 3 months\n\n        _banValidator(_miningAddress);\n\n\n\n        // Remove malicious validator from the `pools`\n\n        IStaking(stakingContract()).removePool(stakingAddress);\n\n\n\n        address[] storage miningAddresses = addressArrayStorage[PENDING_VALIDATORS];\n\n\n\n        for (uint256 i = 0; i < miningAddresses.length; i++) {\n\n            if (miningAddresses[i] == _miningAddress) {\n\n                // Remove the malicious validator from `pendingValidators`\n\n                miningAddresses[i] = miningAddresses[miningAddresses.length - 1];\n\n                miningAddresses.length--;\n\n                return true;\n\n            }\n\n        }\n\n\n\n        return false;\n",
                    "message": "Function 'ValidatorSetBase._removeMaliciousValidator' (ValidatorSetBase.sol#693-718) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeMaliciousValidator(address _miningAddress) internal returns(bool) {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase._removeMaliciousValidator (ValidatorSetBase.sol#693) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 724,
                    "vulnerability_to_line": 726,
                    "vulnerability_code": "    function _setInitiateChangeAllowed(bool _allowed) internal {\n\n        boolStorage[INITIATE_CHANGE_ALLOWED] = _allowed;\n",
                    "message": "Function 'ValidatorSetBase._setInitiateChangeAllowed' (ValidatorSetBase.sol#724-726) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 724,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setInitiateChangeAllowed(bool _allowed) internal {\n",
                    "message": "Parameter '_allowed' of ValidatorSetBase._setInitiateChangeAllowed (ValidatorSetBase.sol#724) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": 739,
                    "vulnerability_code": "    function _setIsValidator(address _miningAddress, bool _isValidator) internal {\n\n        boolStorage[keccak256(abi.encode(IS_VALIDATOR, _miningAddress))] = _isValidator;\n\n\n\n        if (_isValidator) {\n\n            uintStorage[keccak256(abi.encode(VALIDATOR_COUNTER, _miningAddress))]++;\n\n        }\n",
                    "message": "Function 'ValidatorSetBase._setIsValidator' (ValidatorSetBase.sol#733-739) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIsValidator(address _miningAddress, bool _isValidator) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase._setIsValidator (ValidatorSetBase.sol#733) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIsValidator(address _miningAddress, bool _isValidator) internal {\n",
                    "message": "Parameter '_isValidator' of ValidatorSetBase._setIsValidator (ValidatorSetBase.sol#733) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": 747,
                    "vulnerability_code": "    function _setIsValidatorOnPreviousEpoch(address _miningAddress, bool _isValidator) internal {\n\n        boolStorage[keccak256(abi.encode(IS_VALIDATOR_ON_PREVIOUS_EPOCH, _miningAddress))] = _isValidator;\n",
                    "message": "Function 'ValidatorSetBase._setIsValidatorOnPreviousEpoch' (ValidatorSetBase.sol#745-747) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIsValidatorOnPreviousEpoch(address _miningAddress, bool _isValidator) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase._setIsValidatorOnPreviousEpoch (ValidatorSetBase.sol#745) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIsValidatorOnPreviousEpoch(address _miningAddress, bool _isValidator) internal {\n",
                    "message": "Parameter '_isValidator' of ValidatorSetBase._setIsValidatorOnPreviousEpoch (ValidatorSetBase.sol#745) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 756,
                    "vulnerability_to_line": 779,
                    "vulnerability_code": "    function _setPendingValidators(\n\n        IStaking _stakingContract,\n\n        address[] memory _stakingAddresses,\n\n        address _unremovableStakingAddress\n\n    ) internal {\n\n        if (_stakingAddresses.length == 0) return;\n\n\n\n        uint256 i;\n\n\n\n        delete addressArrayStorage[PENDING_VALIDATORS];\n\n\n\n        if (_unremovableStakingAddress != address(0)) {\n\n            addressArrayStorage[PENDING_VALIDATORS].push(miningByStakingAddress(_unremovableStakingAddress));\n\n        }\n\n\n\n        for (i = 0; i < _stakingAddresses.length; i++) {\n\n            addressArrayStorage[PENDING_VALIDATORS].push(miningByStakingAddress(_stakingAddresses[i]));\n\n        }\n\n\n\n        address[] memory poolsToBeRemoved = _stakingContract.getPoolsToBeRemoved();\n\n        for (i = 0; i < poolsToBeRemoved.length; i++) {\n\n            _stakingContract.removePool(poolsToBeRemoved[i]);\n\n        }\n",
                    "message": "Function 'ValidatorSetBase._setPendingValidators' (ValidatorSetBase.sol#756-779) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IStaking _stakingContract,\n",
                    "message": "Parameter '_stakingContract' of ValidatorSetBase._setPendingValidators (ValidatorSetBase.sol#757) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 758,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _stakingAddresses,\n",
                    "message": "Parameter '_stakingAddresses' of ValidatorSetBase._setPendingValidators (ValidatorSetBase.sol#758) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 759,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _unremovableStakingAddress\n",
                    "message": "Parameter '_unremovableStakingAddress' of ValidatorSetBase._setPendingValidators (ValidatorSetBase.sol#759) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": 789,
                    "vulnerability_code": "    function _setQueueValidators(address[] memory _miningAddresses, bool _newStakingEpoch) internal {\n\n        addressArrayStorage[QUEUE_VALIDATORS] = _miningAddresses;\n\n        boolStorage[QUEUE_VALIDATORS_NEW_STAKING_EPOCH] = _newStakingEpoch;\n",
                    "message": "Function 'ValidatorSetBase._setQueueValidators' (ValidatorSetBase.sol#786-789) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setQueueValidators(address[] memory _miningAddresses, bool _newStakingEpoch) internal {\n",
                    "message": "Parameter '_miningAddresses' of ValidatorSetBase._setQueueValidators (ValidatorSetBase.sol#786) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setQueueValidators(address[] memory _miningAddresses, bool _newStakingEpoch) internal {\n",
                    "message": "Parameter '_newStakingEpoch' of ValidatorSetBase._setQueueValidators (ValidatorSetBase.sol#786) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": 805,
                    "vulnerability_code": "    function _setStakingAddress(address _miningAddress, address _stakingAddress) internal {\n\n        require(_miningAddress != address(0));\n\n        require(_stakingAddress != address(0));\n\n        require(_miningAddress != _stakingAddress);\n\n        require(miningByStakingAddress(_stakingAddress) == address(0));\n\n        require(miningByStakingAddress(_miningAddress) == address(0));\n\n        require(stakingByMiningAddress(_stakingAddress) == address(0));\n\n        require(stakingByMiningAddress(_miningAddress) == address(0));\n\n        addressStorage[keccak256(abi.encode(MINING_BY_STAKING_ADDRESS, _stakingAddress))] = _miningAddress;\n\n        addressStorage[keccak256(abi.encode(STAKING_BY_MINING_ADDRESS, _miningAddress))] = _stakingAddress;\n",
                    "message": "Function 'ValidatorSetBase._setStakingAddress' (ValidatorSetBase.sol#795-805) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakingAddress(address _miningAddress, address _stakingAddress) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase._setStakingAddress (ValidatorSetBase.sol#795) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setStakingAddress(address _miningAddress, address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of ValidatorSetBase._setStakingAddress (ValidatorSetBase.sol#795) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 810,
                    "vulnerability_to_line": 812,
                    "vulnerability_code": "    function _setUnremovableValidator(address _stakingAddress) internal {\n\n        addressStorage[UNREMOVABLE_STAKING_ADDRESS] = _stakingAddress;\n",
                    "message": "Function 'ValidatorSetBase._setUnremovableValidator' (ValidatorSetBase.sol#810-812) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 810,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setUnremovableValidator(address _stakingAddress) internal {\n",
                    "message": "Parameter '_stakingAddress' of ValidatorSetBase._setUnremovableValidator (ValidatorSetBase.sol#810) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 818,
                    "vulnerability_to_line": 820,
                    "vulnerability_code": "    function _setValidatorIndex(address _miningAddress, uint256 _index) internal {\n\n        uintStorage[keccak256(abi.encode(VALIDATOR_INDEX, _miningAddress))] = _index;\n",
                    "message": "Function 'ValidatorSetBase._setValidatorIndex' (ValidatorSetBase.sol#818-820) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 818,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setValidatorIndex(address _miningAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_miningAddress' of ValidatorSetBase._setValidatorIndex (ValidatorSetBase.sol#818) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 818,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setValidatorIndex(address _miningAddress, uint256 _index) internal {\n",
                    "message": "Parameter '_index' of ValidatorSetBase._setValidatorIndex (ValidatorSetBase.sol#818) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 826,
                    "vulnerability_to_line": 828,
                    "vulnerability_code": "    function _setValidatorSetApplyBlock(uint256 _blockNumber) internal {\n\n        uintStorage[VALIDATOR_SET_APPLY_BLOCK] = _blockNumber;\n",
                    "message": "Function 'ValidatorSetBase._setValidatorSetApplyBlock' (ValidatorSetBase.sol#826-828) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 826,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setValidatorSetApplyBlock(uint256 _blockNumber) internal {\n",
                    "message": "Parameter '_blockNumber' of ValidatorSetBase._setValidatorSetApplyBlock (ValidatorSetBase.sol#826) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 832,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _banStart() internal view returns(uint256);\n",
                    "message": "Function 'ValidatorSetBase._banStart' (ValidatorSetBase.sol#832) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 836,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _banUntil() internal view returns(uint256);\n",
                    "message": "Function 'ValidatorSetBase._banUntil' (ValidatorSetBase.sol#836) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 839,
                    "vulnerability_to_line": 841,
                    "vulnerability_code": "    function _getCurrentBlockNumber() internal view returns(uint256) {\n\n        return block.number;\n",
                    "message": "Function 'ValidatorSetBase._getCurrentBlockNumber' (ValidatorSetBase.sol#839-841) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 848,
                    "vulnerability_to_line": 861,
                    "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n\n        internal\n\n        pure\n\n        returns(uint256)\n\n    {\n\n        int256 r = int256(_randomNumber % uint256(_likelihoodSum)) + 1;\n\n        uint256 index = 0;\n\n        while (true) {\n\n            r -= _likelihood[index];\n\n            if (r <= 0) break;\n\n            index++;\n\n        }\n\n        return index;\n",
                    "message": "Function 'ValidatorSetBase._getRandomIndex' (ValidatorSetBase.sol#848-861) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n",
                    "message": "Parameter '_likelihood' of ValidatorSetBase._getRandomIndex (ValidatorSetBase.sol#848) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n",
                    "message": "Parameter '_likelihoodSum' of ValidatorSetBase._getRandomIndex (ValidatorSetBase.sol#848) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getRandomIndex(int256[] memory _likelihood, int256 _likelihoodSum, uint256 _randomNumber)\n",
                    "message": "Parameter '_randomNumber' of ValidatorSetBase._getRandomIndex (ValidatorSetBase.sol#848) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (ValidatorSetBase.sol#93) is never used in ValidatorSetBase\nEternalStorage.bytesStorage (ValidatorSetBase.sol#95) is never used in ValidatorSetBase\nEternalStorage.bytes32Storage (ValidatorSetBase.sol#98) is never used in ValidatorSetBase\nEternalStorage.uintArrayStorage (ValidatorSetBase.sol#100) is never used in ValidatorSetBase\nEternalStorage.stringArrayStorage (ValidatorSetBase.sol#101) is never used in ValidatorSetBase\nEternalStorage.bytesArrayStorage (ValidatorSetBase.sol#103) is never used in ValidatorSetBase\nEternalStorage.boolArrayStorage (ValidatorSetBase.sol#104) is never used in ValidatorSetBase\nEternalStorage.intArrayStorage (ValidatorSetBase.sol#105) is never used in ValidatorSetBase\nEternalStorage.bytes32ArrayStorage (ValidatorSetBase.sol#106) is never used in ValidatorSetBase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == 0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _setUnremovableValidator(address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < previousValidators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (i = 0; i < currentValidators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialMiningAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata _initialStakingAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool _firstValidatorIsUnremovable\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isInitialized()); // initialization can only be done once\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isInitialized()); // initialization can only be done once\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_blockRewardContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_blockRewardContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_blockRewardContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_randomContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_randomContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_randomContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_stakingContract != address(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_initialMiningAddresses.length > 0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_initialMiningAddresses.length > 0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_initialMiningAddresses.length == _initialStakingAddresses.length);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_initialMiningAddresses.length == _initialStakingAddresses.length);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_initialMiningAddresses.length == _initialStakingAddresses.length);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        addressStorage[BLOCK_REWARD_CONTRACT] = _blockRewardContract;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        addressStorage[RANDOM_CONTRACT] = _randomContract;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        addressStorage[STAKING_CONTRACT] = _stakingContract;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] storage currentValidators = addressArrayStorage[CURRENT_VALIDATORS];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] storage pendingValidators = addressArrayStorage[PENDING_VALIDATORS];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialMiningAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentValidators.push(_initialMiningAddresses[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentValidators.push(_initialMiningAddresses[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pendingValidators.push(_initialMiningAddresses[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            pendingValidators.push(_initialMiningAddresses[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setValidatorIndex(_initialMiningAddresses[i], i);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setValidatorIndex(_initialMiningAddresses[i], i);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setValidatorIndex(_initialMiningAddresses[i], i);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setIsValidator(_initialMiningAddresses[i], true);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setIsValidator(_initialMiningAddresses[i], true);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setStakingAddress(_initialMiningAddresses[i], _initialStakingAddresses[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setStakingAddress(_initialMiningAddresses[i], _initialStakingAddresses[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setStakingAddress(_initialMiningAddresses[i], _initialStakingAddresses[i]);\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/abstracts/BlockRewardBase.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = extraLength; i < receivers.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = from; i < to; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 641,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (validatorStake != 0 && totalStaked != 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 642,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (validatorHasMore30Per) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 643,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    rewardPercent = REWARD_PERCENT_MULTIPLIER * validatorStake / totalStaked;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    rewardPercent = REWARD_PERCENT_MULTIPLIER * 3 / 10;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < extraLength; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = extraLength; i < receivers.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            j++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 582,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uintStorage[QUEUE_ER_FIRST]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = from; i < to; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_87"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner (BlockRewardBase.sol#80) is never initialized. It is used in:\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => uint256[]) internal uintArrayStorage;\n",
                    "message": "EternalStorage.uintArrayStorage (BlockRewardBase.sol#91) is never initialized. It is used in:\n\t- snapshotRewardPercents (BlockRewardBase.sol#441-445)\n\t- _setSnapshot (BlockRewardBase.sol#621-682)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": 279,
                    "vulnerability_code": "    function migrateMintingStatistics(address _bridge, IBlockReward _prevBlockRewardContract) external onlyOwner {\n\n        require(mintedTotally() == 0);\n\n        uint256 prevMinted = _prevBlockRewardContract.mintedTotally();\n\n        uint256 prevMintedByBridge = _prevBlockRewardContract.mintedTotallyByBridge(_bridge);\n\n        require(prevMinted != 0);\n\n        require(prevMintedByBridge != 0);\n\n        uintStorage[MINTED_TOTALLY] = prevMinted;\n\n        uintStorage[keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))] = prevMintedByBridge;\n",
                    "message": "Reentrancy in BlockRewardBase.migrateMintingStatistics (BlockRewardBase.sol#271-279):\n\tExternal calls:\n\t- prevMinted = _prevBlockRewardContract.mintedTotally() (BlockRewardBase.sol#273)\n\t- prevMintedByBridge = _prevBlockRewardContract.mintedTotallyByBridge(_bridge) (BlockRewardBase.sol#274)\n\tState variables written after the call(s):\n\t- uintStorage (BlockRewardBase.sol#277)\n\t- uintStorage (BlockRewardBase.sol#278)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 669,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n",
                    "message": "BlockRewardBase._setSnapshot has external calls inside a loop:\n\t- rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress,delegators[i]) (BlockRewardBase.sol#669)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n",
                    "message": "BlockRewardBase._setSnapshot has external calls inside a loop:\n\t- rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress,delegators[i]) (BlockRewardBase.sol#674)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": 682,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n\n        uint256 validatorStake = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, _stakingAddress);\n\n        uint256 totalStaked = _stakingContract.stakeAmountTotalMinusOrderedWithdraw(_stakingAddress);\n\n        uint256 delegatorsAmount = totalStaked >= validatorStake ? totalStaked - validatorStake : 0;\n\n        bool validatorHasMore30Per = validatorStake * 7 > delegatorsAmount * 3;\n\n\n\n        address[] memory delegators = _stakingContract.poolDelegators(_stakingAddress);\n\n        uint256 rewardPercent;\n\n\n\n        address[] storage stakers = addressArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_STAKERS, _stakingAddress\n\n        ))];\n\n\n\n        uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_REWARD_PERCENTS, _stakingAddress\n\n        ))];\n\n\n\n        if (_offset == 0) {\n\n            // Calculate reward percent for validator\n\n            rewardPercent = 0;\n\n            if (validatorStake != 0 && totalStaked != 0) {\n\n                if (validatorHasMore30Per) {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * validatorStake / totalStaked;\n\n                } else {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * 3 / 10;\n\n                }\n\n            }\n\n            stakers.push(_stakingAddress);\n\n            rewardPercents.push(rewardPercent);\n\n            addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES].push(_stakingAddress);\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] += totalStaked;\n\n        }\n\n\n\n        uint256 from = _offset * delegators.length / DELEGATORS_ALIQUOT;\n\n        uint256 to = (_offset + 1) * delegators.length / DELEGATORS_ALIQUOT;\n\n\n\n        if (_offset == 0) {\n\n            to += delegators.length % DELEGATORS_ALIQUOT;\n\n        } else {\n\n            from += delegators.length % DELEGATORS_ALIQUOT;\n\n        }\n\n\n\n        // Calculate reward percent for each delegator\n\n        for (uint256 i = from; i < to; i++) {\n\n            rewardPercent = 0;\n\n\n\n            if (validatorHasMore30Per) {\n\n                if (totalStaked != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent / totalStaked;\n\n                }\n\n            } else {\n\n                if (delegatorsAmount != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent * 7 / (delegatorsAmount * 10);\n\n                }\n\n            }\n\n\n\n            stakers.push(delegators[i]);\n\n            rewardPercents.push(rewardPercent);\n\n        }\n",
                    "message": "Reentrancy in BlockRewardBase._setSnapshot (BlockRewardBase.sol#621-682):\n\tExternal calls:\n\t- validatorStake = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress,_stakingAddress) (BlockRewardBase.sol#622)\n\t- totalStaked = _stakingContract.stakeAmountTotalMinusOrderedWithdraw(_stakingAddress) (BlockRewardBase.sol#623)\n\t- delegators = _stakingContract.poolDelegators(_stakingAddress) (BlockRewardBase.sol#627)\n\tState variables written after the call(s):\n\t- addressArrayStorage (BlockRewardBase.sol#650)\n\t- uintStorage (BlockRewardBase.sol#651)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "EternalStorage._owner should be constant (BlockRewardBase.sol#80)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isRewarding() external view returns(bool);\n",
                    "message": "IBlockReward.isRewarding (BlockRewardBase.sol#9) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 379,
                    "vulnerability_code": "    function isRewarding() public view returns(bool) {\n\n        return boolStorage[IS_REWARDING];\n",
                    "message": "BlockRewardBase.isRewarding (BlockRewardBase.sol#377-379) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": 385,
                    "vulnerability_code": "    function isSnapshotting() public view returns(bool) {\n\n        return boolStorage[IS_SNAPSHOTTING];\n",
                    "message": "BlockRewardBase.isSnapshotting (BlockRewardBase.sol#383-385) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isSnapshotting() external view returns(bool);\n",
                    "message": "IBlockReward.isSnapshotting (BlockRewardBase.sol#10) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) external view returns(uint256);\n",
                    "message": "IBlockReward.mintedTotallyByBridge (BlockRewardBase.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": 420,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))];\n",
                    "message": "BlockRewardBase.mintedTotallyByBridge (BlockRewardBase.sol#418-420) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": 341,
                    "vulnerability_code": "    function blockRewardContractId() public pure returns(bytes4) {\n\n        return BLOCK_REWARD_CONTRACT_ID;\n",
                    "message": "BlockRewardBase.blockRewardContractId (BlockRewardBase.sol#339-341) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": 346,
                    "vulnerability_code": "    function ercToErcBridgesAllowed() public view returns(address[] memory) {\n\n        return addressArrayStorage[ERC_TO_ERC_BRIDGES_ALLOWED];\n",
                    "message": "BlockRewardBase.ercToErcBridgesAllowed (BlockRewardBase.sol#344-346) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": 351,
                    "vulnerability_code": "    function ercToNativeBridgesAllowed() public view returns(address[] memory) {\n\n        return addressArrayStorage[ERC_TO_NATIVE_BRIDGES_ALLOWED];\n",
                    "message": "BlockRewardBase.ercToNativeBridgesAllowed (BlockRewardBase.sol#349-351) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": 362,
                    "vulnerability_code": "    function getBridgeNativeFee() public view returns(uint256) {\n\n        return uintStorage[BRIDGE_NATIVE_FEE];\n",
                    "message": "BlockRewardBase.getBridgeNativeFee (BlockRewardBase.sol#360-362) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": 368,
                    "vulnerability_code": "    function getBridgeTokenFee() public view returns(uint256) {\n\n        return uintStorage[BRIDGE_TOKEN_FEE];\n",
                    "message": "BlockRewardBase.getBridgeTokenFee (BlockRewardBase.sol#366-368) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": 392,
                    "vulnerability_code": "    function mintedForAccount(address _account) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(MINTED_FOR_ACCOUNT, _account))];\n",
                    "message": "BlockRewardBase.mintedForAccount (BlockRewardBase.sol#390-392) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": 406,
                    "vulnerability_code": "    function mintedForAccountInBlock(address _account, uint256 _blockNumber)\n\n        public\n\n        view\n\n        returns(uint256)\n\n    {\n\n        return uintStorage[\n\n            keccak256(abi.encode(MINTED_FOR_ACCOUNT_IN_BLOCK, _account, _blockNumber))\n\n        ];\n",
                    "message": "BlockRewardBase.mintedForAccountInBlock (BlockRewardBase.sol#398-406) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": 413,
                    "vulnerability_code": "    function mintedInBlock(uint256 _blockNumber) public view returns(uint256) {\n\n        return uintStorage[keccak256(abi.encode(MINTED_IN_BLOCK, _blockNumber))];\n",
                    "message": "BlockRewardBase.mintedInBlock (BlockRewardBase.sol#411-413) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": 432,
                    "vulnerability_code": "    function nativeToErcBridgesAllowed() public view returns(address[] memory) {\n\n        return addressArrayStorage[NATIVE_TO_ERC_BRIDGES_ALLOWED];\n",
                    "message": "BlockRewardBase.nativeToErcBridgesAllowed (BlockRewardBase.sol#430-432) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": 445,
                    "vulnerability_code": "    function snapshotRewardPercents(address _validatorStakingAddress) public view returns(uint256[] memory) {\n\n        return uintArrayStorage[\n\n            keccak256(abi.encode(SNAPSHOT_REWARD_PERCENTS, _validatorStakingAddress))\n\n        ];\n",
                    "message": "BlockRewardBase.snapshotRewardPercents (BlockRewardBase.sol#441-445) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": 456,
                    "vulnerability_code": "    function snapshotStakers(address _validatorStakingAddress) public view returns(address[] memory) {\n\n        return addressArrayStorage[\n\n            keccak256(abi.encode(SNAPSHOT_STAKERS, _validatorStakingAddress))\n\n        ];\n",
                    "message": "BlockRewardBase.snapshotStakers (BlockRewardBase.sol#452-456) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 463,
                    "vulnerability_code": "    function snapshotStakingAddresses() public view returns(address[] memory) {\n\n        return addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES];\n",
                    "message": "BlockRewardBase.snapshotStakingAddresses (BlockRewardBase.sol#461-463) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": 470,
                    "vulnerability_code": "    function snapshotTotalStakeAmount() public view returns(uint256) {\n\n        return uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT];\n",
                    "message": "BlockRewardBase.snapshotTotalStakeAmount (BlockRewardBase.sol#468-470) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 473,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function validatorSetContract() public view returns(IValidatorSet) {\n\n        return IValidatorSet(addressStorage[VALIDATOR_SET_CONTRACT]);\n",
                    "message": "BlockRewardBase.validatorSetContract (BlockRewardBase.sol#473-475) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in BlockRewardBase.sol:\n\t- pragma solidity0.5.9 (BlockRewardBase.sol#3): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardBase.sol#17): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardBase.sol#52): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardBase.sol#72): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardBase.sol#103): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardBase.sol#121): it allows old versions\n\t- pragma solidity0.5.9 (BlockRewardBase.sol#160): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address) external;\n",
                    "message": "Parameter '' of IBlockReward.initialize (BlockRewardBase.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function DELEGATORS_ALIQUOT() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IBlockReward.DELEGATORS_ALIQUOT' (BlockRewardBase.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (BlockRewardBase.sol#22) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (BlockRewardBase.sol#23) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (BlockRewardBase.sol#24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (BlockRewardBase.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (BlockRewardBase.sol#26) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (BlockRewardBase.sol#27) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (BlockRewardBase.sol#30) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (BlockRewardBase.sol#30) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (BlockRewardBase.sol#37) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (BlockRewardBase.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (BlockRewardBase.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (BlockRewardBase.sol#40) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (BlockRewardBase.sol#41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (BlockRewardBase.sol#43) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (BlockRewardBase.sol#46) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
                    "message": "Parameter '' of IStaking.clearUnremovableValidator (BlockRewardBase.sol#56) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address) external;\n",
                    "message": "Parameter '' of IStaking.removePool (BlockRewardBase.sol#58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "Parameter '' of IStaking.poolDelegators (BlockRewardBase.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (BlockRewardBase.sol#65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (BlockRewardBase.sol#65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (BlockRewardBase.sol#66) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _owner;\n",
                    "message": "Variable 'EternalStorage._owner' (BlockRewardBase.sol#80) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address _validatorSet) external {\n",
                    "message": "Parameter '_validatorSet' of BlockRewardBase.initialize (BlockRewardBase.sol#260) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256) {\n",
                    "message": "Parameter '_bridge' of BlockRewardBase.mintedTotallyByBridge (BlockRewardBase.sol#418) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addBridgeNativeFeeReceivers(uint256 _amount) external onlyErcToNativeBridge {\n",
                    "message": "Parameter '_amount' of BlockRewardBase.addBridgeNativeFeeReceivers (BlockRewardBase.sol#231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addBridgeTokenFeeReceivers(uint256 _amount) external onlyXToErcBridge {\n",
                    "message": "Parameter '_amount' of BlockRewardBase.addBridgeTokenFeeReceivers (BlockRewardBase.sol#240) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExtraReceiver(uint256 _amount, address _receiver) external onlyErcToNativeBridge {\n",
                    "message": "Parameter '_amount' of BlockRewardBase.addExtraReceiver (BlockRewardBase.sol#249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExtraReceiver(uint256 _amount, address _receiver) external onlyErcToNativeBridge {\n",
                    "message": "Parameter '_receiver' of BlockRewardBase.addExtraReceiver (BlockRewardBase.sol#249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function migrateMintingStatistics(address _bridge, IBlockReward _prevBlockRewardContract) external onlyOwner {\n",
                    "message": "Parameter '_bridge' of BlockRewardBase.migrateMintingStatistics (BlockRewardBase.sol#271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function migrateMintingStatistics(address _bridge, IBlockReward _prevBlockRewardContract) external onlyOwner {\n",
                    "message": "Parameter '_prevBlockRewardContract' of BlockRewardBase.migrateMintingStatistics (BlockRewardBase.sol#271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErcToNativeBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_bridgesAllowed' of BlockRewardBase.setErcToNativeBridgesAllowed (BlockRewardBase.sol#284) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setNativeToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_bridgesAllowed' of BlockRewardBase.setNativeToErcBridgesAllowed (BlockRewardBase.sol#302) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErcToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": "Parameter '_bridgesAllowed' of BlockRewardBase.setErcToErcBridgesAllowed (BlockRewardBase.sol#320) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedForAccount(address _account) public view returns(uint256) {\n",
                    "message": "Parameter '_account' of BlockRewardBase.mintedForAccount (BlockRewardBase.sol#390) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedForAccountInBlock(address _account, uint256 _blockNumber)\n",
                    "message": "Parameter '_account' of BlockRewardBase.mintedForAccountInBlock (BlockRewardBase.sol#398) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedForAccountInBlock(address _account, uint256 _blockNumber)\n",
                    "message": "Parameter '_blockNumber' of BlockRewardBase.mintedForAccountInBlock (BlockRewardBase.sol#398) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedInBlock(uint256 _blockNumber) public view returns(uint256) {\n",
                    "message": "Parameter '_blockNumber' of BlockRewardBase.mintedInBlock (BlockRewardBase.sol#411) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function snapshotRewardPercents(address _validatorStakingAddress) public view returns(uint256[] memory) {\n",
                    "message": "Parameter '_validatorStakingAddress' of BlockRewardBase.snapshotRewardPercents (BlockRewardBase.sol#441) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function snapshotStakers(address _validatorStakingAddress) public view returns(address[] memory) {\n",
                    "message": "Parameter '_validatorStakingAddress' of BlockRewardBase.snapshotStakers (BlockRewardBase.sol#452) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": 557,
                    "vulnerability_code": "    function _mintNativeCoins(\n\n        address[] memory _receivers,\n\n        uint256[] memory _rewards,\n\n        uint256 _queueLimit\n\n    )\n\n        internal\n\n        returns(address[] memory receivers, uint256[] memory rewards)\n\n    {\n\n        uint256 extraLength = extraReceiversQueueSize();\n\n\n\n        if (extraLength > _queueLimit) {\n\n            extraLength = _queueLimit;\n\n        }\n\n\n\n        receivers = new address[](extraLength + _receivers.length);\n\n        rewards = new uint256[](receivers.length);\n\n\n\n        uint256 i;\n\n        uint256 j = 0;\n\n\n\n        for (i = 0; i < extraLength; i++) {\n\n            (uint256 amount, address receiver, address bridge) = _dequeueExtraReceiver();\n\n            receivers[i] = receiver;\n\n            rewards[i] = amount;\n\n            _setMinted(amount, receiver, bridge);\n\n        }\n\n\n\n        for (i = extraLength; i < receivers.length; i++) {\n\n            receivers[i] = _receivers[j];\n\n            rewards[i] = _rewards[j];\n\n            j++;\n\n        }\n\n\n\n        emit MintedNative(receivers, rewards);\n\n\n\n        return (receivers, rewards);\n",
                    "message": "Function 'BlockRewardBase._mintNativeCoins' (BlockRewardBase.sol#521-557) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _receivers,\n",
                    "message": "Parameter '_receivers' of BlockRewardBase._mintNativeCoins (BlockRewardBase.sol#522) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] memory _rewards,\n",
                    "message": "Parameter '_rewards' of BlockRewardBase._mintNativeCoins (BlockRewardBase.sol#523) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _queueLimit\n",
                    "message": "Parameter '_queueLimit' of BlockRewardBase._mintNativeCoins (BlockRewardBase.sol#524) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": 584,
                    "vulnerability_code": "    function _dequeueExtraReceiver() internal returns(uint256 amount, address receiver, address bridge) {\n\n        uint256 queueFirst = uintStorage[QUEUE_ER_FIRST];\n\n        uint256 queueLast = uintStorage[QUEUE_ER_LAST];\n\n\n\n        if (queueLast < queueFirst) {\n\n            amount = 0;\n\n            receiver = address(0);\n\n            bridge = address(0);\n\n        } else {\n\n            bytes32 amountHash = keccak256(abi.encode(QUEUE_ER_AMOUNT, queueFirst));\n\n            bytes32 receiverHash = keccak256(abi.encode(QUEUE_ER_RECEIVER, queueFirst));\n\n            bytes32 bridgeHash = keccak256(abi.encode(QUEUE_ER_BRIDGE, queueFirst));\n\n            amount = uintStorage[amountHash];\n\n            receiver = addressStorage[receiverHash];\n\n            bridge = addressStorage[bridgeHash];\n\n            delete uintStorage[amountHash];\n\n            delete addressStorage[receiverHash];\n\n            delete addressStorage[bridgeHash];\n\n            uintStorage[QUEUE_ER_FIRST]++;\n\n        }\n",
                    "message": "Function 'BlockRewardBase._dequeueExtraReceiver' (BlockRewardBase.sol#564-584) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": 597,
                    "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n\n        uint256 queueLast = uintStorage[QUEUE_ER_LAST] + 1;\n\n        uintStorage[keccak256(abi.encode(QUEUE_ER_AMOUNT, queueLast))] = _amount;\n\n        addressStorage[keccak256(abi.encode(QUEUE_ER_RECEIVER, queueLast))] = _receiver;\n\n        addressStorage[keccak256(abi.encode(QUEUE_ER_BRIDGE, queueLast))] = _bridge;\n\n        uintStorage[QUEUE_ER_LAST] = queueLast;\n",
                    "message": "Function 'BlockRewardBase._enqueueExtraReceiver' (BlockRewardBase.sol#591-597) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n",
                    "message": "Parameter '_amount' of BlockRewardBase._enqueueExtraReceiver (BlockRewardBase.sol#591) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n",
                    "message": "Parameter '_receiver' of BlockRewardBase._enqueueExtraReceiver (BlockRewardBase.sol#591) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _enqueueExtraReceiver(uint256 _amount, address _receiver, address _bridge) internal {\n",
                    "message": "Parameter '_bridge' of BlockRewardBase._enqueueExtraReceiver (BlockRewardBase.sol#591) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": 610,
                    "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n\n        uintStorage[keccak256(abi.encode(MINTED_FOR_ACCOUNT_IN_BLOCK, _account, block.number))] = _amount;\n\n        uintStorage[keccak256(abi.encode(MINTED_FOR_ACCOUNT, _account))] += _amount;\n\n        uintStorage[keccak256(abi.encode(MINTED_IN_BLOCK, block.number))] += _amount;\n\n        uintStorage[keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))] += _amount;\n\n        uintStorage[MINTED_TOTALLY] += _amount;\n",
                    "message": "Function 'BlockRewardBase._setMinted' (BlockRewardBase.sol#604-610) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n",
                    "message": "Parameter '_amount' of BlockRewardBase._setMinted (BlockRewardBase.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n",
                    "message": "Parameter '_account' of BlockRewardBase._setMinted (BlockRewardBase.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setMinted(uint256 _amount, address _account, address _bridge) internal {\n",
                    "message": "Parameter '_bridge' of BlockRewardBase._setMinted (BlockRewardBase.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": 682,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n\n        uint256 validatorStake = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, _stakingAddress);\n\n        uint256 totalStaked = _stakingContract.stakeAmountTotalMinusOrderedWithdraw(_stakingAddress);\n\n        uint256 delegatorsAmount = totalStaked >= validatorStake ? totalStaked - validatorStake : 0;\n\n        bool validatorHasMore30Per = validatorStake * 7 > delegatorsAmount * 3;\n\n\n\n        address[] memory delegators = _stakingContract.poolDelegators(_stakingAddress);\n\n        uint256 rewardPercent;\n\n\n\n        address[] storage stakers = addressArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_STAKERS, _stakingAddress\n\n        ))];\n\n\n\n        uint256[] storage rewardPercents = uintArrayStorage[keccak256(abi.encode(\n\n            SNAPSHOT_REWARD_PERCENTS, _stakingAddress\n\n        ))];\n\n\n\n        if (_offset == 0) {\n\n            // Calculate reward percent for validator\n\n            rewardPercent = 0;\n\n            if (validatorStake != 0 && totalStaked != 0) {\n\n                if (validatorHasMore30Per) {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * validatorStake / totalStaked;\n\n                } else {\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * 3 / 10;\n\n                }\n\n            }\n\n            stakers.push(_stakingAddress);\n\n            rewardPercents.push(rewardPercent);\n\n            addressArrayStorage[SNAPSHOT_STAKING_ADDRESSES].push(_stakingAddress);\n\n            uintStorage[SNAPSHOT_TOTAL_STAKE_AMOUNT] += totalStaked;\n\n        }\n\n\n\n        uint256 from = _offset * delegators.length / DELEGATORS_ALIQUOT;\n\n        uint256 to = (_offset + 1) * delegators.length / DELEGATORS_ALIQUOT;\n\n\n\n        if (_offset == 0) {\n\n            to += delegators.length % DELEGATORS_ALIQUOT;\n\n        } else {\n\n            from += delegators.length % DELEGATORS_ALIQUOT;\n\n        }\n\n\n\n        // Calculate reward percent for each delegator\n\n        for (uint256 i = from; i < to; i++) {\n\n            rewardPercent = 0;\n\n\n\n            if (validatorHasMore30Per) {\n\n                if (totalStaked != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent / totalStaked;\n\n                }\n\n            } else {\n\n                if (delegatorsAmount != 0) {\n\n                    rewardPercent = _stakingContract.stakeAmountMinusOrderedWithdraw(_stakingAddress, delegators[i]);\n\n                    rewardPercent = REWARD_PERCENT_MULTIPLIER * rewardPercent * 7 / (delegatorsAmount * 10);\n\n                }\n\n            }\n\n\n\n            stakers.push(delegators[i]);\n\n            rewardPercents.push(rewardPercent);\n\n        }\n",
                    "message": "Function 'BlockRewardBase._setSnapshot' (BlockRewardBase.sol#621-682) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n",
                    "message": "Parameter '_stakingAddress' of BlockRewardBase._setSnapshot (BlockRewardBase.sol#621) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n",
                    "message": "Parameter '_stakingContract' of BlockRewardBase._setSnapshot (BlockRewardBase.sol#621) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setSnapshot(address _stakingAddress, IStaking _stakingContract, uint256 _offset) internal {\n",
                    "message": "Parameter '_offset' of BlockRewardBase._setSnapshot (BlockRewardBase.sol#621) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (BlockRewardBase.sol#84) is never used in BlockRewardBase\nEternalStorage.bytesStorage (BlockRewardBase.sol#86) is never used in BlockRewardBase\nEternalStorage.intStorage (BlockRewardBase.sol#88) is never used in BlockRewardBase\nEternalStorage.bytes32Storage (BlockRewardBase.sol#89) is never used in BlockRewardBase\nEternalStorage.stringArrayStorage (BlockRewardBase.sol#92) is never used in BlockRewardBase\nEternalStorage.bytesArrayStorage (BlockRewardBase.sol#94) is never used in BlockRewardBase\nEternalStorage.boolArrayStorage (BlockRewardBase.sol#95) is never used in BlockRewardBase\nEternalStorage.intArrayStorage (BlockRewardBase.sol#96) is never used in BlockRewardBase\nEternalStorage.bytes32ArrayStorage (BlockRewardBase.sol#97) is never used in BlockRewardBase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == 0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 570,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            receiver = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bridge = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = extraLength; i < receivers.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < oldBridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bridgesAllowed.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErcToNativeBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setNativeToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setErcToErcBridgesAllowed(address[] calldata _bridgesAllowed) external onlyOwner onlyInitialized {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns(address[] memory receivers, uint256[] memory rewards)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _dequeueExtraReceiver() internal returns(uint256 amount, address receiver, address bridge) {\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/interfaces/IOwnerRegistry.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in IOwnerRegistry.sol:\n\t- pragma solidity0.5.9 (IOwnerRegistry.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/interfaces/IERC20Minting.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in IERC20Minting.sol:\n\t- pragma solidity0.5.9 (IERC20Minting.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IERC20Minting.balanceOf (IERC20Minting.sol#15) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/interfaces/IValidatorSet.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_16"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in IValidatorSet.sol:\n\t- pragma solidity0.5.9 (IValidatorSet.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IValidatorSet.initialize (IValidatorSet.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.initialize (IValidatorSet.sol#9) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_1' of IValidatorSet.initialize (IValidatorSet.sol#10) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_2' of IValidatorSet.initialize (IValidatorSet.sol#11) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_3' of IValidatorSet.initialize (IValidatorSet.sol#12) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_4' of IValidatorSet.initialize (IValidatorSet.sol#13) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '' of IValidatorSet.setStakingAddress (IValidatorSet.sol#16) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingAddress(address, address) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSet.setStakingAddress (IValidatorSet.sol#16) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isReportValidatorValid(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isReportValidatorValid (IValidatorSet.sol#23) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidator (IValidatorSet.sol#24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidatorBanned(address) external view returns(bool);\n",
                    "message": "Parameter '' of IValidatorSet.isValidatorBanned (IValidatorSet.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MAX_VALIDATORS() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IValidatorSet.MAX_VALIDATORS' (IValidatorSet.sol#26) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function miningByStakingAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.miningByStakingAddress (IValidatorSet.sol#27) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakingByMiningAddress(address) external view returns(address);\n",
                    "message": "Parameter '' of IValidatorSet.stakingByMiningAddress (IValidatorSet.sol#29) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorIndex(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IValidatorSet.validatorIndex (IValidatorSet.sol#32) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function newValidatorSet() external returns(bool, uint256);\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/interfaces/IStakingAuRa.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_10"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in IStakingAuRa.sol:\n\t- pragma solidity0.5.9 (IStakingAuRa.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IStakingAuRa.initialize (IStakingAuRa.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_0' of IStakingAuRa.initialize (IStakingAuRa.sol#9) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_1' of IStakingAuRa.initialize (IStakingAuRa.sol#10) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_2' of IStakingAuRa.initialize (IStakingAuRa.sol#11) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_3' of IStakingAuRa.initialize (IStakingAuRa.sol#12) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_4' of IStakingAuRa.initialize (IStakingAuRa.sol#13) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_5' of IStakingAuRa.initialize (IStakingAuRa.sol#14) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_6' of IStakingAuRa.initialize (IStakingAuRa.sol#15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingEpochStartBlock(uint256) external;\n",
                    "message": "Parameter '' of IStakingAuRa.setStakingEpochStartBlock (IStakingAuRa.sol#17) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/interfaces/IBlockReward.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in IBlockReward.sol:\n\t- pragma solidity0.5.9 (IBlockReward.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address) external;\n",
                    "message": "Parameter '' of IBlockReward.initialize (IBlockReward.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function DELEGATORS_ALIQUOT() external view returns(uint256); // solhint-disable-line func-name-mixedcase\n",
                    "message": "Function 'IBlockReward.DELEGATORS_ALIQUOT' (IBlockReward.sol#8) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/interfaces/ICertifier.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in ICertifier.sol:\n\t- pragma solidity0.5.9 (ICertifier.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address[] calldata, address) external;\n",
                    "message": "Parameter '' of ICertifier.initialize (ICertifier.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address[] calldata, address) external;\n",
                    "message": "Parameter '_scope_0' of ICertifier.initialize (ICertifier.sol#7) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/interfaces/IValidatorSetAuRa.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in IValidatorSetAuRa.sol:\n\t- pragma solidity0.5.9 (IValidatorSetAuRa.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeMaliciousValidator(address) external;\n",
                    "message": "Parameter '' of IValidatorSetAuRa.removeMaliciousValidator (IValidatorSetAuRa.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '' of IValidatorSetAuRa.reportMaliciousCallable (IValidatorSetAuRa.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '_scope_0' of IValidatorSetAuRa.reportMaliciousCallable (IValidatorSetAuRa.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": "Parameter '_scope_1' of IValidatorSetAuRa.reportMaliciousCallable (IValidatorSetAuRa.sol#8) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reportMaliciousCallable(address, address, uint256) external view returns(bool, bool);\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/interfaces/IValidatorSetHBBFT.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Different versions of Solidity is used in IValidatorSetHBBFT.sol:\n\t- Version used: ['0.5.9', 'ABIEncoderV2']\n\t- IValidatorSetHBBFT.sol#3 declares pragma solidity0.5.9\n\t- IValidatorSetHBBFT.sol#4 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in IValidatorSetHBBFT.sol:\n\t- pragma solidity0.5.9 (IValidatorSetHBBFT.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearMaliceReported(address) external;\n",
                    "message": "Parameter '' of IValidatorSetHBBFT.clearMaliceReported (IValidatorSetHBBFT.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initializePublicKeys(bytes[] calldata) external;\n",
                    "message": "Parameter '' of IValidatorSetHBBFT.initializePublicKeys (IValidatorSetHBBFT.sol#9) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function savePublicKey(address, bytes calldata) external;\n",
                    "message": "Parameter '' of IValidatorSetHBBFT.savePublicKey (IValidatorSetHBBFT.sol#10) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function savePublicKey(address, bytes calldata) external;\n",
                    "message": "Parameter '_scope_0' of IValidatorSetHBBFT.savePublicKey (IValidatorSetHBBFT.sol#10) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/interfaces/ITxPermission.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in ITxPermission.sol:\n\t- pragma solidity0.5.9 (ITxPermission.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address[] calldata, address) external;\n",
                    "message": "Parameter '' of ITxPermission.initialize (ITxPermission.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address[] calldata, address) external;\n",
                    "message": "Parameter '_scope_0' of ITxPermission.initialize (ITxPermission.sol#7) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/interfaces/IStaking.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in IStaking.sol:\n\t- pragma solidity0.5.9 (IStaking.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearUnremovableValidator(address) external;\n",
                    "message": "Parameter '' of IStaking.clearUnremovableValidator (IStaking.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removePool(address) external;\n",
                    "message": "Parameter '' of IStaking.removePool (IStaking.sol#9) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function poolDelegators(address) external view returns(address[] memory);\n",
                    "message": "Parameter '' of IStaking.poolDelegators (IStaking.sol#15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountMinusOrderedWithdraw (IStaking.sol#16) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountMinusOrderedWithdraw(address, address) external view returns(uint256);\n",
                    "message": "Parameter '_scope_0' of IStaking.stakeAmountMinusOrderedWithdraw (IStaking.sol#16) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stakeAmountTotalMinusOrderedWithdraw(address) external view returns(uint256);\n",
                    "message": "Parameter '' of IStaking.stakeAmountTotalMinusOrderedWithdraw (IStaking.sol#17) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPoolsLikelihood() external view returns(int256[] memory, int256);\n",
                    "message": null
                }
            ]
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/interfaces/IRandom.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in IRandom.sol:\n\t- pragma solidity0.5.9 (IRandom.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/interfaces/IRandomHBBFT.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in IRandomHBBFT.sol:\n\t- pragma solidity0.5.9 (IRandomHBBFT.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(address) external;\n",
                    "message": "Parameter '' of IRandomHBBFT.initialize (IRandomHBBFT.sol#7) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/interfaces/IRandomAuRa.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in IRandomAuRa.sol:\n\t- pragma solidity0.5.9 (IRandomAuRa.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(uint256, address) external;\n",
                    "message": "Parameter '' of IRandomAuRa.initialize (IRandomAuRa.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function initialize(uint256, address) external;\n",
                    "message": "Parameter '_scope_0' of IRandomAuRa.initialize (IRandomAuRa.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHashCallable(address, bytes32) external view returns(bool);\n",
                    "message": "Parameter '' of IRandomAuRa.commitHashCallable (IRandomAuRa.sol#9) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function commitHashCallable(address, bytes32) external view returns(bool);\n",
                    "message": "Parameter '_scope_0' of IRandomAuRa.commitHashCallable (IRandomAuRa.sol#9) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSecretCallable(address, uint256) external view returns(bool);\n",
                    "message": "Parameter '' of IRandomAuRa.revealSecretCallable (IRandomAuRa.sol#10) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function revealSecretCallable(address, uint256) external view returns(bool);\n",
                    "message": "Parameter '_scope_0' of IRandomAuRa.revealSecretCallable (IRandomAuRa.sol#10) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/interfaces/IMetadataRegistry.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in IMetadataRegistry.sol:\n\t- pragma solidity0.5.9 (IMetadataRegistry.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/interfaces/IReverseRegistry.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in IReverseRegistry.sol:\n\t- pragma solidity0.5.9 (IReverseRegistry.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/interfaces/IStakingHBBFT.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in IStakingHBBFT.sol:\n\t- pragma solidity0.5.9 (IStakingHBBFT.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '' of IStakingHBBFT.initialize (IStakingHBBFT.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata,\n",
                    "message": "Parameter '_scope_0' of IStakingHBBFT.initialize (IStakingHBBFT.sol#9) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_1' of IStakingHBBFT.initialize (IStakingHBBFT.sol#10) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256,\n",
                    "message": "Parameter '_scope_2' of IStakingHBBFT.initialize (IStakingHBBFT.sol#11) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool\n",
                    "message": "Parameter '_scope_3' of IStakingHBBFT.initialize (IStakingHBBFT.sol#12) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "posdao-contracts-fdaa685de851378b35741bdab986414dfd9042b1/contracts/interfaces/IEternalStorageProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.9;\n",
                    "message": "Detected issues with version pragma in IEternalStorageProxy.sol:\n\t- pragma solidity0.5.9 (IEternalStorageProxy.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeTo(address) external returns(bool);\n",
                    "message": "Parameter '' of IEternalStorageProxy.upgradeTo (IEternalStorageProxy.sol#7) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    }
}