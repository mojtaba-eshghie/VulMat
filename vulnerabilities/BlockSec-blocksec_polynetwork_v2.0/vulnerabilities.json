{
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/mocks/libs/utils/UtilsMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        storageBytes = bytes(\"I am global in global storage\");\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "         require(key.length >= 67, \"key lenggh is too short\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    m++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_49"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": 18,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
                    "message": "Utils.bytesToBytes32 (UtilsMock.sol#12-18) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": 31,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Utils.bytesToUint256 (UtilsMock.sol#24-31) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 50,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
                    "message": "Utils.uint256ToBytes (UtilsMock.sol#37-50) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": 65,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
                    "message": "Utils.bytesToAddress (UtilsMock.sol#56-65) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": 83,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
                    "message": "Utils.addressToBytes (UtilsMock.sol#71-83) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": 178,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
                    "message": "Utils.equalStorage (UtilsMock.sol#108-178) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
                    "message": "Utils.slice (UtilsMock.sol#187-251) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": 311,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "Utils.isContract (UtilsMock.sol#298-311) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": 18,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
                    "message": "Utils.bytesToBytes32 uses assembly (UtilsMock.sol#12-18)\n\t- UtilsMock.sol#14-17\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": 31,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Utils.bytesToUint256 uses assembly (UtilsMock.sol#24-31)\n\t- UtilsMock.sol#26-29\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 50,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
                    "message": "Utils.uint256ToBytes uses assembly (UtilsMock.sol#37-50)\n\t- UtilsMock.sol#39-49\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": 65,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
                    "message": "Utils.bytesToAddress uses assembly (UtilsMock.sol#56-65)\n\t- UtilsMock.sol#59-63\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": 83,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
                    "message": "Utils.addressToBytes uses assembly (UtilsMock.sol#71-83)\n\t- UtilsMock.sol#72-82\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": 178,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
                    "message": "Utils.equalStorage uses assembly (UtilsMock.sol#108-178)\n\t- UtilsMock.sol#111-175\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
                    "message": "Utils.slice uses assembly (UtilsMock.sol#187-251)\n\t- UtilsMock.sol#200-248\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": 311,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "Utils.isContract uses assembly (UtilsMock.sol#298-311)\n\t- UtilsMock.sol#309\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 323,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _b) public pure returns (bytes32) {\n\n        return Utils.bytesToBytes32(_b);\n",
                    "message": "UtilsMock.bytesToBytes32 (UtilsMock.sol#323-325) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 327,
                    "vulnerability_to_line": 329,
                    "vulnerability_code": "    function bytesToUint256(bytes memory  _v) public pure returns (uint256) {\n\n        return Utils.bytesToUint256(_v);\n",
                    "message": "UtilsMock.bytesToUint256 (UtilsMock.sol#327-329) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": 333,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _v) public pure returns (bytes memory) {\n\n        return Utils.uint256ToBytes(_v);\n",
                    "message": "UtilsMock.uint256ToBytes (UtilsMock.sol#331-333) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _v) public pure returns (address) {\n\n        return Utils.bytesToAddress(_v);\n",
                    "message": "UtilsMock.bytesToAddress (UtilsMock.sol#335-337) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": 341,
                    "vulnerability_code": "    function addressToBytes(address _v) public pure returns (bytes memory) {\n\n        return Utils.addressToBytes(_v);\n",
                    "message": "UtilsMock.addressToBytes (UtilsMock.sol#339-341) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": 344,
                    "vulnerability_code": "    function hashLeaf(bytes memory _data) public pure returns (bytes32) {\n\n        return Utils.hashLeaf(_data);\n",
                    "message": "UtilsMock.hashLeaf (UtilsMock.sol#342-344) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": 347,
                    "vulnerability_code": "    function hashChildren(bytes32 left, bytes32 right) public pure returns (bytes32) {\n\n        return Utils.hashChildren(left, right);\n",
                    "message": "UtilsMock.hashChildren (UtilsMock.sol#345-347) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": 350,
                    "vulnerability_code": "    function equalStorage( bytes memory memoryBytes) public view returns (bool) {\n\n        return Utils.equalStorage(storageBytes, memoryBytes);\n",
                    "message": "UtilsMock.equalStorage (UtilsMock.sol#348-350) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": 353,
                    "vulnerability_code": "    function slice(bytes memory _bytes, uint _start, uint _length )public pure returns (bytes memory){\n\n        return Utils.slice(_bytes, _start, _length);\n",
                    "message": "UtilsMock.slice (UtilsMock.sol#351-353) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": 357,
                    "vulnerability_code": "    function containMAddresses(address[] memory keepers, address[] memory signers, uint m) public pure returns(bool){\n\n        return Utils.containMAddresses(keepers, signers, m);\n",
                    "message": "UtilsMock.containMAddresses (UtilsMock.sol#355-357) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in UtilsMock.sol:\n\t- pragma solidity^0.5.0 (UtilsMock.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (UtilsMock.sol#316): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": "Parameter '_bs' of Utils.bytesToBytes32 (UtilsMock.sol#12) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
                    "message": "Parameter '_bs' of Utils.bytesToUint256 (UtilsMock.sol#24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": "Parameter '_value' of Utils.uint256ToBytes (UtilsMock.sol#37) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": "Parameter '_bs' of Utils.bytesToAddress (UtilsMock.sol#56) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_data' of Utils.hashLeaf (UtilsMock.sol#89) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_l' of Utils.hashChildren (UtilsMock.sol#98) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_r' of Utils.hashChildren (UtilsMock.sol#98) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory _bytes,\n",
                    "message": "Parameter '_bytes' of Utils.slice (UtilsMock.sol#188) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint _start,\n",
                    "message": "Parameter '_start' of Utils.slice (UtilsMock.sol#189) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint _length\n",
                    "message": "Parameter '_length' of Utils.slice (UtilsMock.sol#190) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_keepers' of Utils.containMAddresses (UtilsMock.sol#258) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_signers' of Utils.containMAddresses (UtilsMock.sol#258) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_m' of Utils.containMAddresses (UtilsMock.sol#258) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 323,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _b) public pure returns (bytes32) {\n",
                    "message": "Parameter '_b' of UtilsMock.bytesToBytes32 (UtilsMock.sol#323) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 327,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToUint256(bytes memory  _v) public pure returns (uint256) {\n",
                    "message": "Parameter '_v' of UtilsMock.bytesToUint256 (UtilsMock.sol#327) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _v) public pure returns (bytes memory) {\n",
                    "message": "Parameter '_v' of UtilsMock.uint256ToBytes (UtilsMock.sol#331) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _v) public pure returns (address) {\n",
                    "message": "Parameter '_v' of UtilsMock.bytesToAddress (UtilsMock.sol#335) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressToBytes(address _v) public pure returns (bytes memory) {\n",
                    "message": "Parameter '_v' of UtilsMock.addressToBytes (UtilsMock.sol#339) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashLeaf(bytes memory _data) public pure returns (bytes32) {\n",
                    "message": "Parameter '_data' of UtilsMock.hashLeaf (UtilsMock.sol#342) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function slice(bytes memory _bytes, uint _start, uint _length )public pure returns (bytes memory){\n",
                    "message": "Parameter '_bytes' of UtilsMock.slice (UtilsMock.sol#351) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function slice(bytes memory _bytes, uint _start, uint _length )public pure returns (bytes memory){\n",
                    "message": "Parameter '_start' of UtilsMock.slice (UtilsMock.sol#351) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function slice(bytes memory _bytes, uint _start, uint _length )public pure returns (bytes memory){\n",
                    "message": "Parameter '_length' of UtilsMock.slice (UtilsMock.sol#351) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "             newkey[2] = byte(0x02);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "             newkey[2] = byte(0x03);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        result = sha256(abi.encodePacked(byte(0x0), _data));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function slice(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { codehash := extcodehash(account) }\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/mocks/libs/math/SafeMathMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": 167,
                    "vulnerability_code": "    function sub(uint256 a, uint256 b) public pure returns (uint256) {\n\n        return SafeMath.sub(a, b);\n",
                    "message": "SafeMathMock.sub (SafeMathMock.sol#165-167) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": 171,
                    "vulnerability_code": "    function add(uint256 a, uint256 b) public pure returns (uint256) {\n\n        return SafeMath.add(a, b);\n",
                    "message": "SafeMathMock.add (SafeMathMock.sol#169-171) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": 174,
                    "vulnerability_code": "    function mul(uint256 a, uint256 b) public pure returns (uint256) {\n\n        return SafeMath.mul(a, b);\n",
                    "message": "SafeMathMock.mul (SafeMathMock.sol#172-174) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": 178,
                    "vulnerability_code": "    function div(uint256 a, uint256 b) public pure returns (uint256) {\n\n        return SafeMath.div(a, b);\n",
                    "message": "SafeMathMock.div (SafeMathMock.sol#176-178) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": 181,
                    "vulnerability_code": "    function mod(uint256 a, uint256 b) public pure returns (uint256) {\n\n        return SafeMath.mod(a, b);\n",
                    "message": "SafeMathMock.mod (SafeMathMock.sol#179-181) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in SafeMathMock.sol:\n\t- pragma solidity^0.5.0 (SafeMathMock.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (SafeMathMock.sol#162): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/mocks/libs/common/ZeroCopySinkMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_51"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteBool (ZeroCopySinkMock.sol#24-41) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": 65,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint8 (ZeroCopySinkMock.sol#55-65) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": 90,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint16 (ZeroCopySinkMock.sol#71-90) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": 114,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint32 (ZeroCopySinkMock.sol#96-114) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": 139,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint64 (ZeroCopySinkMock.sol#120-139) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": 165,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint255 (ZeroCopySinkMock.sol#145-165) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteBool uses assembly (ZeroCopySinkMock.sol#24-41)\n\t- ZeroCopySinkMock.sol#26-39\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": 65,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint8 uses assembly (ZeroCopySinkMock.sol#55-65)\n\t- ZeroCopySinkMock.sol#57-63\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": 90,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint16 uses assembly (ZeroCopySinkMock.sol#71-90)\n\t- ZeroCopySinkMock.sol#74-88\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": 114,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint32 uses assembly (ZeroCopySinkMock.sol#96-114)\n\t- ZeroCopySinkMock.sol#98-112\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": 139,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint64 uses assembly (ZeroCopySinkMock.sol#120-139)\n\t- ZeroCopySinkMock.sol#123-137\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": 165,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint255 uses assembly (ZeroCopySinkMock.sol#145-165)\n\t- ZeroCopySinkMock.sol#149-163\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint N = 10;\n",
                    "message": "ZeroCopySinkMock.N should be constant (ZeroCopySinkMock.sol#194)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": 201,
                    "vulnerability_code": "    function WriteBool(bool _b) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteBool(_b);\n\n        }\n\n        return ZeroCopySink.WriteBool(_b);\n",
                    "message": "ZeroCopySinkMock.WriteBool (ZeroCopySinkMock.sol#195-201) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 209,
                    "vulnerability_code": "    function WriteByte(byte _b) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteByte(_b);\n\n        }\n\n        return ZeroCopySink.WriteByte(_b);\n",
                    "message": "ZeroCopySinkMock.WriteByte (ZeroCopySinkMock.sol#203-209) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": 217,
                    "vulnerability_code": "    function WriteUint8(uint8 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint8(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint8(_v);\n",
                    "message": "ZeroCopySinkMock.WriteUint8 (ZeroCopySinkMock.sol#211-217) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": 225,
                    "vulnerability_code": "    function WriteUint16(uint16 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint16(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint16(_v);\n",
                    "message": "ZeroCopySinkMock.WriteUint16 (ZeroCopySinkMock.sol#219-225) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": 233,
                    "vulnerability_code": "    function WriteUint32(uint32 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint32(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint32(_v);\n",
                    "message": "ZeroCopySinkMock.WriteUint32 (ZeroCopySinkMock.sol#227-233) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": 241,
                    "vulnerability_code": "    function WriteUint64(uint64 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint64(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint64(_v);\n",
                    "message": "ZeroCopySinkMock.WriteUint64 (ZeroCopySinkMock.sol#235-241) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": 248,
                    "vulnerability_code": "    function WriteUint255(uint256 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint255(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint255(_v);\n",
                    "message": "ZeroCopySinkMock.WriteUint255 (ZeroCopySinkMock.sol#242-248) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": 256,
                    "vulnerability_code": "    function WriteVarBytes(bytes memory _b) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteVarBytes(_b);\n\n        }\n\n        return ZeroCopySink.WriteVarBytes(_b);\n",
                    "message": "ZeroCopySinkMock.WriteVarBytes (ZeroCopySinkMock.sol#250-256) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": 264,
                    "vulnerability_code": "    function WriteVarUint(uint64 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteVarUint(_v);\n\n        }\n\n        return ZeroCopySink.WriteVarUint(_v);\n",
                    "message": "ZeroCopySinkMock.WriteVarUint (ZeroCopySinkMock.sol#258-264) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in ZeroCopySinkMock.sol:\n\t- pragma solidity^0.5.0 (ZeroCopySinkMock.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (ZeroCopySinkMock.sol#191): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteBool' (ZeroCopySinkMock.sol#24-41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 49,
                    "vulnerability_code": "    function WriteByte(byte b) internal pure returns (bytes memory) {\n\n        return WriteUint8(uint8(b));\n",
                    "message": "Function 'ZeroCopySink.WriteByte' (ZeroCopySinkMock.sol#47-49) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": 65,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint8' (ZeroCopySinkMock.sol#55-65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": 90,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint16' (ZeroCopySinkMock.sol#71-90) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": 114,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint32' (ZeroCopySinkMock.sol#96-114) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": 139,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint64' (ZeroCopySinkMock.sol#120-139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": 165,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint255' (ZeroCopySinkMock.sol#145-165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": 174,
                    "vulnerability_code": "    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {\n\n        uint64 l = uint64(data.length);\n\n        return abi.encodePacked(WriteVarUint(l), data);\n",
                    "message": "Function 'ZeroCopySink.WriteVarBytes' (ZeroCopySinkMock.sol#171-174) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": 186,
                    "vulnerability_code": "    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {\n\n        if (v < 0xFD){\n\n    \t\treturn WriteUint8(uint8(v));\n\n    \t} else if (v <= 0xFFFF) {\n\n    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n\n    \t} else if (v <= 0xFFFFFFFF) {\n\n            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n\n    \t} else {\n\n    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n\n    \t}\n",
                    "message": "Function 'ZeroCopySink.WriteVarUint' (ZeroCopySinkMock.sol#176-186) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": 201,
                    "vulnerability_code": "    function WriteBool(bool _b) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteBool(_b);\n\n        }\n\n        return ZeroCopySink.WriteBool(_b);\n",
                    "message": "Function 'ZeroCopySinkMock.WriteBool' (ZeroCopySinkMock.sol#195-201) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteBool(bool _b) public returns (bytes memory) {\n",
                    "message": "Parameter '_b' of ZeroCopySinkMock.WriteBool (ZeroCopySinkMock.sol#195) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 209,
                    "vulnerability_code": "    function WriteByte(byte _b) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteByte(_b);\n\n        }\n\n        return ZeroCopySink.WriteByte(_b);\n",
                    "message": "Function 'ZeroCopySinkMock.WriteByte' (ZeroCopySinkMock.sol#203-209) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteByte(byte _b) public returns (bytes memory) {\n",
                    "message": "Parameter '_b' of ZeroCopySinkMock.WriteByte (ZeroCopySinkMock.sol#203) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": 217,
                    "vulnerability_code": "    function WriteUint8(uint8 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint8(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint8(_v);\n",
                    "message": "Function 'ZeroCopySinkMock.WriteUint8' (ZeroCopySinkMock.sol#211-217) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint8(uint8 _v) public returns (bytes memory) {\n",
                    "message": "Parameter '_v' of ZeroCopySinkMock.WriteUint8 (ZeroCopySinkMock.sol#211) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": 225,
                    "vulnerability_code": "    function WriteUint16(uint16 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint16(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint16(_v);\n",
                    "message": "Function 'ZeroCopySinkMock.WriteUint16' (ZeroCopySinkMock.sol#219-225) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint16(uint16 _v) public returns (bytes memory) {\n",
                    "message": "Parameter '_v' of ZeroCopySinkMock.WriteUint16 (ZeroCopySinkMock.sol#219) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": 233,
                    "vulnerability_code": "    function WriteUint32(uint32 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint32(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint32(_v);\n",
                    "message": "Function 'ZeroCopySinkMock.WriteUint32' (ZeroCopySinkMock.sol#227-233) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint32(uint32 _v) public returns (bytes memory) {\n",
                    "message": "Parameter '_v' of ZeroCopySinkMock.WriteUint32 (ZeroCopySinkMock.sol#227) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": 241,
                    "vulnerability_code": "    function WriteUint64(uint64 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint64(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint64(_v);\n",
                    "message": "Function 'ZeroCopySinkMock.WriteUint64' (ZeroCopySinkMock.sol#235-241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint64(uint64 _v) public returns (bytes memory) {\n",
                    "message": "Parameter '_v' of ZeroCopySinkMock.WriteUint64 (ZeroCopySinkMock.sol#235) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": 248,
                    "vulnerability_code": "    function WriteUint255(uint256 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteUint255(_v);\n\n        }\n\n        return ZeroCopySink.WriteUint255(_v);\n",
                    "message": "Function 'ZeroCopySinkMock.WriteUint255' (ZeroCopySinkMock.sol#242-248) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint255(uint256 _v) public returns (bytes memory) {\n",
                    "message": "Parameter '_v' of ZeroCopySinkMock.WriteUint255 (ZeroCopySinkMock.sol#242) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": 256,
                    "vulnerability_code": "    function WriteVarBytes(bytes memory _b) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteVarBytes(_b);\n\n        }\n\n        return ZeroCopySink.WriteVarBytes(_b);\n",
                    "message": "Function 'ZeroCopySinkMock.WriteVarBytes' (ZeroCopySinkMock.sol#250-256) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteVarBytes(bytes memory _b) public returns (bytes memory) {\n",
                    "message": "Parameter '_b' of ZeroCopySinkMock.WriteVarBytes (ZeroCopySinkMock.sol#250) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": 264,
                    "vulnerability_code": "    function WriteVarUint(uint64 _v) public returns (bytes memory) {\n\n        bytes memory executeResult;\n\n        for (uint i = 0; i <= N; i++) {\n\n            executeResult = ZeroCopySink.WriteVarUint(_v);\n\n        }\n\n        return ZeroCopySink.WriteVarUint(_v);\n",
                    "message": "Function 'ZeroCopySinkMock.WriteVarUint' (ZeroCopySinkMock.sol#258-264) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteVarUint(uint64 _v) public returns (bytes memory) {\n",
                    "message": "Parameter '_v' of ZeroCopySinkMock.WriteVarUint (ZeroCopySinkMock.sol#258) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint N = 10;\n",
                    "message": "Variable 'ZeroCopySinkMock.N' (ZeroCopySinkMock.sol#194) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v < 0xFD){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v <= 0xFFFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v <= 0xFFFFFFFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint N = 10;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/mocks/libs/common/ZeroCopySourceMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"NextBool value error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value < 0xFD, \"NextVarUint, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_78"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
                    "message": "ZeroCopySource.NextBool (ZeroCopySourceMock.sol#25-41) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextByte (ZeroCopySourceMock.sol#48-55) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 73,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextUint8 (ZeroCopySourceMock.sol#62-73) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": 93,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
                    "message": "ZeroCopySource.NextUint16 (ZeroCopySourceMock.sol#80-93) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 121,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
                    "message": "ZeroCopySource.NextUint32 (ZeroCopySourceMock.sol#101-121) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": 148,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
                    "message": "ZeroCopySource.NextUint64 (ZeroCopySourceMock.sol#128-148) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": 177,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextUint255 (ZeroCopySourceMock.sol#156-177) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": 239,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
                    "message": "ZeroCopySource.NextVarBytes (ZeroCopySourceMock.sol#184-239) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": 252,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextHash (ZeroCopySourceMock.sol#245-252) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": 266,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
                    "message": "ZeroCopySource.NextBytes20 (ZeroCopySourceMock.sol#259-266) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
                    "message": "ZeroCopySource.NextBool uses assembly (ZeroCopySourceMock.sol#25-41)\n\t- ZeroCopySourceMock.sol#29-31\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextByte uses assembly (ZeroCopySourceMock.sol#48-55)\n\t- ZeroCopySourceMock.sol#51-53\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 73,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextUint8 uses assembly (ZeroCopySourceMock.sol#62-73)\n\t- ZeroCopySourceMock.sol#65-71\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": 93,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
                    "message": "ZeroCopySource.NextUint16 uses assembly (ZeroCopySourceMock.sol#80-93)\n\t- ZeroCopySourceMock.sol#84-91\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 121,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
                    "message": "ZeroCopySource.NextUint32 uses assembly (ZeroCopySourceMock.sol#101-121)\n\t- ZeroCopySourceMock.sol#104-119\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": 148,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
                    "message": "ZeroCopySource.NextUint64 uses assembly (ZeroCopySourceMock.sol#128-148)\n\t- ZeroCopySourceMock.sol#131-146\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": 177,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextUint255 uses assembly (ZeroCopySourceMock.sol#156-177)\n\t- ZeroCopySourceMock.sol#159-174\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": 239,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
                    "message": "ZeroCopySource.NextVarBytes uses assembly (ZeroCopySourceMock.sol#184-239)\n\t- ZeroCopySourceMock.sol#189-236\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": 252,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextHash uses assembly (ZeroCopySourceMock.sol#245-252)\n\t- ZeroCopySourceMock.sol#248-250\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": 266,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
                    "message": "ZeroCopySource.NextBytes20 uses assembly (ZeroCopySourceMock.sol#259-266)\n\t- ZeroCopySourceMock.sol#262-264\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint N = 10;\n",
                    "message": "ZeroCopySourceMock.N should be constant (ZeroCopySourceMock.sol#302)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": 310,
                    "vulnerability_code": "    function NextBool(bytes memory _b, uint256 _off) public returns (bool, uint256) {\n\n        bool res;\n\n        uint256 offset = 0;\n\n        for (uint i = 0; i <= N; i++) {\n\n            (res, offset) = ZeroCopySource.NextBool(_b, _off);\n\n        }\n\n        return ZeroCopySource.NextBool(_b, _off);\n",
                    "message": "ZeroCopySourceMock.NextBool (ZeroCopySourceMock.sol#303-310) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": 314,
                    "vulnerability_code": "    function NextByte(bytes memory _b, uint256 _off) public returns (byte, uint256) {\n\n        return ZeroCopySource.NextByte(_b, _off);\n",
                    "message": "ZeroCopySourceMock.NextByte (ZeroCopySourceMock.sol#312-314) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": 318,
                    "vulnerability_code": "    function NextUint8(bytes memory _b, uint256 _off) public returns (uint8, uint256) {\n\n        return ZeroCopySource.NextUint8(_b, _off);\n",
                    "message": "ZeroCopySourceMock.NextUint8 (ZeroCopySourceMock.sol#316-318) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": 322,
                    "vulnerability_code": "    function NextUint16(bytes memory _b, uint256 _off) public returns (uint16, uint256) {\n\n        return ZeroCopySource.NextUint16(_b, _off);\n",
                    "message": "ZeroCopySourceMock.NextUint16 (ZeroCopySourceMock.sol#320-322) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": 326,
                    "vulnerability_code": "    function NextUint32(bytes memory _b, uint256 _off) public returns (uint32, uint256) {\n\n        return ZeroCopySource.NextUint32(_b, _off);\n",
                    "message": "ZeroCopySourceMock.NextUint32 (ZeroCopySourceMock.sol#324-326) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": 330,
                    "vulnerability_code": "    function NextUint64(bytes memory _b, uint256 _off) public returns (uint64, uint256) {\n\n        return ZeroCopySource.NextUint64(_b, _off);\n",
                    "message": "ZeroCopySourceMock.NextUint64 (ZeroCopySourceMock.sol#328-330) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": 334,
                    "vulnerability_code": "    function NextVarBytes(bytes memory _b, uint256 _off) public returns (bytes memory, uint256) {\n\n        return ZeroCopySource.NextVarBytes(_b, _off);\n",
                    "message": "ZeroCopySourceMock.NextVarBytes (ZeroCopySourceMock.sol#332-334) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": 338,
                    "vulnerability_code": "    function NextHash(bytes memory _b, uint256 _off) public returns (bytes32, uint256) {\n\n        return ZeroCopySource.NextHash(_b, _off);\n",
                    "message": "ZeroCopySourceMock.NextHash (ZeroCopySourceMock.sol#336-338) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": 346,
                    "vulnerability_code": "    function NextBytes20(bytes memory _b, uint256 _off) public returns (bytes20, uint256) {\n\n        return ZeroCopySource.NextBytes20(_b, _off);\n",
                    "message": "ZeroCopySourceMock.NextBytes20 (ZeroCopySourceMock.sol#344-346) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": 350,
                    "vulnerability_code": "    function NextUint255(bytes memory _b, uint256 _off) public returns (uint256, uint256) {\n\n        return ZeroCopySource.NextUint255(_b, _off);\n",
                    "message": "ZeroCopySourceMock.NextUint255 (ZeroCopySourceMock.sol#348-350) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": 353,
                    "vulnerability_code": "    function NextVarUint(bytes memory _b, uint256 _off) public returns (uint, uint256) {\n\n        return ZeroCopySource.NextVarUint(_b, _off);\n",
                    "message": "ZeroCopySourceMock.NextVarUint (ZeroCopySourceMock.sol#351-353) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in ZeroCopySourceMock.sol:\n\t- pragma solidity^0.5.0 (ZeroCopySourceMock.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (ZeroCopySourceMock.sol#299): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
                    "message": "Function 'ZeroCopySource.NextBool' (ZeroCopySourceMock.sol#25-41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "Function 'ZeroCopySource.NextByte' (ZeroCopySourceMock.sol#48-55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 73,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "Function 'ZeroCopySource.NextUint8' (ZeroCopySourceMock.sol#62-73) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": 93,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
                    "message": "Function 'ZeroCopySource.NextUint16' (ZeroCopySourceMock.sol#80-93) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 121,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
                    "message": "Function 'ZeroCopySource.NextUint32' (ZeroCopySourceMock.sol#101-121) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": 148,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
                    "message": "Function 'ZeroCopySource.NextUint64' (ZeroCopySourceMock.sol#128-148) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": 177,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
                    "message": "Function 'ZeroCopySource.NextUint255' (ZeroCopySourceMock.sol#156-177) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": 239,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
                    "message": "Function 'ZeroCopySource.NextVarBytes' (ZeroCopySourceMock.sol#184-239) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": 252,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
                    "message": "Function 'ZeroCopySource.NextHash' (ZeroCopySourceMock.sol#245-252) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": 266,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
                    "message": "Function 'ZeroCopySource.NextBytes20' (ZeroCopySourceMock.sol#259-266) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": 294,
                    "vulnerability_code": "    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\n\n        byte v;\n\n        (v, offset) = NextByte(buff, offset);\n\n\n\n        uint value;\n\n        if (v == 0xFD) {\n\n            // return NextUint16(buff, offset);\n\n            (value, offset) = NextUint16(buff, offset);\n\n            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n\n            return (value, offset);\n\n        } else if (v == 0xFE) {\n\n            // return NextUint32(buff, offset);\n\n            (value, offset) = NextUint32(buff, offset);\n\n            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        } else if (v == 0xFF) {\n\n            // return NextUint64(buff, offset);\n\n            (value, offset) = NextUint64(buff, offset);\n\n            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        } else{\n\n            // return (uint8(v), offset);\n\n            value = uint8(v);\n\n            require(value < 0xFD, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        }\n",
                    "message": "Function 'ZeroCopySource.NextVarUint' (ZeroCopySourceMock.sol#268-294) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": 310,
                    "vulnerability_code": "    function NextBool(bytes memory _b, uint256 _off) public returns (bool, uint256) {\n\n        bool res;\n\n        uint256 offset = 0;\n\n        for (uint i = 0; i <= N; i++) {\n\n            (res, offset) = ZeroCopySource.NextBool(_b, _off);\n\n        }\n\n        return ZeroCopySource.NextBool(_b, _off);\n",
                    "message": "Function 'ZeroCopySourceMock.NextBool' (ZeroCopySourceMock.sol#303-310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBool(bytes memory _b, uint256 _off) public returns (bool, uint256) {\n",
                    "message": "Parameter '_b' of ZeroCopySourceMock.NextBool (ZeroCopySourceMock.sol#303) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBool(bytes memory _b, uint256 _off) public returns (bool, uint256) {\n",
                    "message": "Parameter '_off' of ZeroCopySourceMock.NextBool (ZeroCopySourceMock.sol#303) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": 314,
                    "vulnerability_code": "    function NextByte(bytes memory _b, uint256 _off) public returns (byte, uint256) {\n\n        return ZeroCopySource.NextByte(_b, _off);\n",
                    "message": "Function 'ZeroCopySourceMock.NextByte' (ZeroCopySourceMock.sol#312-314) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextByte(bytes memory _b, uint256 _off) public returns (byte, uint256) {\n",
                    "message": "Parameter '_b' of ZeroCopySourceMock.NextByte (ZeroCopySourceMock.sol#312) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextByte(bytes memory _b, uint256 _off) public returns (byte, uint256) {\n",
                    "message": "Parameter '_off' of ZeroCopySourceMock.NextByte (ZeroCopySourceMock.sol#312) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": 318,
                    "vulnerability_code": "    function NextUint8(bytes memory _b, uint256 _off) public returns (uint8, uint256) {\n\n        return ZeroCopySource.NextUint8(_b, _off);\n",
                    "message": "Function 'ZeroCopySourceMock.NextUint8' (ZeroCopySourceMock.sol#316-318) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint8(bytes memory _b, uint256 _off) public returns (uint8, uint256) {\n",
                    "message": "Parameter '_b' of ZeroCopySourceMock.NextUint8 (ZeroCopySourceMock.sol#316) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint8(bytes memory _b, uint256 _off) public returns (uint8, uint256) {\n",
                    "message": "Parameter '_off' of ZeroCopySourceMock.NextUint8 (ZeroCopySourceMock.sol#316) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": 322,
                    "vulnerability_code": "    function NextUint16(bytes memory _b, uint256 _off) public returns (uint16, uint256) {\n\n        return ZeroCopySource.NextUint16(_b, _off);\n",
                    "message": "Function 'ZeroCopySourceMock.NextUint16' (ZeroCopySourceMock.sol#320-322) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint16(bytes memory _b, uint256 _off) public returns (uint16, uint256) {\n",
                    "message": "Parameter '_b' of ZeroCopySourceMock.NextUint16 (ZeroCopySourceMock.sol#320) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint16(bytes memory _b, uint256 _off) public returns (uint16, uint256) {\n",
                    "message": "Parameter '_off' of ZeroCopySourceMock.NextUint16 (ZeroCopySourceMock.sol#320) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": 326,
                    "vulnerability_code": "    function NextUint32(bytes memory _b, uint256 _off) public returns (uint32, uint256) {\n\n        return ZeroCopySource.NextUint32(_b, _off);\n",
                    "message": "Function 'ZeroCopySourceMock.NextUint32' (ZeroCopySourceMock.sol#324-326) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint32(bytes memory _b, uint256 _off) public returns (uint32, uint256) {\n",
                    "message": "Parameter '_b' of ZeroCopySourceMock.NextUint32 (ZeroCopySourceMock.sol#324) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint32(bytes memory _b, uint256 _off) public returns (uint32, uint256) {\n",
                    "message": "Parameter '_off' of ZeroCopySourceMock.NextUint32 (ZeroCopySourceMock.sol#324) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": 330,
                    "vulnerability_code": "    function NextUint64(bytes memory _b, uint256 _off) public returns (uint64, uint256) {\n\n        return ZeroCopySource.NextUint64(_b, _off);\n",
                    "message": "Function 'ZeroCopySourceMock.NextUint64' (ZeroCopySourceMock.sol#328-330) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint64(bytes memory _b, uint256 _off) public returns (uint64, uint256) {\n",
                    "message": "Parameter '_b' of ZeroCopySourceMock.NextUint64 (ZeroCopySourceMock.sol#328) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint64(bytes memory _b, uint256 _off) public returns (uint64, uint256) {\n",
                    "message": "Parameter '_off' of ZeroCopySourceMock.NextUint64 (ZeroCopySourceMock.sol#328) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": 334,
                    "vulnerability_code": "    function NextVarBytes(bytes memory _b, uint256 _off) public returns (bytes memory, uint256) {\n\n        return ZeroCopySource.NextVarBytes(_b, _off);\n",
                    "message": "Function 'ZeroCopySourceMock.NextVarBytes' (ZeroCopySourceMock.sol#332-334) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarBytes(bytes memory _b, uint256 _off) public returns (bytes memory, uint256) {\n",
                    "message": "Parameter '_b' of ZeroCopySourceMock.NextVarBytes (ZeroCopySourceMock.sol#332) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarBytes(bytes memory _b, uint256 _off) public returns (bytes memory, uint256) {\n",
                    "message": "Parameter '_off' of ZeroCopySourceMock.NextVarBytes (ZeroCopySourceMock.sol#332) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": 338,
                    "vulnerability_code": "    function NextHash(bytes memory _b, uint256 _off) public returns (bytes32, uint256) {\n\n        return ZeroCopySource.NextHash(_b, _off);\n",
                    "message": "Function 'ZeroCopySourceMock.NextHash' (ZeroCopySourceMock.sol#336-338) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextHash(bytes memory _b, uint256 _off) public returns (bytes32, uint256) {\n",
                    "message": "Parameter '_b' of ZeroCopySourceMock.NextHash (ZeroCopySourceMock.sol#336) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextHash(bytes memory _b, uint256 _off) public returns (bytes32, uint256) {\n",
                    "message": "Parameter '_off' of ZeroCopySourceMock.NextHash (ZeroCopySourceMock.sol#336) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": 346,
                    "vulnerability_code": "    function NextBytes20(bytes memory _b, uint256 _off) public returns (bytes20, uint256) {\n\n        return ZeroCopySource.NextBytes20(_b, _off);\n",
                    "message": "Function 'ZeroCopySourceMock.NextBytes20' (ZeroCopySourceMock.sol#344-346) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBytes20(bytes memory _b, uint256 _off) public returns (bytes20, uint256) {\n",
                    "message": "Parameter '_b' of ZeroCopySourceMock.NextBytes20 (ZeroCopySourceMock.sol#344) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBytes20(bytes memory _b, uint256 _off) public returns (bytes20, uint256) {\n",
                    "message": "Parameter '_off' of ZeroCopySourceMock.NextBytes20 (ZeroCopySourceMock.sol#344) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": 350,
                    "vulnerability_code": "    function NextUint255(bytes memory _b, uint256 _off) public returns (uint256, uint256) {\n\n        return ZeroCopySource.NextUint255(_b, _off);\n",
                    "message": "Function 'ZeroCopySourceMock.NextUint255' (ZeroCopySourceMock.sol#348-350) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint255(bytes memory _b, uint256 _off) public returns (uint256, uint256) {\n",
                    "message": "Parameter '_b' of ZeroCopySourceMock.NextUint255 (ZeroCopySourceMock.sol#348) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint255(bytes memory _b, uint256 _off) public returns (uint256, uint256) {\n",
                    "message": "Parameter '_off' of ZeroCopySourceMock.NextUint255 (ZeroCopySourceMock.sol#348) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": 353,
                    "vulnerability_code": "    function NextVarUint(bytes memory _b, uint256 _off) public returns (uint, uint256) {\n\n        return ZeroCopySource.NextVarUint(_b, _off);\n",
                    "message": "Function 'ZeroCopySourceMock.NextVarUint' (ZeroCopySourceMock.sol#351-353) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarUint(bytes memory _b, uint256 _off) public returns (uint, uint256) {\n",
                    "message": "Parameter '_b' of ZeroCopySourceMock.NextVarUint (ZeroCopySourceMock.sol#351) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarUint(bytes memory _b, uint256 _off) public returns (uint, uint256) {\n",
                    "message": "Parameter '_off' of ZeroCopySourceMock.NextVarUint (ZeroCopySourceMock.sol#351) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint N = 10;\n",
                    "message": "Variable 'ZeroCopySourceMock.N' (ZeroCopySourceMock.sol#302) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v == 0x01) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v == 0x00) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v == 0xFD) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (v == 0xFE) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (v == 0xFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value < 0xFD, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= N; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v == 0x00) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBool(bytes memory _b, uint256 _off) public returns (bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextByte(bytes memory _b, uint256 _off) public returns (byte, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint8(bytes memory _b, uint256 _off) public returns (uint8, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint16(bytes memory _b, uint256 _off) public returns (uint16, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint32(bytes memory _b, uint256 _off) public returns (uint32, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint64(bytes memory _b, uint256 _off) public returns (uint64, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarBytes(bytes memory _b, uint256 _off) public returns (bytes memory, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextHash(bytes memory _b, uint256 _off) public returns (bytes32, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBytes20(bytes memory _b, uint256 _off) public returns (bytes20, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint255(bytes memory _b, uint256 _off) public returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarUint(bytes memory _b, uint256 _off) public returns (uint, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint N = 10;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/core/lock_proxy/LockProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 1190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 1253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract LockProxy is Ownable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 855,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address msgSender = _msgSender();\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = msgSender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit OwnershipTransferred(address(0), msgSender);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 855,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isOwner(), \"Ownable: caller is not the owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"NextBool value error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 285,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 391,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value < 0xFD, \"NextVarUint, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 619,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 624,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 870,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "         require(key.length >= 67, \"key lenggh is too short\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1016,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1070,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require((value == 0) || (token.allowance(address(this), spender) == 0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SafeERC20: approve from non-zero to non-zero allowance\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(Utils.isContract(address(token)), \"SafeERC20: call to non-contract\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"SafeERC20: low-level call failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_msgSender() == ieccmp.getEthCrossChainManager(), \"msgSender is not EthCrossChainManagerContract\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amount != 0, \"amount cannot be zero!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_transferToContract(fromAssetHash, amount), \"transfer asset from fromAddress to lock_proxy contract  failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(toAssetHash.length != 0, \"empty illegal toAssetHash\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1326,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(toProxyHash.length != 0, \"empty illegal toProxyHash\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1327,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(eccm.crossChain(toChainId, toProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1346,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(fromContractAddr.length != 0, \"from proxy contract address cannot be empty\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(Utils.equalStorage(proxyHashMap[fromChainId], fromContractAddr), \"From Proxy contract address error!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(args.toAssetHash.length != 0, \"toAssetHash cannot be empty\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(args.toAddress.length != 0, \"toAddress cannot be empty\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_transferFromContract(toAssetHash, toAddress, args.amount), \"transfer asset from lock_proxy contract to toAddress failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(msg.value != 0, \"transferred ether cannot be zero!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(msg.value == amount, \"transferred ether is not equal to amount!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(msg.value == 0, \"there should be no ether transfer!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_transferERC20ToContract(fromAssetHash, _msgSender(), address(this), amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1393,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_transferERC20FromContract(toAssetHash, toAddress, amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 391,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 855,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 857,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    m++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1070,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require((value == 0) || (token.allowance(address(this), spender) == 0),\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SafeERC20: approve from non-zero to non-zero allowance\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_msgSender() == ieccmp.getEthCrossChainManager(), \"msgSender is not EthCrossChainManagerContract\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_transferToContract(fromAssetHash, amount), \"transfer asset from fromAddress to lock_proxy contract  failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1327,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(eccm.crossChain(toChainId, toProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1346,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(fromContractAddr.length != 0, \"from proxy contract address cannot be empty\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(Utils.equalStorage(proxyHashMap[fromChainId], fromContractAddr), \"From Proxy contract address error!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_transferFromContract(toAssetHash, toAddress, args.amount), \"transfer asset from lock_proxy contract to toAddress failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(msg.value != 0, \"transferred ether cannot be zero!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(msg.value == amount, \"transferred ether is not equal to amount!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(msg.value == 0, \"there should be no ether transfer!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_transferERC20ToContract(fromAssetHash, _msgSender(), address(this), amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1393,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_transferERC20FromContract(toAssetHash, toAddress, amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_103"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 1386,
                    "vulnerability_to_line": 1396,
                    "vulnerability_code": "    function _transferFromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {\n\n        if (toAssetHash == address(0x0000000000000000000000000000000000000000)) {\n\n            // toAssetHash === address(0) denotes contract needs to unlock ether to toAddress\n\n            // convert toAddress from 'address' type to 'address payable' type, then actively transfer ether\n\n            address(uint160(toAddress)).transfer(amount);\n\n        } else {\n\n            // actively transfer amount of asset from msg.sender to lock_proxy contract \n\n            require(_transferERC20FromContract(toAssetHash, toAddress, amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n\n        }\n\n        return true;\n",
                    "message": "LockProxy._transferFromContract (LockProxy.sol#1386-1396) sends eth to arbitrary user\n\tDangerous calls:\n\t- address(uint160(toAddress)).transfer(amount) (LockProxy.sol#1390)\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": 151,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
                    "message": "ZeroCopySource.NextBool (LockProxy.sol#135-151) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": 165,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextByte (LockProxy.sol#158-165) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": 183,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextUint8 (LockProxy.sol#172-183) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 190,
                    "vulnerability_to_line": 203,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
                    "message": "ZeroCopySource.NextUint16 (LockProxy.sol#190-203) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": 231,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
                    "message": "ZeroCopySource.NextUint32 (LockProxy.sol#211-231) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": 258,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
                    "message": "ZeroCopySource.NextUint64 (LockProxy.sol#238-258) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 266,
                    "vulnerability_to_line": 287,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextUint255 (LockProxy.sol#266-287) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": 349,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
                    "message": "ZeroCopySource.NextVarBytes (LockProxy.sol#294-349) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": 362,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextHash (LockProxy.sol#355-362) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 376,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
                    "message": "ZeroCopySource.NextBytes20 (LockProxy.sol#369-376) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteBool (LockProxy.sol#430-447) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint8 (LockProxy.sol#461-471) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": 496,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint16 (LockProxy.sol#477-496) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": 520,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint32 (LockProxy.sol#502-520) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": 545,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint64 (LockProxy.sol#526-545) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": 571,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint255 (LockProxy.sol#551-571) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": 612,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
                    "message": "Utils.bytesToBytes32 (LockProxy.sol#606-612) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 618,
                    "vulnerability_to_line": 625,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Utils.bytesToUint256 (LockProxy.sol#618-625) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 631,
                    "vulnerability_to_line": 644,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
                    "message": "Utils.uint256ToBytes (LockProxy.sol#631-644) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": 659,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
                    "message": "Utils.bytesToAddress (LockProxy.sol#650-659) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": 677,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
                    "message": "Utils.addressToBytes (LockProxy.sol#665-677) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 702,
                    "vulnerability_to_line": 772,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
                    "message": "Utils.equalStorage (LockProxy.sol#702-772) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": 845,
                    "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
                    "message": "Utils.slice (LockProxy.sol#781-845) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 892,
                    "vulnerability_to_line": 905,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "Utils.isContract (LockProxy.sol#892-905) is declared view but contains assembly code\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        TxArgs memory args;\n",
                    "message": "args in LockProxy._deserializeTxArgs (LockProxy.sol#1423) is a local variable never initialiazed\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": 151,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
                    "message": "ZeroCopySource.NextBool uses assembly (LockProxy.sol#135-151)\n\t- LockProxy.sol#139-141\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": 165,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextByte uses assembly (LockProxy.sol#158-165)\n\t- LockProxy.sol#161-163\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": 183,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextUint8 uses assembly (LockProxy.sol#172-183)\n\t- LockProxy.sol#175-181\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 190,
                    "vulnerability_to_line": 203,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
                    "message": "ZeroCopySource.NextUint16 uses assembly (LockProxy.sol#190-203)\n\t- LockProxy.sol#194-201\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": 231,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
                    "message": "ZeroCopySource.NextUint32 uses assembly (LockProxy.sol#211-231)\n\t- LockProxy.sol#214-229\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": 258,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
                    "message": "ZeroCopySource.NextUint64 uses assembly (LockProxy.sol#238-258)\n\t- LockProxy.sol#241-256\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 266,
                    "vulnerability_to_line": 287,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextUint255 uses assembly (LockProxy.sol#266-287)\n\t- LockProxy.sol#269-284\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": 349,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
                    "message": "ZeroCopySource.NextVarBytes uses assembly (LockProxy.sol#294-349)\n\t- LockProxy.sol#299-346\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": 362,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextHash uses assembly (LockProxy.sol#355-362)\n\t- LockProxy.sol#358-360\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 376,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
                    "message": "ZeroCopySource.NextBytes20 uses assembly (LockProxy.sol#369-376)\n\t- LockProxy.sol#372-374\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteBool uses assembly (LockProxy.sol#430-447)\n\t- LockProxy.sol#432-445\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint8 uses assembly (LockProxy.sol#461-471)\n\t- LockProxy.sol#463-469\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": 496,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint16 uses assembly (LockProxy.sol#477-496)\n\t- LockProxy.sol#480-494\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": 520,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint32 uses assembly (LockProxy.sol#502-520)\n\t- LockProxy.sol#504-518\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": 545,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint64 uses assembly (LockProxy.sol#526-545)\n\t- LockProxy.sol#529-543\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": 571,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint255 uses assembly (LockProxy.sol#551-571)\n\t- LockProxy.sol#555-569\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": 612,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
                    "message": "Utils.bytesToBytes32 uses assembly (LockProxy.sol#606-612)\n\t- LockProxy.sol#608-611\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 618,
                    "vulnerability_to_line": 625,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Utils.bytesToUint256 uses assembly (LockProxy.sol#618-625)\n\t- LockProxy.sol#620-623\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 631,
                    "vulnerability_to_line": 644,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
                    "message": "Utils.uint256ToBytes uses assembly (LockProxy.sol#631-644)\n\t- LockProxy.sol#633-643\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": 659,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
                    "message": "Utils.bytesToAddress uses assembly (LockProxy.sol#650-659)\n\t- LockProxy.sol#653-657\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": 677,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
                    "message": "Utils.addressToBytes uses assembly (LockProxy.sol#665-677)\n\t- LockProxy.sol#666-676\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 702,
                    "vulnerability_to_line": 772,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
                    "message": "Utils.equalStorage uses assembly (LockProxy.sol#702-772)\n\t- LockProxy.sol#705-769\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": 845,
                    "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
                    "message": "Utils.slice uses assembly (LockProxy.sol#781-845)\n\t- LockProxy.sol#794-842\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 892,
                    "vulnerability_to_line": 905,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "Utils.isContract uses assembly (LockProxy.sol#892-905)\n\t- LockProxy.sol#903\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function owner() public view returns (address) {\n\n        return _owner;\n",
                    "message": "Ownable.owner (LockProxy.sol#62-64) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": 91,
                    "vulnerability_code": "    function renounceOwnership() public onlyOwner {\n\n        emit OwnershipTransferred(_owner, address(0));\n\n        _owner = address(0);\n",
                    "message": "Ownable.renounceOwnership (LockProxy.sol#88-91) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": 99,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public  onlyOwner {\n\n        _transferOwnership(newOwner);\n",
                    "message": "Ownable.transferOwnership (LockProxy.sol#97-99) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1279,
                    "vulnerability_to_line": 1282,
                    "vulnerability_code": "    function setManagerProxy(address ethCCMProxyAddr) onlyOwner public {\n\n        managerProxyContract = ethCCMProxyAddr;\n\n        emit SetManagerProxyEvent(managerProxyContract);\n",
                    "message": "LockProxy.setManagerProxy (LockProxy.sol#1279-1282) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": 1288,
                    "vulnerability_code": "    function bindProxyHash(uint64 toChainId, bytes memory targetProxyHash) onlyOwner public returns (bool) {\n\n        proxyHashMap[toChainId] = targetProxyHash;\n\n        emit BindProxyEvent(toChainId, targetProxyHash);\n\n        return true;\n",
                    "message": "LockProxy.bindProxyHash (LockProxy.sol#1284-1288) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": 1294,
                    "vulnerability_code": "    function bindAssetHash(address fromAssetHash, uint64 toChainId, bytes memory toAssetHash) onlyOwner public returns (bool) {\n\n        assetHashMap[fromAssetHash][toChainId] = toAssetHash;\n\n        emit BindAssetEvent(fromAssetHash, toChainId, toAssetHash, getBalanceFor(fromAssetHash));\n\n        return true;\n",
                    "message": "LockProxy.bindAssetHash (LockProxy.sol#1290-1294) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1305,
                    "vulnerability_to_line": 1333,
                    "vulnerability_code": "    function lock(address fromAssetHash, uint64 toChainId, bytes memory toAddress, uint256 amount) public payable returns (bool) {\n\n        require(amount != 0, \"amount cannot be zero!\");\n\n        \n\n        \n\n        require(_transferToContract(fromAssetHash, amount), \"transfer asset from fromAddress to lock_proxy contract  failed!\");\n\n        \n\n        bytes memory toAssetHash = assetHashMap[fromAssetHash][toChainId];\n\n        require(toAssetHash.length != 0, \"empty illegal toAssetHash\");\n\n\n\n        TxArgs memory txArgs = TxArgs({\n\n            toAssetHash: toAssetHash,\n\n            toAddress: toAddress,\n\n            amount: amount\n\n        });\n\n        bytes memory txData = _serializeTxArgs(txArgs);\n\n        \n\n        IEthCrossChainManagerProxy eccmp = IEthCrossChainManagerProxy(managerProxyContract);\n\n        address eccmAddr = eccmp.getEthCrossChainManager();\n\n        IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr);\n\n        \n\n        bytes memory toProxyHash = proxyHashMap[toChainId];\n\n        require(toProxyHash.length != 0, \"empty illegal toProxyHash\");\n\n        require(eccm.crossChain(toChainId, toProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\");\n\n\n\n        emit LockEvent(fromAssetHash, _msgSender(), toChainId, toAssetHash, toAddress, amount);\n\n        \n\n        return true;\n\n\n",
                    "message": "LockProxy.lock (LockProxy.sol#1305-1333) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1343,
                    "vulnerability_to_line": 1360,
                    "vulnerability_code": "    function unlock(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) onlyManagerContract public returns (bool) {\n\n        TxArgs memory args = _deserializeTxArgs(argsBs);\n\n\n\n        require(fromContractAddr.length != 0, \"from proxy contract address cannot be empty\");\n\n        require(Utils.equalStorage(proxyHashMap[fromChainId], fromContractAddr), \"From Proxy contract address error!\");\n\n        \n\n        require(args.toAssetHash.length != 0, \"toAssetHash cannot be empty\");\n\n        address toAssetHash = Utils.bytesToAddress(args.toAssetHash);\n\n\n\n        require(args.toAddress.length != 0, \"toAddress cannot be empty\");\n\n        address toAddress = Utils.bytesToAddress(args.toAddress);\n\n        \n\n        \n\n        require(_transferFromContract(toAssetHash, toAddress, args.amount), \"transfer asset from lock_proxy contract to toAddress failed!\");\n\n        \n\n        emit UnlockEvent(toAssetHash, toAddress, args.amount);\n\n        return true;\n",
                    "message": "LockProxy.unlock (LockProxy.sol#1343-1360) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in LockProxy.sol:\n\t- pragma solidity^0.5.0 (LockProxy.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxy.sol#34): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxy.sol#113): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxy.sol#409): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxy.sol#597): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxy.sol#910): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxy.sol#989): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxy.sol#1148): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxy.sol#1223): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxy.sol#1234): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxy.sol#1245): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 1199,
                    "vulnerability_to_line": 1218,
                    "vulnerability_code": "    function callOptionalReturn(IERC20 token, bytes memory data) private {\n\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n\n        // we're implementing it ourselves.\n\n\n\n        // A Solidity high level call has three parts:\n\n        //  1. The target address is checked to verify it contains contract code\n\n        //  2. The call itself is made, and success asserted\n\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n\n        // solhint-disable-next-line max-line-length\n\n        require(Utils.isContract(address(token)), \"SafeERC20: call to non-contract\");\n\n\n\n        // solhint-disable-next-line avoid-low-level-calls\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n\n        require(success, \"SafeERC20: low-level call failed\");\n\n\n\n        if (returndata.length > 0) { // Return data is optional\n\n            // solhint-disable-next-line max-line-length\n\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n\n        }\n",
                    "message": "Low level call in SafeERC20.callOptionalReturn (LockProxy.sol#1199-1218):\n\t-(success,returndata) = address(token).call(data) LockProxy.sol#1211\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 24,
                    "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
                    "message": "Function 'Context._msgSender' (LockProxy.sol#22-24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": 29,
                    "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
                    "message": "Function 'Context._msgData' (LockProxy.sol#26-29) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": 108,
                    "vulnerability_code": "    function _transferOwnership(address newOwner) internal {\n\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\n        emit OwnershipTransferred(_owner, newOwner);\n\n        _owner = newOwner;\n",
                    "message": "Function 'Ownable._transferOwnership' (LockProxy.sol#104-108) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": 151,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
                    "message": "Function 'ZeroCopySource.NextBool' (LockProxy.sol#135-151) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": 165,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "Function 'ZeroCopySource.NextByte' (LockProxy.sol#158-165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": 183,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "Function 'ZeroCopySource.NextUint8' (LockProxy.sol#172-183) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 190,
                    "vulnerability_to_line": 203,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
                    "message": "Function 'ZeroCopySource.NextUint16' (LockProxy.sol#190-203) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": 231,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
                    "message": "Function 'ZeroCopySource.NextUint32' (LockProxy.sol#211-231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": 258,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
                    "message": "Function 'ZeroCopySource.NextUint64' (LockProxy.sol#238-258) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 266,
                    "vulnerability_to_line": 287,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
                    "message": "Function 'ZeroCopySource.NextUint255' (LockProxy.sol#266-287) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": 349,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
                    "message": "Function 'ZeroCopySource.NextVarBytes' (LockProxy.sol#294-349) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": 362,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
                    "message": "Function 'ZeroCopySource.NextHash' (LockProxy.sol#355-362) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 376,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
                    "message": "Function 'ZeroCopySource.NextBytes20' (LockProxy.sol#369-376) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": 404,
                    "vulnerability_code": "    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\n\n        byte v;\n\n        (v, offset) = NextByte(buff, offset);\n\n\n\n        uint value;\n\n        if (v == 0xFD) {\n\n            // return NextUint16(buff, offset);\n\n            (value, offset) = NextUint16(buff, offset);\n\n            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n\n            return (value, offset);\n\n        } else if (v == 0xFE) {\n\n            // return NextUint32(buff, offset);\n\n            (value, offset) = NextUint32(buff, offset);\n\n            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        } else if (v == 0xFF) {\n\n            // return NextUint64(buff, offset);\n\n            (value, offset) = NextUint64(buff, offset);\n\n            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        } else{\n\n            // return (uint8(v), offset);\n\n            value = uint8(v);\n\n            require(value < 0xFD, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        }\n",
                    "message": "Function 'ZeroCopySource.NextVarUint' (LockProxy.sol#378-404) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteBool' (LockProxy.sol#430-447) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 455,
                    "vulnerability_code": "    function WriteByte(byte b) internal pure returns (bytes memory) {\n\n        return WriteUint8(uint8(b));\n",
                    "message": "Function 'ZeroCopySink.WriteByte' (LockProxy.sol#453-455) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint8' (LockProxy.sol#461-471) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": 496,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint16' (LockProxy.sol#477-496) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": 520,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint32' (LockProxy.sol#502-520) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": 545,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint64' (LockProxy.sol#526-545) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": 571,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint255' (LockProxy.sol#551-571) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 577,
                    "vulnerability_to_line": 580,
                    "vulnerability_code": "    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {\n\n        uint64 l = uint64(data.length);\n\n        return abi.encodePacked(WriteVarUint(l), data);\n",
                    "message": "Function 'ZeroCopySink.WriteVarBytes' (LockProxy.sol#577-580) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 582,
                    "vulnerability_to_line": 592,
                    "vulnerability_code": "    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {\n\n        if (v < 0xFD){\n\n    \t\treturn WriteUint8(uint8(v));\n\n    \t} else if (v <= 0xFFFF) {\n\n    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n\n    \t} else if (v <= 0xFFFFFFFF) {\n\n            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n\n    \t} else {\n\n    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n\n    \t}\n",
                    "message": "Function 'ZeroCopySink.WriteVarUint' (LockProxy.sol#582-592) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": "Parameter '_bs' of Utils.bytesToBytes32 (LockProxy.sol#606) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 618,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
                    "message": "Parameter '_bs' of Utils.bytesToUint256 (LockProxy.sol#618) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 631,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": "Parameter '_value' of Utils.uint256ToBytes (LockProxy.sol#631) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": "Parameter '_bs' of Utils.bytesToAddress (LockProxy.sol#650) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 683,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_data' of Utils.hashLeaf (LockProxy.sol#683) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 692,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_l' of Utils.hashChildren (LockProxy.sol#692) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 692,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_r' of Utils.hashChildren (LockProxy.sol#692) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 782,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory _bytes,\n",
                    "message": "Parameter '_bytes' of Utils.slice (LockProxy.sol#782) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 783,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint _start,\n",
                    "message": "Parameter '_start' of Utils.slice (LockProxy.sol#783) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 784,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint _length\n",
                    "message": "Parameter '_length' of Utils.slice (LockProxy.sol#784) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_keepers' of Utils.containMAddresses (LockProxy.sol#852) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_signers' of Utils.containMAddresses (LockProxy.sol#852) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_m' of Utils.containMAddresses (LockProxy.sol#852) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1372,
                    "vulnerability_to_line": 1385,
                    "vulnerability_code": "    function _transferToContract(address fromAssetHash, uint256 amount) internal returns (bool) {\n\n        if (fromAssetHash == address(0)) {\n\n            // fromAssetHash === address(0) denotes user choose to lock ether\n\n            // passively check if the received msg.value equals amount\n\n            require(msg.value != 0, \"transferred ether cannot be zero!\");\n\n            require(msg.value == amount, \"transferred ether is not equal to amount!\");\n\n        } else {\n\n            // make sure lockproxy contract will decline any received ether\n\n            require(msg.value == 0, \"there should be no ether transfer!\");\n\n            // actively transfer amount of asset from msg.sender to lock_proxy contract\n\n            require(_transferERC20ToContract(fromAssetHash, _msgSender(), address(this), amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n\n        }\n\n        return true;\n",
                    "message": "Function 'LockProxy._transferToContract' (LockProxy.sol#1372-1385) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1386,
                    "vulnerability_to_line": 1396,
                    "vulnerability_code": "    function _transferFromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {\n\n        if (toAssetHash == address(0x0000000000000000000000000000000000000000)) {\n\n            // toAssetHash === address(0) denotes contract needs to unlock ether to toAddress\n\n            // convert toAddress from 'address' type to 'address payable' type, then actively transfer ether\n\n            address(uint160(toAddress)).transfer(amount);\n\n        } else {\n\n            // actively transfer amount of asset from msg.sender to lock_proxy contract \n\n            require(_transferERC20FromContract(toAssetHash, toAddress, amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n\n        }\n\n        return true;\n",
                    "message": "Function 'LockProxy._transferFromContract' (LockProxy.sol#1386-1396) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1399,
                    "vulnerability_to_line": 1404,
                    "vulnerability_code": "    function _transferERC20ToContract(address fromAssetHash, address fromAddress, address toAddress, uint256 amount) internal returns (bool) {\n\n         IERC20 erc20Token = IERC20(fromAssetHash);\n\n        //  require(erc20Token.transferFrom(fromAddress, toAddress, amount), \"trasnfer ERC20 Token failed!\");\n\n         erc20Token.safeTransferFrom(fromAddress, toAddress, amount);\n\n         return true;\n",
                    "message": "Function 'LockProxy._transferERC20ToContract' (LockProxy.sol#1399-1404) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1405,
                    "vulnerability_to_line": 1410,
                    "vulnerability_code": "    function _transferERC20FromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {\n\n         IERC20 erc20Token = IERC20(toAssetHash);\n\n        //  require(erc20Token.transfer(toAddress, amount), \"trasnfer ERC20 Token failed!\");\n\n         erc20Token.safeTransfer(toAddress, amount);\n\n         return true;\n",
                    "message": "Function 'LockProxy._transferERC20FromContract' (LockProxy.sol#1405-1410) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1412,
                    "vulnerability_to_line": 1420,
                    "vulnerability_code": "    function _serializeTxArgs(TxArgs memory args) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        buff = abi.encodePacked(\n\n            ZeroCopySink.WriteVarBytes(args.toAssetHash),\n\n            ZeroCopySink.WriteVarBytes(args.toAddress),\n\n            ZeroCopySink.WriteUint255(args.amount)\n\n            );\n\n        return buff;\n",
                    "message": "Function 'LockProxy._serializeTxArgs' (LockProxy.sol#1412-1420) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1422,
                    "vulnerability_to_line": 1429,
                    "vulnerability_code": "    function _deserializeTxArgs(bytes memory valueBs) internal pure returns (TxArgs memory) {\n\n        TxArgs memory args;\n\n        uint256 off = 0;\n\n        (args.toAssetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n\n        (args.toAddress, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n\n        (args.amount, off) = ZeroCopySource.NextUint255(valueBs, off);\n\n        return args;\n",
                    "message": "Function 'LockProxy._deserializeTxArgs' (LockProxy.sol#1422-1429) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 1265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => bool) safeTransfer;\n",
                    "message": "LockProxy.safeTransfer (LockProxy.sol#1265) is never used in LockProxy\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (toAssetHash == address(0x0000000000000000000000000000000000000000)) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v == 0x01) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v == 0x00) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v == 0xFD) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (v == 0xFE) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 391,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 391,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 393,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (v == 0xFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value < 0xFD, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 583,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v < 0xFD){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 585,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v <= 0xFFFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 587,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v <= 0xFFFFFFFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 590,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 873,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "             newkey[2] = byte(0x02);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 875,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "             newkey[2] = byte(0x03);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        result = sha256(abi.encodePacked(byte(0x0), _data));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 855,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 631,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 855,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_MSGVALUE_EQUALS_ZERO",
                    "vulnerability_from_line": 1380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(msg.value == 0, \"there should be no ether transfer!\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 1279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setManagerProxy(address ethCCMProxyAddr) onlyOwner public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 910,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 989,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _owner;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v == 0x00) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 1162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 1254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 618,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 631,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function slice(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 702,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 892,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 1165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 1169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 1180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 1185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 1190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 1211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, bytes memory returndata) = address(token).call(data);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 372,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 633,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 653,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 705,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 794,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 903,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { codehash := extcodehash(account) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => bool) safeTransfer;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/core/lock_proxy/LockProxyPip1.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 775,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address ethCCMProxyAddr) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        managerProxyContract = ethCCMProxyAddr;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit SetManagerProxyEvent(managerProxyContract);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 775,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"NextBool value error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value < 0xFD, \"NextVarUint, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 473,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 573,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 791,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "         require(key.length >= 67, \"key lenggh is too short\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 858,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 912,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_msgSender() == ieccmp.getEthCrossChainManager(), \"msgSender is not EthCrossChainManagerContract\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1064,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(nativeChainId != 0, \"nativeChainId cannot be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(nativeLockProxy.length != 0, \"empty nativeLockProxy\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1066,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(nativeAssetHash.length != 0, \"empty nativeAssetHash\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1071,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(registry[key] != true, \"asset already registered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1072,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(balances[key] == 0, \"balance is not zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1073,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_balanceFor(assetHash) == delegatedSupply, \"controlled balance does not match delegatedSupply\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1085,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(eccm.crossChain(nativeChainId, nativeLockProxy, \"registerAsset\", txData), \"EthCrossChainManager crossChain executed error!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1096,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(registry[key] != true, \"asset already registerd\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(toChainId != 0, \"toChainId cannot be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(targetProxyHash.length != 0, \"empty targetProxyHash\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(toAssetHash.length != 0, \"empty toAssetHash\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(toAddress.length != 0, \"empty toAddress\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amount != 0, \"amount must be more than zero!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_transferToContract(fromAssetHash, amount), \"transfer asset from fromAddress to lock_proxy contract  failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(registry[key] == true, \"asset not registered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(feeAddress.length != 0, \"empty fee address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_transferFromContract(fromAssetHash, Utils.bytesToAddress(feeAddress), feeAmount), \"transfer asset from lock_proxy contract to feeAddress failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(eccm.crossChain(toChainId, targetProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(registry[key] == true, \"asset not registered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(balances[key] >= args.amount, \"insufficient balance in registry\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_transferFromContract(toAssetHash, feeAddress, args.feeAmount), \"transfer asset from lock_proxy contract to feeAddress failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_transferFromContract(toAssetHash, toAddress, afterFeeAmount), \"transfer asset from lock_proxy contract to toAddress failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(msg.value == amount, \"transferred ether is not equal to amount!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_transferERC20ToContract(fromAssetHash, _msgSender(), address(this), amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_transferERC20FromContract(toAssetHash, toAddress, amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "         require(erc20Token.transferFrom(fromAddress, toAddress, amount), \"trasnfer ERC20 Token failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "         require(erc20Token.transfer(toAddress, amount), \"trasnfer ERC20 Token failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (feeAmount != 0 && deductFeeInLock) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(feeAddress.length != 0, \"empty fee address\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 afterFeeAmount = amount.sub(feeAmount);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_transferFromContract(fromAssetHash, Utils.bytesToAddress(feeAddress), feeAmount), \"transfer asset from lock_proxy contract to feeAddress failed!\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // set feeAmount to zero as fee has already been transferred\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            txArgs.feeAmount = 0;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            txArgs.amount = afterFeeAmount;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 775,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 778,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    m++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 573,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 912,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_msgSender() == ieccmp.getEthCrossChainManager(), \"msgSender is not EthCrossChainManagerContract\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1073,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_balanceFor(assetHash) == delegatedSupply, \"controlled balance does not match delegatedSupply\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1085,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(eccm.crossChain(nativeChainId, nativeLockProxy, \"registerAsset\", txData), \"EthCrossChainManager crossChain executed error!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_transferToContract(fromAssetHash, amount), \"transfer asset from fromAddress to lock_proxy contract  failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_transferFromContract(fromAssetHash, Utils.bytesToAddress(feeAddress), feeAmount), \"transfer asset from lock_proxy contract to feeAddress failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(eccm.crossChain(toChainId, targetProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_transferFromContract(toAssetHash, feeAddress, args.feeAmount), \"transfer asset from lock_proxy contract to feeAddress failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_transferFromContract(toAssetHash, toAddress, afterFeeAmount), \"transfer asset from lock_proxy contract to toAddress failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(msg.value == amount, \"transferred ether is not equal to amount!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_transferERC20ToContract(fromAssetHash, _msgSender(), address(this), amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_transferERC20FromContract(toAssetHash, toAddress, amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_105"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 1238,
                    "vulnerability_to_line": 1248,
                    "vulnerability_code": "    function _transferFromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {\n\n        if (toAssetHash == address(0x0000000000000000000000000000000000000000)) {\n\n            // toAssetHash === address(0) denotes contract needs to unlock ether to toAddress\n\n            // convert toAddress from 'address' type to 'address payable' type, then actively transfer ether\n\n            address(uint160(toAddress)).transfer(amount);\n\n        } else {\n\n            // actively transfer amount of asset from msg.sender to lock_proxy contract\n\n            require(_transferERC20FromContract(toAssetHash, toAddress, amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n\n        }\n\n        return true;\n",
                    "message": "LockProxyPip1._transferFromContract (LockProxyPip1.sol#1238-1248) sends eth to arbitrary user\n\tDangerous calls:\n\t- address(uint160(toAddress)).transfer(amount) (LockProxyPip1.sol#1242)\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
                    "message": "ZeroCopySource.NextBool (LockProxyPip1.sol#56-72) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": 86,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextByte (LockProxyPip1.sol#79-86) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": 104,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextUint8 (LockProxyPip1.sol#93-104) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": 124,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
                    "message": "ZeroCopySource.NextUint16 (LockProxyPip1.sol#111-124) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
                    "message": "ZeroCopySource.NextUint32 (LockProxyPip1.sol#132-152) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
                    "message": "ZeroCopySource.NextUint64 (LockProxyPip1.sol#159-179) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextUint255 (LockProxyPip1.sol#187-208) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": 270,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
                    "message": "ZeroCopySource.NextVarBytes (LockProxyPip1.sol#215-270) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": 283,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextHash (LockProxyPip1.sol#276-283) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": 297,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
                    "message": "ZeroCopySource.NextBytes20 (LockProxyPip1.sol#290-297) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": 368,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteBool (LockProxyPip1.sol#351-368) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": 392,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint8 (LockProxyPip1.sol#382-392) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": 417,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint16 (LockProxyPip1.sol#398-417) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": 441,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint32 (LockProxyPip1.sol#423-441) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": 466,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint64 (LockProxyPip1.sol#447-466) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": 492,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint255 (LockProxyPip1.sol#472-492) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": 533,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
                    "message": "Utils.bytesToBytes32 (LockProxyPip1.sol#527-533) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": 546,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Utils.bytesToUint256 (LockProxyPip1.sol#539-546) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": 565,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
                    "message": "Utils.uint256ToBytes (LockProxyPip1.sol#552-565) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": 580,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
                    "message": "Utils.bytesToAddress (LockProxyPip1.sol#571-580) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": 598,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
                    "message": "Utils.addressToBytes (LockProxyPip1.sol#586-598) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": 693,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
                    "message": "Utils.equalStorage (LockProxyPip1.sol#623-693) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 702,
                    "vulnerability_to_line": 766,
                    "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
                    "message": "Utils.slice (LockProxyPip1.sol#702-766) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": 826,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "Utils.isContract (LockProxyPip1.sol#813-826) is declared view but contains assembly code\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": 1089,
                    "vulnerability_code": "    function delegateAsset(uint64 nativeChainId, bytes memory nativeLockProxy, bytes memory nativeAssetHash, uint256 delegatedSupply) public {\n\n        require(nativeChainId != 0, \"nativeChainId cannot be zero\");\n\n        require(nativeLockProxy.length != 0, \"empty nativeLockProxy\");\n\n        require(nativeAssetHash.length != 0, \"empty nativeAssetHash\");\n\n\n\n        address assetHash = _msgSender();\n\n        bytes32 key = _getRegistryKey(assetHash, nativeChainId, nativeLockProxy, nativeAssetHash);\n\n\n\n        require(registry[key] != true, \"asset already registered\");\n\n        require(balances[key] == 0, \"balance is not zero\");\n\n        require(_balanceFor(assetHash) == delegatedSupply, \"controlled balance does not match delegatedSupply\");\n\n\n\n        registry[key] = true;\n\n\n\n        RegisterAssetTxArgs memory txArgs = RegisterAssetTxArgs({\n\n            assetHash: Utils.addressToBytes(assetHash),\n\n            nativeAssetHash: nativeAssetHash\n\n        });\n\n\n\n        bytes memory txData = _serializeRegisterAssetTxArgs(txArgs);\n\n\n\n        IEthCrossChainManager eccm = _getEccm();\n\n        require(eccm.crossChain(nativeChainId, nativeLockProxy, \"registerAsset\", txData), \"EthCrossChainManager crossChain executed error!\");\n\n        balances[key] = delegatedSupply;\n\n\n\n        emit DelegateAssetEvent(assetHash, nativeChainId, nativeLockProxy, nativeAssetHash);\n",
                    "message": "Reentrancy in LockProxyPip1.delegateAsset (LockProxyPip1.sol#1063-1089):\n\tExternal calls:\n\t- require(bool,string)(_balanceFor(assetHash) == delegatedSupply,controlled balance does not match delegatedSupply) (LockProxyPip1.sol#1073)\n\tState variables written after the call(s):\n\t- registry (LockProxyPip1.sol#1075)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": 1089,
                    "vulnerability_code": "    function delegateAsset(uint64 nativeChainId, bytes memory nativeLockProxy, bytes memory nativeAssetHash, uint256 delegatedSupply) public {\n\n        require(nativeChainId != 0, \"nativeChainId cannot be zero\");\n\n        require(nativeLockProxy.length != 0, \"empty nativeLockProxy\");\n\n        require(nativeAssetHash.length != 0, \"empty nativeAssetHash\");\n\n\n\n        address assetHash = _msgSender();\n\n        bytes32 key = _getRegistryKey(assetHash, nativeChainId, nativeLockProxy, nativeAssetHash);\n\n\n\n        require(registry[key] != true, \"asset already registered\");\n\n        require(balances[key] == 0, \"balance is not zero\");\n\n        require(_balanceFor(assetHash) == delegatedSupply, \"controlled balance does not match delegatedSupply\");\n\n\n\n        registry[key] = true;\n\n\n\n        RegisterAssetTxArgs memory txArgs = RegisterAssetTxArgs({\n\n            assetHash: Utils.addressToBytes(assetHash),\n\n            nativeAssetHash: nativeAssetHash\n\n        });\n\n\n\n        bytes memory txData = _serializeRegisterAssetTxArgs(txArgs);\n\n\n\n        IEthCrossChainManager eccm = _getEccm();\n\n        require(eccm.crossChain(nativeChainId, nativeLockProxy, \"registerAsset\", txData), \"EthCrossChainManager crossChain executed error!\");\n\n        balances[key] = delegatedSupply;\n\n\n\n        emit DelegateAssetEvent(assetHash, nativeChainId, nativeLockProxy, nativeAssetHash);\n",
                    "message": "Reentrancy in LockProxyPip1.delegateAsset (LockProxyPip1.sol#1063-1089):\n\tExternal calls:\n\t- require(bool,string)(_balanceFor(assetHash) == delegatedSupply,controlled balance does not match delegatedSupply) (LockProxyPip1.sol#1073)\n\t- eccm = _getEccm() (LockProxyPip1.sol#1084)\n\t- require(bool,string)(eccm.crossChain(nativeChainId,nativeLockProxy,registerAsset,txData),EthCrossChainManager crossChain executed error!) (LockProxyPip1.sol#1085)\n\tState variables written after the call(s):\n\t- balances (LockProxyPip1.sol#1086)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1285,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RegisterAssetTxArgs memory args;\n",
                    "message": "args in LockProxyPip1._deserializeRegisterAssetTxArgs (LockProxyPip1.sol#1285) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        TxArgs memory args;\n",
                    "message": "args in LockProxyPip1._deserializeTxArgs (LockProxyPip1.sol#1293) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1111,
                    "vulnerability_to_line": 1165,
                    "vulnerability_code": "    function lock(\n\n        address fromAssetHash,\n\n        uint64 toChainId,\n\n        bytes memory targetProxyHash,\n\n        bytes memory toAssetHash,\n\n        bytes memory toAddress,\n\n        uint256 amount,\n\n        bool deductFeeInLock,\n\n        uint256 feeAmount,\n\n        bytes memory feeAddress\n\n    )\n\n        public\n\n        payable\n\n        returns (bool)\n\n    {\n\n        require(toChainId != 0, \"toChainId cannot be zero\");\n\n        require(targetProxyHash.length != 0, \"empty targetProxyHash\");\n\n        require(toAssetHash.length != 0, \"empty toAssetHash\");\n\n        require(toAddress.length != 0, \"empty toAddress\");\n\n        require(amount != 0, \"amount must be more than zero!\");\n\n\n\n        require(_transferToContract(fromAssetHash, amount), \"transfer asset from fromAddress to lock_proxy contract  failed!\");\n\n\n\n        bytes32 key = _getRegistryKey(fromAssetHash, toChainId, targetProxyHash, toAssetHash);\n\n        require(registry[key] == true, \"asset not registered\");\n\n\n\n        TxArgs memory txArgs = TxArgs({\n\n            fromAssetHash: Utils.addressToBytes(fromAssetHash),\n\n            toAssetHash: toAssetHash,\n\n            toAddress: toAddress,\n\n            amount: amount,\n\n            feeAmount: feeAmount,\n\n            feeAddress: feeAddress\n\n        });\n\n\n\n        if (feeAmount != 0 && deductFeeInLock) {\n\n            require(feeAddress.length != 0, \"empty fee address\");\n\n            uint256 afterFeeAmount = amount.sub(feeAmount);\n\n            require(_transferFromContract(fromAssetHash, Utils.bytesToAddress(feeAddress), feeAmount), \"transfer asset from lock_proxy contract to feeAddress failed!\");\n\n\n\n            // set feeAmount to zero as fee has already been transferred\n\n            txArgs.feeAmount = 0;\n\n            txArgs.amount = afterFeeAmount;\n\n        }\n\n\n\n        bytes memory txData = _serializeTxArgs(txArgs);\n\n        IEthCrossChainManager eccm = _getEccm();\n\n\n\n        require(eccm.crossChain(toChainId, targetProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\");\n\n        balances[key] = balances[key].add(txArgs.amount);\n\n\n\n        emit LockEvent(fromAssetHash, _msgSender(), toChainId, toAssetHash, toAddress, txData);\n\n\n\n        return true;\n",
                    "message": "Reentrancy in LockProxyPip1.lock (LockProxyPip1.sol#1111-1165):\n\tExternal calls:\n\t- require(bool,string)(_transferToContract(fromAssetHash,amount),transfer asset from fromAddress to lock_proxy contract  failed!) (LockProxyPip1.sol#1132)\n\t- require(bool,string)(_transferFromContract(fromAssetHash,Utils.bytesToAddress(feeAddress),feeAmount),transfer asset from lock_proxy contract to feeAddress failed!) (LockProxyPip1.sol#1149)\n\t- eccm = _getEccm() (LockProxyPip1.sol#1157)\n\t- require(bool,string)(eccm.crossChain(toChainId,targetProxyHash,unlock,txData),EthCrossChainManager crossChain executed error!) (LockProxyPip1.sol#1159)\n\tExternal calls sending eth:\n\t- require(bool,string)(_transferFromContract(fromAssetHash,Utils.bytesToAddress(feeAddress),feeAmount),transfer asset from lock_proxy contract to feeAddress failed!) (LockProxyPip1.sol#1149)\n\tState variables written after the call(s):\n\t- balances (LockProxyPip1.sol#1160)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
                    "message": "ZeroCopySource.NextBool uses assembly (LockProxyPip1.sol#56-72)\n\t- LockProxyPip1.sol#60-62\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": 86,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextByte uses assembly (LockProxyPip1.sol#79-86)\n\t- LockProxyPip1.sol#82-84\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": 104,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextUint8 uses assembly (LockProxyPip1.sol#93-104)\n\t- LockProxyPip1.sol#96-102\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": 124,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
                    "message": "ZeroCopySource.NextUint16 uses assembly (LockProxyPip1.sol#111-124)\n\t- LockProxyPip1.sol#115-122\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
                    "message": "ZeroCopySource.NextUint32 uses assembly (LockProxyPip1.sol#132-152)\n\t- LockProxyPip1.sol#135-150\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
                    "message": "ZeroCopySource.NextUint64 uses assembly (LockProxyPip1.sol#159-179)\n\t- LockProxyPip1.sol#162-177\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextUint255 uses assembly (LockProxyPip1.sol#187-208)\n\t- LockProxyPip1.sol#190-205\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": 270,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
                    "message": "ZeroCopySource.NextVarBytes uses assembly (LockProxyPip1.sol#215-270)\n\t- LockProxyPip1.sol#220-267\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": 283,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextHash uses assembly (LockProxyPip1.sol#276-283)\n\t- LockProxyPip1.sol#279-281\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": 297,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
                    "message": "ZeroCopySource.NextBytes20 uses assembly (LockProxyPip1.sol#290-297)\n\t- LockProxyPip1.sol#293-295\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": 368,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteBool uses assembly (LockProxyPip1.sol#351-368)\n\t- LockProxyPip1.sol#353-366\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": 392,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint8 uses assembly (LockProxyPip1.sol#382-392)\n\t- LockProxyPip1.sol#384-390\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": 417,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint16 uses assembly (LockProxyPip1.sol#398-417)\n\t- LockProxyPip1.sol#401-415\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": 441,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint32 uses assembly (LockProxyPip1.sol#423-441)\n\t- LockProxyPip1.sol#425-439\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": 466,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint64 uses assembly (LockProxyPip1.sol#447-466)\n\t- LockProxyPip1.sol#450-464\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": 492,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint255 uses assembly (LockProxyPip1.sol#472-492)\n\t- LockProxyPip1.sol#476-490\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": 533,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
                    "message": "Utils.bytesToBytes32 uses assembly (LockProxyPip1.sol#527-533)\n\t- LockProxyPip1.sol#529-532\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": 546,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Utils.bytesToUint256 uses assembly (LockProxyPip1.sol#539-546)\n\t- LockProxyPip1.sol#541-544\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": 565,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
                    "message": "Utils.uint256ToBytes uses assembly (LockProxyPip1.sol#552-565)\n\t- LockProxyPip1.sol#554-564\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": 580,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
                    "message": "Utils.bytesToAddress uses assembly (LockProxyPip1.sol#571-580)\n\t- LockProxyPip1.sol#574-578\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": 598,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
                    "message": "Utils.addressToBytes uses assembly (LockProxyPip1.sol#586-598)\n\t- LockProxyPip1.sol#587-597\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": 693,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
                    "message": "Utils.equalStorage uses assembly (LockProxyPip1.sol#623-693)\n\t- LockProxyPip1.sol#626-690\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 702,
                    "vulnerability_to_line": 766,
                    "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
                    "message": "Utils.slice uses assembly (LockProxyPip1.sol#702-766)\n\t- LockProxyPip1.sol#715-763\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": 826,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "Utils.isContract uses assembly (LockProxyPip1.sol#813-826)\n\t- LockProxyPip1.sol#824\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": 1089,
                    "vulnerability_code": "    function delegateAsset(uint64 nativeChainId, bytes memory nativeLockProxy, bytes memory nativeAssetHash, uint256 delegatedSupply) public {\n\n        require(nativeChainId != 0, \"nativeChainId cannot be zero\");\n\n        require(nativeLockProxy.length != 0, \"empty nativeLockProxy\");\n\n        require(nativeAssetHash.length != 0, \"empty nativeAssetHash\");\n\n\n\n        address assetHash = _msgSender();\n\n        bytes32 key = _getRegistryKey(assetHash, nativeChainId, nativeLockProxy, nativeAssetHash);\n\n\n\n        require(registry[key] != true, \"asset already registered\");\n\n        require(balances[key] == 0, \"balance is not zero\");\n\n        require(_balanceFor(assetHash) == delegatedSupply, \"controlled balance does not match delegatedSupply\");\n\n\n\n        registry[key] = true;\n\n\n\n        RegisterAssetTxArgs memory txArgs = RegisterAssetTxArgs({\n\n            assetHash: Utils.addressToBytes(assetHash),\n\n            nativeAssetHash: nativeAssetHash\n\n        });\n\n\n\n        bytes memory txData = _serializeRegisterAssetTxArgs(txArgs);\n\n\n\n        IEthCrossChainManager eccm = _getEccm();\n\n        require(eccm.crossChain(nativeChainId, nativeLockProxy, \"registerAsset\", txData), \"EthCrossChainManager crossChain executed error!\");\n\n        balances[key] = delegatedSupply;\n\n\n\n        emit DelegateAssetEvent(assetHash, nativeChainId, nativeLockProxy, nativeAssetHash);\n",
                    "message": "LockProxyPip1.delegateAsset (LockProxyPip1.sol#1063-1089) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1100,
                    "vulnerability_code": "    function registerAsset(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) onlyManagerContract public returns (bool) {\n\n        RegisterAssetTxArgs memory args = _deserializeRegisterAssetTxArgs(argsBs);\n\n\n\n        bytes32 key = _getRegistryKey(Utils.bytesToAddress(args.nativeAssetHash), fromChainId, fromContractAddr, args.assetHash);\n\n\n\n        require(registry[key] != true, \"asset already registerd\");\n\n        registry[key] = true;\n\n\n\n        return true;\n",
                    "message": "LockProxyPip1.registerAsset (LockProxyPip1.sol#1091-1100) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1111,
                    "vulnerability_to_line": 1165,
                    "vulnerability_code": "    function lock(\n\n        address fromAssetHash,\n\n        uint64 toChainId,\n\n        bytes memory targetProxyHash,\n\n        bytes memory toAssetHash,\n\n        bytes memory toAddress,\n\n        uint256 amount,\n\n        bool deductFeeInLock,\n\n        uint256 feeAmount,\n\n        bytes memory feeAddress\n\n    )\n\n        public\n\n        payable\n\n        returns (bool)\n\n    {\n\n        require(toChainId != 0, \"toChainId cannot be zero\");\n\n        require(targetProxyHash.length != 0, \"empty targetProxyHash\");\n\n        require(toAssetHash.length != 0, \"empty toAssetHash\");\n\n        require(toAddress.length != 0, \"empty toAddress\");\n\n        require(amount != 0, \"amount must be more than zero!\");\n\n\n\n        require(_transferToContract(fromAssetHash, amount), \"transfer asset from fromAddress to lock_proxy contract  failed!\");\n\n\n\n        bytes32 key = _getRegistryKey(fromAssetHash, toChainId, targetProxyHash, toAssetHash);\n\n        require(registry[key] == true, \"asset not registered\");\n\n\n\n        TxArgs memory txArgs = TxArgs({\n\n            fromAssetHash: Utils.addressToBytes(fromAssetHash),\n\n            toAssetHash: toAssetHash,\n\n            toAddress: toAddress,\n\n            amount: amount,\n\n            feeAmount: feeAmount,\n\n            feeAddress: feeAddress\n\n        });\n\n\n\n        if (feeAmount != 0 && deductFeeInLock) {\n\n            require(feeAddress.length != 0, \"empty fee address\");\n\n            uint256 afterFeeAmount = amount.sub(feeAmount);\n\n            require(_transferFromContract(fromAssetHash, Utils.bytesToAddress(feeAddress), feeAmount), \"transfer asset from lock_proxy contract to feeAddress failed!\");\n\n\n\n            // set feeAmount to zero as fee has already been transferred\n\n            txArgs.feeAmount = 0;\n\n            txArgs.amount = afterFeeAmount;\n\n        }\n\n\n\n        bytes memory txData = _serializeTxArgs(txArgs);\n\n        IEthCrossChainManager eccm = _getEccm();\n\n\n\n        require(eccm.crossChain(toChainId, targetProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\");\n\n        balances[key] = balances[key].add(txArgs.amount);\n\n\n\n        emit LockEvent(fromAssetHash, _msgSender(), toChainId, toAssetHash, toAddress, txData);\n\n\n\n        return true;\n",
                    "message": "LockProxyPip1.lock (LockProxyPip1.sol#1111-1165) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1175,
                    "vulnerability_to_line": 1201,
                    "vulnerability_code": "    function unlock(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) onlyManagerContract public returns (bool) {\n\n        TxArgs memory args = _deserializeTxArgs(argsBs);\n\n        address toAssetHash = Utils.bytesToAddress(args.toAssetHash);\n\n        address toAddress = Utils.bytesToAddress(args.toAddress);\n\n\n\n        bytes32 key = _getRegistryKey(toAssetHash, fromChainId, fromContractAddr, args.fromAssetHash);\n\n\n\n        require(registry[key] == true, \"asset not registered\");\n\n        require(balances[key] >= args.amount, \"insufficient balance in registry\");\n\n\n\n        balances[key] = balances[key].sub(args.amount);\n\n\n\n        uint256 afterFeeAmount = args.amount;\n\n        if (args.feeAmount != 0) {\n\n            afterFeeAmount = args.amount.sub(args.feeAmount);\n\n            address feeAddress = Utils.bytesToAddress(args.feeAddress);\n\n\n\n            // transfer feeAmount to feeAddress\n\n            require(_transferFromContract(toAssetHash, feeAddress, args.feeAmount), \"transfer asset from lock_proxy contract to feeAddress failed!\");\n\n            emit UnlockEvent(toAssetHash, feeAddress, args.feeAmount);\n\n        }\n\n\n\n        require(_transferFromContract(toAssetHash, toAddress, afterFeeAmount), \"transfer asset from lock_proxy contract to toAddress failed!\");\n\n\n\n        emit UnlockEvent(toAssetHash, toAddress, args.amount);\n\n        return true;\n",
                    "message": "LockProxyPip1.unlock (LockProxyPip1.sol#1175-1201) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in LockProxyPip1.sol:\n\t- pragma solidity^0.5.0 (LockProxyPip1.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxyPip1.sol#34): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxyPip1.sol#330): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxyPip1.sol#518): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxyPip1.sol#831): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxyPip1.sol#990): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxyPip1.sol#1001): it allows old versions\n\t- pragma solidity^0.5.0 (LockProxyPip1.sol#1012): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 24,
                    "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
                    "message": "Function 'Context._msgSender' (LockProxyPip1.sol#22-24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": 29,
                    "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
                    "message": "Function 'Context._msgData' (LockProxyPip1.sol#26-29) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
                    "message": "Function 'ZeroCopySource.NextBool' (LockProxyPip1.sol#56-72) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": 86,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "Function 'ZeroCopySource.NextByte' (LockProxyPip1.sol#79-86) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": 104,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "Function 'ZeroCopySource.NextUint8' (LockProxyPip1.sol#93-104) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": 124,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
                    "message": "Function 'ZeroCopySource.NextUint16' (LockProxyPip1.sol#111-124) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
                    "message": "Function 'ZeroCopySource.NextUint32' (LockProxyPip1.sol#132-152) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
                    "message": "Function 'ZeroCopySource.NextUint64' (LockProxyPip1.sol#159-179) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
                    "message": "Function 'ZeroCopySource.NextUint255' (LockProxyPip1.sol#187-208) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": 270,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
                    "message": "Function 'ZeroCopySource.NextVarBytes' (LockProxyPip1.sol#215-270) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": 283,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
                    "message": "Function 'ZeroCopySource.NextHash' (LockProxyPip1.sol#276-283) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": 297,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
                    "message": "Function 'ZeroCopySource.NextBytes20' (LockProxyPip1.sol#290-297) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\n\n        byte v;\n\n        (v, offset) = NextByte(buff, offset);\n\n\n\n        uint value;\n\n        if (v == 0xFD) {\n\n            // return NextUint16(buff, offset);\n\n            (value, offset) = NextUint16(buff, offset);\n\n            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n\n            return (value, offset);\n\n        } else if (v == 0xFE) {\n\n            // return NextUint32(buff, offset);\n\n            (value, offset) = NextUint32(buff, offset);\n\n            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        } else if (v == 0xFF) {\n\n            // return NextUint64(buff, offset);\n\n            (value, offset) = NextUint64(buff, offset);\n\n            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        } else{\n\n            // return (uint8(v), offset);\n\n            value = uint8(v);\n\n            require(value < 0xFD, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        }\n",
                    "message": "Function 'ZeroCopySource.NextVarUint' (LockProxyPip1.sol#299-325) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": 368,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteBool' (LockProxyPip1.sol#351-368) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": 376,
                    "vulnerability_code": "    function WriteByte(byte b) internal pure returns (bytes memory) {\n\n        return WriteUint8(uint8(b));\n",
                    "message": "Function 'ZeroCopySink.WriteByte' (LockProxyPip1.sol#374-376) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": 392,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint8' (LockProxyPip1.sol#382-392) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": 417,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint16' (LockProxyPip1.sol#398-417) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": 441,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint32' (LockProxyPip1.sol#423-441) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": 466,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint64' (LockProxyPip1.sol#447-466) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": 492,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint255' (LockProxyPip1.sol#472-492) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": 501,
                    "vulnerability_code": "    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {\n\n        uint64 l = uint64(data.length);\n\n        return abi.encodePacked(WriteVarUint(l), data);\n",
                    "message": "Function 'ZeroCopySink.WriteVarBytes' (LockProxyPip1.sol#498-501) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": 513,
                    "vulnerability_code": "    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {\n\n        if (v < 0xFD){\n\n    \t\treturn WriteUint8(uint8(v));\n\n    \t} else if (v <= 0xFFFF) {\n\n    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n\n    \t} else if (v <= 0xFFFFFFFF) {\n\n            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n\n    \t} else {\n\n    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n\n    \t}\n",
                    "message": "Function 'ZeroCopySink.WriteVarUint' (LockProxyPip1.sol#503-513) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": "Parameter '_bs' of Utils.bytesToBytes32 (LockProxyPip1.sol#527) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
                    "message": "Parameter '_bs' of Utils.bytesToUint256 (LockProxyPip1.sol#539) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": "Parameter '_value' of Utils.uint256ToBytes (LockProxyPip1.sol#552) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": "Parameter '_bs' of Utils.bytesToAddress (LockProxyPip1.sol#571) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_data' of Utils.hashLeaf (LockProxyPip1.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 613,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_l' of Utils.hashChildren (LockProxyPip1.sol#613) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 613,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_r' of Utils.hashChildren (LockProxyPip1.sol#613) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 703,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory _bytes,\n",
                    "message": "Parameter '_bytes' of Utils.slice (LockProxyPip1.sol#703) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 704,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint _start,\n",
                    "message": "Parameter '_start' of Utils.slice (LockProxyPip1.sol#704) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 705,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint _length\n",
                    "message": "Parameter '_length' of Utils.slice (LockProxyPip1.sol#705) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 773,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_keepers' of Utils.containMAddresses (LockProxyPip1.sol#773) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 773,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_signers' of Utils.containMAddresses (LockProxyPip1.sol#773) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 773,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_m' of Utils.containMAddresses (LockProxyPip1.sol#773) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1203,
                    "vulnerability_to_line": 1212,
                    "vulnerability_code": "    function _balanceFor(address fromAssetHash) public view returns (uint256) {\n\n        if (fromAssetHash == address(0)) {\n\n            // return address(this).balance; // this expression would result in error: Failed to decode output: Error: insufficient data for uint256 type\n\n            address selfAddr = address(this);\n\n            return selfAddr.balance;\n\n        } else {\n\n            ERC20Interface erc20Token = ERC20Interface(fromAssetHash);\n\n            return erc20Token.balanceOf(address(this));\n\n        }\n",
                    "message": "Function 'LockProxyPip1._balanceFor' (LockProxyPip1.sol#1203-1212) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1213,
                    "vulnerability_to_line": 1218,
                    "vulnerability_code": "    function _getEccm() internal view returns (IEthCrossChainManager) {\n\n      IEthCrossChainManagerProxy eccmp = IEthCrossChainManagerProxy(managerProxyContract);\n\n      address eccmAddr = eccmp.getEthCrossChainManager();\n\n      IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr);\n\n      return eccm;\n",
                    "message": "Function 'LockProxyPip1._getEccm' (LockProxyPip1.sol#1213-1218) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1219,
                    "vulnerability_to_line": 1226,
                    "vulnerability_code": "    function _getRegistryKey(address assetHash, uint64 nativeChainId, bytes memory nativeLockProxy, bytes memory nativeAssetHash) internal pure returns (bytes32) {\n\n        return keccak256(abi.encodePacked(\n\n            assetHash,\n\n            nativeChainId,\n\n            nativeLockProxy,\n\n            nativeAssetHash\n\n        ));\n",
                    "message": "Function 'LockProxyPip1._getRegistryKey' (LockProxyPip1.sol#1219-1226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1227,
                    "vulnerability_to_line": 1237,
                    "vulnerability_code": "    function _transferToContract(address fromAssetHash, uint256 amount) internal returns (bool) {\n\n        if (fromAssetHash == address(0)) {\n\n            // fromAssetHash === address(0) denotes user choose to lock ether\n\n            // passively check if the received msg.value equals amount\n\n            require(msg.value == amount, \"transferred ether is not equal to amount!\");\n\n        } else {\n\n            // actively transfer amount of asset from msg.sender to lock_proxy contract\n\n            require(_transferERC20ToContract(fromAssetHash, _msgSender(), address(this), amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n\n        }\n\n        return true;\n",
                    "message": "Function 'LockProxyPip1._transferToContract' (LockProxyPip1.sol#1227-1237) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1238,
                    "vulnerability_to_line": 1248,
                    "vulnerability_code": "    function _transferFromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {\n\n        if (toAssetHash == address(0x0000000000000000000000000000000000000000)) {\n\n            // toAssetHash === address(0) denotes contract needs to unlock ether to toAddress\n\n            // convert toAddress from 'address' type to 'address payable' type, then actively transfer ether\n\n            address(uint160(toAddress)).transfer(amount);\n\n        } else {\n\n            // actively transfer amount of asset from msg.sender to lock_proxy contract\n\n            require(_transferERC20FromContract(toAssetHash, toAddress, amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n\n        }\n\n        return true;\n",
                    "message": "Function 'LockProxyPip1._transferFromContract' (LockProxyPip1.sol#1238-1248) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1251,
                    "vulnerability_to_line": 1255,
                    "vulnerability_code": "    function _transferERC20ToContract(address fromAssetHash, address fromAddress, address toAddress, uint256 amount) internal returns (bool) {\n\n         ERC20Interface erc20Token = ERC20Interface(fromAssetHash);\n\n         require(erc20Token.transferFrom(fromAddress, toAddress, amount), \"trasnfer ERC20 Token failed!\");\n\n         return true;\n",
                    "message": "Function 'LockProxyPip1._transferERC20ToContract' (LockProxyPip1.sol#1251-1255) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1256,
                    "vulnerability_to_line": 1260,
                    "vulnerability_code": "    function _transferERC20FromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {\n\n         ERC20Interface erc20Token = ERC20Interface(toAssetHash);\n\n         require(erc20Token.transfer(toAddress, amount), \"trasnfer ERC20 Token failed!\");\n\n         return true;\n",
                    "message": "Function 'LockProxyPip1._transferERC20FromContract' (LockProxyPip1.sol#1256-1260) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": 1273,
                    "vulnerability_code": "    function _serializeTxArgs(TxArgs memory args) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        buff = abi.encodePacked(\n\n            ZeroCopySink.WriteVarBytes(args.fromAssetHash),\n\n            ZeroCopySink.WriteVarBytes(args.toAssetHash),\n\n            ZeroCopySink.WriteVarBytes(args.toAddress),\n\n            ZeroCopySink.WriteUint255(args.amount),\n\n            ZeroCopySink.WriteUint255(args.feeAmount),\n\n            ZeroCopySink.WriteVarBytes(args.feeAddress)\n\n        );\n\n        return buff;\n",
                    "message": "Function 'LockProxyPip1._serializeTxArgs' (LockProxyPip1.sol#1262-1273) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1275,
                    "vulnerability_to_line": 1282,
                    "vulnerability_code": "    function _serializeRegisterAssetTxArgs(RegisterAssetTxArgs memory args) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        buff = abi.encodePacked(\n\n            ZeroCopySink.WriteVarBytes(args.assetHash),\n\n            ZeroCopySink.WriteVarBytes(args.nativeAssetHash)\n\n        );\n\n        return buff;\n",
                    "message": "Function 'LockProxyPip1._serializeRegisterAssetTxArgs' (LockProxyPip1.sol#1275-1282) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": 1290,
                    "vulnerability_code": "    function _deserializeRegisterAssetTxArgs(bytes memory valueBs) internal pure returns (RegisterAssetTxArgs memory) {\n\n        RegisterAssetTxArgs memory args;\n\n        uint256 off = 0;\n\n        (args.assetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n\n        (args.nativeAssetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n\n        return args;\n",
                    "message": "Function 'LockProxyPip1._deserializeRegisterAssetTxArgs' (LockProxyPip1.sol#1284-1290) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1292,
                    "vulnerability_to_line": 1302,
                    "vulnerability_code": "    function _deserializeTxArgs(bytes memory valueBs) internal pure returns (TxArgs memory) {\n\n        TxArgs memory args;\n\n        uint256 off = 0;\n\n        (args.fromAssetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n\n        (args.toAssetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n\n        (args.toAddress, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n\n        (args.amount, off) = ZeroCopySource.NextUint255(valueBs, off);\n\n        (args.feeAmount, off) = ZeroCopySource.NextUint255(valueBs, off);\n\n        (args.feeAddress, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n\n        return args;\n",
                    "message": "Function 'LockProxyPip1._deserializeTxArgs' (LockProxyPip1.sol#1292-1302) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (toAssetHash == address(0x0000000000000000000000000000000000000000)) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v == 0x01) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v == 0x00) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v == 0xFD) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (v == 0xFE) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (v == 0xFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value < 0xFD, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v < 0xFD){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v <= 0xFFFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 507,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 508,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v <= 0xFFFFFFFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 794,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "             newkey[2] = byte(0x02);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 796,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "             newkey[2] = byte(0x03);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        result = sha256(abi.encodePacked(byte(0x0), _data));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 775,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 775,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 831,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 990,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1012,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v == 0x00) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 1027,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 702,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function slice(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 476,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 587,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 715,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 824,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { codehash := extcodehash(account) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 996,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 996,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 996,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 996,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 996,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 996,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/core/cross_chain_manager/interface/IEthCrossChainData.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in IEthCrossChainData.sol:\n\t- pragma solidity^0.5.0 (IEthCrossChainData.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/core/cross_chain_manager/interface/IEthCrossChainManager.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in IEthCrossChainManager.sol:\n\t- pragma solidity^0.5.0 (IEthCrossChainManager.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/core/cross_chain_manager/interface/IEthCrossChainManagerProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in IEthCrossChainManagerProxy.sol:\n\t- pragma solidity^0.5.0 (IEthCrossChainManagerProxy.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/core/cross_chain_manager/interface/IUpgradableECCM.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in IUpgradableECCM.sol:\n\t- pragma solidity^0.5.0 (IUpgradableECCM.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeToNew(address) external returns (bool);\n",
                    "message": "Parameter '' of IUpgradableECCM.upgradeToNew (IUpgradableECCM.sol#12) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/core/cross_chain_manager/upgrade/UpgradableECCM.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract UpgradableECCM is IUpgradableECCM, Ownable, Pausable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _paused = false;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address msgSender = _msgSender();\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = msgSender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit OwnershipTransferred(address(0), msgSender);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (address ethCrossChainDataAddr, uint64 _chainId) Pausable() Ownable()  public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EthCrossChainDataAddress = ethCrossChainDataAddr;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        chainId = _chainId;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_paused, \"Pausable: paused\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_paused, \"Pausable: not paused\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isOwner(), \"Ownable: caller is not the owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(eccd.pause(), \"pause EthCrossChainData contract failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(eccd.unpause(), \"unpause EthCrossChainData contract failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(eccd.pause(), \"pause EthCrossChainData contract failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(eccd.unpause(), \"unpause EthCrossChainData contract failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_21"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "    function owner() public view returns (address) {\n\n        return _owner;\n",
                    "message": "Ownable.owner (UpgradableECCM.sol#177-179) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 206,
                    "vulnerability_code": "    function renounceOwnership() public onlyOwner {\n\n        emit OwnershipTransferred(_owner, address(0));\n\n        _owner = address(0);\n",
                    "message": "Ownable.renounceOwnership (UpgradableECCM.sol#203-206) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": 214,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public  onlyOwner {\n\n        _transferOwnership(newOwner);\n",
                    "message": "Ownable.transferOwnership (UpgradableECCM.sol#212-214) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": 250,
                    "vulnerability_code": "    function pause() onlyOwner public returns (bool) {\n\n        if (!paused()) {\n\n            _pause();\n\n        }\n\n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n\n        if (!eccd.paused()) {\n\n            require(eccd.pause(), \"pause EthCrossChainData contract failed\");\n\n        }\n\n        return true;\n",
                    "message": "UpgradableECCM.pause (UpgradableECCM.sol#241-250) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function pause() external returns (bool);\n",
                    "message": "IUpgradableECCM.pause (UpgradableECCM.sol#35) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": 261,
                    "vulnerability_code": "    function unpause() onlyOwner public returns (bool) {\n\n        if (paused()) {\n\n            _unpause();\n\n        }\n\n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n\n        if (eccd.paused()) {\n\n            require(eccd.unpause(), \"unpause EthCrossChainData contract failed\");\n\n        }\n\n        return true;\n",
                    "message": "UpgradableECCM.unpause (UpgradableECCM.sol#252-261) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function unpause() external returns (bool);\n",
                    "message": "IUpgradableECCM.unpause (UpgradableECCM.sol#36) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeToNew(address) external returns (bool);\n",
                    "message": "IUpgradableECCM.upgradeToNew (UpgradableECCM.sol#38) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": 268,
                    "vulnerability_code": "    function upgradeToNew(address newEthCrossChainManagerAddress) whenPaused onlyOwner public returns (bool) {\n\n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n\n        eccd.transferOwnership(newEthCrossChainManagerAddress);\n\n        return true;\n",
                    "message": "UpgradableECCM.upgradeToNew (UpgradableECCM.sol#264-268) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": 273,
                    "vulnerability_code": "    function setChainId(uint64 _newChainId) whenPaused onlyOwner public returns (bool) {\n\n        chainId = _newChainId;\n\n        return true;\n",
                    "message": "UpgradableECCM.setChainId (UpgradableECCM.sol#270-273) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setChainId(uint64 _newChainId) external returns (bool);\n",
                    "message": "IUpgradableECCM.setChainId (UpgradableECCM.sol#40) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in UpgradableECCM.sol:\n\t- pragma solidity^0.5.0 (UpgradableECCM.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (UpgradableECCM.sol#29): it allows old versions\n\t- pragma solidity^0.5.0 (UpgradableECCM.sol#45): it allows old versions\n\t- pragma solidity^0.5.0 (UpgradableECCM.sol#76): it allows old versions\n\t- pragma solidity^0.5.0 (UpgradableECCM.sol#149): it allows old versions\n\t- pragma solidity^0.5.0 (UpgradableECCM.sol#228): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeToNew(address) external returns (bool);\n",
                    "message": "Parameter '' of IUpgradableECCM.upgradeToNew (UpgradableECCM.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": 66,
                    "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
                    "message": "Function 'Context._msgSender' (UpgradableECCM.sol#64-66) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
                    "message": "Function 'Context._msgData' (UpgradableECCM.sol#68-71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": 136,
                    "vulnerability_code": "    function _pause() internal whenNotPaused {\n\n        _paused = true;\n\n        emit Paused(_msgSender());\n",
                    "message": "Function 'Pausable._pause' (UpgradableECCM.sol#133-136) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": 144,
                    "vulnerability_code": "    function _unpause() internal whenPaused {\n\n        _paused = false;\n\n        emit Unpaused(_msgSender());\n",
                    "message": "Function 'Pausable._unpause' (UpgradableECCM.sol#141-144) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": 223,
                    "vulnerability_code": "    function _transferOwnership(address newOwner) internal {\n\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\n        emit OwnershipTransferred(_owner, newOwner);\n\n        _owner = newOwner;\n",
                    "message": "Function 'Ownable._transferOwnership' (UpgradableECCM.sol#219-223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setChainId(uint64 _newChainId) whenPaused onlyOwner public returns (bool) {\n",
                    "message": "Parameter '_newChainId' of UpgradableECCM.setChainId (UpgradableECCM.sol#270) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (address ethCrossChainDataAddr, uint64 _chainId) Pausable() Ownable()  public {\n",
                    "message": "Parameter '_chainId' of UpgradableECCM. (UpgradableECCM.sol#237) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public EthCrossChainDataAddress;\n",
                    "message": "Variable 'UpgradableECCM.EthCrossChainDataAddress' (UpgradableECCM.sol#234) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setChainId(uint64 _newChainId) whenPaused onlyOwner public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _paused;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _owner;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/core/cross_chain_manager/upgrade/EthCrossChainManagerProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract EthCrossChainManagerProxy is IEthCrossChainManagerProxy, Ownable, Pausable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address msgSender = _msgSender();\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = msgSender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit OwnershipTransferred(address(0), msgSender);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _paused = false;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ethCrossChainManagerAddr) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EthCrossChainManagerAddr_ = _ethCrossChainManagerAddr;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isOwner(), \"Ownable: caller is not the owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_paused, \"Pausable: paused\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_paused, \"Pausable: not paused\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(pause(), \"pause EthCrossChainManagerProxy contract failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(eccm.pause(), \"pause EthCrossChainManager contract failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(eccm.pause(), \"Pause old EthCrossChainManager contract failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(eccm.upgradeToNew(_newEthCrossChainManagerAddr), \"EthCrossChainManager upgradeToNew failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(neweccm.isOwner(), \"EthCrossChainManagerProxy is not owner of new EthCrossChainManager contract\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(eccm.unpause(), \"unpause EthCrossChainManager contract failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(unpause(), \"unpause EthCrossChainManagerProxy contract failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(eccm.pause(), \"Pause old EthCrossChainManager contract failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(eccm.setChainId(_newChainId), \"set chain ID failed. \");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(pause(), \"pause EthCrossChainManagerProxy contract failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(eccm.pause(), \"pause EthCrossChainManager contract failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(eccm.pause(), \"Pause old EthCrossChainManager contract failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(eccm.upgradeToNew(_newEthCrossChainManagerAddr), \"EthCrossChainManager upgradeToNew failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(neweccm.isOwner(), \"EthCrossChainManagerProxy is not owner of new EthCrossChainManager contract\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(eccm.unpause(), \"unpause EthCrossChainManager contract failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(unpause(), \"unpause EthCrossChainManagerProxy contract failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(eccm.pause(), \"Pause old EthCrossChainManager contract failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_22"
            ],
            "vulnerability_findings": [
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": 253,
                    "vulnerability_code": "    function upgradeEthCrossChainManager(address _newEthCrossChainManagerAddr) onlyOwner whenPaused public returns (bool) {\n\n        IUpgradableECCM eccm = IUpgradableECCM(EthCrossChainManagerAddr_);\n\n        if (!eccm.paused()) {\n\n            require(eccm.pause(), \"Pause old EthCrossChainManager contract failed!\");\n\n        }\n\n        require(eccm.upgradeToNew(_newEthCrossChainManagerAddr), \"EthCrossChainManager upgradeToNew failed!\");\n\n        IUpgradableECCM neweccm = IUpgradableECCM(_newEthCrossChainManagerAddr);\n\n        require(neweccm.isOwner(), \"EthCrossChainManagerProxy is not owner of new EthCrossChainManager contract\");\n\n        EthCrossChainManagerAddr_ = _newEthCrossChainManagerAddr;\n",
                    "message": "Reentrancy in EthCrossChainManagerProxy.upgradeEthCrossChainManager (EthCrossChainManagerProxy.sol#244-253):\n\tExternal calls:\n\t- ! eccm.paused() (EthCrossChainManagerProxy.sol#246-248)\n\t- require(bool,string)(eccm.pause(),Pause old EthCrossChainManager contract failed!) (EthCrossChainManagerProxy.sol#247)\n\t- require(bool,string)(eccm.upgradeToNew(_newEthCrossChainManagerAddr),EthCrossChainManager upgradeToNew failed!) (EthCrossChainManagerProxy.sol#249)\n\t- require(bool,string)(neweccm.isOwner(),EthCrossChainManagerProxy is not owner of new EthCrossChainManager contract) (EthCrossChainManagerProxy.sol#251)\n\tState variables written after the call(s):\n\t- EthCrossChainManagerAddr_ (EthCrossChainManagerProxy.sol#252)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": 258,
                    "vulnerability_code": "    function unpauseEthCrossChainManager() onlyOwner whenPaused public returns (bool) {\n\n        IUpgradableECCM eccm = IUpgradableECCM(EthCrossChainManagerAddr_);\n\n        require(eccm.unpause(), \"unpause EthCrossChainManager contract failed!\");\n\n        require(unpause(), \"unpause EthCrossChainManagerProxy contract failed!\");\n",
                    "message": "Reentrancy in EthCrossChainManagerProxy.unpauseEthCrossChainManager (EthCrossChainManagerProxy.sol#254-258):\n\tExternal calls:\n\t- require(bool,string)(eccm.unpause(),unpause EthCrossChainManager contract failed!) (EthCrossChainManagerProxy.sol#256)\n\tState variables written after the call(s):\n\t- _paused (EthCrossChainManagerProxy.sol#257)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function owner() public view returns (address) {\n\n        return _owner;\n",
                    "message": "Ownable.owner (EthCrossChainManagerProxy.sol#62-64) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": 91,
                    "vulnerability_code": "    function renounceOwnership() public onlyOwner {\n\n        emit OwnershipTransferred(_owner, address(0));\n\n        _owner = address(0);\n",
                    "message": "Ownable.renounceOwnership (EthCrossChainManagerProxy.sol#88-91) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": 99,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public  onlyOwner {\n\n        _transferOwnership(newOwner);\n",
                    "message": "Ownable.transferOwnership (EthCrossChainManagerProxy.sol#97-99) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getEthCrossChainManager() external view returns (address);\n",
                    "message": "IEthCrossChainManagerProxy.getEthCrossChainManager (EthCrossChainManagerProxy.sol#208) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": 261,
                    "vulnerability_code": "    function getEthCrossChainManager() whenNotPaused public view returns (address) {\n\n        return EthCrossChainManagerAddr_;\n",
                    "message": "EthCrossChainManagerProxy.getEthCrossChainManager (EthCrossChainManagerProxy.sol#259-261) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function pauseEthCrossChainManager() onlyOwner whenNotPaused public returns (bool) {\n\n        IUpgradableECCM eccm = IUpgradableECCM(EthCrossChainManagerAddr_);\n\n        require(pause(), \"pause EthCrossChainManagerProxy contract failed!\");\n\n        require(eccm.pause(), \"pause EthCrossChainManager contract failed!\");\n",
                    "message": "EthCrossChainManagerProxy.pauseEthCrossChainManager (EthCrossChainManagerProxy.sol#239-243) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": 253,
                    "vulnerability_code": "    function upgradeEthCrossChainManager(address _newEthCrossChainManagerAddr) onlyOwner whenPaused public returns (bool) {\n\n        IUpgradableECCM eccm = IUpgradableECCM(EthCrossChainManagerAddr_);\n\n        if (!eccm.paused()) {\n\n            require(eccm.pause(), \"Pause old EthCrossChainManager contract failed!\");\n\n        }\n\n        require(eccm.upgradeToNew(_newEthCrossChainManagerAddr), \"EthCrossChainManager upgradeToNew failed!\");\n\n        IUpgradableECCM neweccm = IUpgradableECCM(_newEthCrossChainManagerAddr);\n\n        require(neweccm.isOwner(), \"EthCrossChainManagerProxy is not owner of new EthCrossChainManager contract\");\n\n        EthCrossChainManagerAddr_ = _newEthCrossChainManagerAddr;\n",
                    "message": "EthCrossChainManagerProxy.upgradeEthCrossChainManager (EthCrossChainManagerProxy.sol#244-253) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": 258,
                    "vulnerability_code": "    function unpauseEthCrossChainManager() onlyOwner whenPaused public returns (bool) {\n\n        IUpgradableECCM eccm = IUpgradableECCM(EthCrossChainManagerAddr_);\n\n        require(eccm.unpause(), \"unpause EthCrossChainManager contract failed!\");\n\n        require(unpause(), \"unpause EthCrossChainManagerProxy contract failed!\");\n",
                    "message": "EthCrossChainManagerProxy.unpauseEthCrossChainManager (EthCrossChainManagerProxy.sol#254-258) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": 268,
                    "vulnerability_code": "    function changeManagerChainID(uint64 _newChainId) onlyOwner whenPaused public {\n\n        IUpgradableECCM eccm = IUpgradableECCM(EthCrossChainManagerAddr_);\n\n        if (!eccm.paused()) {\n\n            require(eccm.pause(), \"Pause old EthCrossChainManager contract failed!\");\n\n        }\n\n        require(eccm.setChainId(_newChainId), \"set chain ID failed. \");\n",
                    "message": "EthCrossChainManagerProxy.changeManagerChainID (EthCrossChainManagerProxy.sol#262-268) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in EthCrossChainManagerProxy.sol:\n\t- pragma solidity^0.5.0 (EthCrossChainManagerProxy.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (EthCrossChainManagerProxy.sol#34): it allows old versions\n\t- pragma solidity^0.5.0 (EthCrossChainManagerProxy.sol#113): it allows old versions\n\t- pragma solidity^0.5.0 (EthCrossChainManagerProxy.sol#186): it allows old versions\n\t- pragma solidity^0.5.0 (EthCrossChainManagerProxy.sol#202): it allows old versions\n\t- pragma solidity^0.5.0 (EthCrossChainManagerProxy.sol#213): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 24,
                    "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
                    "message": "Function 'Context._msgSender' (EthCrossChainManagerProxy.sol#22-24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": 29,
                    "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
                    "message": "Function 'Context._msgData' (EthCrossChainManagerProxy.sol#26-29) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": 108,
                    "vulnerability_code": "    function _transferOwnership(address newOwner) internal {\n\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\n        emit OwnershipTransferred(_owner, newOwner);\n\n        _owner = newOwner;\n",
                    "message": "Function 'Ownable._transferOwnership' (EthCrossChainManagerProxy.sol#104-108) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": 173,
                    "vulnerability_code": "    function _pause() internal whenNotPaused {\n\n        _paused = true;\n\n        emit Paused(_msgSender());\n",
                    "message": "Function 'Pausable._pause' (EthCrossChainManagerProxy.sol#170-173) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": 181,
                    "vulnerability_code": "    function _unpause() internal whenPaused {\n\n        _paused = false;\n\n        emit Unpaused(_msgSender());\n",
                    "message": "Function 'Pausable._unpause' (EthCrossChainManagerProxy.sol#178-181) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeToNew(address) external returns (bool);\n",
                    "message": "Parameter '' of IUpgradableECCM.upgradeToNew (EthCrossChainManagerProxy.sol#195) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ethCrossChainManagerAddr) public {\n",
                    "message": "Parameter '_ethCrossChainManagerAddr' of EthCrossChainManagerProxy. (EthCrossChainManagerProxy.sol#221) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeEthCrossChainManager(address _newEthCrossChainManagerAddr) onlyOwner whenPaused public returns (bool) {\n",
                    "message": "Parameter '_newEthCrossChainManagerAddr' of EthCrossChainManagerProxy.upgradeEthCrossChainManager (EthCrossChainManagerProxy.sol#244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function changeManagerChainID(uint64 _newChainId) onlyOwner whenPaused public {\n",
                    "message": "Parameter '_newChainId' of EthCrossChainManagerProxy.changeManagerChainID (EthCrossChainManagerProxy.sol#262) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private EthCrossChainManagerAddr_;\n",
                    "message": "Variable 'EthCrossChainManagerProxy.EthCrossChainManagerAddr_' (EthCrossChainManagerProxy.sol#219) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function pauseEthCrossChainManager() onlyOwner whenNotPaused public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeEthCrossChainManager(address _newEthCrossChainManagerAddr) onlyOwner whenPaused public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function unpauseEthCrossChainManager() onlyOwner whenPaused public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _owner;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _paused;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private EthCrossChainManagerAddr_;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/core/cross_chain_manager/libs/EthCrossChainUtils.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 744,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 744,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1014,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < size; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1041,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "         for(uint i = 0; i < _keyLen; i++){\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1080,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint j = 0; j  < sigCount; j++){\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1097,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < keeperLen; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < keeperLen; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"NextBool value error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value < 0xFD, \"NextVarUint, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 497,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 760,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "         require(key.length >= 67, \"key lenggh is too short\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 827,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 881,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1022,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                revert(\"merkleProve, NextByte for position info failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1025,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(hash == _root, \"merkleProve, expect root is not equal actual root\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_pubKeyList.length % POLYCHAIN_PUBKEY_LEN == 0, \"_pubKeyList length illegal!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(n >= 1, \"too short _pubKeyList!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 744,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 747,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    m++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1014,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < size; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1041,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "         for(uint i = 0; i < _keyLen; i++){\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1080,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint j = 0; j  < sigCount; j++){\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1097,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < keeperLen; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < keeperLen; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 881,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1022,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                revert(\"merkleProve, NextByte for position info failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1025,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(hash == _root, \"merkleProve, expect root is not equal actual root\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_98"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
                    "message": "ZeroCopySource.NextBool (EthCrossChainUtils.sol#25-41) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextByte (EthCrossChainUtils.sol#48-55) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 73,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextUint8 (EthCrossChainUtils.sol#62-73) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": 93,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
                    "message": "ZeroCopySource.NextUint16 (EthCrossChainUtils.sol#80-93) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 121,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
                    "message": "ZeroCopySource.NextUint32 (EthCrossChainUtils.sol#101-121) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": 148,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
                    "message": "ZeroCopySource.NextUint64 (EthCrossChainUtils.sol#128-148) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": 177,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextUint255 (EthCrossChainUtils.sol#156-177) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": 239,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
                    "message": "ZeroCopySource.NextVarBytes (EthCrossChainUtils.sol#184-239) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": 252,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextHash (EthCrossChainUtils.sol#245-252) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": 266,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
                    "message": "ZeroCopySource.NextBytes20 (EthCrossChainUtils.sol#259-266) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteBool (EthCrossChainUtils.sol#320-337) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": 361,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint8 (EthCrossChainUtils.sol#351-361) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": 386,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint16 (EthCrossChainUtils.sol#367-386) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 392,
                    "vulnerability_to_line": 410,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint32 (EthCrossChainUtils.sol#392-410) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": 435,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint64 (EthCrossChainUtils.sol#416-435) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": 461,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint255 (EthCrossChainUtils.sol#441-461) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": 502,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
                    "message": "Utils.bytesToBytes32 (EthCrossChainUtils.sol#496-502) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 508,
                    "vulnerability_to_line": 515,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Utils.bytesToUint256 (EthCrossChainUtils.sol#508-515) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": 534,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
                    "message": "Utils.uint256ToBytes (EthCrossChainUtils.sol#521-534) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": 549,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
                    "message": "Utils.bytesToAddress (EthCrossChainUtils.sol#540-549) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": 567,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
                    "message": "Utils.addressToBytes (EthCrossChainUtils.sol#555-567) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 592,
                    "vulnerability_to_line": 662,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
                    "message": "Utils.equalStorage (EthCrossChainUtils.sol#592-662) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": 735,
                    "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
                    "message": "Utils.slice (EthCrossChainUtils.sol#671-735) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 782,
                    "vulnerability_to_line": 795,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "Utils.isContract (EthCrossChainUtils.sol#782-795) is declared view but contains assembly code\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        TxParam memory txParam;\n",
                    "message": "txParam in ECCUtils.deserializeMerkleValue (EthCrossChainUtils.sol#1132) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Header memory header;\n",
                    "message": "header in ECCUtils.deserializeHeader (EthCrossChainUtils.sol#1157) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ToMerkleValue memory toMerkleValue;\n",
                    "message": "toMerkleValue in ECCUtils.deserializeMerkleValue (EthCrossChainUtils.sol#1125) is a local variable never initialiazed\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
                    "message": "ZeroCopySource.NextBool uses assembly (EthCrossChainUtils.sol#25-41)\n\t- EthCrossChainUtils.sol#29-31\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextByte uses assembly (EthCrossChainUtils.sol#48-55)\n\t- EthCrossChainUtils.sol#51-53\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 73,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextUint8 uses assembly (EthCrossChainUtils.sol#62-73)\n\t- EthCrossChainUtils.sol#65-71\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": 93,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
                    "message": "ZeroCopySource.NextUint16 uses assembly (EthCrossChainUtils.sol#80-93)\n\t- EthCrossChainUtils.sol#84-91\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 121,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
                    "message": "ZeroCopySource.NextUint32 uses assembly (EthCrossChainUtils.sol#101-121)\n\t- EthCrossChainUtils.sol#104-119\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": 148,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
                    "message": "ZeroCopySource.NextUint64 uses assembly (EthCrossChainUtils.sol#128-148)\n\t- EthCrossChainUtils.sol#131-146\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": 177,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextUint255 uses assembly (EthCrossChainUtils.sol#156-177)\n\t- EthCrossChainUtils.sol#159-174\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": 239,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
                    "message": "ZeroCopySource.NextVarBytes uses assembly (EthCrossChainUtils.sol#184-239)\n\t- EthCrossChainUtils.sol#189-236\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": 252,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextHash uses assembly (EthCrossChainUtils.sol#245-252)\n\t- EthCrossChainUtils.sol#248-250\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": 266,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
                    "message": "ZeroCopySource.NextBytes20 uses assembly (EthCrossChainUtils.sol#259-266)\n\t- EthCrossChainUtils.sol#262-264\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteBool uses assembly (EthCrossChainUtils.sol#320-337)\n\t- EthCrossChainUtils.sol#322-335\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": 361,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint8 uses assembly (EthCrossChainUtils.sol#351-361)\n\t- EthCrossChainUtils.sol#353-359\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": 386,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint16 uses assembly (EthCrossChainUtils.sol#367-386)\n\t- EthCrossChainUtils.sol#370-384\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 392,
                    "vulnerability_to_line": 410,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint32 uses assembly (EthCrossChainUtils.sol#392-410)\n\t- EthCrossChainUtils.sol#394-408\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": 435,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint64 uses assembly (EthCrossChainUtils.sol#416-435)\n\t- EthCrossChainUtils.sol#419-433\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": 461,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint255 uses assembly (EthCrossChainUtils.sol#441-461)\n\t- EthCrossChainUtils.sol#445-459\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": 502,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
                    "message": "Utils.bytesToBytes32 uses assembly (EthCrossChainUtils.sol#496-502)\n\t- EthCrossChainUtils.sol#498-501\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 508,
                    "vulnerability_to_line": 515,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Utils.bytesToUint256 uses assembly (EthCrossChainUtils.sol#508-515)\n\t- EthCrossChainUtils.sol#510-513\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": 534,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
                    "message": "Utils.uint256ToBytes uses assembly (EthCrossChainUtils.sol#521-534)\n\t- EthCrossChainUtils.sol#523-533\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": 549,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
                    "message": "Utils.bytesToAddress uses assembly (EthCrossChainUtils.sol#540-549)\n\t- EthCrossChainUtils.sol#543-547\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": 567,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
                    "message": "Utils.addressToBytes uses assembly (EthCrossChainUtils.sol#555-567)\n\t- EthCrossChainUtils.sol#556-566\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 592,
                    "vulnerability_to_line": 662,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
                    "message": "Utils.equalStorage uses assembly (EthCrossChainUtils.sol#592-662)\n\t- EthCrossChainUtils.sol#595-659\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": 735,
                    "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
                    "message": "Utils.slice uses assembly (EthCrossChainUtils.sol#671-735)\n\t- EthCrossChainUtils.sol#684-732\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 782,
                    "vulnerability_to_line": 795,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "Utils.isContract uses assembly (EthCrossChainUtils.sol#782-795)\n\t- EthCrossChainUtils.sol#793\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in EthCrossChainUtils.sol:\n\t- pragma solidity^0.5.0 (EthCrossChainUtils.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (EthCrossChainUtils.sol#299): it allows old versions\n\t- pragma solidity^0.5.0 (EthCrossChainUtils.sol#487): it allows old versions\n\t- pragma solidity^0.5.0 (EthCrossChainUtils.sol#800): it allows old versions\n\t- pragma solidity^0.5.0 (EthCrossChainUtils.sol#959): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
                    "message": "Function 'ZeroCopySource.NextBool' (EthCrossChainUtils.sol#25-41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "Function 'ZeroCopySource.NextByte' (EthCrossChainUtils.sol#48-55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 73,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "Function 'ZeroCopySource.NextUint8' (EthCrossChainUtils.sol#62-73) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": 93,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
                    "message": "Function 'ZeroCopySource.NextUint16' (EthCrossChainUtils.sol#80-93) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 121,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
                    "message": "Function 'ZeroCopySource.NextUint32' (EthCrossChainUtils.sol#101-121) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": 148,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
                    "message": "Function 'ZeroCopySource.NextUint64' (EthCrossChainUtils.sol#128-148) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": 177,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
                    "message": "Function 'ZeroCopySource.NextUint255' (EthCrossChainUtils.sol#156-177) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": 239,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
                    "message": "Function 'ZeroCopySource.NextVarBytes' (EthCrossChainUtils.sol#184-239) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": 252,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
                    "message": "Function 'ZeroCopySource.NextHash' (EthCrossChainUtils.sol#245-252) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": 266,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
                    "message": "Function 'ZeroCopySource.NextBytes20' (EthCrossChainUtils.sol#259-266) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": 294,
                    "vulnerability_code": "    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\n\n        byte v;\n\n        (v, offset) = NextByte(buff, offset);\n\n\n\n        uint value;\n\n        if (v == 0xFD) {\n\n            // return NextUint16(buff, offset);\n\n            (value, offset) = NextUint16(buff, offset);\n\n            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n\n            return (value, offset);\n\n        } else if (v == 0xFE) {\n\n            // return NextUint32(buff, offset);\n\n            (value, offset) = NextUint32(buff, offset);\n\n            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        } else if (v == 0xFF) {\n\n            // return NextUint64(buff, offset);\n\n            (value, offset) = NextUint64(buff, offset);\n\n            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        } else{\n\n            // return (uint8(v), offset);\n\n            value = uint8(v);\n\n            require(value < 0xFD, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        }\n",
                    "message": "Function 'ZeroCopySource.NextVarUint' (EthCrossChainUtils.sol#268-294) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteBool' (EthCrossChainUtils.sol#320-337) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 343,
                    "vulnerability_to_line": 345,
                    "vulnerability_code": "    function WriteByte(byte b) internal pure returns (bytes memory) {\n\n        return WriteUint8(uint8(b));\n",
                    "message": "Function 'ZeroCopySink.WriteByte' (EthCrossChainUtils.sol#343-345) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": 361,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint8' (EthCrossChainUtils.sol#351-361) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": 386,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint16' (EthCrossChainUtils.sol#367-386) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 392,
                    "vulnerability_to_line": 410,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint32' (EthCrossChainUtils.sol#392-410) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": 435,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint64' (EthCrossChainUtils.sol#416-435) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": 461,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint255' (EthCrossChainUtils.sol#441-461) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 467,
                    "vulnerability_to_line": 470,
                    "vulnerability_code": "    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {\n\n        uint64 l = uint64(data.length);\n\n        return abi.encodePacked(WriteVarUint(l), data);\n",
                    "message": "Function 'ZeroCopySink.WriteVarBytes' (EthCrossChainUtils.sol#467-470) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": 482,
                    "vulnerability_code": "    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {\n\n        if (v < 0xFD){\n\n    \t\treturn WriteUint8(uint8(v));\n\n    \t} else if (v <= 0xFFFF) {\n\n    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n\n    \t} else if (v <= 0xFFFFFFFF) {\n\n            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n\n    \t} else {\n\n    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n\n    \t}\n",
                    "message": "Function 'ZeroCopySink.WriteVarUint' (EthCrossChainUtils.sol#472-482) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": "Parameter '_bs' of Utils.bytesToBytes32 (EthCrossChainUtils.sol#496) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 508,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
                    "message": "Parameter '_bs' of Utils.bytesToUint256 (EthCrossChainUtils.sol#508) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": "Parameter '_value' of Utils.uint256ToBytes (EthCrossChainUtils.sol#521) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": "Parameter '_bs' of Utils.bytesToAddress (EthCrossChainUtils.sol#540) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 573,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_data' of Utils.hashLeaf (EthCrossChainUtils.sol#573) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 582,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_l' of Utils.hashChildren (EthCrossChainUtils.sol#582) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 582,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_r' of Utils.hashChildren (EthCrossChainUtils.sol#582) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 672,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory _bytes,\n",
                    "message": "Parameter '_bytes' of Utils.slice (EthCrossChainUtils.sol#672) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint _start,\n",
                    "message": "Parameter '_start' of Utils.slice (EthCrossChainUtils.sol#673) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint _length\n",
                    "message": "Parameter '_length' of Utils.slice (EthCrossChainUtils.sol#674) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 742,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_keepers' of Utils.containMAddresses (EthCrossChainUtils.sol#742) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 742,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_signers' of Utils.containMAddresses (EthCrossChainUtils.sol#742) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 742,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_m' of Utils.containMAddresses (EthCrossChainUtils.sol#742) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1005,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function merkleProve(bytes memory _auditPath, bytes32 _root) internal pure returns (bytes memory) {\n",
                    "message": "Parameter '_auditPath' of ECCUtils.merkleProve (EthCrossChainUtils.sol#1005) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1005,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function merkleProve(bytes memory _auditPath, bytes32 _root) internal pure returns (bytes memory) {\n",
                    "message": "Parameter '_root' of ECCUtils.merkleProve (EthCrossChainUtils.sol#1005) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1035,
                    "vulnerability_to_line": 1051,
                    "vulnerability_code": "    function _getBookKeeper(uint _keyLen, uint _m, bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory){\n\n         bytes memory buff;\n\n         buff = ZeroCopySink.WriteUint16(uint16(_keyLen));\n\n         address[] memory keepers = new address[](_keyLen);\n\n         bytes32 hash;\n\n         bytes memory publicKey;\n\n         for(uint i = 0; i < _keyLen; i++){\n\n             publicKey = Utils.slice(_pubKeyList, i*POLYCHAIN_PUBKEY_LEN, POLYCHAIN_PUBKEY_LEN);\n\n             buff =  abi.encodePacked(buff, ZeroCopySink.WriteVarBytes(Utils.compressMCPubKey(publicKey)));\n\n             hash = keccak256(Utils.slice(publicKey, 3, 64));\n\n             keepers[i] = address(uint160(uint256(hash)));\n\n         }\n\n\n\n         buff = abi.encodePacked(buff, ZeroCopySink.WriteUint16(uint16(_m)));\n\n         bytes20  nextBookKeeper = ripemd160(abi.encodePacked(sha256(buff)));\n\n         return (nextBookKeeper, keepers);\n",
                    "message": "Function 'ECCUtils._getBookKeeper' (EthCrossChainUtils.sol#1035-1051) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1035,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getBookKeeper(uint _keyLen, uint _m, bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory){\n",
                    "message": "Parameter '_keyLen' of ECCUtils._getBookKeeper (EthCrossChainUtils.sol#1035) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1035,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getBookKeeper(uint _keyLen, uint _m, bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory){\n",
                    "message": "Parameter '_m' of ECCUtils._getBookKeeper (EthCrossChainUtils.sol#1035) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1035,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getBookKeeper(uint _keyLen, uint _m, bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory){\n",
                    "message": "Parameter '_pubKeyList' of ECCUtils._getBookKeeper (EthCrossChainUtils.sol#1035) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function verifyPubkey(bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory) {\n",
                    "message": "Parameter '_pubKeyList' of ECCUtils.verifyPubkey (EthCrossChainUtils.sol#1058) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1072,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function verifySig(bytes memory _rawHeader, bytes memory _sigList, address[] memory _keepers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_rawHeader' of ECCUtils.verifySig (EthCrossChainUtils.sol#1072) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1072,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function verifySig(bytes memory _rawHeader, bytes memory _sigList, address[] memory _keepers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_sigList' of ECCUtils.verifySig (EthCrossChainUtils.sol#1072) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1072,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function verifySig(bytes memory _rawHeader, bytes memory _sigList, address[] memory _keepers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_keepers' of ECCUtils.verifySig (EthCrossChainUtils.sol#1072) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1072,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function verifySig(bytes memory _rawHeader, bytes memory _sigList, address[] memory _keepers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_m' of ECCUtils.verifySig (EthCrossChainUtils.sol#1072) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function deserializeMerkleValue(bytes memory _valueBs) internal pure returns (ToMerkleValue memory) {\n",
                    "message": "Parameter '_valueBs' of ECCUtils.deserializeMerkleValue (EthCrossChainUtils.sol#1124) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function deserializeHeader(bytes memory _headerBs) internal pure returns (Header memory) {\n",
                    "message": "Parameter '_headerBs' of ECCUtils.deserializeHeader (EthCrossChainUtils.sol#1156) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v == 0x01) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v == 0x00) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v == 0xFD) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (v == 0xFE) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (v == 0xFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value < 0xFD, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 473,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v < 0xFD){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 475,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v <= 0xFFFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 476,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v <= 0xFFFFFFFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 583,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "             newkey[2] = byte(0x02);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 765,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "             newkey[2] = byte(0x03);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1017,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pos == 0x00) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1019,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if (pos == 0x01) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        result = sha256(abi.encodePacked(byte(0x0), _data));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 744,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 744,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1097,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < keeperLen; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v == 0x00) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 1019,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if (pos == 0x01) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 965,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 392,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 508,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function slice(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 592,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 782,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1035,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getBookKeeper(uint _keyLen, uint _m, bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function verifyPubkey(bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 445,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 543,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 556,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 793,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { codehash := extcodehash(account) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 997,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant POLYCHAIN_PUBKEY_LEN = 67;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 998,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant POLYCHAIN_SIGNATURE_LEN = 65;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/core/assets/ong/ONGX.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _name = name;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _symbol = symbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _decimals = decimals;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (address proxyContractAddress) public ERC20Detailed(\"Ontology Gas\", \"xONG\", 9) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 567,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _mint(proxyContractAddress, 1000000000000000000);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: mint to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_28"
            ],
            "vulnerability_findings": [
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.name (local variable @ ONGX.sol#98) shadows:\n\t- ERC20Detailed.name (function @ ONGX.sol#107-109)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.symbol (local variable @ ONGX.sol#98) shadows:\n\t- ERC20Detailed.symbol (function @ ONGX.sol#115-117)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.decimals (local variable @ ONGX.sol#98) shadows:\n\t- ERC20Detailed.decimals (function @ ONGX.sol#131-133)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 109,
                    "vulnerability_code": "    function name() public view returns (string memory) {\n\n        return _name;\n",
                    "message": "ERC20Detailed.name (ONGX.sol#107-109) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": 117,
                    "vulnerability_code": "    function symbol() public view returns (string memory) {\n\n        return _symbol;\n",
                    "message": "ERC20Detailed.symbol (ONGX.sol#115-117) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "    function decimals() public view returns (uint8) {\n\n        return _decimals;\n",
                    "message": "ERC20Detailed.decimals (ONGX.sol#131-133) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() external view returns (uint256);\n",
                    "message": "IERC20.totalSupply (ONGX.sol#13) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return _totalSupply;\n",
                    "message": "ERC20.totalSupply (ONGX.sol#369-371) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address account) external view returns (uint256);\n",
                    "message": "IERC20.balanceOf (ONGX.sol#18) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function balanceOf(address account) public view returns (uint256) {\n\n        return _balances[account];\n",
                    "message": "ERC20.balanceOf (ONGX.sol#376-378) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address recipient, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.transfer (ONGX.sol#27) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": 391,
                    "vulnerability_code": "    function transfer(address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(_msgSender(), recipient, amount);\n\n        return true;\n",
                    "message": "ERC20.transfer (ONGX.sol#388-391) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256) {\n\n        return _allowances[owner][spender];\n",
                    "message": "ERC20.allowance (ONGX.sol#396-398) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address owner, address spender) external view returns (uint256);\n",
                    "message": "IERC20.allowance (ONGX.sol#36) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.approve (ONGX.sol#52) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": 410,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n\n        _approve(_msgSender(), spender, amount);\n\n        return true;\n",
                    "message": "ERC20.approve (ONGX.sol#407-410) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": 428,
                    "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(sender, recipient, amount);\n\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\n        return true;\n",
                    "message": "ERC20.transferFrom (ONGX.sol#424-428) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.transferFrom (ONGX.sol#63) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": 445,
                    "vulnerability_code": "    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\n        return true;\n",
                    "message": "ERC20.increaseAllowance (ONGX.sol#442-445) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 464,
                    "vulnerability_code": "    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n\n        return true;\n",
                    "message": "ERC20.decreaseAllowance (ONGX.sol#461-464) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in ONGX.sol:\n\t- pragma solidity^0.5.0 (ONGX.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (ONGX.sol#82): it allows old versions\n\t- pragma solidity^0.5.0 (ONGX.sol#138): it allows old versions\n\t- pragma solidity^0.5.0 (ONGX.sol#169): it allows old versions\n\t- pragma solidity^0.5.0 (ONGX.sol#328): it allows old versions\n\t- pragma solidity^0.5.0 (ONGX.sol#560): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 159,
                    "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
                    "message": "Function 'Context._msgSender' (ONGX.sol#157-159) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": 164,
                    "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
                    "message": "Function 'Context._msgData' (ONGX.sol#161-164) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": 487,
                    "vulnerability_code": "    function _transfer(address sender, address recipient, uint256 amount) internal {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n",
                    "message": "Function 'ERC20._transfer' (ONGX.sol#480-487) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": 504,
                    "vulnerability_code": "    function _mint(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n",
                    "message": "Function 'ERC20._mint' (ONGX.sol#498-504) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": 523,
                    "vulnerability_code": "    function _burn(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Transfer(account, address(0), amount);\n",
                    "message": "Function 'ERC20._burn' (ONGX.sol#517-523) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": 544,
                    "vulnerability_code": "    function _approve(address owner, address spender, uint256 amount) internal {\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n",
                    "message": "Function 'ERC20._approve' (ONGX.sol#538-544) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": 555,
                    "vulnerability_code": "    function _burnFrom(address account, uint256 amount) internal {\n\n        _burn(account, amount);\n\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n",
                    "message": "Function 'ERC20._burnFrom' (ONGX.sol#552-555) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _name;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _symbol;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private _decimals;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) private _balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) private _allowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _totalSupply;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/core/assets/btc/BTCX.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 775,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 948,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 949,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _name = name;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 950,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _symbol = symbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 951,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _decimals = decimals;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 952,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (bytes memory _redeemScript) public ERC20Detailed(\"BTC Token\", \"BTCX\", 8) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1465,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        operator = _msgSender();\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1466,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        redeemScript = _redeemScript;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 775,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"NextBool value error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value < 0xFD, \"NextVarUint, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 473,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 573,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 791,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "         require(key.length >= 67, \"key lenggh is too short\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1015,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1069,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: mint to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_msgSender() == ieccmp.getEthCrossChainManager(), \"msgSender is not EthCrossChainManagerContract\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1437,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(chainId != 0, \"chainId illegal!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(fromContractAddr.length != 0, \"from asset contract address cannot be empty\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(Utils.equalStorage(bondAssetHashes[fromChainId], fromContractAddr), \"From contract address error!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1486,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mint(toAddress, uint256(args.amount)), \"mint BTCX in unlock method failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(amount >= minimumLimit, \"btcx amount should be greater than 2000\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1516,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(burn(uint256(amount)), \"Burn msg.sender BTCX tokens failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(eccm.crossChain(toChainId, bondAssetHashes[toChainId], \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 775,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 778,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    m++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 573,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1069,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_msgSender() == ieccmp.getEthCrossChainManager(), \"msgSender is not EthCrossChainManagerContract\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(fromContractAddr.length != 0, \"from asset contract address cannot be empty\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1486,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mint(toAddress, uint256(args.amount)), \"mint BTCX in unlock method failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(amount >= minimumLimit, \"btcx amount should be greater than 2000\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1516,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(burn(uint256(amount)), \"Burn msg.sender BTCX tokens failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(eccm.crossChain(toChainId, bondAssetHashes[toChainId], \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_120"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
                    "message": "ZeroCopySource.NextBool (BTCX.sol#56-72) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": 86,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextByte (BTCX.sol#79-86) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": 104,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextUint8 (BTCX.sol#93-104) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": 124,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
                    "message": "ZeroCopySource.NextUint16 (BTCX.sol#111-124) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
                    "message": "ZeroCopySource.NextUint32 (BTCX.sol#132-152) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
                    "message": "ZeroCopySource.NextUint64 (BTCX.sol#159-179) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextUint255 (BTCX.sol#187-208) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": 270,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
                    "message": "ZeroCopySource.NextVarBytes (BTCX.sol#215-270) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": 283,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextHash (BTCX.sol#276-283) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": 297,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
                    "message": "ZeroCopySource.NextBytes20 (BTCX.sol#290-297) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": 368,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteBool (BTCX.sol#351-368) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": 392,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint8 (BTCX.sol#382-392) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": 417,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint16 (BTCX.sol#398-417) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": 441,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint32 (BTCX.sol#423-441) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": 466,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint64 (BTCX.sol#447-466) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": 492,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint255 (BTCX.sol#472-492) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": 533,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
                    "message": "Utils.bytesToBytes32 (BTCX.sol#527-533) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": 546,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Utils.bytesToUint256 (BTCX.sol#539-546) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": 565,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
                    "message": "Utils.uint256ToBytes (BTCX.sol#552-565) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": 580,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
                    "message": "Utils.bytesToAddress (BTCX.sol#571-580) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": 598,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
                    "message": "Utils.addressToBytes (BTCX.sol#586-598) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": 693,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
                    "message": "Utils.equalStorage (BTCX.sol#623-693) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 702,
                    "vulnerability_to_line": 766,
                    "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
                    "message": "Utils.slice (BTCX.sol#702-766) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": 826,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "Utils.isContract (BTCX.sol#813-826) is declared view but contains assembly code\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        TxArgs memory args;\n",
                    "message": "args in BTCX._deserializeTxArgs (BTCX.sol#1549) is a local variable never initialiazed\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 948,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.name (local variable @ BTCX.sol#948) shadows:\n\t- ERC20Detailed.name (function @ BTCX.sol#957-959)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 948,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.symbol (local variable @ BTCX.sol#948) shadows:\n\t- ERC20Detailed.symbol (function @ BTCX.sol#965-967)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 948,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.decimals (local variable @ BTCX.sol#948) shadows:\n\t- ERC20Detailed.decimals (function @ BTCX.sol#981-983)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 1530,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _serializeToBtcTxArgs(TxArgs memory args, bytes memory redeemScript) internal pure returns (bytes memory) {\n",
                    "message": "BTCX._serializeToBtcTxArgs.redeemScript (local variable @ BTCX.sol#1530) shadows:\n\t- BTCX.redeemScript (state variable @ BTCX.sol#1459)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
                    "message": "ZeroCopySource.NextBool uses assembly (BTCX.sol#56-72)\n\t- BTCX.sol#60-62\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": 86,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextByte uses assembly (BTCX.sol#79-86)\n\t- BTCX.sol#82-84\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": 104,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextUint8 uses assembly (BTCX.sol#93-104)\n\t- BTCX.sol#96-102\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": 124,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
                    "message": "ZeroCopySource.NextUint16 uses assembly (BTCX.sol#111-124)\n\t- BTCX.sol#115-122\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
                    "message": "ZeroCopySource.NextUint32 uses assembly (BTCX.sol#132-152)\n\t- BTCX.sol#135-150\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
                    "message": "ZeroCopySource.NextUint64 uses assembly (BTCX.sol#159-179)\n\t- BTCX.sol#162-177\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextUint255 uses assembly (BTCX.sol#187-208)\n\t- BTCX.sol#190-205\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": 270,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
                    "message": "ZeroCopySource.NextVarBytes uses assembly (BTCX.sol#215-270)\n\t- BTCX.sol#220-267\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": 283,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextHash uses assembly (BTCX.sol#276-283)\n\t- BTCX.sol#279-281\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": 297,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
                    "message": "ZeroCopySource.NextBytes20 uses assembly (BTCX.sol#290-297)\n\t- BTCX.sol#293-295\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": 368,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteBool uses assembly (BTCX.sol#351-368)\n\t- BTCX.sol#353-366\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": 392,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint8 uses assembly (BTCX.sol#382-392)\n\t- BTCX.sol#384-390\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": 417,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint16 uses assembly (BTCX.sol#398-417)\n\t- BTCX.sol#401-415\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": 441,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint32 uses assembly (BTCX.sol#423-441)\n\t- BTCX.sol#425-439\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": 466,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint64 uses assembly (BTCX.sol#447-466)\n\t- BTCX.sol#450-464\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": 492,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint255 uses assembly (BTCX.sol#472-492)\n\t- BTCX.sol#476-490\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": 533,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
                    "message": "Utils.bytesToBytes32 uses assembly (BTCX.sol#527-533)\n\t- BTCX.sol#529-532\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": 546,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Utils.bytesToUint256 uses assembly (BTCX.sol#539-546)\n\t- BTCX.sol#541-544\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": 565,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
                    "message": "Utils.uint256ToBytes uses assembly (BTCX.sol#552-565)\n\t- BTCX.sol#554-564\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": 580,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
                    "message": "Utils.bytesToAddress uses assembly (BTCX.sol#571-580)\n\t- BTCX.sol#574-578\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": 598,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
                    "message": "Utils.addressToBytes uses assembly (BTCX.sol#586-598)\n\t- BTCX.sol#587-597\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": 693,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
                    "message": "Utils.equalStorage uses assembly (BTCX.sol#623-693)\n\t- BTCX.sol#626-690\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 702,
                    "vulnerability_to_line": 766,
                    "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
                    "message": "Utils.slice uses assembly (BTCX.sol#702-766)\n\t- BTCX.sol#715-763\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": 826,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "Utils.isContract uses assembly (BTCX.sol#813-826)\n\t- BTCX.sol#824\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": 959,
                    "vulnerability_code": "    function name() public view returns (string memory) {\n\n        return _name;\n",
                    "message": "ERC20Detailed.name (BTCX.sol#957-959) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 965,
                    "vulnerability_to_line": 967,
                    "vulnerability_code": "    function symbol() public view returns (string memory) {\n\n        return _symbol;\n",
                    "message": "ERC20Detailed.symbol (BTCX.sol#965-967) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 981,
                    "vulnerability_to_line": 983,
                    "vulnerability_code": "    function decimals() public view returns (uint8) {\n\n        return _decimals;\n",
                    "message": "ERC20Detailed.decimals (BTCX.sol#981-983) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1188,
                    "vulnerability_to_line": 1190,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return _totalSupply;\n",
                    "message": "ERC20.totalSupply (BTCX.sol#1188-1190) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 863,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() external view returns (uint256);\n",
                    "message": "IERC20.totalSupply (BTCX.sol#863) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 868,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address account) external view returns (uint256);\n",
                    "message": "IERC20.balanceOf (BTCX.sol#868) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1195,
                    "vulnerability_to_line": 1197,
                    "vulnerability_code": "    function balanceOf(address account) public view returns (uint256) {\n\n        return _balances[account];\n",
                    "message": "ERC20.balanceOf (BTCX.sol#1195-1197) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1207,
                    "vulnerability_to_line": 1210,
                    "vulnerability_code": "    function transfer(address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(_msgSender(), recipient, amount);\n\n        return true;\n",
                    "message": "ERC20.transfer (BTCX.sol#1207-1210) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 877,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address recipient, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.transfer (BTCX.sol#877) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 886,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address owner, address spender) external view returns (uint256);\n",
                    "message": "IERC20.allowance (BTCX.sol#886) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1215,
                    "vulnerability_to_line": 1217,
                    "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256) {\n\n        return _allowances[owner][spender];\n",
                    "message": "ERC20.allowance (BTCX.sol#1215-1217) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1226,
                    "vulnerability_to_line": 1229,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n\n        _approve(_msgSender(), spender, amount);\n\n        return true;\n",
                    "message": "ERC20.approve (BTCX.sol#1226-1229) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.approve (BTCX.sol#902) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 913,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.transferFrom (BTCX.sol#913) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1243,
                    "vulnerability_to_line": 1247,
                    "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(sender, recipient, amount);\n\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\n        return true;\n",
                    "message": "ERC20.transferFrom (BTCX.sol#1243-1247) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": 1264,
                    "vulnerability_code": "    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\n        return true;\n",
                    "message": "ERC20.increaseAllowance (BTCX.sol#1261-1264) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1280,
                    "vulnerability_to_line": 1283,
                    "vulnerability_code": "    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n\n        return true;\n",
                    "message": "ERC20.decreaseAllowance (BTCX.sol#1280-1283) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1427,
                    "vulnerability_to_line": 1430,
                    "vulnerability_code": "    function setManagerProxy(address ethCrossChainManagerProxyAddr) onlyOperator public {\n\n        managerProxyContract = ethCrossChainManagerProxyAddr;\n\n        emit SetManagerProxyEvent(managerProxyContract);\n",
                    "message": "ERC20Extended.setManagerProxy (BTCX.sol#1427-1430) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1436,
                    "vulnerability_to_line": 1440,
                    "vulnerability_code": "    function bindAssetHash(uint64 chainId, bytes memory contractAddr) onlyOperator public {\n\n        require(chainId != 0, \"chainId illegal!\");\n\n        bondAssetHashes[chainId] = contractAddr;\n\n        emit BindAssetHash(chainId, contractAddr);\n",
                    "message": "ERC20Extended.bindAssetHash (BTCX.sol#1436-1440) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1468,
                    "vulnerability_to_line": 1471,
                    "vulnerability_code": "    function setMinimumLimit(uint64 minimumTransferLimit) onlyOperator public returns (bool) {\n\n        minimumLimit = minimumTransferLimit;\n\n        return true;\n",
                    "message": "BTCX.setMinimumLimit (BTCX.sol#1468-1471) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1480,
                    "vulnerability_to_line": 1490,
                    "vulnerability_code": "    function unlock(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) onlyManagerContract public returns (bool) {\n\n        TxArgs memory args = _deserializeTxArgs(argsBs);\n\n        require(fromContractAddr.length != 0, \"from asset contract address cannot be empty\");\n\n        require(Utils.equalStorage(bondAssetHashes[fromChainId], fromContractAddr), \"From contract address error!\");\n\n        \n\n        address toAddress = Utils.bytesToAddress(args.toAddress);\n\n        require(mint(toAddress, uint256(args.amount)), \"mint BTCX in unlock method failed!\");\n\n        \n\n        emit UnlockEvent(address(this), toAddress, args.amount);\n\n        return true;\n",
                    "message": "BTCX.unlock (BTCX.sol#1480-1490) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1500,
                    "vulnerability_to_line": 1528,
                    "vulnerability_code": "    function lock(uint64 toChainId, bytes memory toUserAddr, uint64 amount) public returns (bool) {\n\n        TxArgs memory txArgs = TxArgs({\n\n            toAddress: toUserAddr,\n\n            amount: amount\n\n        });\n\n\n\n        bytes memory txData;\n\n        // if toChainId is BTC chain, put redeemScript into Args\n\n        if (toChainId == 1) {\n\n            require(amount >= minimumLimit, \"btcx amount should be greater than 2000\");\n\n            txData = _serializeToBtcTxArgs(txArgs, redeemScript);\n\n        } else {\n\n            txData = _serializeTxArgs(txArgs);\n\n        }\n\n        \n\n\n\n        require(burn(uint256(amount)), \"Burn msg.sender BTCX tokens failed\");\n\n    \n\n        IEthCrossChainManagerProxy eccmp = IEthCrossChainManagerProxy(managerProxyContract);\n\n        address eccmAddr = eccmp.getEthCrossChainManager();\n\n        IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr);\n\n        \n\n        require(eccm.crossChain(toChainId, bondAssetHashes[toChainId], \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\");\n\n\n\n        emit LockEvent(address(this), _msgSender(), toChainId, bondAssetHashes[toChainId], toUserAddr, amount);\n\n        \n\n        return true;\n\n\n",
                    "message": "BTCX.lock (BTCX.sol#1500-1528) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in BTCX.sol:\n\t- pragma solidity^0.5.0 (BTCX.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (BTCX.sol#34): it allows old versions\n\t- pragma solidity^0.5.0 (BTCX.sol#330): it allows old versions\n\t- pragma solidity^0.5.0 (BTCX.sol#518): it allows old versions\n\t- pragma solidity^0.5.0 (BTCX.sol#831): it allows old versions\n\t- pragma solidity^0.5.0 (BTCX.sol#842): it allows old versions\n\t- pragma solidity^0.5.0 (BTCX.sol#853): it allows old versions\n\t- pragma solidity^0.5.0 (BTCX.sol#932): it allows old versions\n\t- pragma solidity^0.5.0 (BTCX.sol#988): it allows old versions\n\t- pragma solidity^0.5.0 (BTCX.sol#1147): it allows old versions\n\t- pragma solidity^0.5.0 (BTCX.sol#1379): it allows old versions\n\t- pragma solidity^0.5.0 (BTCX.sol#1445): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 24,
                    "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
                    "message": "Function 'Context._msgSender' (BTCX.sol#22-24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": 29,
                    "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
                    "message": "Function 'Context._msgData' (BTCX.sol#26-29) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
                    "message": "Function 'ZeroCopySource.NextBool' (BTCX.sol#56-72) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": 86,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "Function 'ZeroCopySource.NextByte' (BTCX.sol#79-86) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": 104,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "Function 'ZeroCopySource.NextUint8' (BTCX.sol#93-104) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": 124,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
                    "message": "Function 'ZeroCopySource.NextUint16' (BTCX.sol#111-124) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
                    "message": "Function 'ZeroCopySource.NextUint32' (BTCX.sol#132-152) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
                    "message": "Function 'ZeroCopySource.NextUint64' (BTCX.sol#159-179) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
                    "message": "Function 'ZeroCopySource.NextUint255' (BTCX.sol#187-208) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": 270,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
                    "message": "Function 'ZeroCopySource.NextVarBytes' (BTCX.sol#215-270) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": 283,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
                    "message": "Function 'ZeroCopySource.NextHash' (BTCX.sol#276-283) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": 297,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
                    "message": "Function 'ZeroCopySource.NextBytes20' (BTCX.sol#290-297) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\n\n        byte v;\n\n        (v, offset) = NextByte(buff, offset);\n\n\n\n        uint value;\n\n        if (v == 0xFD) {\n\n            // return NextUint16(buff, offset);\n\n            (value, offset) = NextUint16(buff, offset);\n\n            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n\n            return (value, offset);\n\n        } else if (v == 0xFE) {\n\n            // return NextUint32(buff, offset);\n\n            (value, offset) = NextUint32(buff, offset);\n\n            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        } else if (v == 0xFF) {\n\n            // return NextUint64(buff, offset);\n\n            (value, offset) = NextUint64(buff, offset);\n\n            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        } else{\n\n            // return (uint8(v), offset);\n\n            value = uint8(v);\n\n            require(value < 0xFD, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        }\n",
                    "message": "Function 'ZeroCopySource.NextVarUint' (BTCX.sol#299-325) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": 368,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteBool' (BTCX.sol#351-368) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": 376,
                    "vulnerability_code": "    function WriteByte(byte b) internal pure returns (bytes memory) {\n\n        return WriteUint8(uint8(b));\n",
                    "message": "Function 'ZeroCopySink.WriteByte' (BTCX.sol#374-376) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": 392,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint8' (BTCX.sol#382-392) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": 417,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint16' (BTCX.sol#398-417) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": 441,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint32' (BTCX.sol#423-441) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": 466,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint64' (BTCX.sol#447-466) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": 492,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint255' (BTCX.sol#472-492) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": 501,
                    "vulnerability_code": "    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {\n\n        uint64 l = uint64(data.length);\n\n        return abi.encodePacked(WriteVarUint(l), data);\n",
                    "message": "Function 'ZeroCopySink.WriteVarBytes' (BTCX.sol#498-501) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": 513,
                    "vulnerability_code": "    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {\n\n        if (v < 0xFD){\n\n    \t\treturn WriteUint8(uint8(v));\n\n    \t} else if (v <= 0xFFFF) {\n\n    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n\n    \t} else if (v <= 0xFFFFFFFF) {\n\n            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n\n    \t} else {\n\n    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n\n    \t}\n",
                    "message": "Function 'ZeroCopySink.WriteVarUint' (BTCX.sol#503-513) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": "Parameter '_bs' of Utils.bytesToBytes32 (BTCX.sol#527) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
                    "message": "Parameter '_bs' of Utils.bytesToUint256 (BTCX.sol#539) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": "Parameter '_value' of Utils.uint256ToBytes (BTCX.sol#552) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": "Parameter '_bs' of Utils.bytesToAddress (BTCX.sol#571) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_data' of Utils.hashLeaf (BTCX.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 613,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_l' of Utils.hashChildren (BTCX.sol#613) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 613,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_r' of Utils.hashChildren (BTCX.sol#613) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 703,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory _bytes,\n",
                    "message": "Parameter '_bytes' of Utils.slice (BTCX.sol#703) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 704,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint _start,\n",
                    "message": "Parameter '_start' of Utils.slice (BTCX.sol#704) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 705,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint _length\n",
                    "message": "Parameter '_length' of Utils.slice (BTCX.sol#705) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 773,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_keepers' of Utils.containMAddresses (BTCX.sol#773) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 773,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_signers' of Utils.containMAddresses (BTCX.sol#773) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 773,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_m' of Utils.containMAddresses (BTCX.sol#773) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1299,
                    "vulnerability_to_line": 1306,
                    "vulnerability_code": "    function _transfer(address sender, address recipient, uint256 amount) internal {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n",
                    "message": "Function 'ERC20._transfer' (BTCX.sol#1299-1306) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1317,
                    "vulnerability_to_line": 1323,
                    "vulnerability_code": "    function _mint(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n",
                    "message": "Function 'ERC20._mint' (BTCX.sol#1317-1323) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1336,
                    "vulnerability_to_line": 1342,
                    "vulnerability_code": "    function _burn(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Transfer(account, address(0), amount);\n",
                    "message": "Function 'ERC20._burn' (BTCX.sol#1336-1342) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1357,
                    "vulnerability_to_line": 1363,
                    "vulnerability_code": "    function _approve(address owner, address spender, uint256 amount) internal {\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n",
                    "message": "Function 'ERC20._approve' (BTCX.sol#1357-1363) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1371,
                    "vulnerability_to_line": 1374,
                    "vulnerability_code": "    function _burnFrom(address account, uint256 amount) internal {\n\n        _burn(account, amount);\n\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n",
                    "message": "Function 'ERC20._burnFrom' (BTCX.sol#1371-1374) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (bytes memory _redeemScript) public ERC20Detailed(\"BTC Token\", \"BTCX\", 8) {\n",
                    "message": "Parameter '_redeemScript' of BTCX. (BTCX.sol#1464) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1530,
                    "vulnerability_to_line": 1538,
                    "vulnerability_code": "    function _serializeToBtcTxArgs(TxArgs memory args, bytes memory redeemScript) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        buff = abi.encodePacked(\n\n            ZeroCopySink.WriteVarBytes(args.toAddress),\n\n            ZeroCopySink.WriteUint64(args.amount),\n\n            ZeroCopySink.WriteVarBytes(redeemScript)\n\n            );\n\n        return buff;\n",
                    "message": "Function 'BTCX._serializeToBtcTxArgs' (BTCX.sol#1530-1538) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1539,
                    "vulnerability_to_line": 1546,
                    "vulnerability_code": "    function _serializeTxArgs(TxArgs memory args) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        buff = abi.encodePacked(\n\n            ZeroCopySink.WriteVarBytes(args.toAddress),\n\n            ZeroCopySink.WriteUint64(args.amount)\n\n            );\n\n        return buff;\n",
                    "message": "Function 'BTCX._serializeTxArgs' (BTCX.sol#1539-1546) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1548,
                    "vulnerability_to_line": 1554,
                    "vulnerability_code": "    function _deserializeTxArgs(bytes memory valueBs) internal pure returns (TxArgs memory) {\n\n        TxArgs memory args;\n\n        uint256 off = 0;\n\n        (args.toAddress, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n\n        (args.amount, off) = ZeroCopySource.NextUint64(valueBs, off);\n\n        return args;\n",
                    "message": "Function 'BTCX._deserializeTxArgs' (BTCX.sol#1548-1554) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v == 0x01) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v == 0x00) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v == 0xFD) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (v == 0xFE) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (v == 0xFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value < 0xFD, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v < 0xFD){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v <= 0xFFFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 507,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 508,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v <= 0xFFFFFFFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 794,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "             newkey[2] = byte(0x02);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 796,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "             newkey[2] = byte(0x03);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        result = sha256(abi.encodePacked(byte(0x0), _data));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 775,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 775,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 831,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 842,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 853,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 932,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 988,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1445,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 939,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _name;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 940,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _symbol;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 941,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private _decimals;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) private _balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) private _allowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _totalSupply;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v == 0x00) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 1177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 702,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function slice(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 476,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 587,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 715,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 824,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { codehash := extcodehash(account) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/core/assets/ont/xONT.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _name = name;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _symbol = symbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _decimals = decimals;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (address lockProxyContractAddress) public ERC20Detailed(\"Ontology Token\", \"xONT\", 0) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 567,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _mint(lockProxyContractAddress, 1000000000);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: mint to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_28"
            ],
            "vulnerability_findings": [
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.name (local variable @ xONT.sol#98) shadows:\n\t- ERC20Detailed.name (function @ xONT.sol#107-109)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.symbol (local variable @ xONT.sol#98) shadows:\n\t- ERC20Detailed.symbol (function @ xONT.sol#115-117)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.decimals (local variable @ xONT.sol#98) shadows:\n\t- ERC20Detailed.decimals (function @ xONT.sol#131-133)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 109,
                    "vulnerability_code": "    function name() public view returns (string memory) {\n\n        return _name;\n",
                    "message": "ERC20Detailed.name (xONT.sol#107-109) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": 117,
                    "vulnerability_code": "    function symbol() public view returns (string memory) {\n\n        return _symbol;\n",
                    "message": "ERC20Detailed.symbol (xONT.sol#115-117) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "    function decimals() public view returns (uint8) {\n\n        return _decimals;\n",
                    "message": "ERC20Detailed.decimals (xONT.sol#131-133) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() external view returns (uint256);\n",
                    "message": "IERC20.totalSupply (xONT.sol#13) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return _totalSupply;\n",
                    "message": "ERC20.totalSupply (xONT.sol#369-371) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address account) external view returns (uint256);\n",
                    "message": "IERC20.balanceOf (xONT.sol#18) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function balanceOf(address account) public view returns (uint256) {\n\n        return _balances[account];\n",
                    "message": "ERC20.balanceOf (xONT.sol#376-378) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address recipient, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.transfer (xONT.sol#27) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": 391,
                    "vulnerability_code": "    function transfer(address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(_msgSender(), recipient, amount);\n\n        return true;\n",
                    "message": "ERC20.transfer (xONT.sol#388-391) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256) {\n\n        return _allowances[owner][spender];\n",
                    "message": "ERC20.allowance (xONT.sol#396-398) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address owner, address spender) external view returns (uint256);\n",
                    "message": "IERC20.allowance (xONT.sol#36) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.approve (xONT.sol#52) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": 410,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n\n        _approve(_msgSender(), spender, amount);\n\n        return true;\n",
                    "message": "ERC20.approve (xONT.sol#407-410) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": 428,
                    "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(sender, recipient, amount);\n\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\n        return true;\n",
                    "message": "ERC20.transferFrom (xONT.sol#424-428) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.transferFrom (xONT.sol#63) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": 445,
                    "vulnerability_code": "    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\n        return true;\n",
                    "message": "ERC20.increaseAllowance (xONT.sol#442-445) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 464,
                    "vulnerability_code": "    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n\n        return true;\n",
                    "message": "ERC20.decreaseAllowance (xONT.sol#461-464) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in xONT.sol:\n\t- pragma solidity^0.5.0 (xONT.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (xONT.sol#82): it allows old versions\n\t- pragma solidity^0.5.0 (xONT.sol#138): it allows old versions\n\t- pragma solidity^0.5.0 (xONT.sol#169): it allows old versions\n\t- pragma solidity^0.5.0 (xONT.sol#328): it allows old versions\n\t- pragma solidity^0.5.0 (xONT.sol#560): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 159,
                    "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
                    "message": "Function 'Context._msgSender' (xONT.sol#157-159) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": 164,
                    "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
                    "message": "Function 'Context._msgData' (xONT.sol#161-164) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": 487,
                    "vulnerability_code": "    function _transfer(address sender, address recipient, uint256 amount) internal {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n",
                    "message": "Function 'ERC20._transfer' (xONT.sol#480-487) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": 504,
                    "vulnerability_code": "    function _mint(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n",
                    "message": "Function 'ERC20._mint' (xONT.sol#498-504) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": 523,
                    "vulnerability_code": "    function _burn(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Transfer(account, address(0), amount);\n",
                    "message": "Function 'ERC20._burn' (xONT.sol#517-523) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": 544,
                    "vulnerability_code": "    function _approve(address owner, address spender, uint256 amount) internal {\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n",
                    "message": "Function 'ERC20._approve' (xONT.sol#538-544) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": 555,
                    "vulnerability_code": "    function _burnFrom(address account, uint256 amount) internal {\n\n        _burn(account, amount);\n\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n",
                    "message": "Function 'ERC20._burnFrom' (xONT.sol#552-555) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _name;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _symbol;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private _decimals;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) private _balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) private _allowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _totalSupply;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/core/assets/neo/eNEO.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _name = name;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _symbol = symbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _decimals = decimals;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (address lockProxyContractAddress) public ERC20Detailed(\"NEO Token\", \"eNEO\", 8) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 567,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _mint(lockProxyContractAddress, 10000000000000000);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: mint to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_29"
            ],
            "vulnerability_findings": [
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.name (local variable @ eNEO.sol#98) shadows:\n\t- ERC20Detailed.name (function @ eNEO.sol#107-109)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.symbol (local variable @ eNEO.sol#98) shadows:\n\t- ERC20Detailed.symbol (function @ eNEO.sol#115-117)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.decimals (local variable @ eNEO.sol#98) shadows:\n\t- ERC20Detailed.decimals (function @ eNEO.sol#131-133)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 109,
                    "vulnerability_code": "    function name() public view returns (string memory) {\n\n        return _name;\n",
                    "message": "ERC20Detailed.name (eNEO.sol#107-109) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": 117,
                    "vulnerability_code": "    function symbol() public view returns (string memory) {\n\n        return _symbol;\n",
                    "message": "ERC20Detailed.symbol (eNEO.sol#115-117) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "    function decimals() public view returns (uint8) {\n\n        return _decimals;\n",
                    "message": "ERC20Detailed.decimals (eNEO.sol#131-133) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() external view returns (uint256);\n",
                    "message": "IERC20.totalSupply (eNEO.sol#13) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return _totalSupply;\n",
                    "message": "ERC20.totalSupply (eNEO.sol#369-371) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address account) external view returns (uint256);\n",
                    "message": "IERC20.balanceOf (eNEO.sol#18) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function balanceOf(address account) public view returns (uint256) {\n\n        return _balances[account];\n",
                    "message": "ERC20.balanceOf (eNEO.sol#376-378) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address recipient, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.transfer (eNEO.sol#27) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": 391,
                    "vulnerability_code": "    function transfer(address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(_msgSender(), recipient, amount);\n\n        return true;\n",
                    "message": "ERC20.transfer (eNEO.sol#388-391) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256) {\n\n        return _allowances[owner][spender];\n",
                    "message": "ERC20.allowance (eNEO.sol#396-398) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address owner, address spender) external view returns (uint256);\n",
                    "message": "IERC20.allowance (eNEO.sol#36) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.approve (eNEO.sol#52) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": 410,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n\n        _approve(_msgSender(), spender, amount);\n\n        return true;\n",
                    "message": "ERC20.approve (eNEO.sol#407-410) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": 428,
                    "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(sender, recipient, amount);\n\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\n        return true;\n",
                    "message": "ERC20.transferFrom (eNEO.sol#424-428) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.transferFrom (eNEO.sol#63) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": 445,
                    "vulnerability_code": "    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\n        return true;\n",
                    "message": "ERC20.increaseAllowance (eNEO.sol#442-445) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 464,
                    "vulnerability_code": "    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n\n        return true;\n",
                    "message": "ERC20.decreaseAllowance (eNEO.sol#461-464) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in eNEO.sol:\n\t- pragma solidity^0.5.0 (eNEO.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (eNEO.sol#82): it allows old versions\n\t- pragma solidity^0.5.0 (eNEO.sol#138): it allows old versions\n\t- pragma solidity^0.5.0 (eNEO.sol#169): it allows old versions\n\t- pragma solidity^0.5.0 (eNEO.sol#328): it allows old versions\n\t- pragma solidity^0.5.0 (eNEO.sol#560): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 159,
                    "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
                    "message": "Function 'Context._msgSender' (eNEO.sol#157-159) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": 164,
                    "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
                    "message": "Function 'Context._msgData' (eNEO.sol#161-164) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": 487,
                    "vulnerability_code": "    function _transfer(address sender, address recipient, uint256 amount) internal {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n",
                    "message": "Function 'ERC20._transfer' (eNEO.sol#480-487) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": 504,
                    "vulnerability_code": "    function _mint(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n",
                    "message": "Function 'ERC20._mint' (eNEO.sol#498-504) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": 523,
                    "vulnerability_code": "    function _burn(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Transfer(account, address(0), amount);\n",
                    "message": "Function 'ERC20._burn' (eNEO.sol#517-523) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": 544,
                    "vulnerability_code": "    function _approve(address owner, address spender, uint256 amount) internal {\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n",
                    "message": "Function 'ERC20._approve' (eNEO.sol#538-544) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": 555,
                    "vulnerability_code": "    function _burnFrom(address account, uint256 amount) internal {\n\n        _burn(account, amount);\n\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n",
                    "message": "Function 'ERC20._burnFrom' (eNEO.sol#552-555) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": 569,
                    "vulnerability_code": "contract eNEO is Context, ERC20, ERC20Detailed {\n\n    \n\n    constructor (address lockProxyContractAddress) public ERC20Detailed(\"NEO Token\", \"eNEO\", 8) {\n\n        _mint(lockProxyContractAddress, 10000000000000000);\n\n    }\n",
                    "message": "Contract 'eNEO' (eNEO.sol#564-569) is not in CapWords\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _name;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _symbol;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private _decimals;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) private _balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) private _allowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _totalSupply;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/core/assets/erc20_template/ERC20Template.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _name = name;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _symbol = symbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _decimals = decimals;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () public ERC20Detailed(\"ERC20 Template\", \"ERC20T\", 9) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 567,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _mint(_msgSender(), 10000000000000);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 426,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: mint to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 484,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 426,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 484,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_28"
            ],
            "vulnerability_findings": [
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.name (local variable @ ERC20Template.sol#520) shadows:\n\t- ERC20Detailed.name (function @ ERC20Template.sol#529-531)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.symbol (local variable @ ERC20Template.sol#520) shadows:\n\t- ERC20Detailed.symbol (function @ ERC20Template.sol#537-539)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.decimals (local variable @ ERC20Template.sol#520) shadows:\n\t- ERC20Detailed.decimals (function @ ERC20Template.sol#553-555)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() external view returns (uint256);\n",
                    "message": "IERC20.totalSupply (ERC20Template.sol#44) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": 315,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return _totalSupply;\n",
                    "message": "ERC20.totalSupply (ERC20Template.sol#313-315) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": 322,
                    "vulnerability_code": "    function balanceOf(address account) public view returns (uint256) {\n\n        return _balances[account];\n",
                    "message": "ERC20.balanceOf (ERC20Template.sol#320-322) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address account) external view returns (uint256);\n",
                    "message": "IERC20.balanceOf (ERC20Template.sol#49) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address recipient, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.transfer (ERC20Template.sol#58) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": 335,
                    "vulnerability_code": "    function transfer(address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(_msgSender(), recipient, amount);\n\n        return true;\n",
                    "message": "ERC20.transfer (ERC20Template.sol#332-335) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": 342,
                    "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256) {\n\n        return _allowances[owner][spender];\n",
                    "message": "ERC20.allowance (ERC20Template.sol#340-342) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address owner, address spender) external view returns (uint256);\n",
                    "message": "IERC20.allowance (ERC20Template.sol#67) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.approve (ERC20Template.sol#83) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": 354,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n\n        _approve(_msgSender(), spender, amount);\n\n        return true;\n",
                    "message": "ERC20.approve (ERC20Template.sol#351-354) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": 372,
                    "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(sender, recipient, amount);\n\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\n        return true;\n",
                    "message": "ERC20.transferFrom (ERC20Template.sol#368-372) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.transferFrom (ERC20Template.sol#94) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": 389,
                    "vulnerability_code": "    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\n        return true;\n",
                    "message": "ERC20.increaseAllowance (ERC20Template.sol#386-389) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 405,
                    "vulnerability_to_line": 408,
                    "vulnerability_code": "    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n\n        return true;\n",
                    "message": "ERC20.decreaseAllowance (ERC20Template.sol#405-408) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": 531,
                    "vulnerability_code": "    function name() public view returns (string memory) {\n\n        return _name;\n",
                    "message": "ERC20Detailed.name (ERC20Template.sol#529-531) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 537,
                    "vulnerability_to_line": 539,
                    "vulnerability_code": "    function symbol() public view returns (string memory) {\n\n        return _symbol;\n",
                    "message": "ERC20Detailed.symbol (ERC20Template.sol#537-539) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": 555,
                    "vulnerability_code": "    function decimals() public view returns (uint8) {\n\n        return _decimals;\n",
                    "message": "ERC20Detailed.decimals (ERC20Template.sol#553-555) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in ERC20Template.sol:\n\t- pragma solidity^0.5.0 (ERC20Template.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (ERC20Template.sol#34): it allows old versions\n\t- pragma solidity^0.5.0 (ERC20Template.sol#113): it allows old versions\n\t- pragma solidity^0.5.0 (ERC20Template.sol#272): it allows old versions\n\t- pragma solidity^0.5.0 (ERC20Template.sol#504): it allows old versions\n\t- pragma solidity^0.5.0 (ERC20Template.sol#560): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 24,
                    "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
                    "message": "Function 'Context._msgSender' (ERC20Template.sol#22-24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": 29,
                    "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
                    "message": "Function 'Context._msgData' (ERC20Template.sol#26-29) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": 431,
                    "vulnerability_code": "    function _transfer(address sender, address recipient, uint256 amount) internal {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n",
                    "message": "Function 'ERC20._transfer' (ERC20Template.sol#424-431) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": 448,
                    "vulnerability_code": "    function _mint(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n",
                    "message": "Function 'ERC20._mint' (ERC20Template.sol#442-448) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 467,
                    "vulnerability_code": "    function _burn(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Transfer(account, address(0), amount);\n",
                    "message": "Function 'ERC20._burn' (ERC20Template.sol#461-467) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 482,
                    "vulnerability_to_line": 488,
                    "vulnerability_code": "    function _approve(address owner, address spender, uint256 amount) internal {\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n",
                    "message": "Function 'ERC20._approve' (ERC20Template.sol#482-488) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": 499,
                    "vulnerability_code": "    function _burnFrom(address account, uint256 amount) internal {\n\n        _burn(account, amount);\n\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n",
                    "message": "Function 'ERC20._burnFrom' (ERC20Template.sol#496-499) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) private _balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) private _allowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _totalSupply;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _name;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _symbol;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private _decimals;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/core/assets/oep4_template/OEP4Template.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _name = name;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _symbol = symbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _decimals = decimals;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (address proxyContractAddress) public ERC20Detailed(\"OEP4 Template\", \"OEP4T\", 9) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _mint(address(this), 10000 * 10 ** 9);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 570,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Operator = _msgSender();\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        proxyHash = proxyContractAddress;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: mint to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_msgSender() == Operator, \"Only Operator has access!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 581,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_proxyHash == proxyHash, \"proxy contract address cannot be changed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 585,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(this.transfer(_proxyHash, _amount), \"transfer token to proxy contract failed!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 581,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_proxyHash == proxyHash, \"proxy contract address cannot be changed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 585,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(this.transfer(_proxyHash, _amount), \"transfer token to proxy contract failed!\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_32"
            ],
            "vulnerability_findings": [
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.name (local variable @ OEP4Template.sol#98) shadows:\n\t- ERC20Detailed.name (function @ OEP4Template.sol#107-109)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.symbol (local variable @ OEP4Template.sol#98) shadows:\n\t- ERC20Detailed.symbol (function @ OEP4Template.sol#115-117)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.decimals (local variable @ OEP4Template.sol#98) shadows:\n\t- ERC20Detailed.decimals (function @ OEP4Template.sol#131-133)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 109,
                    "vulnerability_code": "    function name() public view returns (string memory) {\n\n        return _name;\n",
                    "message": "ERC20Detailed.name (OEP4Template.sol#107-109) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": 117,
                    "vulnerability_code": "    function symbol() public view returns (string memory) {\n\n        return _symbol;\n",
                    "message": "ERC20Detailed.symbol (OEP4Template.sol#115-117) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "    function decimals() public view returns (uint8) {\n\n        return _decimals;\n",
                    "message": "ERC20Detailed.decimals (OEP4Template.sol#131-133) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return _totalSupply;\n",
                    "message": "ERC20.totalSupply (OEP4Template.sol#369-371) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() external view returns (uint256);\n",
                    "message": "IERC20.totalSupply (OEP4Template.sol#13) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function balanceOf(address account) public view returns (uint256) {\n\n        return _balances[account];\n",
                    "message": "ERC20.balanceOf (OEP4Template.sol#376-378) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address account) external view returns (uint256);\n",
                    "message": "IERC20.balanceOf (OEP4Template.sol#18) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": 391,
                    "vulnerability_code": "    function transfer(address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(_msgSender(), recipient, amount);\n\n        return true;\n",
                    "message": "ERC20.transfer (OEP4Template.sol#388-391) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address recipient, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.transfer (OEP4Template.sol#27) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256) {\n\n        return _allowances[owner][spender];\n",
                    "message": "ERC20.allowance (OEP4Template.sol#396-398) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address owner, address spender) external view returns (uint256);\n",
                    "message": "IERC20.allowance (OEP4Template.sol#36) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": 410,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n\n        _approve(_msgSender(), spender, amount);\n\n        return true;\n",
                    "message": "ERC20.approve (OEP4Template.sol#407-410) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.approve (OEP4Template.sol#52) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.transferFrom (OEP4Template.sol#63) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": 428,
                    "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(sender, recipient, amount);\n\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\n        return true;\n",
                    "message": "ERC20.transferFrom (OEP4Template.sol#424-428) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": 445,
                    "vulnerability_code": "    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\n        return true;\n",
                    "message": "ERC20.increaseAllowance (OEP4Template.sol#442-445) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 464,
                    "vulnerability_code": "    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n\n        return true;\n",
                    "message": "ERC20.decreaseAllowance (OEP4Template.sol#461-464) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 579,
                    "vulnerability_to_line": 588,
                    "vulnerability_code": "    function deletageToProxy(address _proxyHash, uint256 _amount) onlyOperator public returns (bool) {\n\n        if (proxyHash != address(0)) {\n\n            require(_proxyHash == proxyHash, \"proxy contract address cannot be changed!\");\n\n        } else {\n\n            proxyHash = _proxyHash;\n\n        }\n\n        require(this.transfer(_proxyHash, _amount), \"transfer token to proxy contract failed!\");\n\n        return true;\n\n        \n",
                    "message": "OEP4Template.deletageToProxy (OEP4Template.sol#579-588) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in OEP4Template.sol:\n\t- pragma solidity^0.5.0 (OEP4Template.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (OEP4Template.sol#82): it allows old versions\n\t- pragma solidity^0.5.0 (OEP4Template.sol#138): it allows old versions\n\t- pragma solidity^0.5.0 (OEP4Template.sol#169): it allows old versions\n\t- pragma solidity^0.5.0 (OEP4Template.sol#328): it allows old versions\n\t- pragma solidity^0.5.0 (OEP4Template.sol#560): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 159,
                    "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
                    "message": "Function 'Context._msgSender' (OEP4Template.sol#157-159) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": 164,
                    "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
                    "message": "Function 'Context._msgData' (OEP4Template.sol#161-164) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": 487,
                    "vulnerability_code": "    function _transfer(address sender, address recipient, uint256 amount) internal {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n",
                    "message": "Function 'ERC20._transfer' (OEP4Template.sol#480-487) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": 504,
                    "vulnerability_code": "    function _mint(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n",
                    "message": "Function 'ERC20._mint' (OEP4Template.sol#498-504) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": 523,
                    "vulnerability_code": "    function _burn(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Transfer(account, address(0), amount);\n",
                    "message": "Function 'ERC20._burn' (OEP4Template.sol#517-523) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": 544,
                    "vulnerability_code": "    function _approve(address owner, address spender, uint256 amount) internal {\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n",
                    "message": "Function 'ERC20._approve' (OEP4Template.sol#538-544) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": 555,
                    "vulnerability_code": "    function _burnFrom(address account, uint256 amount) internal {\n\n        _burn(account, amount);\n\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n",
                    "message": "Function 'ERC20._burnFrom' (OEP4Template.sol#552-555) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 579,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function deletageToProxy(address _proxyHash, uint256 _amount) onlyOperator public returns (bool) {\n",
                    "message": "Parameter '_proxyHash' of OEP4Template.deletageToProxy (OEP4Template.sol#579) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 579,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function deletageToProxy(address _proxyHash, uint256 _amount) onlyOperator public returns (bool) {\n",
                    "message": "Parameter '_amount' of OEP4Template.deletageToProxy (OEP4Template.sol#579) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public Operator;\n",
                    "message": "Variable 'OEP4Template.Operator' (OEP4Template.sol#566) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _name;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _symbol;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private _decimals;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) private _balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) private _allowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _totalSupply;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/libs/token/ERC20/IERC20.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in IERC20.sol:\n\t- pragma solidity^0.5.0 (IERC20.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/libs/token/ERC20/ERC20.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 426,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: mint to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 484,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 426,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 484,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_22"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": 315,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return _totalSupply;\n",
                    "message": "ERC20.totalSupply (ERC20.sol#313-315) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() external view returns (uint256);\n",
                    "message": "IERC20.totalSupply (ERC20.sol#44) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": 322,
                    "vulnerability_code": "    function balanceOf(address account) public view returns (uint256) {\n\n        return _balances[account];\n",
                    "message": "ERC20.balanceOf (ERC20.sol#320-322) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address account) external view returns (uint256);\n",
                    "message": "IERC20.balanceOf (ERC20.sol#49) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": 335,
                    "vulnerability_code": "    function transfer(address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(_msgSender(), recipient, amount);\n\n        return true;\n",
                    "message": "ERC20.transfer (ERC20.sol#332-335) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address recipient, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.transfer (ERC20.sol#58) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": 342,
                    "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256) {\n\n        return _allowances[owner][spender];\n",
                    "message": "ERC20.allowance (ERC20.sol#340-342) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address owner, address spender) external view returns (uint256);\n",
                    "message": "IERC20.allowance (ERC20.sol#67) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": 354,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n\n        _approve(_msgSender(), spender, amount);\n\n        return true;\n",
                    "message": "ERC20.approve (ERC20.sol#351-354) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.approve (ERC20.sol#83) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.transferFrom (ERC20.sol#94) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": 372,
                    "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(sender, recipient, amount);\n\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\n        return true;\n",
                    "message": "ERC20.transferFrom (ERC20.sol#368-372) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": 389,
                    "vulnerability_code": "    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\n        return true;\n",
                    "message": "ERC20.increaseAllowance (ERC20.sol#386-389) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 405,
                    "vulnerability_to_line": 408,
                    "vulnerability_code": "    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n\n        return true;\n",
                    "message": "ERC20.decreaseAllowance (ERC20.sol#405-408) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in ERC20.sol:\n\t- pragma solidity^0.5.0 (ERC20.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (ERC20.sol#34): it allows old versions\n\t- pragma solidity^0.5.0 (ERC20.sol#113): it allows old versions\n\t- pragma solidity^0.5.0 (ERC20.sol#272): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 24,
                    "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
                    "message": "Function 'Context._msgSender' (ERC20.sol#22-24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": 29,
                    "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
                    "message": "Function 'Context._msgData' (ERC20.sol#26-29) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": 431,
                    "vulnerability_code": "    function _transfer(address sender, address recipient, uint256 amount) internal {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n",
                    "message": "Function 'ERC20._transfer' (ERC20.sol#424-431) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": 448,
                    "vulnerability_code": "    function _mint(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n",
                    "message": "Function 'ERC20._mint' (ERC20.sol#442-448) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 467,
                    "vulnerability_code": "    function _burn(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Transfer(account, address(0), amount);\n",
                    "message": "Function 'ERC20._burn' (ERC20.sol#461-467) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 482,
                    "vulnerability_to_line": 488,
                    "vulnerability_code": "    function _approve(address owner, address spender, uint256 amount) internal {\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n",
                    "message": "Function 'ERC20._approve' (ERC20.sol#482-488) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": 499,
                    "vulnerability_code": "    function _burnFrom(address account, uint256 amount) internal {\n\n        _burn(account, amount);\n\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n",
                    "message": "Function 'ERC20._burnFrom' (ERC20.sol#496-499) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) private _balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) private _allowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _totalSupply;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/libs/token/ERC20/SafeERC20.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "         require(key.length >= 67, \"key lenggh is too short\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 583,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require((value == 0) || (token.allowance(address(this), spender) == 0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 584,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SafeERC20: approve from non-zero to non-zero allowance\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 585,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(Utils.isContract(address(token)), \"SafeERC20: call to non-contract\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 618,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"SafeERC20: low-level call failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 622,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    m++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 583,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require((value == 0) || (token.allowance(address(this), spender) == 0),\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 584,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SafeERC20: approve from non-zero to non-zero allowance\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 585,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 622,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_31"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": 256,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
                    "message": "Utils.bytesToBytes32 (SafeERC20.sol#250-256) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": 269,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Utils.bytesToUint256 (SafeERC20.sol#262-269) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": 288,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
                    "message": "Utils.uint256ToBytes (SafeERC20.sol#275-288) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": 303,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
                    "message": "Utils.bytesToAddress (SafeERC20.sol#294-303) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": 321,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
                    "message": "Utils.addressToBytes (SafeERC20.sol#309-321) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 346,
                    "vulnerability_to_line": 416,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
                    "message": "Utils.equalStorage (SafeERC20.sol#346-416) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": 489,
                    "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
                    "message": "Utils.slice (SafeERC20.sol#425-489) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": 549,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "Utils.isContract (SafeERC20.sol#536-549) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": 256,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
                    "message": "Utils.bytesToBytes32 uses assembly (SafeERC20.sol#250-256)\n\t- SafeERC20.sol#252-255\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": 269,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Utils.bytesToUint256 uses assembly (SafeERC20.sol#262-269)\n\t- SafeERC20.sol#264-267\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": 288,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
                    "message": "Utils.uint256ToBytes uses assembly (SafeERC20.sol#275-288)\n\t- SafeERC20.sol#277-287\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": 303,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
                    "message": "Utils.bytesToAddress uses assembly (SafeERC20.sol#294-303)\n\t- SafeERC20.sol#297-301\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": 321,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
                    "message": "Utils.addressToBytes uses assembly (SafeERC20.sol#309-321)\n\t- SafeERC20.sol#310-320\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 346,
                    "vulnerability_to_line": 416,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
                    "message": "Utils.equalStorage uses assembly (SafeERC20.sol#346-416)\n\t- SafeERC20.sol#349-413\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": 489,
                    "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
                    "message": "Utils.slice uses assembly (SafeERC20.sol#425-489)\n\t- SafeERC20.sol#438-486\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": 549,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "Utils.isContract uses assembly (SafeERC20.sol#536-549)\n\t- SafeERC20.sol#547\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in SafeERC20.sol:\n\t- pragma solidity^0.5.0 (SafeERC20.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (SafeERC20.sol#82): it allows old versions\n\t- pragma solidity^0.5.0 (SafeERC20.sol#241): it allows old versions\n\t- pragma solidity^0.5.0 (SafeERC20.sol#554): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": 624,
                    "vulnerability_code": "    function callOptionalReturn(IERC20 token, bytes memory data) private {\n\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n\n        // we're implementing it ourselves.\n\n\n\n        // A Solidity high level call has three parts:\n\n        //  1. The target address is checked to verify it contains contract code\n\n        //  2. The call itself is made, and success asserted\n\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n\n        // solhint-disable-next-line max-line-length\n\n        require(Utils.isContract(address(token)), \"SafeERC20: call to non-contract\");\n\n\n\n        // solhint-disable-next-line avoid-low-level-calls\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n\n        require(success, \"SafeERC20: low-level call failed\");\n\n\n\n        if (returndata.length > 0) { // Return data is optional\n\n            // solhint-disable-next-line max-line-length\n\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n\n        }\n",
                    "message": "Low level call in SafeERC20.callOptionalReturn (SafeERC20.sol#605-624):\n\t-(success,returndata) = address(token).call(data) SafeERC20.sol#617\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": "Parameter '_bs' of Utils.bytesToBytes32 (SafeERC20.sol#250) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
                    "message": "Parameter '_bs' of Utils.bytesToUint256 (SafeERC20.sol#262) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": "Parameter '_value' of Utils.uint256ToBytes (SafeERC20.sol#275) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": "Parameter '_bs' of Utils.bytesToAddress (SafeERC20.sol#294) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 327,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_data' of Utils.hashLeaf (SafeERC20.sol#327) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_l' of Utils.hashChildren (SafeERC20.sol#336) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_r' of Utils.hashChildren (SafeERC20.sol#336) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 426,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory _bytes,\n",
                    "message": "Parameter '_bytes' of Utils.slice (SafeERC20.sol#426) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint _start,\n",
                    "message": "Parameter '_start' of Utils.slice (SafeERC20.sol#427) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint _length\n",
                    "message": "Parameter '_length' of Utils.slice (SafeERC20.sol#428) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_keepers' of Utils.containMAddresses (SafeERC20.sol#496) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_signers' of Utils.containMAddresses (SafeERC20.sol#496) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_m' of Utils.containMAddresses (SafeERC20.sol#496) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "             newkey[2] = byte(0x02);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 519,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "             newkey[2] = byte(0x03);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        result = sha256(abi.encodePacked(byte(0x0), _data));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function slice(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 346,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 617,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, bytes memory returndata) = address(token).call(data);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 438,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { codehash := extcodehash(account) }\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/libs/token/ERC20/ERC20Extended.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _name = name;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _symbol = symbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _decimals = decimals;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: mint to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_msgSender() == ieccmp.getEthCrossChainManager(), \"msgSender is not EthCrossChainManagerContract\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 629,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(chainId != 0, \"chainId illegal!\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_msgSender() == ieccmp.getEthCrossChainManager(), \"msgSender is not EthCrossChainManagerContract\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_34"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 579,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public operator;    // operator should be the address who deploys this contract, and responsible for 'setManager' and 'bindContractAddrWithChainId'\n",
                    "message": "ERC20Extended.operator (ERC20Extended.sol#579) is never initialized. It is used in:\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.name (local variable @ ERC20Extended.sol#98) shadows:\n\t- ERC20Detailed.name (function @ ERC20Extended.sol#107-109)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.symbol (local variable @ ERC20Extended.sol#98) shadows:\n\t- ERC20Detailed.symbol (function @ ERC20Extended.sol#115-117)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.decimals (local variable @ ERC20Extended.sol#98) shadows:\n\t- ERC20Detailed.decimals (function @ ERC20Extended.sol#131-133)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 579,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public operator;    // operator should be the address who deploys this contract, and responsible for 'setManager' and 'bindContractAddrWithChainId'\n",
                    "message": "ERC20Extended.operator should be constant (ERC20Extended.sol#579)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 109,
                    "vulnerability_code": "    function name() public view returns (string memory) {\n\n        return _name;\n",
                    "message": "ERC20Detailed.name (ERC20Extended.sol#107-109) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": 117,
                    "vulnerability_code": "    function symbol() public view returns (string memory) {\n\n        return _symbol;\n",
                    "message": "ERC20Detailed.symbol (ERC20Extended.sol#115-117) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "    function decimals() public view returns (uint8) {\n\n        return _decimals;\n",
                    "message": "ERC20Detailed.decimals (ERC20Extended.sol#131-133) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return _totalSupply;\n",
                    "message": "ERC20.totalSupply (ERC20Extended.sol#369-371) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() external view returns (uint256);\n",
                    "message": "IERC20.totalSupply (ERC20Extended.sol#13) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address account) external view returns (uint256);\n",
                    "message": "IERC20.balanceOf (ERC20Extended.sol#18) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function balanceOf(address account) public view returns (uint256) {\n\n        return _balances[account];\n",
                    "message": "ERC20.balanceOf (ERC20Extended.sol#376-378) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": 391,
                    "vulnerability_code": "    function transfer(address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(_msgSender(), recipient, amount);\n\n        return true;\n",
                    "message": "ERC20.transfer (ERC20Extended.sol#388-391) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address recipient, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.transfer (ERC20Extended.sol#27) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address owner, address spender) external view returns (uint256);\n",
                    "message": "IERC20.allowance (ERC20Extended.sol#36) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256) {\n\n        return _allowances[owner][spender];\n",
                    "message": "ERC20.allowance (ERC20Extended.sol#396-398) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.approve (ERC20Extended.sol#52) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": 410,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n\n        _approve(_msgSender(), spender, amount);\n\n        return true;\n",
                    "message": "ERC20.approve (ERC20Extended.sol#407-410) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.transferFrom (ERC20Extended.sol#63) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": 428,
                    "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(sender, recipient, amount);\n\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\n        return true;\n",
                    "message": "ERC20.transferFrom (ERC20Extended.sol#424-428) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": 445,
                    "vulnerability_code": "    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\n        return true;\n",
                    "message": "ERC20.increaseAllowance (ERC20Extended.sol#442-445) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 464,
                    "vulnerability_code": "    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n\n        return true;\n",
                    "message": "ERC20.decreaseAllowance (ERC20Extended.sol#461-464) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 601,
                    "vulnerability_to_line": 604,
                    "vulnerability_code": "    function mint(address account, uint256 amount) public onlyManagerContract returns (bool) {\n\n        _mint(account, amount);\n\n        return true;\n",
                    "message": "ERC20Extended.mint (ERC20Extended.sol#601-604) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 609,
                    "vulnerability_to_line": 612,
                    "vulnerability_code": "    function burn(uint256 amount) public returns (bool) {\n\n        _burn(_msgSender(), amount);\n\n        return true;\n",
                    "message": "ERC20Extended.burn (ERC20Extended.sol#609-612) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 619,
                    "vulnerability_to_line": 622,
                    "vulnerability_code": "    function setManagerProxy(address ethCrossChainManagerProxyAddr) onlyOperator public {\n\n        managerProxyContract = ethCrossChainManagerProxyAddr;\n\n        emit SetManagerProxyEvent(managerProxyContract);\n",
                    "message": "ERC20Extended.setManagerProxy (ERC20Extended.sol#619-622) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 628,
                    "vulnerability_to_line": 632,
                    "vulnerability_code": "    function bindAssetHash(uint64 chainId, bytes memory contractAddr) onlyOperator public {\n\n        require(chainId != 0, \"chainId illegal!\");\n\n        bondAssetHashes[chainId] = contractAddr;\n\n        emit BindAssetHash(chainId, contractAddr);\n",
                    "message": "ERC20Extended.bindAssetHash (ERC20Extended.sol#628-632) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in ERC20Extended.sol:\n\t- pragma solidity^0.5.0 (ERC20Extended.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (ERC20Extended.sol#82): it allows old versions\n\t- pragma solidity^0.5.0 (ERC20Extended.sol#138): it allows old versions\n\t- pragma solidity^0.5.0 (ERC20Extended.sol#169): it allows old versions\n\t- pragma solidity^0.5.0 (ERC20Extended.sol#328): it allows old versions\n\t- pragma solidity^0.5.0 (ERC20Extended.sol#560): it allows old versions\n\t- pragma solidity^0.5.0 (ERC20Extended.sol#571): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 159,
                    "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
                    "message": "Function 'Context._msgSender' (ERC20Extended.sol#157-159) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": 164,
                    "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
                    "message": "Function 'Context._msgData' (ERC20Extended.sol#161-164) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": 487,
                    "vulnerability_code": "    function _transfer(address sender, address recipient, uint256 amount) internal {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n",
                    "message": "Function 'ERC20._transfer' (ERC20Extended.sol#480-487) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": 504,
                    "vulnerability_code": "    function _mint(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n",
                    "message": "Function 'ERC20._mint' (ERC20Extended.sol#498-504) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": 523,
                    "vulnerability_code": "    function _burn(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Transfer(account, address(0), amount);\n",
                    "message": "Function 'ERC20._burn' (ERC20Extended.sol#517-523) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": 544,
                    "vulnerability_code": "    function _approve(address owner, address spender, uint256 amount) internal {\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n",
                    "message": "Function 'ERC20._approve' (ERC20Extended.sol#538-544) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": 555,
                    "vulnerability_code": "    function _burnFrom(address account, uint256 amount) internal {\n\n        _burn(account, amount);\n\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n",
                    "message": "Function 'ERC20._burnFrom' (ERC20Extended.sol#552-555) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _name;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _symbol;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private _decimals;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) private _balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) private _allowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _totalSupply;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/libs/token/ERC20/ERC20Detailed.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _name = name;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _symbol = symbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _decimals = decimals;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.name (local variable @ ERC20Detailed.sol#98) shadows:\n\t- ERC20Detailed.name (function @ ERC20Detailed.sol#107-109)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.symbol (local variable @ ERC20Detailed.sol#98) shadows:\n\t- ERC20Detailed.symbol (function @ ERC20Detailed.sol#115-117)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name, string memory symbol, uint8 decimals) public {\n",
                    "message": "ERC20Detailed.constructor.decimals (local variable @ ERC20Detailed.sol#98) shadows:\n\t- ERC20Detailed.decimals (function @ ERC20Detailed.sol#131-133)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 109,
                    "vulnerability_code": "    function name() public view returns (string memory) {\n\n        return _name;\n",
                    "message": "ERC20Detailed.name (ERC20Detailed.sol#107-109) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": 117,
                    "vulnerability_code": "    function symbol() public view returns (string memory) {\n\n        return _symbol;\n",
                    "message": "ERC20Detailed.symbol (ERC20Detailed.sol#115-117) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "    function decimals() public view returns (uint8) {\n\n        return _decimals;\n",
                    "message": "ERC20Detailed.decimals (ERC20Detailed.sol#131-133) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in ERC20Detailed.sol:\n\t- pragma solidity^0.5.0 (ERC20Detailed.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (ERC20Detailed.sol#82): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _name;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _symbol;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private _decimals;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/libs/GSN/Context.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal { }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in Context.sol:\n\t- pragma solidity^0.5.0 (Context.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 24,
                    "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
                    "message": "Function 'Context._msgSender' (Context.sol#22-24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": 29,
                    "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
                    "message": "Function 'Context._msgData' (Context.sol#26-29) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/libs/lifecycle/Pausable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _paused = false;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_paused, \"Pausable: paused\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_paused, \"Pausable: not paused\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": 70,
                    "vulnerability_code": "    function paused() public view returns (bool) {\n\n        return _paused;\n",
                    "message": "Pausable.paused (Pausable.sol#68-70) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in Pausable.sol:\n\t- pragma solidity^0.5.0 (Pausable.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (Pausable.sol#34): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 24,
                    "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
                    "message": "Function 'Context._msgSender' (Pausable.sol#22-24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": 29,
                    "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
                    "message": "Function 'Context._msgData' (Pausable.sol#26-29) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function _pause() internal whenNotPaused {\n\n        _paused = true;\n\n        emit Paused(_msgSender());\n",
                    "message": "Function 'Pausable._pause' (Pausable.sol#91-94) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": 102,
                    "vulnerability_code": "    function _unpause() internal whenPaused {\n\n        _paused = false;\n\n        emit Unpaused(_msgSender());\n",
                    "message": "Function 'Pausable._unpause' (Pausable.sol#99-102) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _paused;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/libs/utils/Utils.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 32, \"bytes length is not 32.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "         require(key.length >= 67, \"key lenggh is too short\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    m++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_bs.length == 20, \"bytes length does not match address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_30"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": 18,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
                    "message": "Utils.bytesToBytes32 (Utils.sol#12-18) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": 31,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Utils.bytesToUint256 (Utils.sol#24-31) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 50,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
                    "message": "Utils.uint256ToBytes (Utils.sol#37-50) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": 65,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
                    "message": "Utils.bytesToAddress (Utils.sol#56-65) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": 83,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
                    "message": "Utils.addressToBytes (Utils.sol#71-83) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": 178,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
                    "message": "Utils.equalStorage (Utils.sol#108-178) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
                    "message": "Utils.slice (Utils.sol#187-251) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": 311,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "Utils.isContract (Utils.sol#298-311) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": 18,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n\n            value := mload(add(_bs, 0x20))\n\n        }\n",
                    "message": "Utils.bytesToBytes32 uses assembly (Utils.sol#12-18)\n\t- Utils.sol#14-17\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": 31,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n\n        require(_bs.length == 32, \"bytes length is not 32.\");\n\n        assembly {\n\n            // load 32 bytes from memory starting from position _bs + 32\n\n            value := mload(add(_bs, 0x20))\n\n        }\n\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Utils.bytesToUint256 uses assembly (Utils.sol#24-31)\n\t- Utils.sol#26-29\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 50,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x20)\n\n            //In the next word, put value in bytes format to the next 32 bytes\n\n            mstore(add(bs, 0x20), _value)\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n        }\n",
                    "message": "Utils.uint256ToBytes uses assembly (Utils.sol#37-50)\n\t- Utils.sol#39-49\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": 65,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n\n    {\n\n        require(_bs.length == 20, \"bytes length does not match address\");\n\n        assembly {\n\n            // for _bs, first word store _bs.length, second word store _bs.value\n\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n\n            addr := mload(add(_bs, 0x14))\n\n        }\n\n\n",
                    "message": "Utils.bytesToAddress uses assembly (Utils.sol#56-65)\n\t- Utils.sol#59-63\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": 83,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n\n        assembly {\n\n            // Get a location of some free memory and store it in result as\n\n            // Solidity does for memory variables.\n\n            bs := mload(0x40)\n\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n\n            mstore(bs, 0x14)\n\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n\n            mstore(add(bs, 0x20), shl(96, _addr))\n\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n\n            mstore(0x40, add(bs, 0x40))\n\n       }\n",
                    "message": "Utils.addressToBytes uses assembly (Utils.sol#71-83)\n\t- Utils.sol#72-82\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": 178,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n\n        bool success = true;\n\n\n\n        assembly {\n\n            // we know _preBytes_offset is 0\n\n            let fslot := sload(_preBytes_slot)\n\n            // Arrays of 31 bytes or less have an even value in their slot,\n\n            // while longer arrays have an odd value. The actual length is\n\n            // the slot divided by two for odd values, and the lowest order\n\n            // byte divided by two for even values.\n\n            // If the slot is even, bitwise and the slot with 255 and divide by\n\n            // two to get the length. If the slot is odd, bitwise and the slot\n\n            // with -1 and divide by two.\n\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n\n            let mlength := mload(_postBytes)\n\n\n\n            // if lengths don't match the arrays are not equal\n\n            switch eq(slength, mlength)\n\n            case 1 {\n\n                // fslot can contain both the length and contents of the array\n\n                // if slength < 32 bytes so let's prepare for that\n\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n\n                // slength != 0\n\n                if iszero(iszero(slength)) {\n\n                    switch lt(slength, 32)\n\n                    case 1 {\n\n                        // blank the last byte which is the length\n\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n\n                            // unsuccess:\n\n                            success := 0\n\n                        }\n\n                    }\n\n                    default {\n\n                        // cb is a circuit breaker in the for loop since there's\n\n                        //  no said feature for inline assembly loops\n\n                        // cb = 1 - don't breaker\n\n                        // cb = 0 - break\n\n                        let cb := 1\n\n\n\n                        // get the keccak hash to get the contents of the array\n\n                        mstore(0x0, _preBytes_slot)\n\n                        let sc := keccak256(0x0, 0x20)\n\n\n\n                        let mc := add(_postBytes, 0x20)\n\n                        let end := add(mc, mlength)\n\n\n\n                        // the next line is the loop condition:\n\n                        // while(uint(mc < end) + cb == 2)\n\n                        for {} eq(add(lt(mc, end), cb), 2) {\n\n                            sc := add(sc, 1)\n\n                            mc := add(mc, 0x20)\n\n                        } {\n\n                            if iszero(eq(sload(sc), mload(mc))) {\n\n                                // unsuccess:\n\n                                success := 0\n\n                                cb := 0\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            default {\n\n                // unsuccess:\n\n                success := 0\n\n            }\n\n        }\n\n\n\n        return success;\n",
                    "message": "Utils.equalStorage uses assembly (Utils.sol#108-178)\n\t- Utils.sol#111-175\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function slice(\n\n        bytes memory _bytes,\n\n        uint _start,\n\n        uint _length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        require(_bytes.length >= (_start + _length));\n\n\n\n        bytes memory tempBytes;\n\n\n\n        assembly {\n\n            switch iszero(_length)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                // lengthmod <= _length % 32\n\n                let lengthmod := and(_length, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, _length)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, _length)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return tempBytes;\n",
                    "message": "Utils.slice uses assembly (Utils.sol#187-251)\n\t- Utils.sol#200-248\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": 311,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "Utils.isContract uses assembly (Utils.sol#298-311)\n\t- Utils.sol#309\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in Utils.sol:\n\t- pragma solidity^0.5.0 (Utils.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": "Parameter '_bs' of Utils.bytesToBytes32 (Utils.sol#12) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
                    "message": "Parameter '_bs' of Utils.bytesToUint256 (Utils.sol#24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": "Parameter '_value' of Utils.uint256ToBytes (Utils.sol#37) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": "Parameter '_bs' of Utils.bytesToAddress (Utils.sol#56) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_data' of Utils.hashLeaf (Utils.sol#89) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_l' of Utils.hashChildren (Utils.sol#98) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n",
                    "message": "Parameter '_r' of Utils.hashChildren (Utils.sol#98) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory _bytes,\n",
                    "message": "Parameter '_bytes' of Utils.slice (Utils.sol#188) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint _start,\n",
                    "message": "Parameter '_start' of Utils.slice (Utils.sol#189) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint _length\n",
                    "message": "Parameter '_length' of Utils.slice (Utils.sol#190) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_keepers' of Utils.containMAddresses (Utils.sol#258) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_signers' of Utils.containMAddresses (Utils.sol#258) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n",
                    "message": "Parameter '_m' of Utils.containMAddresses (Utils.sol#258) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "             newkey[2] = byte(0x02);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "             newkey[2] = byte(0x03);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        result = sha256(abi.encodePacked(byte(0x0), _data));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < _signers.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _keepers.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function slice(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { codehash := extcodehash(account) }\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/libs/math/SafeMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in SafeMath.sol:\n\t- pragma solidity^0.5.0 (SafeMath.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/libs/ownership/Ownable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address msgSender = _msgSender();\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = msgSender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit OwnershipTransferred(address(0), msgSender);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isOwner(), \"Ownable: caller is not the owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function owner() public view returns (address) {\n\n        return _owner;\n",
                    "message": "Ownable.owner (Ownable.sol#62-64) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": 91,
                    "vulnerability_code": "    function renounceOwnership() public onlyOwner {\n\n        emit OwnershipTransferred(_owner, address(0));\n\n        _owner = address(0);\n",
                    "message": "Ownable.renounceOwnership (Ownable.sol#88-91) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": 99,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public  onlyOwner {\n\n        _transferOwnership(newOwner);\n",
                    "message": "Ownable.transferOwnership (Ownable.sol#97-99) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in Ownable.sol:\n\t- pragma solidity^0.5.0 (Ownable.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (Ownable.sol#34): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 24,
                    "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
                    "message": "Function 'Context._msgSender' (Ownable.sol#22-24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": 29,
                    "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
                    "message": "Function 'Context._msgData' (Ownable.sol#26-29) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": 108,
                    "vulnerability_code": "    function _transferOwnership(address newOwner) internal {\n\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\n        emit OwnershipTransferred(_owner, newOwner);\n\n        _owner = newOwner;\n",
                    "message": "Function 'Ownable._transferOwnership' (Ownable.sol#104-108) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _owner;\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/libs/common/ZeroCopySource.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"NextBool value error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value < 0xFD, \"NextVarUint, value outside range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_32"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
                    "message": "ZeroCopySource.NextBool (ZeroCopySource.sol#25-41) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextByte (ZeroCopySource.sol#48-55) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 73,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextUint8 (ZeroCopySource.sol#62-73) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": 93,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
                    "message": "ZeroCopySource.NextUint16 (ZeroCopySource.sol#80-93) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 121,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
                    "message": "ZeroCopySource.NextUint32 (ZeroCopySource.sol#101-121) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": 148,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
                    "message": "ZeroCopySource.NextUint64 (ZeroCopySource.sol#128-148) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": 177,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextUint255 (ZeroCopySource.sol#156-177) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": 239,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
                    "message": "ZeroCopySource.NextVarBytes (ZeroCopySource.sol#184-239) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": 252,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextHash (ZeroCopySource.sol#245-252) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": 266,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
                    "message": "ZeroCopySource.NextBytes20 (ZeroCopySource.sol#259-266) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
                    "message": "ZeroCopySource.NextBool uses assembly (ZeroCopySource.sol#25-41)\n\t- ZeroCopySource.sol#29-31\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextByte uses assembly (ZeroCopySource.sol#48-55)\n\t- ZeroCopySource.sol#51-53\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 73,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "ZeroCopySource.NextUint8 uses assembly (ZeroCopySource.sol#62-73)\n\t- ZeroCopySource.sol#65-71\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": 93,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
                    "message": "ZeroCopySource.NextUint16 uses assembly (ZeroCopySource.sol#80-93)\n\t- ZeroCopySource.sol#84-91\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 121,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
                    "message": "ZeroCopySource.NextUint32 uses assembly (ZeroCopySource.sol#101-121)\n\t- ZeroCopySource.sol#104-119\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": 148,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
                    "message": "ZeroCopySource.NextUint64 uses assembly (ZeroCopySource.sol#128-148)\n\t- ZeroCopySource.sol#131-146\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": 177,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextUint255 uses assembly (ZeroCopySource.sol#156-177)\n\t- ZeroCopySource.sol#159-174\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": 239,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
                    "message": "ZeroCopySource.NextVarBytes uses assembly (ZeroCopySource.sol#184-239)\n\t- ZeroCopySource.sol#189-236\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": 252,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
                    "message": "ZeroCopySource.NextHash uses assembly (ZeroCopySource.sol#245-252)\n\t- ZeroCopySource.sol#248-250\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": 266,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
                    "message": "ZeroCopySource.NextBytes20 uses assembly (ZeroCopySource.sol#259-266)\n\t- ZeroCopySource.sol#262-264\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in ZeroCopySource.sol:\n\t- pragma solidity^0.5.0 (ZeroCopySource.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n\n        // byte === bytes1\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        bool value;\n\n        if (v == 0x01) {\n\n\t\t    value = true;\n\n    \t} else if (v == 0x00) {\n\n            value = false;\n\n        } else {\n\n            revert(\"NextBool value error\");\n\n        }\n\n        return (value, offset + 1);\n",
                    "message": "Function 'ZeroCopySource.NextBool' (ZeroCopySource.sol#25-41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n\n        byte v;\n\n        assembly{\n\n            v := mload(add(add(buff, 0x20), offset))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "Function 'ZeroCopySource.NextByte' (ZeroCopySource.sol#48-55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 73,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n\n        uint8 v;\n\n        assembly{\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x01))\n\n            v := mload(sub(tmpbytes, 0x1f))\n\n        }\n\n        return (v, offset + 1);\n",
                    "message": "Function 'ZeroCopySource.NextUint8' (ZeroCopySource.sol#62-73) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": 93,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n\n        \n\n        uint16 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let bvalue := mload(add(add(buff, 0x20), offset))\n\n            mstore8(tmpbytes, byte(0x01, bvalue))\n\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n\n            mstore(0x40, add(tmpbytes, 0x02))\n\n            v := mload(sub(tmpbytes, 0x1e))\n\n        }\n\n        return (v, offset + 2);\n",
                    "message": "Function 'ZeroCopySource.NextUint16' (ZeroCopySource.sol#80-93) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 121,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n\n        uint32 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x04\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 4);\n",
                    "message": "Function 'ZeroCopySource.NextUint32' (ZeroCopySource.sol#101-121) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": 148,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n\n        uint64 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x08\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n\n        }\n\n        return (v, offset + 8);\n",
                    "message": "Function 'ZeroCopySource.NextUint64' (ZeroCopySource.sol#128-148) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": 177,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n\n        uint256 v;\n\n        assembly {\n\n            let tmpbytes := mload(0x40)\n\n            let byteLen := 0x20\n\n            for {\n\n                let tindex := 0x00\n\n                let bindex := sub(byteLen, 0x01)\n\n                let bvalue := mload(add(add(buff, 0x20), offset))\n\n            } lt(tindex, byteLen) {\n\n                tindex := add(tindex, 0x01)\n\n                bindex := sub(bindex, 0x01)\n\n            }{\n\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n\n            }\n\n            mstore(0x40, add(tmpbytes, byteLen))\n\n            v := mload(tmpbytes)\n\n        }\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n\n        return (v, offset + 32);\n",
                    "message": "Function 'ZeroCopySource.NextUint255' (ZeroCopySource.sol#156-177) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": 239,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n\n        uint len;\n\n        (len, offset) = NextVarUint(buff, offset);\n\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n\n        bytes memory tempBytes;\n\n        assembly{\n\n            switch iszero(len)\n\n            case 0 {\n\n                // Get a location of some free memory and store it in tempBytes as\n\n                // Solidity does for memory variables.\n\n                tempBytes := mload(0x40)\n\n\n\n                // The first word of the slice result is potentially a partial\n\n                // word read from the original array. To read it, we calculate\n\n                // the length of that partial word and start copying that many\n\n                // bytes into the array. The first word we copy will start with\n\n                // data we don't care about, but the last `lengthmod` bytes will\n\n                // land at the beginning of the contents of the new array. When\n\n                // we're done copying, we overwrite the full first word with\n\n                // the actual length of the slice.\n\n                let lengthmod := and(len, 31)\n\n\n\n                // The multiplication in the next line is necessary\n\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n\n                // the following copy loop was copying the origin's length\n\n                // and then ending prematurely not copying everything it should.\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\n                let end := add(mc, len)\n\n\n\n                for {\n\n                    // The multiplication in the next line has the same exact purpose\n\n                    // as the one above.\n\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n\n                } lt(mc, end) {\n\n                    mc := add(mc, 0x20)\n\n                    cc := add(cc, 0x20)\n\n                } {\n\n                    mstore(mc, mload(cc))\n\n                }\n\n\n\n                mstore(tempBytes, len)\n\n\n\n                //update free-memory pointer\n\n                //allocating the array padded to 32 bytes like the compiler does now\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n\n            }\n\n            //if we want a zero-length slice let's just return a zero-length array\n\n            default {\n\n                tempBytes := mload(0x40)\n\n\n\n                mstore(0x40, add(tempBytes, 0x20))\n\n            }\n\n        }\n\n\n\n        return (tempBytes, offset + len);\n",
                    "message": "Function 'ZeroCopySource.NextVarBytes' (ZeroCopySource.sol#184-239) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": 252,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n\n        bytes32 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 32);\n",
                    "message": "Function 'ZeroCopySource.NextHash' (ZeroCopySource.sol#245-252) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": 266,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n\n        bytes20 v;\n\n        assembly {\n\n            v := mload(add(buff, add(offset, 0x20)))\n\n        }\n\n        return (v, offset + 20);\n",
                    "message": "Function 'ZeroCopySource.NextBytes20' (ZeroCopySource.sol#259-266) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": 294,
                    "vulnerability_code": "    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\n\n        byte v;\n\n        (v, offset) = NextByte(buff, offset);\n\n\n\n        uint value;\n\n        if (v == 0xFD) {\n\n            // return NextUint16(buff, offset);\n\n            (value, offset) = NextUint16(buff, offset);\n\n            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n\n            return (value, offset);\n\n        } else if (v == 0xFE) {\n\n            // return NextUint32(buff, offset);\n\n            (value, offset) = NextUint32(buff, offset);\n\n            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        } else if (v == 0xFF) {\n\n            // return NextUint64(buff, offset);\n\n            (value, offset) = NextUint64(buff, offset);\n\n            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        } else{\n\n            // return (uint8(v), offset);\n\n            value = uint8(v);\n\n            require(value < 0xFD, \"NextVarUint, value outside range\");\n\n            return (value, offset);\n\n        }\n",
                    "message": "Function 'ZeroCopySource.NextVarUint' (ZeroCopySource.sol#268-294) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v == 0x01) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v == 0x00) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v == 0xFD) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (v == 0xFE) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (v == 0xFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(value < 0xFD, \"NextVarUint, value outside range\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v == 0x00) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "eth-contracts-2b1cbe073e40a7bd26022d1cda9341b4780d07ee/contracts/libs/common/ZeroCopySink.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_22"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteBool (ZeroCopySink.sol#24-41) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": 65,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint8 (ZeroCopySink.sol#55-65) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": 90,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint16 (ZeroCopySink.sol#71-90) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": 114,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint32 (ZeroCopySink.sol#96-114) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": 139,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint64 (ZeroCopySink.sol#120-139) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": 165,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint255 (ZeroCopySink.sol#145-165) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteBool uses assembly (ZeroCopySink.sol#24-41)\n\t- ZeroCopySink.sol#26-39\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": 65,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint8 uses assembly (ZeroCopySink.sol#55-65)\n\t- ZeroCopySink.sol#57-63\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": 90,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint16 uses assembly (ZeroCopySink.sol#71-90)\n\t- ZeroCopySink.sol#74-88\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": 114,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint32 uses assembly (ZeroCopySink.sol#96-114)\n\t- ZeroCopySink.sol#98-112\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": 139,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint64 uses assembly (ZeroCopySink.sol#120-139)\n\t- ZeroCopySink.sol#123-137\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": 165,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
                    "message": "ZeroCopySink.WriteUint255 uses assembly (ZeroCopySink.sol#145-165)\n\t- ZeroCopySink.sol#149-163\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in ZeroCopySink.sol:\n\t- pragma solidity^0.5.0 (ZeroCopySink.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            switch iszero(b)\n\n            case 1 {\n\n                mstore(add(buff, 0x20), shl(248, 0x00))\n\n                // mstore8(add(buff, 0x20), 0x00)\n\n            }\n\n            default {\n\n                mstore(add(buff, 0x20), shl(248, 0x01))\n\n                // mstore8(add(buff, 0x20), 0x01)\n\n            }\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteBool' (ZeroCopySink.sol#24-41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 49,
                    "vulnerability_code": "    function WriteByte(byte b) internal pure returns (bytes memory) {\n\n        return WriteUint8(uint8(b));\n",
                    "message": "Function 'ZeroCopySink.WriteByte' (ZeroCopySink.sol#47-49) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": 65,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            mstore(buff, 1)\n\n            mstore(add(buff, 0x20), shl(248, v))\n\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n\n            mstore(0x40, add(buff, 0x21))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint8' (ZeroCopySink.sol#55-65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": 90,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x02\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x22))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint16' (ZeroCopySink.sol#71-90) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": 114,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x04\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x24))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint32' (ZeroCopySink.sol#96-114) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": 139,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x08\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x28))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint64' (ZeroCopySink.sol#120-139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": 165,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n\n        bytes memory buff;\n\n\n\n        assembly{\n\n            buff := mload(0x40)\n\n            let byteLen := 0x20\n\n            mstore(buff, byteLen)\n\n            for {\n\n                let mindex := 0x00\n\n                let vindex := 0x1f\n\n            } lt(mindex, byteLen) {\n\n                mindex := add(mindex, 0x01)\n\n                vindex := sub(vindex, 0x01)\n\n            }{\n\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n\n            }\n\n            mstore(0x40, add(buff, 0x40))\n\n        }\n\n        return buff;\n",
                    "message": "Function 'ZeroCopySink.WriteUint255' (ZeroCopySink.sol#145-165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": 174,
                    "vulnerability_code": "    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {\n\n        uint64 l = uint64(data.length);\n\n        return abi.encodePacked(WriteVarUint(l), data);\n",
                    "message": "Function 'ZeroCopySink.WriteVarBytes' (ZeroCopySink.sol#171-174) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": 186,
                    "vulnerability_code": "    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {\n\n        if (v < 0xFD){\n\n    \t\treturn WriteUint8(uint8(v));\n\n    \t} else if (v <= 0xFFFF) {\n\n    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n\n    \t} else if (v <= 0xFFFFFFFF) {\n\n            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n\n    \t} else {\n\n    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n\n    \t}\n",
                    "message": "Function 'ZeroCopySink.WriteVarUint' (ZeroCopySink.sol#176-186) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v < 0xFD){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v <= 0xFFFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t} else if (v <= 0xFFFFFFFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteBool(bool b) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly{\n",
                    "message": null
                }
            ]
        }
    }
}