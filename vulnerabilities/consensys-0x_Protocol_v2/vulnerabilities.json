{
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/sol-compiler/test/fixtures/contracts/base/Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
                    "message": "Token.totalSupply (Token.sol#8) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
                    "message": "Token.balanceOf (Token.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint _value) returns (bool success) {}\n",
                    "message": "Token.transfer (Token.sol#18) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n",
                    "message": "Token.transferFrom (Token.sol#25) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool success) {}\n",
                    "message": "Token.approve (Token.sol#31) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
                    "message": "Token.allowance (Token.sol#36) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": "Detected issues with version pragma in Token.sol:\n\t- pragma solidity^0.4.14 (Token.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/sol-compiler/test/fixtures/contracts/base/SafeMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": "Detected issues with version pragma in SafeMath.sol:\n\t- pragma solidity^0.4.14 (SafeMath.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safeMul(uint a, uint b) internal constant returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safeDiv(uint a, uint b) internal constant returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safeSub(uint a, uint b) internal constant returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safeAdd(uint a, uint b) internal constant returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/1.0.0/Token/Token_v1.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
                    "message": "Token_v1.totalSupply (Token_v1.sol#8) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
                    "message": "Token_v1.balanceOf (Token_v1.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint _value) returns (bool success) {}\n",
                    "message": "Token_v1.transfer (Token_v1.sol#18) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n",
                    "message": "Token_v1.transferFrom (Token_v1.sol#25) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool success) {}\n",
                    "message": "Token_v1.approve (Token_v1.sol#31) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
                    "message": "Token_v1.allowance (Token_v1.sol#36) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.11;\n",
                    "message": "Detected issues with version pragma in Token_v1.sol:\n\t- pragma solidity^0.4.11 (Token_v1.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": 40,
                    "vulnerability_code": "contract Token_v1 {\n\n\n\n    /// @return total amount of tokens\n\n    function totalSupply() constant returns (uint supply) {}\n\n\n\n    /// @param _owner The address from which the balance will be retrieved\n\n    /// @return The balance\n\n    function balanceOf(address _owner) constant returns (uint balance) {}\n\n\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n\n    /// @param _to The address of the recipient\n\n    /// @param _value The amount of token to be transferred\n\n    /// @return Whether the transfer was successful or not\n\n    function transfer(address _to, uint _value) returns (bool success) {}\n\n\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n\n    /// @param _from The address of the sender\n\n    /// @param _to The address of the recipient\n\n    /// @param _value The amount of token to be transferred\n\n    /// @return Whether the transfer was successful or not\n\n    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n\n\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n\n    /// @param _spender The address of the account able to transfer the tokens\n\n    /// @param _value The amount of wei to be approved for transfer\n\n    /// @return Whether the approval was successful or not\n\n    function approve(address _spender, uint _value) returns (bool success) {}\n\n\n\n    /// @param _owner The address of the account owning tokens\n\n    /// @param _spender The address of the account able to transfer the tokens\n\n    /// @return Amount of remaining tokens allowed to spent\n\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n\n\n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n",
                    "message": "Contract 'Token_v1' (Token_v1.sol#5-40) is not in CapWords\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.11;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/1.0.0/Exchange/IExchange_v1.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_26"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function ZRX_TOKEN_CONTRACT()\n\n      public view\n",
                    "message": "IExchange_v1.ZRX_TOKEN_CONTRACT (IExchange_v1.sol#42-44) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": 48,
                    "vulnerability_code": "    function TOKEN_TRANSFER_PROXY_CONTRACT()\n\n      public view\n",
                    "message": "IExchange_v1.TOKEN_TRANSFER_PROXY_CONTRACT (IExchange_v1.sol#46-48) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": 52,
                    "vulnerability_code": "    function EXTERNAL_QUERY_GAS_LIMIT()\n\n      public view\n",
                    "message": "IExchange_v1.EXTERNAL_QUERY_GAS_LIMIT (IExchange_v1.sol#50-52) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function VERSION()\n\n      public view\n",
                    "message": "IExchange_v1.VERSION (IExchange_v1.sol#54-56) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": 60,
                    "vulnerability_code": "    function filled(bytes32)\n\n      public view\n",
                    "message": "IExchange_v1.filled (IExchange_v1.sol#58-60) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function cancelled(bytes32)\n\n      public view\n",
                    "message": "IExchange_v1.cancelled (IExchange_v1.sol#62-64) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "    function getUnavailableTakerTokenAmount(bytes32 orderHash)\n\n        public constant\n",
                    "message": "IExchange_v1.getUnavailableTakerTokenAmount (IExchange_v1.sol#69-71) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 80,
                    "vulnerability_code": "    function getPartialAmount(uint numerator, uint denominator, uint target)\n\n        public constant\n",
                    "message": "IExchange_v1.getPartialAmount (IExchange_v1.sol#78-80) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": 89,
                    "vulnerability_code": "    function isRoundingError(uint numerator, uint denominator, uint target)\n\n        public constant\n",
                    "message": "IExchange_v1.isRoundingError (IExchange_v1.sol#87-89) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": 98,
                    "vulnerability_code": "    function getOrderHash(address[5] orderAddresses, uint[6] orderValues)\n\n        public\n\n        constant\n",
                    "message": "IExchange_v1.getOrderHash (IExchange_v1.sol#95-98) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 114,
                    "vulnerability_code": "    function isValidSignature(\n\n        address signer,\n\n        bytes32 hash,\n\n        uint8 v,\n\n        bytes32 r,\n\n        bytes32 s)\n\n        public constant\n",
                    "message": "IExchange_v1.isValidSignature (IExchange_v1.sol#107-114) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": 134,
                    "vulnerability_code": "    function fillOrder(\n\n          address[5] orderAddresses,\n\n          uint[6] orderValues,\n\n          uint fillTakerTokenAmount,\n\n          bool shouldThrowOnInsufficientBalanceOrAllowance,\n\n          uint8 v,\n\n          bytes32 r,\n\n          bytes32 s)\n\n          public\n",
                    "message": "IExchange_v1.fillOrder (IExchange_v1.sol#125-134) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": 146,
                    "vulnerability_code": "    function cancelOrder(\n\n        address[5] orderAddresses,\n\n        uint[6] orderValues,\n\n        uint cancelTakerTokenAmount)\n\n        public\n",
                    "message": "IExchange_v1.cancelOrder (IExchange_v1.sol#141-146) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function fillOrKillOrder(\n\n        address[5] orderAddresses,\n\n        uint[6] orderValues,\n\n        uint fillTakerTokenAmount,\n\n        uint8 v,\n\n        bytes32 r,\n\n        bytes32 s)\n",
                    "message": "IExchange_v1.fillOrKillOrder (IExchange_v1.sol#156-163) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": 181,
                    "vulnerability_code": "    function batchFillOrders(\n\n        address[5][] orderAddresses,\n\n        uint[6][] orderValues,\n\n        uint[] fillTakerTokenAmounts,\n\n        bool shouldThrowOnInsufficientBalanceOrAllowance,\n\n        uint8[] v,\n\n        bytes32[] r,\n\n        bytes32[] s)\n",
                    "message": "IExchange_v1.batchFillOrders (IExchange_v1.sol#173-181) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 190,
                    "vulnerability_to_line": 197,
                    "vulnerability_code": "    function batchFillOrKillOrders(\n\n        address[5][] orderAddresses,\n\n        uint[6][] orderValues,\n\n        uint[] fillTakerTokenAmounts,\n\n        uint8[] v,\n\n        bytes32[] r,\n\n        bytes32[] s)\n",
                    "message": "IExchange_v1.batchFillOrKillOrders (IExchange_v1.sol#190-197) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": 217,
                    "vulnerability_code": "    function fillOrdersUpTo(\n\n        address[5][] orderAddresses,\n\n        uint[6][] orderValues,\n\n        uint fillTakerTokenAmount,\n\n        bool shouldThrowOnInsufficientBalanceOrAllowance,\n\n        uint8[] v,\n\n        bytes32[] r,\n\n        bytes32[] s)\n\n        public\n",
                    "message": "IExchange_v1.fillOrdersUpTo (IExchange_v1.sol#208-217) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function batchCancelOrders(\n\n        address[5][] orderAddresses,\n\n        uint[6][] orderValues,\n\n        uint[] cancelTakerTokenAmounts)\n",
                    "message": "IExchange_v1.batchCancelOrders (IExchange_v1.sol#223-227) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.19;\n",
                    "message": "Detected issues with version pragma in IExchange_v1.sol:\n\t- pragma solidity^0.4.19 (IExchange_v1.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": 228,
                    "vulnerability_code": "contract IExchange_v1 {\n\n\n\n    // Error Codes\n\n    enum Errors {\n\n        ORDER_EXPIRED,                    // Order has already expired\n\n        ORDER_FULLY_FILLED_OR_CANCELLED,  // Order has already been fully filled or cancelled\n\n        ROUNDING_ERROR_TOO_LARGE,         // Rounding error too large\n\n        INSUFFICIENT_BALANCE_OR_ALLOWANCE // Insufficient balance or allowance for token transfer\n\n    }\n\n\n\n    event LogError(uint8 indexed errorId, bytes32 indexed orderHash);\n\n\n\n    event LogFill(\n\n        address indexed maker,\n\n        address taker,\n\n        address indexed feeRecipient,\n\n        address makerToken,\n\n        address takerToken,\n\n        uint filledMakerTokenAmount,\n\n        uint filledTakerTokenAmount,\n\n        uint paidMakerFee,\n\n        uint paidTakerFee,\n\n        bytes32 indexed tokens, // keccak256(makerToken, takerToken), allows subscribing to a token pair\n\n        bytes32 orderHash\n\n    );\n\n\n\n    event LogCancel(\n\n        address indexed maker,\n\n        address indexed feeRecipient,\n\n        address makerToken,\n\n        address takerToken,\n\n        uint cancelledMakerTokenAmount,\n\n        uint cancelledTakerTokenAmount,\n\n        bytes32 indexed tokens,\n\n        bytes32 orderHash\n\n    );\n\n    \n\n    function ZRX_TOKEN_CONTRACT()\n\n      public view\n\n      returns (address);\n\n      \n\n    function TOKEN_TRANSFER_PROXY_CONTRACT()\n\n      public view\n\n      returns (address);\n\n      \n\n    function EXTERNAL_QUERY_GAS_LIMIT()\n\n      public view\n\n      returns (uint16);\n\n      \n\n    function VERSION()\n\n      public view\n\n      returns (string);\n\n    \n\n    function filled(bytes32)\n\n      public view\n\n      returns (uint256);\n\n      \n\n    function cancelled(bytes32)\n\n      public view\n\n      returns (uint256);\n\n    \n\n    /// @dev Calculates the sum of values already filled and cancelled for a given order.\n\n    /// @param orderHash The Keccak-256 hash of the given order.\n\n    /// @return Sum of values already filled and cancelled.\n\n    function getUnavailableTakerTokenAmount(bytes32 orderHash)\n\n        public constant\n\n        returns (uint);\n\n    \n\n    /// @dev Calculates partial value given a numerator and denominator.\n\n    /// @param numerator Numerator.\n\n    /// @param denominator Denominator.\n\n    /// @param target Value to calculate partial of.\n\n    /// @return Partial value of target.\n\n    function getPartialAmount(uint numerator, uint denominator, uint target)\n\n        public constant\n\n        returns (uint);\n\n    \n\n    /// @dev Checks if rounding error > 0.1%.\n\n    /// @param numerator Numerator.\n\n    /// @param denominator Denominator.\n\n    /// @param target Value to multiply with numerator/denominator.\n\n    /// @return Rounding error is present.\n\n    function isRoundingError(uint numerator, uint denominator, uint target)\n\n        public constant\n\n        returns (bool);\n\n      \n\n    /// @dev Calculates Keccak-256 hash of order with specified parameters.\n\n    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\n\n    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n\n    /// @return Keccak-256 hash of order.\n\n    function getOrderHash(address[5] orderAddresses, uint[6] orderValues)\n\n        public\n\n        constant\n\n        returns (bytes32);\n\n        \n\n    /// @dev Verifies that an order signature is valid.\n\n    /// @param signer address of signer.\n\n    /// @param hash Signed Keccak-256 hash.\n\n    /// @param v ECDSA signature parameter v.\n\n    /// @param r ECDSA signature parameters r.\n\n    /// @param s ECDSA signature parameters s.\n\n    /// @return Validity of order signature.\n\n    function isValidSignature(\n\n        address signer,\n\n        bytes32 hash,\n\n        uint8 v,\n\n        bytes32 r,\n\n        bytes32 s)\n\n        public constant\n\n        returns (bool);\n\n    \n\n    /// @dev Fills the input order.\n\n    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\n\n    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n\n    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n\n    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfer will fail before attempting.\n\n    /// @param v ECDSA signature parameter v.\n\n    /// @param r ECDSA signature parameters r.\n\n    /// @param s ECDSA signature parameters s.\n\n    /// @return Total amount of takerToken filled in trade.\n\n    function fillOrder(\n\n          address[5] orderAddresses,\n\n          uint[6] orderValues,\n\n          uint fillTakerTokenAmount,\n\n          bool shouldThrowOnInsufficientBalanceOrAllowance,\n\n          uint8 v,\n\n          bytes32 r,\n\n          bytes32 s)\n\n          public\n\n          returns (uint filledTakerTokenAmount);\n\n      \n\n    /// @dev Cancels the input order.\n\n    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\n\n    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n\n    /// @param cancelTakerTokenAmount Desired amount of takerToken to cancel in order.\n\n    /// @return Amount of takerToken cancelled.\n\n    function cancelOrder(\n\n        address[5] orderAddresses,\n\n        uint[6] orderValues,\n\n        uint cancelTakerTokenAmount)\n\n        public\n\n        returns (uint);\n\n\n\n\n\n    /// @dev Fills an order with specified parameters and ECDSA signature, throws if specified amount not filled entirely.\n\n    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\n\n    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n\n    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n\n    /// @param v ECDSA signature parameter v.\n\n    /// @param r ECDSA signature parameters r.\n\n    /// @param s ECDSA signature parameters s.\n\n    function fillOrKillOrder(\n\n        address[5] orderAddresses,\n\n        uint[6] orderValues,\n\n        uint fillTakerTokenAmount,\n\n        uint8 v,\n\n        bytes32 r,\n\n        bytes32 s)\n\n        public;\n\n\n\n    /// @dev Synchronously executes multiple fill orders in a single transaction.\n\n    /// @param orderAddresses Array of address arrays containing individual order addresses.\n\n    /// @param orderValues Array of uint arrays containing individual order values.\n\n    /// @param fillTakerTokenAmounts Array of desired amounts of takerToken to fill in orders.\n\n    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfers will fail before attempting.\n\n    /// @param v Array ECDSA signature v parameters.\n\n    /// @param r Array of ECDSA signature r parameters.\n\n    /// @param s Array of ECDSA signature s parameters.\n\n    function batchFillOrders(\n\n        address[5][] orderAddresses,\n\n        uint[6][] orderValues,\n\n        uint[] fillTakerTokenAmounts,\n\n        bool shouldThrowOnInsufficientBalanceOrAllowance,\n\n        uint8[] v,\n\n        bytes32[] r,\n\n        bytes32[] s)\n\n        public;\n\n\n\n    /// @dev Synchronously executes multiple fillOrKill orders in a single transaction.\n\n    /// @param orderAddresses Array of address arrays containing individual order addresses.\n\n    /// @param orderValues Array of uint arrays containing individual order values.\n\n    /// @param fillTakerTokenAmounts Array of desired amounts of takerToken to fill in orders.\n\n    /// @param v Array ECDSA signature v parameters.\n\n    /// @param r Array of ECDSA signature r parameters.\n\n    /// @param s Array of ECDSA signature s parameters.\n\n    function batchFillOrKillOrders(\n\n        address[5][] orderAddresses,\n\n        uint[6][] orderValues,\n\n        uint[] fillTakerTokenAmounts,\n\n        uint8[] v,\n\n        bytes32[] r,\n\n        bytes32[] s)\n\n        public;\n\n\n\n    /// @dev Synchronously executes multiple fill orders in a single transaction until total fillTakerTokenAmount filled.\n\n    /// @param orderAddresses Array of address arrays containing individual order addresses.\n\n    /// @param orderValues Array of uint arrays containing individual order values.\n\n    /// @param fillTakerTokenAmount Desired total amount of takerToken to fill in orders.\n\n    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfers will fail before attempting.\n\n    /// @param v Array ECDSA signature v parameters.\n\n    /// @param r Array of ECDSA signature r parameters.\n\n    /// @param s Array of ECDSA signature s parameters.\n\n    /// @return Total amount of fillTakerTokenAmount filled in orders.\n\n    function fillOrdersUpTo(\n\n        address[5][] orderAddresses,\n\n        uint[6][] orderValues,\n\n        uint fillTakerTokenAmount,\n\n        bool shouldThrowOnInsufficientBalanceOrAllowance,\n\n        uint8[] v,\n\n        bytes32[] r,\n\n        bytes32[] s)\n\n        public\n\n        returns (uint);\n\n\n\n    /// @dev Synchronously cancels multiple orders in a single transaction.\n\n    /// @param orderAddresses Array of address arrays containing individual order addresses.\n\n    /// @param orderValues Array of uint arrays containing individual order values.\n\n    /// @param cancelTakerTokenAmounts Array of desired amounts of takerToken to cancel in orders.\n\n    function batchCancelOrders(\n\n        address[5][] orderAddresses,\n\n        uint[6][] orderValues,\n\n        uint[] cancelTakerTokenAmounts)\n\n        public;\n",
                    "message": "Contract 'IExchange_v1' (IExchange_v1.sol#5-228) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function ZRX_TOKEN_CONTRACT()\n\n      public view\n",
                    "message": "Function 'IExchange_v1.ZRX_TOKEN_CONTRACT' (IExchange_v1.sol#42-44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": 48,
                    "vulnerability_code": "    function TOKEN_TRANSFER_PROXY_CONTRACT()\n\n      public view\n",
                    "message": "Function 'IExchange_v1.TOKEN_TRANSFER_PROXY_CONTRACT' (IExchange_v1.sol#46-48) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": 52,
                    "vulnerability_code": "    function EXTERNAL_QUERY_GAS_LIMIT()\n\n      public view\n",
                    "message": "Function 'IExchange_v1.EXTERNAL_QUERY_GAS_LIMIT' (IExchange_v1.sol#50-52) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function VERSION()\n\n      public view\n",
                    "message": "Function 'IExchange_v1.VERSION' (IExchange_v1.sol#54-56) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function filled(bytes32)\n",
                    "message": "Parameter '' of IExchange_v1.filled (IExchange_v1.sol#58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function cancelled(bytes32)\n",
                    "message": "Parameter '' of IExchange_v1.cancelled (IExchange_v1.sol#62) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getUnavailableTakerTokenAmount(bytes32 orderHash)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPartialAmount(uint numerator, uint denominator, uint target)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isRoundingError(uint numerator, uint denominator, uint target)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getOrderHash(address[5] orderAddresses, uint[6] orderValues)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidSignature(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.19;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "      returns (string);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[5][] orderAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint[6][] orderValues,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint[] fillTakerTokenAmounts,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint8[] v,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes32[] r,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes32[] s)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[5][] orderAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint[6][] orderValues,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint[] fillTakerTokenAmounts,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint8[] v,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes32[] r,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes32[] s)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[5][] orderAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint[6][] orderValues,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint8[] v,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes32[] r,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes32[] s)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[5][] orderAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint[6][] orderValues,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint[] cancelTakerTokenAmounts)\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/1.0.0/Ownable/Ownable_v1.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": 28,
                    "vulnerability_code": "    function transferOwnership(address newOwner) onlyOwner {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable_v1.transferOwnership (Ownable_v1.sol#24-28) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.11;\n",
                    "message": "Detected issues with version pragma in Ownable_v1.sol:\n\t- pragma solidity^0.4.11 (Ownable_v1.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": 29,
                    "vulnerability_code": "contract Ownable_v1 {\n\n    address public owner;\n\n\n\n    function Ownable_v1() {\n\n        owner = msg.sender;\n\n    }\n\n\n\n    modifier onlyOwner() {\n\n        require(msg.sender == owner);\n\n        _;\n\n    }\n\n\n\n    function transferOwnership(address newOwner) onlyOwner {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n\n    }\n",
                    "message": "Contract 'Ownable_v1' (Ownable_v1.sol#12-29) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": 17,
                    "vulnerability_code": "    function Ownable_v1() {\n\n        owner = msg.sender;\n",
                    "message": "Function 'Ownable_v1.Ownable_v1' (Ownable_v1.sol#15-17) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.11;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function Ownable_v1() {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address newOwner) onlyOwner {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/1.0.0/Ownable/IOwnable_v1.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": 16,
                    "vulnerability_code": "    function owner()\n\n      public view\n",
                    "message": "IOwnable_v1.owner (IOwnable_v1.sol#14-16) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": 19,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n",
                    "message": "IOwnable_v1.transferOwnership (IOwnable_v1.sol#18-19) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.19;\n",
                    "message": "Detected issues with version pragma in IOwnable_v1.sol:\n\t- pragma solidity^0.4.19 (IOwnable_v1.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": 20,
                    "vulnerability_code": "contract IOwnable_v1 {\n\n  \n\n    function owner()\n\n      public view\n\n      returns (address);\n\n  \n\n    function transferOwnership(address newOwner)\n\n      public;\n",
                    "message": "Contract 'IOwnable_v1' (IOwnable_v1.sol#12-20) is not in CapWords\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.19;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/1.0.0/SafeMath/SafeMath_v1.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.11;\n",
                    "message": "Detected issues with version pragma in SafeMath_v1.sol:\n\t- pragma solidity^0.4.11 (SafeMath_v1.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": 75,
                    "vulnerability_code": "contract SafeMath_v1 {\n\n    function safeMul(uint a, uint b)\n\n        internal\n\n        constant\n\n        returns (uint256)\n\n    {\n\n        uint c = a * b;\n\n        assert(a == 0 || c / a == b);\n\n        return c;\n\n    }\n\n\n\n    function safeDiv(uint a, uint b)\n\n        internal\n\n        constant\n\n        returns (uint256)\n\n    {\n\n        uint c = a / b;\n\n        return c;\n\n    }\n\n\n\n    function safeSub(uint a, uint b)\n\n        internal\n\n        constant\n\n        returns (uint256)\n\n    {\n\n        assert(b <= a);\n\n        return a - b;\n\n    }\n\n\n\n    function safeAdd(uint a, uint b)\n\n        internal\n\n        constant\n\n        returns (uint256)\n\n    {\n\n        uint c = a + b;\n\n        assert(c >= a);\n\n        return c;\n\n    }\n\n\n\n    function max64(uint64 a, uint64 b)\n\n        internal\n\n        constant\n\n        returns (uint64)\n\n    {\n\n        return a >= b ? a : b;\n\n    }\n\n\n\n    function min64(uint64 a, uint64 b)\n\n        internal\n\n        constant\n\n        returns (uint64)\n\n    {\n\n        return a < b ? a : b;\n\n    }\n\n\n\n    function max256(uint256 a, uint256 b)\n\n        internal\n\n        constant\n\n        returns (uint256)\n\n    {\n\n        return a >= b ? a : b;\n\n    }\n\n\n\n    function min256(uint256 a, uint256 b)\n\n        internal\n\n        constant\n\n        returns (uint256)\n\n    {\n\n        return a < b ? a : b;\n\n    }\n",
                    "message": "Contract 'SafeMath_v1' (SafeMath_v1.sol#5-75) is not in CapWords\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safeMul(uint a, uint b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safeDiv(uint a, uint b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safeSub(uint a, uint b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safeAdd(uint a, uint b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function max64(uint64 a, uint64 b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function min64(uint64 a, uint64 b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function max256(uint256 a, uint256 b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function min256(uint256 a, uint256 b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.11;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/1.0.0/EtherDelta/AccountLevels.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 12,
                    "vulnerability_code": "    function accountLevel(address user) constant returns(uint) {\n\n        return 0;\n",
                    "message": "AccountLevels.accountLevel (AccountLevels.sol#10-12) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.19;\n",
                    "message": "Detected issues with version pragma in AccountLevels.sol:\n\t- pragma solidity^0.4.19 (AccountLevels.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function accountLevel(address user) constant returns(uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.19;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function accountLevel(address user) constant returns(uint) {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/forwarder/mixins/MAssets.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/forwarder/mixins/MWeth.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/forwarder/mixins/MExchangeWrapper.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c / a == b,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b <= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_UNDERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c >= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
                    "message": "LibOrder.hashOrder (MExchangeWrapper.sol#164-210) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
                    "message": "LibOrder.hashOrder uses assembly (MExchangeWrapper.sol#164-210)\n\t- MExchangeWrapper.sol#189-209\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.24;\n",
                    "message": "Different versions of Solidity is used in MExchangeWrapper.sol:\n\t- Version used: ['0.4.24', 'ABIEncoderV2']\n\t- MExchangeWrapper.sol#21 declares pragma solidity0.4.24\n\t- MExchangeWrapper.sol#90 declares pragma solidity0.4.24\n\t- MExchangeWrapper.sol#215 declares pragma solidity0.4.24\n\t- MExchangeWrapper.sol#322 declares pragma solidity0.4.24\n\t- MExchangeWrapper.sol#376 declares pragma solidity0.4.24\n\t- MExchangeWrapper.sol#377 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (MExchangeWrapper.sol#45) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/forwarder/libs/LibForwarderErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant FEE_PERCENTAGE_TOO_LARGE = \"FEE_PROPORTION_TOO_LARGE\";                        // Provided fee percentage greater than 5%.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INSUFFICIENT_ETH_REMAINING = \"INSUFFICIENT_ETH_REMAINING\";                    // Not enough ETH remaining to pay feeRecipient.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant OVERSOLD_WETH = \"OVERSOLD_WETH\";                                              // More WETH sold than provided with current message call.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant COMPLETE_FILL_FAILED = \"COMPLETE_FILL_FAILED\";                                // Desired purchase amount not completely filled (required for ZRX fees only).\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant TRANSFER_FAILED = \"TRANSFER_FAILED\";                                          // Asset transfer failed.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant UNSUPPORTED_TOKEN_PROXY = \"UNSUPPORTED_TOKEN_PROXY\";                          // Proxy in assetData not supported.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant DEFAULT_FUNCTION_WETH_CONTRACT_ONLY = \"DEFAULT_FUNCTION_WETH_CONTRACT_ONLY\";  // Fallback function may only be used for WETH withdrawals.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_MSG_VALUE = \"INVALID_MSG_VALUE\";                                      // msg.value must be greater than 0.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_AMOUNT = \"INVALID_AMOUNT\";                                            // Amount must equal 1.\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/forwarder/interfaces/IForwarderCore.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c / a == b,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b <= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_UNDERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c >= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
                    "message": "LibOrder.hashOrder (IForwarderCore.sol#164-210) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
                    "message": "LibOrder.hashOrder uses assembly (IForwarderCore.sol#164-210)\n\t- IForwarderCore.sol#189-209\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.24;\n",
                    "message": "Different versions of Solidity is used in IForwarderCore.sol:\n\t- Version used: ['0.4.24', 'ABIEncoderV2']\n\t- IForwarderCore.sol#21 declares pragma solidity0.4.24\n\t- IForwarderCore.sol#90 declares pragma solidity0.4.24\n\t- IForwarderCore.sol#215 declares pragma solidity0.4.24\n\t- IForwarderCore.sol#322 declares pragma solidity0.4.24\n\t- IForwarderCore.sol#376 declares pragma solidity0.4.24\n\t- IForwarderCore.sol#377 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 393,
                    "vulnerability_to_line": 406,
                    "vulnerability_code": "    function marketSellOrdersWithEth(\n\n        LibOrder.Order[] memory orders,\n\n        bytes[] memory signatures,\n\n        LibOrder.Order[] memory feeOrders,\n\n        bytes[] memory feeSignatures,\n\n        uint256  feePercentage,\n\n        address feeRecipient\n\n    )\n\n        public\n\n        payable\n\n        returns (\n\n            LibFillResults.FillResults memory orderFillResults,\n\n            LibFillResults.FillResults memory feeOrderFillResults\n",
                    "message": "IForwarderCore.marketSellOrdersWithEth (IForwarderCore.sol#393-406) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": 433,
                    "vulnerability_code": "    function marketBuyOrdersWithEth(\n\n        LibOrder.Order[] memory orders,\n\n        uint256 makerAssetFillAmount,\n\n        bytes[] memory signatures,\n\n        LibOrder.Order[] memory feeOrders,\n\n        bytes[] memory feeSignatures,\n\n        uint256  feePercentage,\n\n        address feeRecipient\n\n    )\n\n        public\n\n        payable\n\n        returns (\n\n            LibFillResults.FillResults memory orderFillResults,\n\n            LibFillResults.FillResults memory feeOrderFillResults\n",
                    "message": "IForwarderCore.marketBuyOrdersWithEth (IForwarderCore.sol#419-433) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (IForwarderCore.sol#45) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract IForwarderCore {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/forwarder/interfaces/IAssets.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestSignatureValidator/TestSignatureValidator.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 872,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 873,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isValidSignature(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 874,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                hash,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 875,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                signerAddress,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 876,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                signature\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 877,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 878,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_SIGNATURE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 879,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 915,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            signature.length > 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 917,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"LENGTH_GREATER_THAN_0_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 918,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 922,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 923,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            signatureTypeRaw < uint8(SignatureType.NSignatureTypes),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 924,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SIGNATURE_UNSUPPORTED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 925,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 942,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"SIGNATURE_ILLEGAL\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 949,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 950,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                signature.length == 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 951,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_0_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 952,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 958,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                signature.length == 65,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 960,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_65_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 961,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 971,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 972,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                signature.length == 65,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 973,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_65_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 999,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1000,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                signature.length == 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_0_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1002,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1049,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1050,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                signature.length == 65,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1051,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_65_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        revert(\"SIGNATURE_UNSUPPORTED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentContextAddress == address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"REENTRANCY_ILLEGAL\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !transactions[transactionHash],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_TX_HASH\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                isValidSignature(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    transactionHash,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    signerAddress,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    signature\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"INVALID_TX_SIGNATURE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1315,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this).delegatecall(data),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FAILED_EXECUTION\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_31"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (TestSignatureValidator.sol#33-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (TestSignatureValidator.sol#47-56) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (TestSignatureValidator.sol#62-163) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (TestSignatureValidator.sol#203-227) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (TestSignatureValidator.sol#232-251) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 275,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes (TestSignatureValidator.sol#256-275) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (TestSignatureValidator.sol#299-325) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (TestSignatureValidator.sol#331-371) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (TestSignatureValidator.sol#377-398) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": 424,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (TestSignatureValidator.sol#404-424) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": 479,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (TestSignatureValidator.sol#460-479) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 511,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength (TestSignatureValidator.sol#487-511) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1331,
                    "vulnerability_to_line": 1361,
                    "vulnerability_code": "    function hashZeroExTransaction(\n\n        uint256 salt,\n\n        address signerAddress,\n\n        bytes memory data\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH;\n\n        bytes32 dataHash = keccak256(data);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH,\n\n        //     salt,\n\n        //     signerAddress,\n\n        //     keccak256(data)\n\n        // ));\n\n\n\n        assembly {\n\n            let memPtr := mload(64)\n\n            mstore(memPtr, schemaHash)\n\n            mstore(add(memPtr, 32), salt)\n\n            mstore(add(memPtr, 64), and(signerAddress, 0xffffffffffffffffffffffffffffffffffffffff))\n\n            mstore(add(memPtr, 96), dataHash)\n\n            result := keccak256(memPtr, 128)\n\n        }\n\n\n\n        return result;\n",
                    "message": "MixinTransactions.hashZeroExTransaction (TestSignatureValidator.sol#1331-1361) is declared view but contains assembly code\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1271,
                    "vulnerability_to_line": 1324,
                    "vulnerability_code": "    function executeTransaction(\n\n        uint256 salt,\n\n        address signerAddress,\n\n        bytes data,\n\n        bytes signature\n\n    )\n\n        external\n\n    {\n\n        // Prevent reentrancy\n\n        require(\n\n            currentContextAddress == address(0),\n\n            \"REENTRANCY_ILLEGAL\"\n\n        );\n\n\n\n        bytes32 transactionHash = hashEIP712Message(hashZeroExTransaction(\n\n            salt,\n\n            signerAddress,\n\n            data\n\n        ));\n\n\n\n        // Validate transaction has not been executed\n\n        require(\n\n            !transactions[transactionHash],\n\n            \"INVALID_TX_HASH\"\n\n        );\n\n\n\n        // Transaction always valid if signer is sender of transaction\n\n        if (signerAddress != msg.sender) {\n\n            // Validate signature\n\n            require(\n\n                isValidSignature(\n\n                    transactionHash,\n\n                    signerAddress,\n\n                    signature\n\n                ),\n\n                \"INVALID_TX_SIGNATURE\"\n\n            );\n\n\n\n            // Set the current transaction signer\n\n            currentContextAddress = signerAddress;\n\n        }\n\n\n\n        // Execute transaction\n\n        transactions[transactionHash] = true;\n\n        require(\n\n            address(this).delegatecall(data),\n\n            \"FAILED_EXECUTION\"\n\n        );\n\n\n\n        // Reset current transaction signer if it was previously updated\n\n        if (signerAddress != msg.sender) {\n\n            currentContextAddress = address(0);\n\n        }\n",
                    "message": "Reentrancy in MixinTransactions.executeTransaction (TestSignatureValidator.sol#1271-1324):\n\tExternal calls:\n\t- require(bool,string)(address(this).delegatecall(data),FAILED_EXECUTION) (TestSignatureValidator.sol#1315-1318)\n\tState variables written after the call(s):\n\t- currentContextAddress (TestSignatureValidator.sol#1322)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 864,
                    "vulnerability_to_line": 881,
                    "vulnerability_code": "    function preSign(\n\n        bytes32 hash,\n\n        address signerAddress,\n\n        bytes signature\n\n    )\n\n        external\n\n    {\n\n        // SWC-Lack of Proper Signature Verification: L52-L59\n\n        require(\n\n            isValidSignature(\n\n                hash,\n\n                signerAddress,\n\n                signature\n\n            ),\n\n            \"INVALID_SIGNATURE\"\n\n        );\n\n        preSigned[hash][signerAddress] = true;\n",
                    "message": "Reentrancy in MixinSignatureValidator.preSign (TestSignatureValidator.sol#864-881):\n\tExternal calls:\n\t- require(bool,string)(isValidSignature(hash,signerAddress,signature),INVALID_SIGNATURE) (TestSignatureValidator.sol#872-879)\n\tState variables written after the call(s):\n\t- preSigned (TestSignatureValidator.sol#880)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (TestSignatureValidator.sol#33-42)\n\t- TestSignatureValidator.sol#38-41\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (TestSignatureValidator.sol#47-56)\n\t- TestSignatureValidator.sol#52-55\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (TestSignatureValidator.sol#62-163)\n\t- TestSignatureValidator.sol#74-80\n\t- TestSignatureValidator.sol#102-130\n\t- TestSignatureValidator.sol#131-161\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (TestSignatureValidator.sol#203-227)\n\t- TestSignatureValidator.sol#222-226\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (TestSignatureValidator.sol#232-251)\n\t- TestSignatureValidator.sol#245-250\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 275,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes uses assembly (TestSignatureValidator.sol#256-275)\n\t- TestSignatureValidator.sol#269-274\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (TestSignatureValidator.sol#299-325)\n\t- TestSignatureValidator.sol#318-324\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (TestSignatureValidator.sol#331-371)\n\t- TestSignatureValidator.sol#350-371\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (TestSignatureValidator.sol#377-398)\n\t- TestSignatureValidator.sol#394-397\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": 424,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (TestSignatureValidator.sol#404-424)\n\t- TestSignatureValidator.sol#421-424\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": 479,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (TestSignatureValidator.sol#460-479)\n\t- TestSignatureValidator.sol#472-478\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 511,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength uses assembly (TestSignatureValidator.sol#487-511)\n\t- TestSignatureValidator.sol#507-510\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1331,
                    "vulnerability_to_line": 1361,
                    "vulnerability_code": "    function hashZeroExTransaction(\n\n        uint256 salt,\n\n        address signerAddress,\n\n        bytes memory data\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH;\n\n        bytes32 dataHash = keccak256(data);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH,\n\n        //     salt,\n\n        //     signerAddress,\n\n        //     keccak256(data)\n\n        // ));\n\n\n\n        assembly {\n\n            let memPtr := mload(64)\n\n            mstore(memPtr, schemaHash)\n\n            mstore(add(memPtr, 32), salt)\n\n            mstore(add(memPtr, 64), and(signerAddress, 0xffffffffffffffffffffffffffffffffffffffff))\n\n            mstore(add(memPtr, 96), dataHash)\n\n            result := keccak256(memPtr, 128)\n\n        }\n\n\n\n        return result;\n",
                    "message": "MixinTransactions.hashZeroExTransaction uses assembly (TestSignatureValidator.sol#1331-1361)\n\t- TestSignatureValidator.sol#1351-1360\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1406,
                    "vulnerability_to_line": 1421,
                    "vulnerability_code": "    function publicIsValidSignature(\n\n        bytes32 hash,\n\n        address signer,\n\n        bytes memory signature\n\n    )\n\n        public\n\n        view\n\n        returns (bool isValid)\n\n    {\n\n        isValid = isValidSignature(\n\n            hash,\n\n            signer,\n\n            signature\n\n        );\n\n        return isValid;\n",
                    "message": "TestSignatureValidator.publicIsValidSignature (TestSignatureValidator.sol#1406-1421) should be declared external\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 1271,
                    "vulnerability_to_line": 1324,
                    "vulnerability_code": "    function executeTransaction(\n\n        uint256 salt,\n\n        address signerAddress,\n\n        bytes data,\n\n        bytes signature\n\n    )\n\n        external\n\n    {\n\n        // Prevent reentrancy\n\n        require(\n\n            currentContextAddress == address(0),\n\n            \"REENTRANCY_ILLEGAL\"\n\n        );\n\n\n\n        bytes32 transactionHash = hashEIP712Message(hashZeroExTransaction(\n\n            salt,\n\n            signerAddress,\n\n            data\n\n        ));\n\n\n\n        // Validate transaction has not been executed\n\n        require(\n\n            !transactions[transactionHash],\n\n            \"INVALID_TX_HASH\"\n\n        );\n\n\n\n        // Transaction always valid if signer is sender of transaction\n\n        if (signerAddress != msg.sender) {\n\n            // Validate signature\n\n            require(\n\n                isValidSignature(\n\n                    transactionHash,\n\n                    signerAddress,\n\n                    signature\n\n                ),\n\n                \"INVALID_TX_SIGNATURE\"\n\n            );\n\n\n\n            // Set the current transaction signer\n\n            currentContextAddress = signerAddress;\n\n        }\n\n\n\n        // Execute transaction\n\n        transactions[transactionHash] = true;\n\n        require(\n\n            address(this).delegatecall(data),\n\n            \"FAILED_EXECUTION\"\n\n        );\n\n\n\n        // Reset current transaction signer if it was previously updated\n\n        if (signerAddress != msg.sender) {\n\n            currentContextAddress = address(0);\n\n        }\n",
                    "message": "Low level call in MixinTransactions.executeTransaction (TestSignatureValidator.sol#1271-1324):\n\t-require(bool,string)(address(this).delegatecall(data),FAILED_EXECUTION) TestSignatureValidator.sol#1315-1318\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (TestSignatureValidator.sol#1195) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentContextAddress = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 941,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (signatureType == SignatureType.Illegal) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytesWithLength(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashZeroExTransaction(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 507,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant ORDER_UNFILLABLE = \"ORDER_UNFILLABLE\";                              // Order cannot be filled.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_MAKER = \"INVALID_MAKER\";                                    // Invalid makerAddress.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_TAKER = \"INVALID_TAKER\";                                    // Invalid takerAddress.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_SENDER = \"INVALID_SENDER\";                                  // Invalid `msg.sender`.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_ORDER_SIGNATURE = \"INVALID_ORDER_SIGNATURE\";                // Signature validation failed. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_TAKER_AMOUNT = \"INVALID_TAKER_AMOUNT\";                      // takerAssetFillAmount cannot equal 0.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant ROUNDING_ERROR = \"ROUNDING_ERROR\";                                  // Rounding error greater than 0.1% of takerAssetFillAmount. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_SIGNATURE = \"INVALID_SIGNATURE\";                            // Signature validation failed. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant SIGNATURE_ILLEGAL = \"SIGNATURE_ILLEGAL\";                            // Signature type is illegal.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant SIGNATURE_UNSUPPORTED = \"SIGNATURE_UNSUPPORTED\";                    // Signature type unsupported.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_NEW_ORDER_EPOCH = \"INVALID_NEW_ORDER_EPOCH\";                // Specified salt must be greater than or equal to existing orderEpoch.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant COMPLETE_FILL_FAILED = \"COMPLETE_FILL_FAILED\";                      // Desired takerAssetFillAmount could not be completely filled. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NEGATIVE_SPREAD_REQUIRED = \"NEGATIVE_SPREAD_REQUIRED\";              // Matched orders must have a negative spread.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant REENTRANCY_ILLEGAL = \"REENTRANCY_ILLEGAL\";                          // Recursive reentrancy is not allowed. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_TX_HASH = \"INVALID_TX_HASH\";                                // Transaction has already been executed. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_TX_SIGNATURE = \"INVALID_TX_SIGNATURE\";                      // Signature validation failed. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant FAILED_EXECUTION = \"FAILED_EXECUTION\";                              // Transaction execution failed. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant ASSET_PROXY_ALREADY_EXISTS = \"ASSET_PROXY_ALREADY_EXISTS\";          // AssetProxy with same id already exists.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant ASSET_PROXY_DOES_NOT_EXIST = \"ASSET_PROXY_DOES_NOT_EXIST\";          // No assetProxy registered at given id.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant TRANSFER_FAILED = \"TRANSFER_FAILED\";                                // Asset transfer unsuccesful.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant LENGTH_GREATER_THAN_0_REQUIRED = \"LENGTH_GREATER_THAN_0_REQUIRED\";  // Byte array must have a length greater than 0.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant LENGTH_GREATER_THAN_3_REQUIRED = \"LENGTH_GREATER_THAN_3_REQUIRED\";  // Byte array must have a length greater than 3.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant LENGTH_0_REQUIRED = \"LENGTH_0_REQUIRED\";                            // Byte array must have a length of 0.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant LENGTH_65_REQUIRED = \"LENGTH_65_REQUIRED\";                          // Byte array must have a length of 65.\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestAssetProxyDispatcher/TestAssetProxyDispatcher.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 830,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 315,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 363,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 393,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 395,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 466,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 556,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 557,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 558,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 581,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 582,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 583,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 584,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 609,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentAssetProxy == address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 853,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ASSET_PROXY_ALREADY_EXISTS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 891,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 892,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assetData.length > 3,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 893,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 907,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 908,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assetProxy != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 909,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"ASSET_PROXY_DOES_NOT_EXIST\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 910,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 315,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 363,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 393,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 395,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 466,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 556,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 557,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 558,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 581,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 582,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 583,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 584,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 609,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_29"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": 96,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (TestAssetProxyDispatcher.sol#87-96) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 110,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (TestAssetProxyDispatcher.sol#101-110) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 217,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (TestAssetProxyDispatcher.sol#116-217) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": 281,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (TestAssetProxyDispatcher.sol#257-281) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": 305,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (TestAssetProxyDispatcher.sol#286-305) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": 329,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes (TestAssetProxyDispatcher.sol#310-329) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": 379,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (TestAssetProxyDispatcher.sol#353-379) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": 425,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (TestAssetProxyDispatcher.sol#385-425) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": 452,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (TestAssetProxyDispatcher.sol#431-452) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": 478,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (TestAssetProxyDispatcher.sol#458-478) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 514,
                    "vulnerability_to_line": 533,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (TestAssetProxyDispatcher.sol#514-533) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": 565,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength (TestAssetProxyDispatcher.sol#541-565) is declared view but contains assembly code\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 842,
                    "vulnerability_to_line": 862,
                    "vulnerability_code": "    function registerAssetProxy(address assetProxy)\n\n        external\n\n        onlyOwner\n\n    {\n\n        IAssetProxy assetProxyContract = IAssetProxy(assetProxy);\n\n\n\n        // Ensure that no asset proxy exists with current id.\n\n        bytes4 assetProxyId = assetProxyContract.getProxyId();\n\n        address currentAssetProxy = assetProxies[assetProxyId];\n\n        require(\n\n            currentAssetProxy == address(0),\n\n            \"ASSET_PROXY_ALREADY_EXISTS\"\n\n        );\n\n\n\n        // Add asset proxy and log registration.\n\n        assetProxies[assetProxyId] = assetProxyContract;\n\n        emit AssetProxyRegistered(\n\n            assetProxyId,\n\n            assetProxy\n\n        );\n",
                    "message": "Reentrancy in MixinAssetProxyDispatcher.registerAssetProxy (TestAssetProxyDispatcher.sol#842-862):\n\tExternal calls:\n\t- assetProxyId = assetProxyContract.getProxyId() (TestAssetProxyDispatcher.sol#849)\n\tState variables written after the call(s):\n\t- assetProxies (TestAssetProxyDispatcher.sol#857)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": 96,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (TestAssetProxyDispatcher.sol#87-96)\n\t- TestAssetProxyDispatcher.sol#92-95\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 110,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (TestAssetProxyDispatcher.sol#101-110)\n\t- TestAssetProxyDispatcher.sol#106-109\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 217,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (TestAssetProxyDispatcher.sol#116-217)\n\t- TestAssetProxyDispatcher.sol#128-134\n\t- TestAssetProxyDispatcher.sol#156-184\n\t- TestAssetProxyDispatcher.sol#185-215\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": 281,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (TestAssetProxyDispatcher.sol#257-281)\n\t- TestAssetProxyDispatcher.sol#276-280\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": 305,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (TestAssetProxyDispatcher.sol#286-305)\n\t- TestAssetProxyDispatcher.sol#299-304\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": 329,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes uses assembly (TestAssetProxyDispatcher.sol#310-329)\n\t- TestAssetProxyDispatcher.sol#323-328\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": 379,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (TestAssetProxyDispatcher.sol#353-379)\n\t- TestAssetProxyDispatcher.sol#372-378\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": 425,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (TestAssetProxyDispatcher.sol#385-425)\n\t- TestAssetProxyDispatcher.sol#404-425\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": 452,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (TestAssetProxyDispatcher.sol#431-452)\n\t- TestAssetProxyDispatcher.sol#448-451\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": 478,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (TestAssetProxyDispatcher.sol#458-478)\n\t- TestAssetProxyDispatcher.sol#475-478\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 514,
                    "vulnerability_to_line": 533,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (TestAssetProxyDispatcher.sol#514-533)\n\t- TestAssetProxyDispatcher.sol#526-532\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": 565,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength uses assembly (TestAssetProxyDispatcher.sol#541-565)\n\t- TestAssetProxyDispatcher.sol#561-564\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 880,
                    "vulnerability_to_line": 979,
                    "vulnerability_code": "    function dispatchTransferFrom(\n\n        bytes memory assetData,\n\n        address from,\n\n        address to,\n\n        uint256 amount\n\n    )\n\n        internal\n\n    {\n\n        // Do nothing if no amount should be transferred.\n\n        if (amount > 0) {\n\n            // Ensure assetData length is valid\n\n            require(\n\n                assetData.length > 3,\n\n                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n\n            );\n\n            \n\n            // Lookup assetProxy\n\n            bytes4 assetProxyId;\n\n            assembly {\n\n                assetProxyId := and(mload(\n\n                    add(assetData, 32)),\n\n                    0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n\n                )\n\n            }\n\n            address assetProxy = assetProxies[assetProxyId];\n\n\n\n            // Ensure that assetProxy exists\n\n            require(\n\n                assetProxy != address(0),\n\n                \"ASSET_PROXY_DOES_NOT_EXIST\"\n\n            );\n\n            \n\n            // We construct calldata for the `assetProxy.transferFrom` ABI.\n\n            // The layout of this calldata is in the table below.\n\n            // \n\n            // | Area     | Offset | Length  | Contents                                    |\n\n            // | -------- |--------|---------|-------------------------------------------- |\n\n            // | Header   | 0      | 4       | function selector                           |\n\n            // | Params   |        | 4 * 32  | function parameters:                        |\n\n            // |          | 4      |         |   1. offset to assetData (*)                |\n\n            // |          | 36     |         |   2. from                                   |\n\n            // |          | 68     |         |   3. to                                     |\n\n            // |          | 100    |         |   4. amount                                 |\n\n            // | Data     |        |         | assetData:                                  |\n\n            // |          | 132    | 32      | assetData Length                            |\n\n            // |          | 164    | **      | assetData Contents                          |\n\n\n\n            assembly {\n\n                /////// Setup State ///////\n\n                // `cdStart` is the start of the calldata for `assetProxy.transferFrom` (equal to free memory ptr).\n\n                let cdStart := mload(64)\n\n                // `dataAreaLength` is the total number of words needed to store `assetData`\n\n                //  As-per the ABI spec, this value is padded up to the nearest multiple of 32,\n\n                //  and includes 32-bytes for length.\n\n                let dataAreaLength := and(add(mload(assetData), 63), 0xFFFFFFFFFFFE0)\n\n                // `cdEnd` is the end of the calldata for `assetProxy.transferFrom`.\n\n                let cdEnd := add(cdStart, add(132, dataAreaLength))\n\n\n\n                \n\n                /////// Setup Header Area ///////\n\n                // This area holds the 4-byte `transferFromSelector`.\n\n                // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n\n                mstore(cdStart, 0xa85e59e400000000000000000000000000000000000000000000000000000000)\n\n                \n\n                /////// Setup Params Area ///////\n\n                // Each parameter is padded to 32-bytes. The entire Params Area is 128 bytes.\n\n                // Notes:\n\n                //   1. The offset to `assetData` is the length of the Params Area (128 bytes).\n\n                //   2. A 20-byte mask is applied to addresses to zero-out the unused bytes.\n\n                mstore(add(cdStart, 4), 128)\n\n                mstore(add(cdStart, 36), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(cdStart, 68), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(cdStart, 100), amount)\n\n                \n\n                /////// Setup Data Area ///////\n\n                // This area holds `assetData`.\n\n                let dataArea := add(cdStart, 132)\n\n                // solhint-disable-next-line no-empty-blocks\n\n                for {} lt(dataArea, cdEnd) {} {\n\n                    mstore(dataArea, mload(assetData))\n\n                    dataArea := add(dataArea, 32)\n\n                    assetData := add(assetData, 32)\n\n                }\n\n\n\n                /////// Call `assetProxy.transferFrom` using the constructed calldata ///////\n\n                let success := call(\n\n                    gas,                    // forward all gas\n\n                    assetProxy,             // call address of asset proxy\n\n                    0,                      // don't send any ETH\n\n                    cdStart,                // pointer to start of input\n\n                    sub(cdEnd, cdStart),    // length of input  \n\n                    cdStart,                // write output over input\n\n                    512                     // reserve 512 bytes for output\n\n                )\n\n                if iszero(success) {\n\n                    revert(cdStart, returndatasize())\n\n                }\n\n            }\n\n        }\n",
                    "message": "MixinAssetProxyDispatcher.dispatchTransferFrom uses assembly (TestAssetProxyDispatcher.sol#880-979)\n\t- TestAssetProxyDispatcher.sol#898-904\n\t- TestAssetProxyDispatcher.sol#927-978\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": 14,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n",
                    "message": "IOwnable.transferOwnership (TestAssetProxyDispatcher.sol#13-14) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": 52,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable.transferOwnership (TestAssetProxyDispatcher.sol#45-52) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1007,
                    "vulnerability_to_line": 1016,
                    "vulnerability_code": "    function publicDispatchTransferFrom(\n\n        bytes memory assetData,\n\n        address from,\n\n        address to,\n\n        uint256 amount\n\n    )\n\n        public\n\n    {\n\n        dispatchTransferFrom(assetData, from, to, amount);\n",
                    "message": "TestAssetProxyDispatcher.publicDispatchTransferFrom (TestAssetProxyDispatcher.sol#1007-1016) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytesWithLength(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 323,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 372,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 448,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 475,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 898,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 927,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/Mintable/Mintable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowed[_from][msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c / a == b,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b <= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_UNDERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c >= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _value <= 100000000000000000000,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 357,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"Minting more than 100000000000000000000 is not allowed.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _value <= 100000000000000000000,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 357,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"Minting more than 100000000000000000000 is not allowed.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_27"
            ],
            "vulnerability_findings": [
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 allowance = allowed[_from][msg.sender];\n",
                    "message": "UnlimitedAllowanceToken.transferFrom.allowance (local variable @ Mintable.sol#209) shadows:\n\t- ERC20Token.allowance (function @ Mintable.sol#165-171)\n\t- IERC20Token.allowance (function @ Mintable.sol#60-62)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": 32,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n\n        public\n",
                    "message": "IERC20Token.transfer (Mintable.sol#30-32) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 123,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n\n        public\n\n        returns (bool)\n\n    {\n\n        require(\n\n            balances[msg.sender] >= _value,\n\n            \"ERC20_INSUFFICIENT_BALANCE\"\n\n        );\n\n        require(\n\n            balances[_to] + _value >= balances[_to],\n\n            \"OVERFLOW\"\n\n        );\n\n        balances[msg.sender] -= _value;\n\n        balances[_to] += _value;\n\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n",
                    "message": "ERC20Token.transfer (Mintable.sol#107-123) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n\n        public\n",
                    "message": "IERC20Token.transferFrom (Mintable.sol#39-41) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": 229,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n\n        public\n\n        returns (bool)\n\n    {\n\n        uint256 allowance = allowed[_from][msg.sender];\n\n        require(\n\n            balances[_from] >= _value,\n\n            \"ERC20_INSUFFICIENT_BALANCE\"\n\n        );\n\n        require(\n\n            allowance >= _value,\n\n            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n\n        );\n\n        require(\n\n            balances[_to] + _value >= balances[_to],\n\n            \"OVERFLOW\"\n\n        );\n\n        balances[_to] += _value;\n\n        balances[_from] -= _value;\n\n        if (allowance < MAX_UINT) {\n\n            allowed[_from][msg.sender] -= _value;\n\n        }\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n",
                    "message": "UnlimitedAllowanceToken.transferFrom (Mintable.sol#205-229) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": 146,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n\n        public\n\n        returns (bool)\n\n    {\n\n        require(\n\n            balances[_from] >= _value,\n\n            \"ERC20_INSUFFICIENT_BALANCE\"\n\n        );\n\n        require(\n\n            allowed[_from][msg.sender] >= _value,\n\n            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n\n        );\n\n        require(\n\n            balances[_to] + _value >= balances[_to],\n\n            \"OVERFLOW\"\n\n        );\n\n        balances[_to] += _value;\n\n        balances[_from] -= _value;\n\n        allowed[_from][msg.sender] -= _value;\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n",
                    "message": "ERC20Token.transferFrom (Mintable.sol#125-146) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 49,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n\n        public\n",
                    "message": "IERC20Token.approve (Mintable.sol#47-49) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": 155,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n\n        public\n\n        returns (bool)\n\n    {\n\n        allowed[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n",
                    "message": "ERC20Token.approve (Mintable.sol#148-155) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function balanceOf(address _owner)\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        return balances[_owner];\n",
                    "message": "ERC20Token.balanceOf (Mintable.sol#157-163) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "    function balanceOf(address _owner)\n\n        public view\n",
                    "message": "IERC20Token.balanceOf (Mintable.sol#53-55) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": 62,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n\n        public view\n",
                    "message": "IERC20Token.allowance (Mintable.sol#60-62) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": 171,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        return allowed[_owner][_spender];\n",
                    "message": "ERC20Token.allowance (Mintable.sol#165-171) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": 361,
                    "vulnerability_code": "    function mint(uint256 _value)\n\n        public\n\n    {\n\n        require(\n\n            _value <= 100000000000000000000,\n\n            \"Minting more than 100000000000000000000 is not allowed.\"\n\n        );\n\n        balances[msg.sender] = safeAdd(_value, balances[msg.sender]);\n\n        totalSupply = safeAdd(totalSupply, _value);\n",
                    "message": "Mintable.mint (Mintable.sol#352-361) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of ERC20Token.transfer (Mintable.sol#107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.transfer (Mintable.sol#107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_from' of ERC20Token.transferFrom (Mintable.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of ERC20Token.transferFrom (Mintable.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.transferFrom (Mintable.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_spender' of ERC20Token.approve (Mintable.sol#148) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.approve (Mintable.sol#148) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner)\n",
                    "message": "Parameter '_owner' of ERC20Token.balanceOf (Mintable.sol#157) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_owner' of ERC20Token.allowance (Mintable.sol#165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_spender' of ERC20Token.allowance (Mintable.sol#165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_from' of UnlimitedAllowanceToken.transferFrom (Mintable.sol#205) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of UnlimitedAllowanceToken.transferFrom (Mintable.sol#205) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of UnlimitedAllowanceToken.transferFrom (Mintable.sol#205) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mint(uint256 _value)\n",
                    "message": "Parameter '_value' of Mintable.mint (Mintable.sol#352) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibs/TestLibs.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c / a == b,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b <= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_UNDERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c >= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_10"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": 374,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
                    "message": "LibOrder.hashOrder (TestLibs.sol#328-374) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": 374,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
                    "message": "LibOrder.hashOrder uses assembly (TestLibs.sol#328-374)\n\t- TestLibs.sol#353-373\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.24;\n",
                    "message": "Different versions of Solidity is used in TestLibs.sol:\n\t- Version used: ['0.4.24', 'ABIEncoderV2']\n\t- TestLibs.sol#3 declares pragma solidity0.4.24\n\t- TestLibs.sol#110 declares pragma solidity0.4.24\n\t- TestLibs.sol#185 declares pragma solidity0.4.24\n\t- TestLibs.sol#254 declares pragma solidity0.4.24\n\t- TestLibs.sol#397 declares pragma solidity0.4.24\n\t- TestLibs.sol#451 declares pragma solidity0.4.24\n\t- TestLibs.sol#452 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 476,
                    "vulnerability_code": "    function publicGetPartialAmount(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        public\n\n        pure\n\n        returns (uint256 partialAmount)\n\n    {\n\n        partialAmount = getPartialAmount(\n\n            numerator,\n\n            denominator,\n\n            target\n\n        );\n\n        return partialAmount;\n",
                    "message": "TestLibs.publicGetPartialAmount (TestLibs.sol#461-476) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 478,
                    "vulnerability_to_line": 493,
                    "vulnerability_code": "    function publicIsRoundingError(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        public\n\n        pure\n\n        returns (bool isError)\n\n    {\n\n        isError = isRoundingError(\n\n            numerator,\n\n            denominator,\n\n            target\n\n        );\n\n        return isError;\n",
                    "message": "TestLibs.publicIsRoundingError (TestLibs.sol#478-493) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 495,
                    "vulnerability_to_line": 502,
                    "vulnerability_code": "    function publicGetOrderHash(Order memory order)\n\n        public\n\n        view\n\n        returns (bytes32 orderHash)\n\n    {\n\n        orderHash = getOrderHash(order);\n\n        return orderHash;\n",
                    "message": "TestLibs.publicGetOrderHash (TestLibs.sol#495-502) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": 510,
                    "vulnerability_code": "    function getOrderSchemaHash()\n\n        public\n\n        pure\n\n        returns (bytes32)\n\n    {\n\n        return EIP712_ORDER_SCHEMA_HASH;\n",
                    "message": "TestLibs.getOrderSchemaHash (TestLibs.sol#504-510) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": 518,
                    "vulnerability_code": "    function getDomainSeparatorSchemaHash()\n\n        public\n\n        pure\n\n        returns (bytes32)\n\n    {\n\n        return EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;\n",
                    "message": "TestLibs.getDomainSeparatorSchemaHash (TestLibs.sol#512-518) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function publicAddFillResults(FillResults memory totalFillResults, FillResults memory singleFillResults)\n\n        public\n\n        pure\n\n        returns (FillResults memory)\n\n    {\n\n        addFillResults(totalFillResults, singleFillResults);\n\n        return totalFillResults;\n",
                    "message": "TestLibs.publicAddFillResults (TestLibs.sol#520-527) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (TestLibs.sol#209) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/DummyERC20Token/DummyERC20Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 395,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 449,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string _symbol,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _decimals,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _totalSupply\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        name = _name;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        symbol = _symbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowed[_from][msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c / a == b,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b <= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_UNDERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c >= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _value <= 100000000000000000000,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 357,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"Minting more than 100000000000000000000 is not allowed.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 402,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 403,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _value <= 100000000000000000000,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 357,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"Minting more than 100000000000000000000 is not allowed.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_34"
            ],
            "vulnerability_findings": [
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 allowance = allowed[_from][msg.sender];\n",
                    "message": "UnlimitedAllowanceToken.transferFrom.allowance (local variable @ DummyERC20Token.sol#209) shadows:\n\t- ERC20Token.allowance (function @ DummyERC20Token.sol#165-171)\n\t- IERC20Token.allowance (function @ DummyERC20Token.sol#60-62)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 123,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n\n        public\n\n        returns (bool)\n\n    {\n\n        require(\n\n            balances[msg.sender] >= _value,\n\n            \"ERC20_INSUFFICIENT_BALANCE\"\n\n        );\n\n        require(\n\n            balances[_to] + _value >= balances[_to],\n\n            \"OVERFLOW\"\n\n        );\n\n        balances[msg.sender] -= _value;\n\n        balances[_to] += _value;\n\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n",
                    "message": "ERC20Token.transfer (DummyERC20Token.sol#107-123) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": 32,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n\n        public\n",
                    "message": "IERC20Token.transfer (DummyERC20Token.sol#30-32) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": 146,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n\n        public\n\n        returns (bool)\n\n    {\n\n        require(\n\n            balances[_from] >= _value,\n\n            \"ERC20_INSUFFICIENT_BALANCE\"\n\n        );\n\n        require(\n\n            allowed[_from][msg.sender] >= _value,\n\n            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n\n        );\n\n        require(\n\n            balances[_to] + _value >= balances[_to],\n\n            \"OVERFLOW\"\n\n        );\n\n        balances[_to] += _value;\n\n        balances[_from] -= _value;\n\n        allowed[_from][msg.sender] -= _value;\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n",
                    "message": "ERC20Token.transferFrom (DummyERC20Token.sol#125-146) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n\n        public\n",
                    "message": "IERC20Token.transferFrom (DummyERC20Token.sol#39-41) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": 229,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n\n        public\n\n        returns (bool)\n\n    {\n\n        uint256 allowance = allowed[_from][msg.sender];\n\n        require(\n\n            balances[_from] >= _value,\n\n            \"ERC20_INSUFFICIENT_BALANCE\"\n\n        );\n\n        require(\n\n            allowance >= _value,\n\n            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n\n        );\n\n        require(\n\n            balances[_to] + _value >= balances[_to],\n\n            \"OVERFLOW\"\n\n        );\n\n        balances[_to] += _value;\n\n        balances[_from] -= _value;\n\n        if (allowance < MAX_UINT) {\n\n            allowed[_from][msg.sender] -= _value;\n\n        }\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n",
                    "message": "UnlimitedAllowanceToken.transferFrom (DummyERC20Token.sol#205-229) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 49,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n\n        public\n",
                    "message": "IERC20Token.approve (DummyERC20Token.sol#47-49) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": 155,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n\n        public\n\n        returns (bool)\n\n    {\n\n        allowed[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n",
                    "message": "ERC20Token.approve (DummyERC20Token.sol#148-155) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": 171,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        return allowed[_owner][_spender];\n",
                    "message": "ERC20Token.allowance (DummyERC20Token.sol#165-171) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": 62,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n\n        public view\n",
                    "message": "IERC20Token.allowance (DummyERC20Token.sol#60-62) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": 361,
                    "vulnerability_code": "    function mint(uint256 _value)\n\n        public\n\n    {\n\n        require(\n\n            _value <= 100000000000000000000,\n\n            \"Minting more than 100000000000000000000 is not allowed.\"\n\n        );\n\n        balances[msg.sender] = safeAdd(_value, balances[msg.sender]);\n\n        totalSupply = safeAdd(totalSupply, _value);\n",
                    "message": "Mintable.mint (DummyERC20Token.sol#352-361) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 408,
                    "vulnerability_to_line": 415,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable.transferOwnership (DummyERC20Token.sol#408-415) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": 377,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n",
                    "message": "IOwnable.transferOwnership (DummyERC20Token.sol#376-377) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function setBalance(address _target, uint256 _value)\n\n        public\n\n        onlyOwner\n\n    {\n\n        uint256 currBalance = balanceOf(_target);\n\n        if (_value < currBalance) {\n\n            totalSupply = safeSub(totalSupply, safeSub(currBalance, _value));\n\n        } else {\n\n            totalSupply = safeAdd(totalSupply, safeSub(_value, currBalance));\n\n        }\n\n        balances[_target] = _value;\n",
                    "message": "DummyERC20Token.setBalance (DummyERC20Token.sol#464-475) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of ERC20Token.transfer (DummyERC20Token.sol#107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.transfer (DummyERC20Token.sol#107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_from' of ERC20Token.transferFrom (DummyERC20Token.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of ERC20Token.transferFrom (DummyERC20Token.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.transferFrom (DummyERC20Token.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_spender' of ERC20Token.approve (DummyERC20Token.sol#148) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.approve (DummyERC20Token.sol#148) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner)\n",
                    "message": "Parameter '_owner' of ERC20Token.balanceOf (DummyERC20Token.sol#157) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_owner' of ERC20Token.allowance (DummyERC20Token.sol#165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_spender' of ERC20Token.allowance (DummyERC20Token.sol#165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_from' of UnlimitedAllowanceToken.transferFrom (DummyERC20Token.sol#205) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of UnlimitedAllowanceToken.transferFrom (DummyERC20Token.sol#205) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of UnlimitedAllowanceToken.transferFrom (DummyERC20Token.sol#205) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mint(uint256 _value)\n",
                    "message": "Parameter '_value' of Mintable.mint (DummyERC20Token.sol#352) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string _name,\n",
                    "message": "Parameter '_name' of DummyERC20Token. (DummyERC20Token.sol#450) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string _symbol,\n",
                    "message": "Parameter '_symbol' of DummyERC20Token. (DummyERC20Token.sol#451) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _decimals,\n",
                    "message": "Parameter '_decimals' of DummyERC20Token. (DummyERC20Token.sol#452) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _totalSupply\n",
                    "message": "Parameter '_totalSupply' of DummyERC20Token. (DummyERC20Token.sol#453) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBalance(address _target, uint256 _value)\n",
                    "message": "Parameter '_target' of DummyERC20Token.setBalance (DummyERC20Token.sol#464) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBalance(address _target, uint256 _value)\n",
                    "message": "Parameter '_value' of DummyERC20Token.setBalance (DummyERC20Token.sol#464) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBalance(address _target, uint256 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string _name,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string _symbol,\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/DummyERC721Token/DummyERC721Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string _symbol)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        name_ = _name;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        symbol_ = _symbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 713,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 715,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 716,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 770,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 771,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 772,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string symbol\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 773,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 775,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ERC721Token(name, symbol)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c / a == b,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b <= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_UNDERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c >= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 719,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 720,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 721,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 788,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 789,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !exists(tokenId),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 790,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"Token with tokenId already exists.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 791,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 805,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exists(tokenId),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 806,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"Token with tokenId does not exist.\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 807,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 788,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 789,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !exists(tokenId),\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 790,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"Token with tokenId already exists.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 791,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 805,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exists(tokenId),\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 806,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"Token with tokenId does not exist.\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 807,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_64"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": 679,
                    "vulnerability_code": "    function isContract(address addr)\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n\n        return size > 0;\n",
                    "message": "ERC721Token.isContract (DummyERC721Token.sol#665-679) is declared view but contains assembly code\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 120,
                    "vulnerability_code": "contract IERC721Token {\n\n    string internal name_;\n\n    string internal symbol_;\n\n\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 _tokenId\n\n    );\n\n\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 _tokenId\n\n    );\n\n\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    function name()\n\n        public\n\n        view\n\n        returns (string);\n\n\n\n    function symbol()\n\n        public\n\n        view\n\n        returns (string);\n\n\n\n    function balanceOf(address _owner)\n\n        public\n\n        view\n\n        returns (uint256 _balance);\n\n\n\n    function ownerOf(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address _owner);\n\n\n\n    function exists(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (bool _exists);\n\n\n\n    function approve(address _to, uint256 _tokenId)\n\n        public;\n\n\n\n    function getApproved(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address _operator);\n\n\n\n    function setApprovalForAll(address _operator, bool _approved)\n\n        public;\n\n\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        public\n\n        view\n\n        returns (bool);\n\n\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        public;\n\n\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        public;\n\n\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes _data\n\n    )\n\n        public;\n",
                    "message": "IERC721Token (DummyERC721Token.sol#36-120) has incorrect ERC20 function interface(s):\n\t-approve (DummyERC721Token.sol#83-84)\n\t-transferFrom (DummyERC721Token.sol#99-104)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": 680,
                    "vulnerability_code": "contract ERC721Token is\n\n    IERC721Token,\n\n    SafeMath\n\n{\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\n\n    // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n\n    bytes4 constant internal ERC721_RECEIVED = 0xf0b9e5ba;\n\n\n\n    // Mapping from token ID to owner\n\n    mapping (uint256 => address) internal tokenOwner;\n\n\n\n    // Mapping from token ID to approved address\n\n    mapping (uint256 => address) internal tokenApprovals;\n\n\n\n    // Mapping from owner to number of owned token\n\n    mapping (address => uint256) internal ownedTokensCount;\n\n\n\n    // Mapping from owner to operator approvals\n\n    mapping (address => mapping (address => bool)) internal operatorApprovals;\n\n\n\n    /**\n\n    * @dev Guarantees msg.sender is owner of the given token\n\n    * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n\n    */\n\n    modifier onlyOwnerOf(uint256 _tokenId) {\n\n        require(ownerOf(_tokenId) == msg.sender);\n\n        _;\n\n    }\n\n\n\n    /**\n\n    * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\n\n    * @param _tokenId uint256 ID of the token to validate\n\n    */\n\n    modifier canTransfer(uint256 _tokenId) {\n\n        require(isApprovedOrOwner(msg.sender, _tokenId));\n\n        _;\n\n    }\n\n\n\n    constructor (\n\n        string _name,\n\n        string _symbol)\n\n        public\n\n    {\n\n        name_ = _name;\n\n        symbol_ = _symbol;\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the token name\n\n    * @return string representing the token name\n\n    */\n\n    function name()\n\n        public\n\n        view\n\n        returns (string)\n\n    {\n\n        return name_;\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the token symbol\n\n    * @return string representing the token symbol\n\n    */\n\n    function symbol()\n\n        public\n\n        view\n\n        returns (string)\n\n    {\n\n        return symbol_;\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the balance of the specified address\n\n    * @param _owner address to query the balance of\n\n    * @return uint256 representing the amount owned by the passed address\n\n    */\n\n    function balanceOf(address _owner)\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        require(_owner != address(0));\n\n        return ownedTokensCount[_owner];\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the owner of the specified token ID\n\n    * @param _tokenId uint256 ID of the token to query the owner of\n\n    * @return owner address currently marked as the owner of the given token ID\n\n    */\n\n    function ownerOf(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address)\n\n    {\n\n        address owner = tokenOwner[_tokenId];\n\n        require(owner != address(0));\n\n        return owner;\n\n    }\n\n\n\n    /**\n\n    * @dev Returns whether the specified token exists\n\n    * @param _tokenId uint256 ID of the token to query the existance of\n\n    * @return whether the token exists\n\n    */\n\n    function exists(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (bool)\n\n    {\n\n        address owner = tokenOwner[_tokenId];\n\n        return owner != address(0);\n\n    }\n\n\n\n    /**\n\n    * @dev Approves another address to transfer the given token ID\n\n    * @dev The zero address indicates there is no approved address.\n\n    * @dev There can only be one approved address per token at a given time.\n\n    * @dev Can only be called by the token owner or an approved operator.\n\n    * @param _to address to be approved for the given token ID\n\n    * @param _tokenId uint256 ID of the token to be approved\n\n    */\n\n    function approve(address _to, uint256 _tokenId)\n\n        public\n\n    {\n\n        address owner = ownerOf(_tokenId);\n\n        require(_to != owner);\n\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n\n\n        if (getApproved(_tokenId) != address(0) || _to != address(0)) {\n\n            tokenApprovals[_tokenId] = _to;\n\n            emit Approval(owner, _to, _tokenId);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the approved address for a token ID, or zero if no address set\n\n    * @param _tokenId uint256 ID of the token to query the approval of\n\n    * @return address currently approved for a the given token ID\n\n    */\n\n    function getApproved(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address)\n\n    {\n\n        return tokenApprovals[_tokenId];\n\n    }\n\n\n\n    /**\n\n    * @dev Sets or unsets the approval of a given operator\n\n    * @dev An operator is allowed to transfer all tokens of the sender on their behalf\n\n    * @param _to operator address to set the approval\n\n    * @param _approved representing the status of the approval to be set\n\n    */\n\n    function setApprovalForAll(address _to, bool _approved)\n\n        public\n\n    {\n\n        require(_to != msg.sender);\n\n        operatorApprovals[msg.sender][_to] = _approved;\n\n        emit ApprovalForAll(msg.sender, _to, _approved);\n\n    }\n\n\n\n    /**\n\n    * @dev Tells whether an operator is approved by a given owner\n\n    * @param _owner owner address which you want to query the approval of\n\n    * @param _operator operator address which you want to query the approval of\n\n    * @return bool whether the given operator is approved by the given owner\n\n    */\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        public\n\n        view\n\n        returns (bool)\n\n    {\n\n        return operatorApprovals[_owner][_operator];\n\n    }\n\n\n\n    /**\n\n    * @dev Transfers the ownership of a given token ID to another address\n\n    * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n\n    * @dev Requires the msg sender to be the owner, approved, or operator\n\n    * @param _from current owner of the token\n\n    * @param _to address to receive the ownership of the given token ID\n\n    * @param _tokenId uint256 ID of the token to be transferred\n\n    */\n\n    function transferFrom(address _from, address _to, uint256 _tokenId)\n\n        public\n\n        canTransfer(_tokenId)\n\n    {\n\n        require(_from != address(0));\n\n        require(_to != address(0));\n\n\n\n        clearApproval(_from, _tokenId);\n\n        removeTokenFrom(_from, _tokenId);\n\n        addTokenTo(_to, _tokenId);\n\n\n\n        emit Transfer(_from, _to, _tokenId);\n\n    }\n\n\n\n    /**\n\n    * @dev Safely transfers the ownership of a given token ID to another address\n\n    * @dev If the target address is a contract, it must implement `onERC721Received`,\n\n    *  which is called upon a safe transfer, and return the magic value\n\n    *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\n\n    *  the transfer is reverted.\n\n    * @dev Requires the msg sender to be the owner, approved, or operator\n\n    * @param _from current owner of the token\n\n    * @param _to address to receive the ownership of the given token ID\n\n    * @param _tokenId uint256 ID of the token to be transferred\n\n    */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId)\n\n        public\n\n        canTransfer(_tokenId)\n\n    {\n\n        // solium-disable-next-line arg-overflow\n\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n\n    }\n\n\n\n    /**\n\n    * @dev Safely transfers the ownership of a given token ID to another address\n\n    * @dev If the target address is a contract, it must implement `onERC721Received`,\n\n    *  which is called upon a safe transfer, and return the magic value\n\n    *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\n\n    *  the transfer is reverted.\n\n    * @dev Requires the msg sender to be the owner, approved, or operator\n\n    * @param _from current owner of the token\n\n    * @param _to address to receive the ownership of the given token ID\n\n    * @param _tokenId uint256 ID of the token to be transferred\n\n    * @param _data bytes data to send along with a safe transfer check\n\n    */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes _data)\n\n        public\n\n        canTransfer(_tokenId)\n\n    {\n\n        transferFrom(_from, _to, _tokenId);\n\n        // solium-disable-next-line arg-overflow\n\n        require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n\n    }\n\n\n\n    /**\n\n    * @dev Returns whether the given spender can transfer a given token ID\n\n    * @param _spender address of the spender to query\n\n    * @param _tokenId uint256 ID of the token to be transferred\n\n    * @return bool whether the msg.sender is approved for the given token ID,\n\n    *  is an operator of the owner, or is the owner of the token\n\n    */\n\n    function isApprovedOrOwner(address _spender, uint256 _tokenId)\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        address owner = ownerOf(_tokenId);\n\n        return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function to mint a new token\n\n    * @dev Reverts if the given token ID already exists\n\n    * @param _to The address that will own the minted token\n\n    * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n\n    */\n\n    function _mint(address _to, uint256 _tokenId)\n\n        internal\n\n    {\n\n        require(_to != address(0));\n\n        addTokenTo(_to, _tokenId);\n\n        emit Transfer(address(0), _to, _tokenId);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function to burn a specific token\n\n    * @dev Reverts if the token does not exist\n\n    * @param _tokenId uint256 ID of the token being burned by the msg.sender\n\n    */\n\n    function _burn(address _owner, uint256 _tokenId)\n\n        internal\n\n    {\n\n        clearApproval(_owner, _tokenId);\n\n        removeTokenFrom(_owner, _tokenId);\n\n        emit Transfer(_owner, address(0), _tokenId);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function to clear current approval of a given token ID\n\n    * @dev Reverts if the given address is not indeed the owner of the token\n\n    * @param _owner owner of the token\n\n    * @param _tokenId uint256 ID of the token to be transferred\n\n    */\n\n    function clearApproval(address _owner, uint256 _tokenId)\n\n        internal\n\n    {\n\n        require(ownerOf(_tokenId) == _owner);\n\n        if (tokenApprovals[_tokenId] != address(0)) {\n\n            tokenApprovals[_tokenId] = address(0);\n\n            emit Approval(_owner, address(0), _tokenId);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function to add a token ID to the list of a given address\n\n    * @param _to address representing the new owner of the given token ID\n\n    * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n\n    */\n\n    function addTokenTo(address _to, uint256 _tokenId)\n\n        internal\n\n    {\n\n        require(tokenOwner[_tokenId] == address(0));\n\n        tokenOwner[_tokenId] = _to;\n\n        ownedTokensCount[_to] = safeAdd(ownedTokensCount[_to], 1);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function to remove a token ID from the list of a given address\n\n    * @param _from address representing the previous owner of the given token ID\n\n    * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n\n    */\n\n    function removeTokenFrom(address _from, uint256 _tokenId)\n\n        internal\n\n    {\n\n        require(ownerOf(_tokenId) == _from);\n\n        ownedTokensCount[_from] = safeSub(ownedTokensCount[_from], 1);\n\n        tokenOwner[_tokenId] = address(0);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function to invoke `onERC721Received` on a target address\n\n    * @dev The call is not executed if the target address is not a contract\n\n    * @param _from address representing the previous owner of the given token ID\n\n    * @param _to target address that will receive the tokens\n\n    * @param _tokenId uint256 ID of the token to be transferred\n\n    * @param _data bytes optional data to send along with the call\n\n    * @return whether the call correctly returned the expected magic value\n\n    */\n\n    function checkAndCallSafeTransfer(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes _data)\n\n        internal\n\n        returns (bool)\n\n    {\n\n        if (!isContract(_to)) {\n\n            return true;\n\n        }\n\n        bytes4 retval = IERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\n\n        return (retval == ERC721_RECEIVED);\n\n    }\n\n\n\n    function isContract(address addr)\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n\n        return size > 0;\n\n    }\n",
                    "message": "ERC721Token (DummyERC721Token.sol#311-680) has incorrect ERC20 function interface(s):\n\t-approve (DummyERC721Token.sol#433-444)\n\t-transferFrom (DummyERC721Token.sol#495-507)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 771,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string name,\n",
                    "message": "DummyERC721Token.constructor.name (local variable @ DummyERC721Token.sol#771) shadows:\n\t- ERC721Token.name (function @ DummyERC721Token.sol#362-368)\n\t- IERC721Token.name (function @ DummyERC721Token.sol#58-61)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 772,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string symbol\n",
                    "message": "DummyERC721Token.constructor.symbol (local variable @ DummyERC721Token.sol#772) shadows:\n\t- ERC721Token.symbol (function @ DummyERC721Token.sol#374-380)\n\t- IERC721Token.symbol (function @ DummyERC721Token.sol#63-66)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function burn(address owner, uint256 tokenId)\n",
                    "message": "DummyERC721Token.burn.owner (local variable @ DummyERC721Token.sol#800) shadows:\n\t- Ownable.owner (state variable @ DummyERC721Token.sol#710)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": 679,
                    "vulnerability_code": "    function isContract(address addr)\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n\n        return size > 0;\n",
                    "message": "ERC721Token.isContract uses assembly (DummyERC721Token.sol#665-679)\n\t- DummyERC721Token.sol#677-678\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": 61,
                    "vulnerability_code": "    function name()\n\n        public\n\n        view\n",
                    "message": "IERC721Token.name (DummyERC721Token.sol#58-61) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": 368,
                    "vulnerability_code": "    function name()\n\n        public\n\n        view\n\n        returns (string)\n\n    {\n\n        return name_;\n",
                    "message": "ERC721Token.name (DummyERC721Token.sol#362-368) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": 380,
                    "vulnerability_code": "    function symbol()\n\n        public\n\n        view\n\n        returns (string)\n\n    {\n\n        return symbol_;\n",
                    "message": "ERC721Token.symbol (DummyERC721Token.sol#374-380) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": 66,
                    "vulnerability_code": "    function symbol()\n\n        public\n\n        view\n",
                    "message": "IERC721Token.symbol (DummyERC721Token.sol#63-66) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "    function balanceOf(address _owner)\n\n        public\n\n        view\n",
                    "message": "IERC721Token.balanceOf (DummyERC721Token.sol#68-71) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": 394,
                    "vulnerability_code": "    function balanceOf(address _owner)\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        require(_owner != address(0));\n\n        return ownedTokensCount[_owner];\n",
                    "message": "ERC721Token.balanceOf (DummyERC721Token.sol#387-394) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": 444,
                    "vulnerability_code": "    function approve(address _to, uint256 _tokenId)\n\n        public\n\n    {\n\n        address owner = ownerOf(_tokenId);\n\n        require(_to != owner);\n\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n\n\n        if (getApproved(_tokenId) != address(0) || _to != address(0)) {\n\n            tokenApprovals[_tokenId] = _to;\n\n            emit Approval(owner, _to, _tokenId);\n\n        }\n",
                    "message": "ERC721Token.approve (DummyERC721Token.sol#433-444) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": 84,
                    "vulnerability_code": "    function approve(address _to, uint256 _tokenId)\n",
                    "message": "IERC721Token.approve (DummyERC721Token.sol#83-84) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 92,
                    "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved)\n",
                    "message": "IERC721Token.setApprovalForAll (DummyERC721Token.sol#91-92) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 465,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function setApprovalForAll(address _to, bool _approved)\n\n        public\n\n    {\n\n        require(_to != msg.sender);\n\n        operatorApprovals[msg.sender][_to] = _approved;\n\n        emit ApprovalForAll(msg.sender, _to, _approved);\n",
                    "message": "ERC721Token.setApprovalForAll (DummyERC721Token.sol#465-471) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": 529,
                    "vulnerability_code": "    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId)\n\n        public\n\n        canTransfer(_tokenId)\n\n    {\n\n        // solium-disable-next-line arg-overflow\n\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n",
                    "message": "ERC721Token.safeTransferFrom (DummyERC721Token.sol#520-529) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n",
                    "message": "IERC721Token.safeTransferFrom (DummyERC721Token.sol#106-111) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": 183,
                    "vulnerability_code": "    function onERC721Received(\n\n        address _from,\n\n        uint256 _tokenId,\n\n        bytes _data)\n\n        public\n",
                    "message": "IERC721Receiver.onERC721Received (DummyERC721Token.sol#178-183) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": 695,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n",
                    "message": "IOwnable.transferOwnership (DummyERC721Token.sol#694-695) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": 733,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable.transferOwnership (DummyERC721Token.sol#726-733) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 784,
                    "vulnerability_to_line": 793,
                    "vulnerability_code": "    function mint(address to, uint256 tokenId)\n\n        public\n\n        onlyOwner\n\n    {\n\n        require(\n\n            !exists(tokenId),\n\n            \"Token with tokenId already exists.\"\n\n        );\n\n        _mint(to, tokenId);\n",
                    "message": "DummyERC721Token.mint (DummyERC721Token.sol#784-793) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": 809,
                    "vulnerability_code": "    function burn(address owner, uint256 tokenId)\n\n        public\n\n        onlyOwner\n\n    {\n\n        require(\n\n            exists(tokenId),\n\n            \"Token with tokenId does not exist.\"\n\n        );\n\n        _burn(owner, tokenId);\n",
                    "message": "DummyERC721Token.burn (DummyERC721Token.sol#800-809) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner)\n",
                    "message": "Parameter '_owner' of ERC721Token.balanceOf (DummyERC721Token.sol#387) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ownerOf(uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.ownerOf (DummyERC721Token.sol#401) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exists(uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.exists (DummyERC721Token.sol#416) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_to' of ERC721Token.approve (DummyERC721Token.sol#433) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.approve (DummyERC721Token.sol#433) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getApproved(uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.getApproved (DummyERC721Token.sol#451) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 465,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setApprovalForAll(address _to, bool _approved)\n",
                    "message": "Parameter '_to' of ERC721Token.setApprovalForAll (DummyERC721Token.sol#465) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 465,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setApprovalForAll(address _to, bool _approved)\n",
                    "message": "Parameter '_approved' of ERC721Token.setApprovalForAll (DummyERC721Token.sol#465) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 479,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
                    "message": "Parameter '_owner' of ERC721Token.isApprovedForAll (DummyERC721Token.sol#479) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 479,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
                    "message": "Parameter '_operator' of ERC721Token.isApprovedForAll (DummyERC721Token.sol#479) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 495,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_from' of ERC721Token.transferFrom (DummyERC721Token.sol#495) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 495,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_to' of ERC721Token.transferFrom (DummyERC721Token.sol#495) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 495,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.transferFrom (DummyERC721Token.sol#495) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of ERC721Token.safeTransferFrom (DummyERC721Token.sol#521) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of ERC721Token.safeTransferFrom (DummyERC721Token.sol#522) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.safeTransferFrom (DummyERC721Token.sol#523) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 544,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of ERC721Token.safeTransferFrom (DummyERC721Token.sol#544) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of ERC721Token.safeTransferFrom (DummyERC721Token.sol#545) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 546,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId,\n",
                    "message": "Parameter '_tokenId' of ERC721Token.safeTransferFrom (DummyERC721Token.sol#546) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _data)\n",
                    "message": "Parameter '_data' of ERC721Token.safeTransferFrom (DummyERC721Token.sol#547) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string _name,\n",
                    "message": "Parameter '_name' of ERC721Token. (DummyERC721Token.sol#350) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string _symbol)\n",
                    "message": "Parameter '_symbol' of ERC721Token. (DummyERC721Token.sol#351) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 563,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isApprovedOrOwner(address _spender, uint256 _tokenId)\n",
                    "message": "Parameter '_spender' of ERC721Token.isApprovedOrOwner (DummyERC721Token.sol#563) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 563,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isApprovedOrOwner(address _spender, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.isApprovedOrOwner (DummyERC721Token.sol#563) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": 584,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId)\n\n        internal\n\n    {\n\n        require(_to != address(0));\n\n        addTokenTo(_to, _tokenId);\n\n        emit Transfer(address(0), _to, _tokenId);\n",
                    "message": "Function 'ERC721Token._mint' (DummyERC721Token.sol#578-584) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_to' of ERC721Token._mint (DummyERC721Token.sol#578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token._mint (DummyERC721Token.sol#578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": 597,
                    "vulnerability_code": "    function _burn(address _owner, uint256 _tokenId)\n\n        internal\n\n    {\n\n        clearApproval(_owner, _tokenId);\n\n        removeTokenFrom(_owner, _tokenId);\n\n        emit Transfer(_owner, address(0), _tokenId);\n",
                    "message": "Function 'ERC721Token._burn' (DummyERC721Token.sol#591-597) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _burn(address _owner, uint256 _tokenId)\n",
                    "message": "Parameter '_owner' of ERC721Token._burn (DummyERC721Token.sol#591) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _burn(address _owner, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token._burn (DummyERC721Token.sol#591) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearApproval(address _owner, uint256 _tokenId)\n",
                    "message": "Parameter '_owner' of ERC721Token.clearApproval (DummyERC721Token.sol#605) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearApproval(address _owner, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.clearApproval (DummyERC721Token.sol#605) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokenTo(address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_to' of ERC721Token.addTokenTo (DummyERC721Token.sol#620) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokenTo(address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.addTokenTo (DummyERC721Token.sol#620) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 633,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeTokenFrom(address _from, uint256 _tokenId)\n",
                    "message": "Parameter '_from' of ERC721Token.removeTokenFrom (DummyERC721Token.sol#633) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 633,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeTokenFrom(address _from, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.removeTokenFrom (DummyERC721Token.sol#633) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 651,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of ERC721Token.checkAndCallSafeTransfer (DummyERC721Token.sol#651) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of ERC721Token.checkAndCallSafeTransfer (DummyERC721Token.sol#652) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 653,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId,\n",
                    "message": "Parameter '_tokenId' of ERC721Token.checkAndCallSafeTransfer (DummyERC721Token.sol#653) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _data)\n",
                    "message": "Parameter '_data' of ERC721Token.checkAndCallSafeTransfer (DummyERC721Token.sol#654) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant internal ERC721_RECEIVED = 0xf0b9e5ba;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant internal ERC721_RECEIVED = 0xf0b9e5ba;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            tokenApprovals[_tokenId] = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 638,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        tokenOwner[_tokenId] = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _to, uint256 _tokenId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (string);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (string);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string _name,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string _symbol)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (string)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (string)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 771,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string name,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 772,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string symbol\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestConstants/TestConstants.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory kovanZrxAssetData = abi.encodeWithSelector(ERC20_PROXY_ID, KOVAN_ZRX_ADDRESS);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory mainetZrxAssetData = abi.encodeWithSelector(ERC20_PROXY_ID, MAINNET_ZRX_ADDRESS);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            kovanZrxAssetData.equals(KOVAN_ZRX_ASSET_DATA),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_KOVAN_ZRX_ASSET_DATA\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 611,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 612,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            mainetZrxAssetData.equals(MAINNET_ZRX_ASSET_DATA),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 613,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_MAINNET_ZRX_ASSET_DATA\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_25"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (TestConstants.sol#33-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (TestConstants.sol#47-56) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (TestConstants.sol#62-163) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (TestConstants.sol#203-227) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (TestConstants.sol#232-251) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 275,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes (TestConstants.sol#256-275) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (TestConstants.sol#299-325) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (TestConstants.sol#331-371) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (TestConstants.sol#377-398) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": 424,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (TestConstants.sol#404-424) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": 479,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (TestConstants.sol#460-479) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 511,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength (TestConstants.sol#487-511) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (TestConstants.sol#33-42)\n\t- TestConstants.sol#38-41\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (TestConstants.sol#47-56)\n\t- TestConstants.sol#52-55\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (TestConstants.sol#62-163)\n\t- TestConstants.sol#74-80\n\t- TestConstants.sol#102-130\n\t- TestConstants.sol#131-161\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (TestConstants.sol#203-227)\n\t- TestConstants.sol#222-226\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (TestConstants.sol#232-251)\n\t- TestConstants.sol#245-250\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 275,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes uses assembly (TestConstants.sol#256-275)\n\t- TestConstants.sol#269-274\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (TestConstants.sol#299-325)\n\t- TestConstants.sol#318-324\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (TestConstants.sol#331-371)\n\t- TestConstants.sol#350-371\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (TestConstants.sol#377-398)\n\t- TestConstants.sol#394-397\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": 424,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (TestConstants.sol#404-424)\n\t- TestConstants.sol#421-424\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": 479,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (TestConstants.sol#460-479)\n\t- TestConstants.sol#472-478\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 511,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength uses assembly (TestConstants.sol#487-511)\n\t- TestConstants.sol#507-510\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 599,
                    "vulnerability_to_line": 617,
                    "vulnerability_code": "    function assertValidZrxAssetData()\n\n        public\n\n        pure\n\n        returns (bool)\n\n    {\n\n        bytes memory kovanZrxAssetData = abi.encodeWithSelector(ERC20_PROXY_ID, KOVAN_ZRX_ADDRESS);\n\n        require(\n\n            kovanZrxAssetData.equals(KOVAN_ZRX_ASSET_DATA),\n\n            \"INVALID_KOVAN_ZRX_ASSET_DATA\"\n\n        );\n\n\n\n        bytes memory mainetZrxAssetData = abi.encodeWithSelector(ERC20_PROXY_ID, MAINNET_ZRX_ADDRESS);\n\n        require(\n\n            mainetZrxAssetData.equals(MAINNET_ZRX_ASSET_DATA),\n\n            \"INVALID_MAINNET_ZRX_ASSET_DATA\"\n\n        );\n\n\n\n        return true;\n",
                    "message": "TestConstants.assertValidZrxAssetData (TestConstants.sol#599-617) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant internal KOVAN_ZRX_ADDRESS = 0x6Ff6C0Ff1d68b964901F986d4C9FA3ac68346570;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant internal MAINNET_ZRX_ADDRESS = 0xE41d2489571d322189246DaFA5ebDe1F4699F498;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytesWithLength(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 507,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/DummyERC721Receiver/DummyERC721Receiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 62,
                    "vulnerability_code": "    function onERC721Received(\n\n        address _from,\n\n        uint256 _tokenId,\n\n        bytes _data)\n\n        public\n",
                    "message": "IERC721Receiver.onERC721Received (DummyERC721Receiver.sol#57-62) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 126,
                    "vulnerability_code": "    function onERC721Received(\n\n        address _from,\n\n        uint256 _tokenId,\n\n        bytes _data\n\n    )\n\n        public\n\n        returns (bytes4)\n\n    {\n\n        emit TokenReceived(_from, _tokenId, _data);\n\n        return ERC721_RECEIVED;\n",
                    "message": "DummyERC721Receiver.onERC721Received (DummyERC721Receiver.sol#116-126) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of DummyERC721Receiver.onERC721Received (DummyERC721Receiver.sol#117) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId,\n",
                    "message": "Parameter '_tokenId' of DummyERC721Receiver.onERC721Received (DummyERC721Receiver.sol#118) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _data\n",
                    "message": "Parameter '_data' of DummyERC721Receiver.onERC721Received (DummyERC721Receiver.sol#119) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant internal ERC721_RECEIVED = 0xf0b9e5ba;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _data\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_40"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (TestLibBytes.sol#33-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (TestLibBytes.sol#47-56) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (TestLibBytes.sol#62-163) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (TestLibBytes.sol#203-227) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (TestLibBytes.sol#232-251) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 275,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes (TestLibBytes.sol#256-275) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (TestLibBytes.sol#299-325) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (TestLibBytes.sol#331-371) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (TestLibBytes.sol#377-398) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": 424,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (TestLibBytes.sol#404-424) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": 479,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (TestLibBytes.sol#460-479) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 511,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength (TestLibBytes.sol#487-511) is declared view but contains assembly code\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 627,
                    "vulnerability_to_line": 636,
                    "vulnerability_code": "    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n\n        public\n\n        pure\n\n        returns (bool equal)\n\n    {\n\n        lhs.popLastByte();\n\n        rhs.popLastByte();\n\n        equal = lhs.equals(rhs);\n\n        return equal;\n",
                    "message": "TestLibBytes.publicEqualsPop1 (TestLibBytes.sol#627-636) does not use the value returned by external calls:\n\t-lhs.popLastByte() (TestLibBytes.sol#632)\n\t-rhs.popLastByte() (TestLibBytes.sol#633)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (TestLibBytes.sol#33-42)\n\t- TestLibBytes.sol#38-41\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (TestLibBytes.sol#47-56)\n\t- TestLibBytes.sol#52-55\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (TestLibBytes.sol#62-163)\n\t- TestLibBytes.sol#74-80\n\t- TestLibBytes.sol#102-130\n\t- TestLibBytes.sol#131-161\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (TestLibBytes.sol#203-227)\n\t- TestLibBytes.sol#222-226\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (TestLibBytes.sol#232-251)\n\t- TestLibBytes.sol#245-250\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 275,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes uses assembly (TestLibBytes.sol#256-275)\n\t- TestLibBytes.sol#269-274\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (TestLibBytes.sol#299-325)\n\t- TestLibBytes.sol#318-324\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (TestLibBytes.sol#331-371)\n\t- TestLibBytes.sol#350-371\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (TestLibBytes.sol#377-398)\n\t- TestLibBytes.sol#394-397\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": 424,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (TestLibBytes.sol#404-424)\n\t- TestLibBytes.sol#421-424\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": 479,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (TestLibBytes.sol#460-479)\n\t- TestLibBytes.sol#472-478\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 511,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength uses assembly (TestLibBytes.sol#487-511)\n\t- TestLibBytes.sol#507-510\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": 600,
                    "vulnerability_code": "    function publicPopLastByte(bytes memory b)\n\n        public\n\n        pure\n\n        returns (bytes memory, bytes1 result)\n\n    {\n\n        result = b.popLastByte();\n\n        return (b, result);\n",
                    "message": "TestLibBytes.publicPopLastByte (TestLibBytes.sol#593-600) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": 612,
                    "vulnerability_code": "    function publicPopLast20Bytes(bytes memory b)\n\n        public\n\n        pure\n\n        returns (bytes memory, address result)\n\n    {\n\n        result = b.popLast20Bytes();\n\n        return (b, result);\n",
                    "message": "TestLibBytes.publicPopLast20Bytes (TestLibBytes.sol#605-612) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 618,
                    "vulnerability_to_line": 625,
                    "vulnerability_code": "    function publicEquals(bytes memory lhs, bytes memory rhs)\n\n        public\n\n        pure\n\n        returns (bool equal)\n\n    {\n\n        equal = lhs.equals(rhs);\n\n        return equal;\n",
                    "message": "TestLibBytes.publicEquals (TestLibBytes.sol#618-625) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 627,
                    "vulnerability_to_line": 636,
                    "vulnerability_code": "    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n\n        public\n\n        pure\n\n        returns (bool equal)\n\n    {\n\n        lhs.popLastByte();\n\n        rhs.popLastByte();\n\n        equal = lhs.equals(rhs);\n\n        return equal;\n",
                    "message": "TestLibBytes.publicEqualsPop1 (TestLibBytes.sol#627-636) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 641,
                    "vulnerability_to_line": 651,
                    "vulnerability_code": "    function publicDeepCopyBytes(\n\n        bytes memory dest,\n\n        bytes memory source\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        LibBytes.deepCopyBytes(dest, source);\n\n        return dest;\n",
                    "message": "TestLibBytes.publicDeepCopyBytes (TestLibBytes.sol#641-651) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 657,
                    "vulnerability_to_line": 667,
                    "vulnerability_code": "    function publicReadAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        public\n\n        pure\n\n        returns (address result)\n\n    {\n\n        result = b.readAddress(index);\n\n        return result;\n",
                    "message": "TestLibBytes.publicReadAddress (TestLibBytes.sol#657-667) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 673,
                    "vulnerability_to_line": 684,
                    "vulnerability_code": "    function publicWriteAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        b.writeAddress(index, input);\n\n        return b;\n",
                    "message": "TestLibBytes.publicWriteAddress (TestLibBytes.sol#673-684) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 690,
                    "vulnerability_to_line": 700,
                    "vulnerability_code": "    function publicReadBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        result = b.readBytes32(index);\n\n        return result;\n",
                    "message": "TestLibBytes.publicReadBytes32 (TestLibBytes.sol#690-700) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 706,
                    "vulnerability_to_line": 717,
                    "vulnerability_code": "    function publicWriteBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        b.writeBytes32(index, input);\n\n        return b;\n",
                    "message": "TestLibBytes.publicWriteBytes32 (TestLibBytes.sol#706-717) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 723,
                    "vulnerability_to_line": 733,
                    "vulnerability_code": "    function publicReadUint256(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        public\n\n        pure\n\n        returns (uint256 result)\n\n    {\n\n        result = b.readUint256(index);\n\n        return result;\n",
                    "message": "TestLibBytes.publicReadUint256 (TestLibBytes.sol#723-733) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 739,
                    "vulnerability_to_line": 750,
                    "vulnerability_code": "    function publicWriteUint256(\n\n        bytes memory b,\n\n        uint256 index,\n\n        uint256 input\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        b.writeUint256(index, input);\n\n        return b;\n",
                    "message": "TestLibBytes.publicWriteUint256 (TestLibBytes.sol#739-750) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 756,
                    "vulnerability_to_line": 766,
                    "vulnerability_code": "    function publicReadBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        result = b.readBytes4(index);\n\n        return result;\n",
                    "message": "TestLibBytes.publicReadBytes4 (TestLibBytes.sol#756-766) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 772,
                    "vulnerability_to_line": 782,
                    "vulnerability_code": "    function publicReadBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        result = b.readBytesWithLength(index);\n\n        return result;\n",
                    "message": "TestLibBytes.publicReadBytesWithLength (TestLibBytes.sol#772-782) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 789,
                    "vulnerability_to_line": 800,
                    "vulnerability_code": "    function publicWriteBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes memory input\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        b.writeBytesWithLength(index, input);\n\n        return b;\n",
                    "message": "TestLibBytes.publicWriteBytesWithLength (TestLibBytes.sol#789-800) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 808,
                    "vulnerability_to_line": 830,
                    "vulnerability_code": "    function testMemcpy(\n\n        bytes mem,\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        public // not external, we need input in memory\n\n        pure\n\n        returns (bytes)\n\n    {\n\n        // Sanity check. Overflows are not checked.\n\n        require(source + length <= mem.length);\n\n        require(dest + length <= mem.length);\n\n\n\n        // Get pointer to memory contents\n\n        uint256 offset = mem.contentAddress();\n\n\n\n        // Execute memCopy adjusted for memory array location\n\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n\n\n        // Return modified memory contents\n\n        return mem;\n",
                    "message": "TestLibBytes.testMemcpy (TestLibBytes.sol#808-830) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytesWithLength(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 809,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes mem,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 816,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bytes)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 507,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/utils/LibBytes/LibBytes.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_24"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (LibBytes.sol#33-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (LibBytes.sol#47-56) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (LibBytes.sol#62-163) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (LibBytes.sol#203-227) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (LibBytes.sol#232-251) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 275,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes (LibBytes.sol#256-275) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (LibBytes.sol#299-325) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (LibBytes.sol#331-371) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (LibBytes.sol#377-398) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": 424,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (LibBytes.sol#404-424) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": 479,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (LibBytes.sol#460-479) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 511,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength (LibBytes.sol#487-511) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (LibBytes.sol#33-42)\n\t- LibBytes.sol#38-41\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (LibBytes.sol#47-56)\n\t- LibBytes.sol#52-55\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (LibBytes.sol#62-163)\n\t- LibBytes.sol#74-80\n\t- LibBytes.sol#102-130\n\t- LibBytes.sol#131-161\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (LibBytes.sol#203-227)\n\t- LibBytes.sol#222-226\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (LibBytes.sol#232-251)\n\t- LibBytes.sol#245-250\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 275,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes uses assembly (LibBytes.sol#256-275)\n\t- LibBytes.sol#269-274\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (LibBytes.sol#299-325)\n\t- LibBytes.sol#318-324\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (LibBytes.sol#331-371)\n\t- LibBytes.sol#350-371\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (LibBytes.sol#377-398)\n\t- LibBytes.sol#394-397\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": 424,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (LibBytes.sol#404-424)\n\t- LibBytes.sol#421-424\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": 479,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (LibBytes.sol#460-479)\n\t- LibBytes.sol#472-478\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 511,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength uses assembly (LibBytes.sol#487-511)\n\t- LibBytes.sol#507-510\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytesWithLength(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 507,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/utils/Ownable/IOwnable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": 14,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n",
                    "message": "IOwnable.transferOwnership (IOwnable.sol#13-14) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/utils/Ownable/Ownable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": 14,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n",
                    "message": "IOwnable.transferOwnership (Ownable.sol#13-14) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": 52,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable.transferOwnership (Ownable.sol#45-52) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/utils/SafeMath/SafeMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c / a == b,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b <= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_UNDERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c >= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/MixinSignatureValidator.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 872,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 873,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isValidSignature(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 874,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                hash,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 875,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                signerAddress,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 876,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                signature\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 877,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 878,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_SIGNATURE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 879,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 915,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            signature.length > 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 917,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"LENGTH_GREATER_THAN_0_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 918,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 922,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 923,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            signatureTypeRaw < uint8(SignatureType.NSignatureTypes),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 924,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SIGNATURE_UNSUPPORTED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 925,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 942,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"SIGNATURE_ILLEGAL\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 949,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 950,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                signature.length == 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 951,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_0_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 952,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 958,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                signature.length == 65,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 960,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_65_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 961,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 971,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 972,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                signature.length == 65,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 973,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_65_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 999,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1000,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                signature.length == 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_0_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1002,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1049,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1050,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                signature.length == 65,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1051,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_65_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        revert(\"SIGNATURE_UNSUPPORTED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_25"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (MixinSignatureValidator.sol#33-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (MixinSignatureValidator.sol#47-56) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (MixinSignatureValidator.sol#62-163) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (MixinSignatureValidator.sol#203-227) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (MixinSignatureValidator.sol#232-251) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 275,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes (MixinSignatureValidator.sol#256-275) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (MixinSignatureValidator.sol#299-325) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (MixinSignatureValidator.sol#331-371) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (MixinSignatureValidator.sol#377-398) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": 424,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (MixinSignatureValidator.sol#404-424) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": 479,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (MixinSignatureValidator.sol#460-479) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 511,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength (MixinSignatureValidator.sol#487-511) is declared view but contains assembly code\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 864,
                    "vulnerability_to_line": 881,
                    "vulnerability_code": "    function preSign(\n\n        bytes32 hash,\n\n        address signerAddress,\n\n        bytes signature\n\n    )\n\n        external\n\n    {\n\n        // SWC-Lack of Proper Signature Verification: L52-L59\n\n        require(\n\n            isValidSignature(\n\n                hash,\n\n                signerAddress,\n\n                signature\n\n            ),\n\n            \"INVALID_SIGNATURE\"\n\n        );\n\n        preSigned[hash][signerAddress] = true;\n",
                    "message": "Reentrancy in MixinSignatureValidator.preSign (MixinSignatureValidator.sol#864-881):\n\tExternal calls:\n\t- require(bool,string)(isValidSignature(hash,signerAddress,signature),INVALID_SIGNATURE) (MixinSignatureValidator.sol#872-879)\n\tState variables written after the call(s):\n\t- preSigned (MixinSignatureValidator.sol#880)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (MixinSignatureValidator.sol#33-42)\n\t- MixinSignatureValidator.sol#38-41\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (MixinSignatureValidator.sol#47-56)\n\t- MixinSignatureValidator.sol#52-55\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (MixinSignatureValidator.sol#62-163)\n\t- MixinSignatureValidator.sol#74-80\n\t- MixinSignatureValidator.sol#102-130\n\t- MixinSignatureValidator.sol#131-161\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (MixinSignatureValidator.sol#203-227)\n\t- MixinSignatureValidator.sol#222-226\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (MixinSignatureValidator.sol#232-251)\n\t- MixinSignatureValidator.sol#245-250\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 275,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes uses assembly (MixinSignatureValidator.sol#256-275)\n\t- MixinSignatureValidator.sol#269-274\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (MixinSignatureValidator.sol#299-325)\n\t- MixinSignatureValidator.sol#318-324\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (MixinSignatureValidator.sol#331-371)\n\t- MixinSignatureValidator.sol#350-371\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (MixinSignatureValidator.sol#377-398)\n\t- MixinSignatureValidator.sol#394-397\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": 424,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (MixinSignatureValidator.sol#404-424)\n\t- MixinSignatureValidator.sol#421-424\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": 479,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (MixinSignatureValidator.sol#460-479)\n\t- MixinSignatureValidator.sol#472-478\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 511,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength uses assembly (MixinSignatureValidator.sol#487-511)\n\t- MixinSignatureValidator.sol#507-510\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 941,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (signatureType == SignatureType.Illegal) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytesWithLength(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 507,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/MixinAssetProxyDispatcher.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 830,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 315,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 363,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 393,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 395,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 466,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 556,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 557,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 558,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 581,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 582,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 583,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 584,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 609,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentAssetProxy == address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 853,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ASSET_PROXY_ALREADY_EXISTS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 891,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 892,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assetData.length > 3,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 893,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 907,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 908,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assetProxy != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 909,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"ASSET_PROXY_DOES_NOT_EXIST\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 910,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 315,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 363,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 393,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 395,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 466,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 556,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 557,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 558,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 581,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 582,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 583,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 584,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 609,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_28"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": 96,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (MixinAssetProxyDispatcher.sol#87-96) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 110,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (MixinAssetProxyDispatcher.sol#101-110) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 217,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (MixinAssetProxyDispatcher.sol#116-217) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": 281,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (MixinAssetProxyDispatcher.sol#257-281) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": 305,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (MixinAssetProxyDispatcher.sol#286-305) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": 329,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes (MixinAssetProxyDispatcher.sol#310-329) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": 379,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (MixinAssetProxyDispatcher.sol#353-379) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": 425,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (MixinAssetProxyDispatcher.sol#385-425) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": 452,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (MixinAssetProxyDispatcher.sol#431-452) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": 478,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (MixinAssetProxyDispatcher.sol#458-478) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 514,
                    "vulnerability_to_line": 533,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (MixinAssetProxyDispatcher.sol#514-533) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": 565,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength (MixinAssetProxyDispatcher.sol#541-565) is declared view but contains assembly code\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 842,
                    "vulnerability_to_line": 862,
                    "vulnerability_code": "    function registerAssetProxy(address assetProxy)\n\n        external\n\n        onlyOwner\n\n    {\n\n        IAssetProxy assetProxyContract = IAssetProxy(assetProxy);\n\n\n\n        // Ensure that no asset proxy exists with current id.\n\n        bytes4 assetProxyId = assetProxyContract.getProxyId();\n\n        address currentAssetProxy = assetProxies[assetProxyId];\n\n        require(\n\n            currentAssetProxy == address(0),\n\n            \"ASSET_PROXY_ALREADY_EXISTS\"\n\n        );\n\n\n\n        // Add asset proxy and log registration.\n\n        assetProxies[assetProxyId] = assetProxyContract;\n\n        emit AssetProxyRegistered(\n\n            assetProxyId,\n\n            assetProxy\n\n        );\n",
                    "message": "Reentrancy in MixinAssetProxyDispatcher.registerAssetProxy (MixinAssetProxyDispatcher.sol#842-862):\n\tExternal calls:\n\t- assetProxyId = assetProxyContract.getProxyId() (MixinAssetProxyDispatcher.sol#849)\n\tState variables written after the call(s):\n\t- assetProxies (MixinAssetProxyDispatcher.sol#857)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": 96,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (MixinAssetProxyDispatcher.sol#87-96)\n\t- MixinAssetProxyDispatcher.sol#92-95\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 110,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (MixinAssetProxyDispatcher.sol#101-110)\n\t- MixinAssetProxyDispatcher.sol#106-109\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 217,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (MixinAssetProxyDispatcher.sol#116-217)\n\t- MixinAssetProxyDispatcher.sol#128-134\n\t- MixinAssetProxyDispatcher.sol#156-184\n\t- MixinAssetProxyDispatcher.sol#185-215\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": 281,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (MixinAssetProxyDispatcher.sol#257-281)\n\t- MixinAssetProxyDispatcher.sol#276-280\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": 305,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (MixinAssetProxyDispatcher.sol#286-305)\n\t- MixinAssetProxyDispatcher.sol#299-304\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": 329,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes uses assembly (MixinAssetProxyDispatcher.sol#310-329)\n\t- MixinAssetProxyDispatcher.sol#323-328\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": 379,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (MixinAssetProxyDispatcher.sol#353-379)\n\t- MixinAssetProxyDispatcher.sol#372-378\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": 425,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (MixinAssetProxyDispatcher.sol#385-425)\n\t- MixinAssetProxyDispatcher.sol#404-425\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": 452,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (MixinAssetProxyDispatcher.sol#431-452)\n\t- MixinAssetProxyDispatcher.sol#448-451\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": 478,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (MixinAssetProxyDispatcher.sol#458-478)\n\t- MixinAssetProxyDispatcher.sol#475-478\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 514,
                    "vulnerability_to_line": 533,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (MixinAssetProxyDispatcher.sol#514-533)\n\t- MixinAssetProxyDispatcher.sol#526-532\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": 565,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength uses assembly (MixinAssetProxyDispatcher.sol#541-565)\n\t- MixinAssetProxyDispatcher.sol#561-564\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 880,
                    "vulnerability_to_line": 979,
                    "vulnerability_code": "    function dispatchTransferFrom(\n\n        bytes memory assetData,\n\n        address from,\n\n        address to,\n\n        uint256 amount\n\n    )\n\n        internal\n\n    {\n\n        // Do nothing if no amount should be transferred.\n\n        if (amount > 0) {\n\n            // Ensure assetData length is valid\n\n            require(\n\n                assetData.length > 3,\n\n                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n\n            );\n\n            \n\n            // Lookup assetProxy\n\n            bytes4 assetProxyId;\n\n            assembly {\n\n                assetProxyId := and(mload(\n\n                    add(assetData, 32)),\n\n                    0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n\n                )\n\n            }\n\n            address assetProxy = assetProxies[assetProxyId];\n\n\n\n            // Ensure that assetProxy exists\n\n            require(\n\n                assetProxy != address(0),\n\n                \"ASSET_PROXY_DOES_NOT_EXIST\"\n\n            );\n\n            \n\n            // We construct calldata for the `assetProxy.transferFrom` ABI.\n\n            // The layout of this calldata is in the table below.\n\n            // \n\n            // | Area     | Offset | Length  | Contents                                    |\n\n            // | -------- |--------|---------|-------------------------------------------- |\n\n            // | Header   | 0      | 4       | function selector                           |\n\n            // | Params   |        | 4 * 32  | function parameters:                        |\n\n            // |          | 4      |         |   1. offset to assetData (*)                |\n\n            // |          | 36     |         |   2. from                                   |\n\n            // |          | 68     |         |   3. to                                     |\n\n            // |          | 100    |         |   4. amount                                 |\n\n            // | Data     |        |         | assetData:                                  |\n\n            // |          | 132    | 32      | assetData Length                            |\n\n            // |          | 164    | **      | assetData Contents                          |\n\n\n\n            assembly {\n\n                /////// Setup State ///////\n\n                // `cdStart` is the start of the calldata for `assetProxy.transferFrom` (equal to free memory ptr).\n\n                let cdStart := mload(64)\n\n                // `dataAreaLength` is the total number of words needed to store `assetData`\n\n                //  As-per the ABI spec, this value is padded up to the nearest multiple of 32,\n\n                //  and includes 32-bytes for length.\n\n                let dataAreaLength := and(add(mload(assetData), 63), 0xFFFFFFFFFFFE0)\n\n                // `cdEnd` is the end of the calldata for `assetProxy.transferFrom`.\n\n                let cdEnd := add(cdStart, add(132, dataAreaLength))\n\n\n\n                \n\n                /////// Setup Header Area ///////\n\n                // This area holds the 4-byte `transferFromSelector`.\n\n                // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n\n                mstore(cdStart, 0xa85e59e400000000000000000000000000000000000000000000000000000000)\n\n                \n\n                /////// Setup Params Area ///////\n\n                // Each parameter is padded to 32-bytes. The entire Params Area is 128 bytes.\n\n                // Notes:\n\n                //   1. The offset to `assetData` is the length of the Params Area (128 bytes).\n\n                //   2. A 20-byte mask is applied to addresses to zero-out the unused bytes.\n\n                mstore(add(cdStart, 4), 128)\n\n                mstore(add(cdStart, 36), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(cdStart, 68), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(cdStart, 100), amount)\n\n                \n\n                /////// Setup Data Area ///////\n\n                // This area holds `assetData`.\n\n                let dataArea := add(cdStart, 132)\n\n                // solhint-disable-next-line no-empty-blocks\n\n                for {} lt(dataArea, cdEnd) {} {\n\n                    mstore(dataArea, mload(assetData))\n\n                    dataArea := add(dataArea, 32)\n\n                    assetData := add(assetData, 32)\n\n                }\n\n\n\n                /////// Call `assetProxy.transferFrom` using the constructed calldata ///////\n\n                let success := call(\n\n                    gas,                    // forward all gas\n\n                    assetProxy,             // call address of asset proxy\n\n                    0,                      // don't send any ETH\n\n                    cdStart,                // pointer to start of input\n\n                    sub(cdEnd, cdStart),    // length of input  \n\n                    cdStart,                // write output over input\n\n                    512                     // reserve 512 bytes for output\n\n                )\n\n                if iszero(success) {\n\n                    revert(cdStart, returndatasize())\n\n                }\n\n            }\n\n        }\n",
                    "message": "MixinAssetProxyDispatcher.dispatchTransferFrom uses assembly (MixinAssetProxyDispatcher.sol#880-979)\n\t- MixinAssetProxyDispatcher.sol#898-904\n\t- MixinAssetProxyDispatcher.sol#927-978\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": 14,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n",
                    "message": "IOwnable.transferOwnership (MixinAssetProxyDispatcher.sol#13-14) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": 52,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable.transferOwnership (MixinAssetProxyDispatcher.sol#45-52) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytesWithLength(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 323,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 372,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 448,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 475,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 898,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 927,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/MixinTransactions.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentContextAddress == address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"REENTRANCY_ILLEGAL\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 395,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !transactions[transactionHash],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_TX_HASH\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 403,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                isValidSignature(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 405,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    transactionHash,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    signerAddress,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    signature\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 408,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"INVALID_TX_SIGNATURE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this).delegatecall(data),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FAILED_EXECUTION\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": 464,
                    "vulnerability_code": "    function hashZeroExTransaction(\n\n        uint256 salt,\n\n        address signerAddress,\n\n        bytes memory data\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH;\n\n        bytes32 dataHash = keccak256(data);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH,\n\n        //     salt,\n\n        //     signerAddress,\n\n        //     keccak256(data)\n\n        // ));\n\n\n\n        assembly {\n\n            let memPtr := mload(64)\n\n            mstore(memPtr, schemaHash)\n\n            mstore(add(memPtr, 32), salt)\n\n            mstore(add(memPtr, 64), and(signerAddress, 0xffffffffffffffffffffffffffffffffffffffff))\n\n            mstore(add(memPtr, 96), dataHash)\n\n            result := keccak256(memPtr, 128)\n\n        }\n\n\n\n        return result;\n",
                    "message": "MixinTransactions.hashZeroExTransaction (MixinTransactions.sol#434-464) is declared view but contains assembly code\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": 427,
                    "vulnerability_code": "    function executeTransaction(\n\n        uint256 salt,\n\n        address signerAddress,\n\n        bytes data,\n\n        bytes signature\n\n    )\n\n        external\n\n    {\n\n        // Prevent reentrancy\n\n        require(\n\n            currentContextAddress == address(0),\n\n            \"REENTRANCY_ILLEGAL\"\n\n        );\n\n\n\n        bytes32 transactionHash = hashEIP712Message(hashZeroExTransaction(\n\n            salt,\n\n            signerAddress,\n\n            data\n\n        ));\n\n\n\n        // Validate transaction has not been executed\n\n        require(\n\n            !transactions[transactionHash],\n\n            \"INVALID_TX_HASH\"\n\n        );\n\n\n\n        // Transaction always valid if signer is sender of transaction\n\n        if (signerAddress != msg.sender) {\n\n            // Validate signature\n\n            require(\n\n                isValidSignature(\n\n                    transactionHash,\n\n                    signerAddress,\n\n                    signature\n\n                ),\n\n                \"INVALID_TX_SIGNATURE\"\n\n            );\n\n\n\n            // Set the current transaction signer\n\n            currentContextAddress = signerAddress;\n\n        }\n\n\n\n        // Execute transaction\n\n        transactions[transactionHash] = true;\n\n        require(\n\n            address(this).delegatecall(data),\n\n            \"FAILED_EXECUTION\"\n\n        );\n\n\n\n        // Reset current transaction signer if it was previously updated\n\n        if (signerAddress != msg.sender) {\n\n            currentContextAddress = address(0);\n\n        }\n",
                    "message": "Reentrancy in MixinTransactions.executeTransaction (MixinTransactions.sol#374-427):\n\tExternal calls:\n\t- require(bool,string)(address(this).delegatecall(data),FAILED_EXECUTION) (MixinTransactions.sol#418-421)\n\tState variables written after the call(s):\n\t- currentContextAddress (MixinTransactions.sol#425)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": 464,
                    "vulnerability_code": "    function hashZeroExTransaction(\n\n        uint256 salt,\n\n        address signerAddress,\n\n        bytes memory data\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH;\n\n        bytes32 dataHash = keccak256(data);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH,\n\n        //     salt,\n\n        //     signerAddress,\n\n        //     keccak256(data)\n\n        // ));\n\n\n\n        assembly {\n\n            let memPtr := mload(64)\n\n            mstore(memPtr, schemaHash)\n\n            mstore(add(memPtr, 32), salt)\n\n            mstore(add(memPtr, 64), and(signerAddress, 0xffffffffffffffffffffffffffffffffffffffff))\n\n            mstore(add(memPtr, 96), dataHash)\n\n            result := keccak256(memPtr, 128)\n\n        }\n\n\n\n        return result;\n",
                    "message": "MixinTransactions.hashZeroExTransaction uses assembly (MixinTransactions.sol#434-464)\n\t- MixinTransactions.sol#454-463\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": 427,
                    "vulnerability_code": "    function executeTransaction(\n\n        uint256 salt,\n\n        address signerAddress,\n\n        bytes data,\n\n        bytes signature\n\n    )\n\n        external\n\n    {\n\n        // Prevent reentrancy\n\n        require(\n\n            currentContextAddress == address(0),\n\n            \"REENTRANCY_ILLEGAL\"\n\n        );\n\n\n\n        bytes32 transactionHash = hashEIP712Message(hashZeroExTransaction(\n\n            salt,\n\n            signerAddress,\n\n            data\n\n        ));\n\n\n\n        // Validate transaction has not been executed\n\n        require(\n\n            !transactions[transactionHash],\n\n            \"INVALID_TX_HASH\"\n\n        );\n\n\n\n        // Transaction always valid if signer is sender of transaction\n\n        if (signerAddress != msg.sender) {\n\n            // Validate signature\n\n            require(\n\n                isValidSignature(\n\n                    transactionHash,\n\n                    signerAddress,\n\n                    signature\n\n                ),\n\n                \"INVALID_TX_SIGNATURE\"\n\n            );\n\n\n\n            // Set the current transaction signer\n\n            currentContextAddress = signerAddress;\n\n        }\n\n\n\n        // Execute transaction\n\n        transactions[transactionHash] = true;\n\n        require(\n\n            address(this).delegatecall(data),\n\n            \"FAILED_EXECUTION\"\n\n        );\n\n\n\n        // Reset current transaction signer if it was previously updated\n\n        if (signerAddress != msg.sender) {\n\n            currentContextAddress = address(0);\n\n        }\n",
                    "message": "Low level call in MixinTransactions.executeTransaction (MixinTransactions.sol#374-427):\n\t-require(bool,string)(address(this).delegatecall(data),FAILED_EXECUTION) MixinTransactions.sol#418-421\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (MixinTransactions.sol#298) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentContextAddress = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashZeroExTransaction(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant ORDER_UNFILLABLE = \"ORDER_UNFILLABLE\";                              // Order cannot be filled.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_MAKER = \"INVALID_MAKER\";                                    // Invalid makerAddress.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_TAKER = \"INVALID_TAKER\";                                    // Invalid takerAddress.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_SENDER = \"INVALID_SENDER\";                                  // Invalid `msg.sender`.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_ORDER_SIGNATURE = \"INVALID_ORDER_SIGNATURE\";                // Signature validation failed. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_TAKER_AMOUNT = \"INVALID_TAKER_AMOUNT\";                      // takerAssetFillAmount cannot equal 0.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant ROUNDING_ERROR = \"ROUNDING_ERROR\";                                  // Rounding error greater than 0.1% of takerAssetFillAmount. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_SIGNATURE = \"INVALID_SIGNATURE\";                            // Signature validation failed. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant SIGNATURE_ILLEGAL = \"SIGNATURE_ILLEGAL\";                            // Signature type is illegal.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant SIGNATURE_UNSUPPORTED = \"SIGNATURE_UNSUPPORTED\";                    // Signature type unsupported.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_NEW_ORDER_EPOCH = \"INVALID_NEW_ORDER_EPOCH\";                // Specified salt must be greater than or equal to existing orderEpoch.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant COMPLETE_FILL_FAILED = \"COMPLETE_FILL_FAILED\";                      // Desired takerAssetFillAmount could not be completely filled. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NEGATIVE_SPREAD_REQUIRED = \"NEGATIVE_SPREAD_REQUIRED\";              // Matched orders must have a negative spread.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant REENTRANCY_ILLEGAL = \"REENTRANCY_ILLEGAL\";                          // Recursive reentrancy is not allowed. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_TX_HASH = \"INVALID_TX_HASH\";                                // Transaction has already been executed. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_TX_SIGNATURE = \"INVALID_TX_SIGNATURE\";                      // Signature validation failed. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant FAILED_EXECUTION = \"FAILED_EXECUTION\";                              // Transaction execution failed. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant ASSET_PROXY_ALREADY_EXISTS = \"ASSET_PROXY_ALREADY_EXISTS\";          // AssetProxy with same id already exists.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant ASSET_PROXY_DOES_NOT_EXIST = \"ASSET_PROXY_DOES_NOT_EXIST\";          // No assetProxy registered at given id.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant TRANSFER_FAILED = \"TRANSFER_FAILED\";                                // Asset transfer unsuccesful.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant LENGTH_GREATER_THAN_0_REQUIRED = \"LENGTH_GREATER_THAN_0_REQUIRED\";  // Byte array must have a length greater than 0.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant LENGTH_GREATER_THAN_3_REQUIRED = \"LENGTH_GREATER_THAN_3_REQUIRED\";  // Byte array must have a length greater than 3.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant LENGTH_0_REQUIRED = \"LENGTH_0_REQUIRED\";                            // Byte array must have a length of 0.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant LENGTH_65_REQUIRED = \"LENGTH_65_REQUIRED\";                          // Byte array must have a length of 65.\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/mixins/MSignatureValidator.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": 58,
                    "vulnerability_code": "    function isValidSignature(\n\n        bytes32 hash,\n\n        address signerAddress,\n\n        bytes memory signature\n\n    )\n\n        public\n\n        view\n",
                    "message": "ISignatureValidator.isValidSignature (MSignatureValidator.sol#51-58) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/mixins/MTransactions.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/mixins/MAssetProxyDispatcher.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/libs/LibExchangeErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant ORDER_UNFILLABLE = \"ORDER_UNFILLABLE\";                              // Order cannot be filled.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_MAKER = \"INVALID_MAKER\";                                    // Invalid makerAddress.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_TAKER = \"INVALID_TAKER\";                                    // Invalid takerAddress.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_SENDER = \"INVALID_SENDER\";                                  // Invalid `msg.sender`.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_ORDER_SIGNATURE = \"INVALID_ORDER_SIGNATURE\";                // Signature validation failed. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_TAKER_AMOUNT = \"INVALID_TAKER_AMOUNT\";                      // takerAssetFillAmount cannot equal 0.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant ROUNDING_ERROR = \"ROUNDING_ERROR\";                                  // Rounding error greater than 0.1% of takerAssetFillAmount. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_SIGNATURE = \"INVALID_SIGNATURE\";                            // Signature validation failed. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant SIGNATURE_ILLEGAL = \"SIGNATURE_ILLEGAL\";                            // Signature type is illegal.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant SIGNATURE_UNSUPPORTED = \"SIGNATURE_UNSUPPORTED\";                    // Signature type unsupported.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_NEW_ORDER_EPOCH = \"INVALID_NEW_ORDER_EPOCH\";                // Specified salt must be greater than or equal to existing orderEpoch.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant COMPLETE_FILL_FAILED = \"COMPLETE_FILL_FAILED\";                      // Desired takerAssetFillAmount could not be completely filled. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NEGATIVE_SPREAD_REQUIRED = \"NEGATIVE_SPREAD_REQUIRED\";              // Matched orders must have a negative spread.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant REENTRANCY_ILLEGAL = \"REENTRANCY_ILLEGAL\";                          // Recursive reentrancy is not allowed. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_TX_HASH = \"INVALID_TX_HASH\";                                // Transaction has already been executed. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_TX_SIGNATURE = \"INVALID_TX_SIGNATURE\";                      // Signature validation failed. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant FAILED_EXECUTION = \"FAILED_EXECUTION\";                              // Transaction execution failed. \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant ASSET_PROXY_ALREADY_EXISTS = \"ASSET_PROXY_ALREADY_EXISTS\";          // AssetProxy with same id already exists.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant ASSET_PROXY_DOES_NOT_EXIST = \"ASSET_PROXY_DOES_NOT_EXIST\";          // No assetProxy registered at given id.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant TRANSFER_FAILED = \"TRANSFER_FAILED\";                                // Asset transfer unsuccesful.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant LENGTH_GREATER_THAN_0_REQUIRED = \"LENGTH_GREATER_THAN_0_REQUIRED\";  // Byte array must have a length greater than 0.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant LENGTH_GREATER_THAN_3_REQUIRED = \"LENGTH_GREATER_THAN_3_REQUIRED\";  // Byte array must have a length greater than 3.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant LENGTH_0_REQUIRED = \"LENGTH_0_REQUIRED\";                            // Byte array must have a length of 0.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant LENGTH_65_REQUIRED = \"LENGTH_65_REQUIRED\";                          // Byte array must have a length of 65.\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/libs/LibOrder.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
                    "message": "LibOrder.hashOrder (LibOrder.sol#164-210) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
                    "message": "LibOrder.hashOrder uses assembly (LibOrder.sol#164-210)\n\t- LibOrder.sol#189-209\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (LibOrder.sol#45) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/libs/LibConstants.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (bytes memory zrxAssetData)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ZRX_ASSET_DATA = zrxAssetData;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes public ZRX_ASSET_DATA;\n",
                    "message": "Variable 'LibConstants.ZRX_ASSET_DATA' (LibConstants.sol#42) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/libs/LibEIP712.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (LibEIP712.sol#45) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/libs/LibAbiEncoder.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
                    "message": "LibOrder.hashOrder (LibAbiEncoder.sol#164-210) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": 428,
                    "vulnerability_code": "    function abiEncodeFillOrder(\n\n        LibOrder.Order memory order,\n\n        uint256 takerAssetFillAmount,\n\n        bytes memory signature\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory fillOrderCalldata)\n\n    {\n\n        // We need to call MExchangeCore.fillOrder using a delegatecall in\n\n        // assembly so that we can intercept a call that throws. For this, we\n\n        // need the input encoded in memory in the Ethereum ABIv2 format [1].\n\n\n\n        // | Area     | Offset | Length  | Contents                                    |\n\n        // | -------- |--------|---------|-------------------------------------------- |\n\n        // | Header   | 0x00   | 4       | function selector                           |\n\n        // | Params   |        | 3 * 32  | function parameters:                        |\n\n        // |          | 0x00   |         |   1. offset to order (*)                    |\n\n        // |          | 0x20   |         |   2. takerAssetFillAmount                   |\n\n        // |          | 0x40   |         |   3. offset to signature (*)                |\n\n        // | Data     |        | 12 * 32 | order:                                      |\n\n        // |          | 0x000  |         |   1.  senderAddress                         |\n\n        // |          | 0x020  |         |   2.  makerAddress                          |\n\n        // |          | 0x040  |         |   3.  takerAddress                          |\n\n        // |          | 0x060  |         |   4.  feeRecipientAddress                   |\n\n        // |          | 0x080  |         |   5.  makerAssetAmount                      |\n\n        // |          | 0x0A0  |         |   6.  takerAssetAmount                      |\n\n        // |          | 0x0C0  |         |   7.  makerFeeAmount                        |\n\n        // |          | 0x0E0  |         |   8.  takerFeeAmount                        |\n\n        // |          | 0x100  |         |   9.  expirationTimeSeconds                 |\n\n        // |          | 0x120  |         |   10. salt                                  |\n\n        // |          | 0x140  |         |   11. Offset to makerAssetData (*)          |\n\n        // |          | 0x160  |         |   12. Offset to takerAssetData (*)          |\n\n        // |          | 0x180  | 32      | makerAssetData Length                       |\n\n        // |          | 0x1A0  | **      | makerAssetData Contents                     |\n\n        // |          | 0x1C0  | 32      | takerAssetData Length                       |\n\n        // |          | 0x1E0  | **      | takerAssetData Contents                     |\n\n        // |          | 0x200  | 32      | signature Length                            |\n\n        // |          | 0x220  | **      | signature Contents                          |\n\n\n\n        // * Offsets are calculated from the beginning of the current area: Header, Params, Data:\n\n        //     An offset stored in the Params area is calculated from the beginning of the Params section.\n\n        //     An offset stored in the Data area is calculated from the beginning of the Data section.\n\n\n\n        // ** The length of dynamic array contents are stored in the field immediately preceeding the contents.\n\n\n\n        // [1]: https://solidity.readthedocs.io/en/develop/abi-spec.html\n\n\n\n        assembly {\n\n\n\n            // Areas below may use the following variables:\n\n            //   1. <area>Start   -- Start of this area in memory\n\n            //   2. <area>End     -- End of this area in memory. This value may\n\n            //                       be precomputed (before writing contents),\n\n            //                       or it may be computed as contents are written.\n\n            //   3. <area>Offset  -- Current offset into area. If an area's End\n\n            //                       is precomputed, this variable tracks the\n\n            //                       offsets of contents as they are written.\n\n\n\n            /////// Setup Header Area ///////\n\n            // Load free memory pointer\n\n            fillOrderCalldata := mload(0x40)\n\n            // bytes4(keccak256(\"fillOrder((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes),uint256,bytes)\"))\n\n            // = 0xb4be83d5\n\n            // Leave 0x20 bytes to store the length\n\n            mstore(add(fillOrderCalldata, 0x20), 0xb4be83d500000000000000000000000000000000000000000000000000000000)\n\n            let headerAreaEnd := add(fillOrderCalldata, 0x24)\n\n\n\n            /////// Setup Params Area ///////\n\n            // This area is preallocated and written to later.\n\n            // This is because we need to fill in offsets that have not yet been calculated.\n\n            let paramsAreaStart := headerAreaEnd\n\n            let paramsAreaEnd := add(paramsAreaStart, 0x60)\n\n            let paramsAreaOffset := paramsAreaStart\n\n\n\n            /////// Setup Data Area ///////\n\n            let dataAreaStart := paramsAreaEnd\n\n            let dataAreaEnd := dataAreaStart\n\n\n\n            // Offset from the source data we're reading from\n\n            let sourceOffset := order\n\n            // arrayLenBytes and arrayLenWords track the length of a dynamically-allocated bytes array.\n\n            let arrayLenBytes := 0\n\n            let arrayLenWords := 0\n\n\n\n            /////// Write order Struct ///////\n\n            // Write memory location of Order, relative to the start of the\n\n            // parameter list, then increment the paramsAreaOffset respectively.\n\n            mstore(paramsAreaOffset, sub(dataAreaEnd, paramsAreaStart))\n\n            paramsAreaOffset := add(paramsAreaOffset, 0x20)\n\n\n\n            // Write values for each field in the order\n\n            // It would be nice to use a loop, but we save on gas by writing\n\n            // the stores sequentially.\n\n            mstore(dataAreaEnd, mload(sourceOffset))                            // makerAddress\n\n            mstore(add(dataAreaEnd, 0x20), mload(add(sourceOffset, 0x20)))      // takerAddress\n\n            mstore(add(dataAreaEnd, 0x40), mload(add(sourceOffset, 0x40)))      // feeRecipientAddress\n\n            mstore(add(dataAreaEnd, 0x60), mload(add(sourceOffset, 0x60)))      // senderAddress\n\n            mstore(add(dataAreaEnd, 0x80), mload(add(sourceOffset, 0x80)))      // makerAssetAmount\n\n            mstore(add(dataAreaEnd, 0xA0), mload(add(sourceOffset, 0xA0)))      // takerAssetAmount\n\n            mstore(add(dataAreaEnd, 0xC0), mload(add(sourceOffset, 0xC0)))      // makerFeeAmount\n\n            mstore(add(dataAreaEnd, 0xE0), mload(add(sourceOffset, 0xE0)))      // takerFeeAmount\n\n            mstore(add(dataAreaEnd, 0x100), mload(add(sourceOffset, 0x100)))    // expirationTimeSeconds\n\n            mstore(add(dataAreaEnd, 0x120), mload(add(sourceOffset, 0x120)))    // salt\n\n            mstore(add(dataAreaEnd, 0x140), mload(add(sourceOffset, 0x140)))    // Offset to makerAssetData\n\n            mstore(add(dataAreaEnd, 0x160), mload(add(sourceOffset, 0x160)))    // Offset to takerAssetData\n\n            dataAreaEnd := add(dataAreaEnd, 0x180)\n\n            sourceOffset := add(sourceOffset, 0x180)\n\n\n\n            // Write offset to <order.makerAssetData>\n\n            mstore(add(dataAreaStart, mul(10, 0x20)), sub(dataAreaEnd, dataAreaStart))\n\n\n\n            // Calculate length of <order.makerAssetData>\n\n            sourceOffset := mload(add(order, 0x140)) // makerAssetData\n\n            arrayLenBytes := mload(sourceOffset)\n\n            sourceOffset := add(sourceOffset, 0x20)\n\n            arrayLenWords := div(add(arrayLenBytes, 0x1F), 0x20)\n\n\n\n            // Write length of <order.makerAssetData>\n\n            mstore(dataAreaEnd, arrayLenBytes)\n\n            dataAreaEnd := add(dataAreaEnd, 0x20)\n\n\n\n            // Write contents of <order.makerAssetData>\n\n            for {let i := 0} lt(i, arrayLenWords) {i := add(i, 1)} {\n\n                mstore(dataAreaEnd, mload(sourceOffset))\n\n                dataAreaEnd := add(dataAreaEnd, 0x20)\n\n                sourceOffset := add(sourceOffset, 0x20)\n\n            }\n\n\n\n            // Write offset to <order.takerAssetData>\n\n            mstore(add(dataAreaStart, mul(11, 0x20)), sub(dataAreaEnd, dataAreaStart))\n\n\n\n            // Calculate length of <order.takerAssetData>\n\n            sourceOffset := mload(add(order, 0x160)) // takerAssetData\n\n            arrayLenBytes := mload(sourceOffset)\n\n            sourceOffset := add(sourceOffset, 0x20)\n\n            arrayLenWords := div(add(arrayLenBytes, 0x1F), 0x20)\n\n\n\n            // Write length of <order.takerAssetData>\n\n            mstore(dataAreaEnd, arrayLenBytes)\n\n            dataAreaEnd := add(dataAreaEnd, 0x20)\n\n\n\n            // Write contents of  <order.takerAssetData>\n\n            for {let i := 0} lt(i, arrayLenWords) {i := add(i, 1)} {\n\n                mstore(dataAreaEnd, mload(sourceOffset))\n\n                dataAreaEnd := add(dataAreaEnd, 0x20)\n\n                sourceOffset := add(sourceOffset, 0x20)\n\n            }\n\n\n\n            /////// Write takerAssetFillAmount ///////\n\n            mstore(paramsAreaOffset, takerAssetFillAmount)\n\n            paramsAreaOffset := add(paramsAreaOffset, 0x20)\n\n\n\n            /////// Write signature ///////\n\n            // Write offset to paramsArea\n\n            mstore(paramsAreaOffset, sub(dataAreaEnd, paramsAreaStart))\n\n\n\n            // Calculate length of signature\n\n            sourceOffset := signature\n\n            arrayLenBytes := mload(sourceOffset)\n\n            sourceOffset := add(sourceOffset, 0x20)\n\n            arrayLenWords := div(add(arrayLenBytes, 0x1F), 0x20)\n\n\n\n            // Write length of signature\n\n            mstore(dataAreaEnd, arrayLenBytes)\n\n            dataAreaEnd := add(dataAreaEnd, 0x20)\n\n\n\n            // Write contents of signature\n\n            for {let i := 0} lt(i, arrayLenWords) {i := add(i, 1)} {\n\n                mstore(dataAreaEnd, mload(sourceOffset))\n\n                dataAreaEnd := add(dataAreaEnd, 0x20)\n\n                sourceOffset := add(sourceOffset, 0x20)\n\n            }\n\n\n\n            // Set length of calldata\n\n            mstore(\n\n                fillOrderCalldata,\n\n                sub(dataAreaEnd, add(fillOrderCalldata, 0x20))\n\n            )\n\n        }\n\n\n\n        return fillOrderCalldata;\n",
                    "message": "LibAbiEncoder.abiEncodeFillOrder (LibAbiEncoder.sol#246-428) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
                    "message": "LibOrder.hashOrder uses assembly (LibAbiEncoder.sol#164-210)\n\t- LibAbiEncoder.sol#189-209\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": 428,
                    "vulnerability_code": "    function abiEncodeFillOrder(\n\n        LibOrder.Order memory order,\n\n        uint256 takerAssetFillAmount,\n\n        bytes memory signature\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory fillOrderCalldata)\n\n    {\n\n        // We need to call MExchangeCore.fillOrder using a delegatecall in\n\n        // assembly so that we can intercept a call that throws. For this, we\n\n        // need the input encoded in memory in the Ethereum ABIv2 format [1].\n\n\n\n        // | Area     | Offset | Length  | Contents                                    |\n\n        // | -------- |--------|---------|-------------------------------------------- |\n\n        // | Header   | 0x00   | 4       | function selector                           |\n\n        // | Params   |        | 3 * 32  | function parameters:                        |\n\n        // |          | 0x00   |         |   1. offset to order (*)                    |\n\n        // |          | 0x20   |         |   2. takerAssetFillAmount                   |\n\n        // |          | 0x40   |         |   3. offset to signature (*)                |\n\n        // | Data     |        | 12 * 32 | order:                                      |\n\n        // |          | 0x000  |         |   1.  senderAddress                         |\n\n        // |          | 0x020  |         |   2.  makerAddress                          |\n\n        // |          | 0x040  |         |   3.  takerAddress                          |\n\n        // |          | 0x060  |         |   4.  feeRecipientAddress                   |\n\n        // |          | 0x080  |         |   5.  makerAssetAmount                      |\n\n        // |          | 0x0A0  |         |   6.  takerAssetAmount                      |\n\n        // |          | 0x0C0  |         |   7.  makerFeeAmount                        |\n\n        // |          | 0x0E0  |         |   8.  takerFeeAmount                        |\n\n        // |          | 0x100  |         |   9.  expirationTimeSeconds                 |\n\n        // |          | 0x120  |         |   10. salt                                  |\n\n        // |          | 0x140  |         |   11. Offset to makerAssetData (*)          |\n\n        // |          | 0x160  |         |   12. Offset to takerAssetData (*)          |\n\n        // |          | 0x180  | 32      | makerAssetData Length                       |\n\n        // |          | 0x1A0  | **      | makerAssetData Contents                     |\n\n        // |          | 0x1C0  | 32      | takerAssetData Length                       |\n\n        // |          | 0x1E0  | **      | takerAssetData Contents                     |\n\n        // |          | 0x200  | 32      | signature Length                            |\n\n        // |          | 0x220  | **      | signature Contents                          |\n\n\n\n        // * Offsets are calculated from the beginning of the current area: Header, Params, Data:\n\n        //     An offset stored in the Params area is calculated from the beginning of the Params section.\n\n        //     An offset stored in the Data area is calculated from the beginning of the Data section.\n\n\n\n        // ** The length of dynamic array contents are stored in the field immediately preceeding the contents.\n\n\n\n        // [1]: https://solidity.readthedocs.io/en/develop/abi-spec.html\n\n\n\n        assembly {\n\n\n\n            // Areas below may use the following variables:\n\n            //   1. <area>Start   -- Start of this area in memory\n\n            //   2. <area>End     -- End of this area in memory. This value may\n\n            //                       be precomputed (before writing contents),\n\n            //                       or it may be computed as contents are written.\n\n            //   3. <area>Offset  -- Current offset into area. If an area's End\n\n            //                       is precomputed, this variable tracks the\n\n            //                       offsets of contents as they are written.\n\n\n\n            /////// Setup Header Area ///////\n\n            // Load free memory pointer\n\n            fillOrderCalldata := mload(0x40)\n\n            // bytes4(keccak256(\"fillOrder((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes),uint256,bytes)\"))\n\n            // = 0xb4be83d5\n\n            // Leave 0x20 bytes to store the length\n\n            mstore(add(fillOrderCalldata, 0x20), 0xb4be83d500000000000000000000000000000000000000000000000000000000)\n\n            let headerAreaEnd := add(fillOrderCalldata, 0x24)\n\n\n\n            /////// Setup Params Area ///////\n\n            // This area is preallocated and written to later.\n\n            // This is because we need to fill in offsets that have not yet been calculated.\n\n            let paramsAreaStart := headerAreaEnd\n\n            let paramsAreaEnd := add(paramsAreaStart, 0x60)\n\n            let paramsAreaOffset := paramsAreaStart\n\n\n\n            /////// Setup Data Area ///////\n\n            let dataAreaStart := paramsAreaEnd\n\n            let dataAreaEnd := dataAreaStart\n\n\n\n            // Offset from the source data we're reading from\n\n            let sourceOffset := order\n\n            // arrayLenBytes and arrayLenWords track the length of a dynamically-allocated bytes array.\n\n            let arrayLenBytes := 0\n\n            let arrayLenWords := 0\n\n\n\n            /////// Write order Struct ///////\n\n            // Write memory location of Order, relative to the start of the\n\n            // parameter list, then increment the paramsAreaOffset respectively.\n\n            mstore(paramsAreaOffset, sub(dataAreaEnd, paramsAreaStart))\n\n            paramsAreaOffset := add(paramsAreaOffset, 0x20)\n\n\n\n            // Write values for each field in the order\n\n            // It would be nice to use a loop, but we save on gas by writing\n\n            // the stores sequentially.\n\n            mstore(dataAreaEnd, mload(sourceOffset))                            // makerAddress\n\n            mstore(add(dataAreaEnd, 0x20), mload(add(sourceOffset, 0x20)))      // takerAddress\n\n            mstore(add(dataAreaEnd, 0x40), mload(add(sourceOffset, 0x40)))      // feeRecipientAddress\n\n            mstore(add(dataAreaEnd, 0x60), mload(add(sourceOffset, 0x60)))      // senderAddress\n\n            mstore(add(dataAreaEnd, 0x80), mload(add(sourceOffset, 0x80)))      // makerAssetAmount\n\n            mstore(add(dataAreaEnd, 0xA0), mload(add(sourceOffset, 0xA0)))      // takerAssetAmount\n\n            mstore(add(dataAreaEnd, 0xC0), mload(add(sourceOffset, 0xC0)))      // makerFeeAmount\n\n            mstore(add(dataAreaEnd, 0xE0), mload(add(sourceOffset, 0xE0)))      // takerFeeAmount\n\n            mstore(add(dataAreaEnd, 0x100), mload(add(sourceOffset, 0x100)))    // expirationTimeSeconds\n\n            mstore(add(dataAreaEnd, 0x120), mload(add(sourceOffset, 0x120)))    // salt\n\n            mstore(add(dataAreaEnd, 0x140), mload(add(sourceOffset, 0x140)))    // Offset to makerAssetData\n\n            mstore(add(dataAreaEnd, 0x160), mload(add(sourceOffset, 0x160)))    // Offset to takerAssetData\n\n            dataAreaEnd := add(dataAreaEnd, 0x180)\n\n            sourceOffset := add(sourceOffset, 0x180)\n\n\n\n            // Write offset to <order.makerAssetData>\n\n            mstore(add(dataAreaStart, mul(10, 0x20)), sub(dataAreaEnd, dataAreaStart))\n\n\n\n            // Calculate length of <order.makerAssetData>\n\n            sourceOffset := mload(add(order, 0x140)) // makerAssetData\n\n            arrayLenBytes := mload(sourceOffset)\n\n            sourceOffset := add(sourceOffset, 0x20)\n\n            arrayLenWords := div(add(arrayLenBytes, 0x1F), 0x20)\n\n\n\n            // Write length of <order.makerAssetData>\n\n            mstore(dataAreaEnd, arrayLenBytes)\n\n            dataAreaEnd := add(dataAreaEnd, 0x20)\n\n\n\n            // Write contents of <order.makerAssetData>\n\n            for {let i := 0} lt(i, arrayLenWords) {i := add(i, 1)} {\n\n                mstore(dataAreaEnd, mload(sourceOffset))\n\n                dataAreaEnd := add(dataAreaEnd, 0x20)\n\n                sourceOffset := add(sourceOffset, 0x20)\n\n            }\n\n\n\n            // Write offset to <order.takerAssetData>\n\n            mstore(add(dataAreaStart, mul(11, 0x20)), sub(dataAreaEnd, dataAreaStart))\n\n\n\n            // Calculate length of <order.takerAssetData>\n\n            sourceOffset := mload(add(order, 0x160)) // takerAssetData\n\n            arrayLenBytes := mload(sourceOffset)\n\n            sourceOffset := add(sourceOffset, 0x20)\n\n            arrayLenWords := div(add(arrayLenBytes, 0x1F), 0x20)\n\n\n\n            // Write length of <order.takerAssetData>\n\n            mstore(dataAreaEnd, arrayLenBytes)\n\n            dataAreaEnd := add(dataAreaEnd, 0x20)\n\n\n\n            // Write contents of  <order.takerAssetData>\n\n            for {let i := 0} lt(i, arrayLenWords) {i := add(i, 1)} {\n\n                mstore(dataAreaEnd, mload(sourceOffset))\n\n                dataAreaEnd := add(dataAreaEnd, 0x20)\n\n                sourceOffset := add(sourceOffset, 0x20)\n\n            }\n\n\n\n            /////// Write takerAssetFillAmount ///////\n\n            mstore(paramsAreaOffset, takerAssetFillAmount)\n\n            paramsAreaOffset := add(paramsAreaOffset, 0x20)\n\n\n\n            /////// Write signature ///////\n\n            // Write offset to paramsArea\n\n            mstore(paramsAreaOffset, sub(dataAreaEnd, paramsAreaStart))\n\n\n\n            // Calculate length of signature\n\n            sourceOffset := signature\n\n            arrayLenBytes := mload(sourceOffset)\n\n            sourceOffset := add(sourceOffset, 0x20)\n\n            arrayLenWords := div(add(arrayLenBytes, 0x1F), 0x20)\n\n\n\n            // Write length of signature\n\n            mstore(dataAreaEnd, arrayLenBytes)\n\n            dataAreaEnd := add(dataAreaEnd, 0x20)\n\n\n\n            // Write contents of signature\n\n            for {let i := 0} lt(i, arrayLenWords) {i := add(i, 1)} {\n\n                mstore(dataAreaEnd, mload(sourceOffset))\n\n                dataAreaEnd := add(dataAreaEnd, 0x20)\n\n                sourceOffset := add(sourceOffset, 0x20)\n\n            }\n\n\n\n            // Set length of calldata\n\n            mstore(\n\n                fillOrderCalldata,\n\n                sub(dataAreaEnd, add(fillOrderCalldata, 0x20))\n\n            )\n\n        }\n\n\n\n        return fillOrderCalldata;\n",
                    "message": "LibAbiEncoder.abiEncodeFillOrder uses assembly (LibAbiEncoder.sol#246-428)\n\t- LibAbiEncoder.sol#294-427\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.24;\n",
                    "message": "Different versions of Solidity is used in LibAbiEncoder.sol:\n\t- Version used: ['0.4.24', 'ABIEncoderV2']\n\t- LibAbiEncoder.sol#21 declares pragma solidity0.4.24\n\t- LibAbiEncoder.sol#90 declares pragma solidity0.4.24\n\t- LibAbiEncoder.sol#233 declares pragma solidity0.4.24\n\t- LibAbiEncoder.sol#234 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": 428,
                    "vulnerability_code": "    function abiEncodeFillOrder(\n\n        LibOrder.Order memory order,\n\n        uint256 takerAssetFillAmount,\n\n        bytes memory signature\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory fillOrderCalldata)\n\n    {\n\n        // We need to call MExchangeCore.fillOrder using a delegatecall in\n\n        // assembly so that we can intercept a call that throws. For this, we\n\n        // need the input encoded in memory in the Ethereum ABIv2 format [1].\n\n\n\n        // | Area     | Offset | Length  | Contents                                    |\n\n        // | -------- |--------|---------|-------------------------------------------- |\n\n        // | Header   | 0x00   | 4       | function selector                           |\n\n        // | Params   |        | 3 * 32  | function parameters:                        |\n\n        // |          | 0x00   |         |   1. offset to order (*)                    |\n\n        // |          | 0x20   |         |   2. takerAssetFillAmount                   |\n\n        // |          | 0x40   |         |   3. offset to signature (*)                |\n\n        // | Data     |        | 12 * 32 | order:                                      |\n\n        // |          | 0x000  |         |   1.  senderAddress                         |\n\n        // |          | 0x020  |         |   2.  makerAddress                          |\n\n        // |          | 0x040  |         |   3.  takerAddress                          |\n\n        // |          | 0x060  |         |   4.  feeRecipientAddress                   |\n\n        // |          | 0x080  |         |   5.  makerAssetAmount                      |\n\n        // |          | 0x0A0  |         |   6.  takerAssetAmount                      |\n\n        // |          | 0x0C0  |         |   7.  makerFeeAmount                        |\n\n        // |          | 0x0E0  |         |   8.  takerFeeAmount                        |\n\n        // |          | 0x100  |         |   9.  expirationTimeSeconds                 |\n\n        // |          | 0x120  |         |   10. salt                                  |\n\n        // |          | 0x140  |         |   11. Offset to makerAssetData (*)          |\n\n        // |          | 0x160  |         |   12. Offset to takerAssetData (*)          |\n\n        // |          | 0x180  | 32      | makerAssetData Length                       |\n\n        // |          | 0x1A0  | **      | makerAssetData Contents                     |\n\n        // |          | 0x1C0  | 32      | takerAssetData Length                       |\n\n        // |          | 0x1E0  | **      | takerAssetData Contents                     |\n\n        // |          | 0x200  | 32      | signature Length                            |\n\n        // |          | 0x220  | **      | signature Contents                          |\n\n\n\n        // * Offsets are calculated from the beginning of the current area: Header, Params, Data:\n\n        //     An offset stored in the Params area is calculated from the beginning of the Params section.\n\n        //     An offset stored in the Data area is calculated from the beginning of the Data section.\n\n\n\n        // ** The length of dynamic array contents are stored in the field immediately preceeding the contents.\n\n\n\n        // [1]: https://solidity.readthedocs.io/en/develop/abi-spec.html\n\n\n\n        assembly {\n\n\n\n            // Areas below may use the following variables:\n\n            //   1. <area>Start   -- Start of this area in memory\n\n            //   2. <area>End     -- End of this area in memory. This value may\n\n            //                       be precomputed (before writing contents),\n\n            //                       or it may be computed as contents are written.\n\n            //   3. <area>Offset  -- Current offset into area. If an area's End\n\n            //                       is precomputed, this variable tracks the\n\n            //                       offsets of contents as they are written.\n\n\n\n            /////// Setup Header Area ///////\n\n            // Load free memory pointer\n\n            fillOrderCalldata := mload(0x40)\n\n            // bytes4(keccak256(\"fillOrder((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes),uint256,bytes)\"))\n\n            // = 0xb4be83d5\n\n            // Leave 0x20 bytes to store the length\n\n            mstore(add(fillOrderCalldata, 0x20), 0xb4be83d500000000000000000000000000000000000000000000000000000000)\n\n            let headerAreaEnd := add(fillOrderCalldata, 0x24)\n\n\n\n            /////// Setup Params Area ///////\n\n            // This area is preallocated and written to later.\n\n            // This is because we need to fill in offsets that have not yet been calculated.\n\n            let paramsAreaStart := headerAreaEnd\n\n            let paramsAreaEnd := add(paramsAreaStart, 0x60)\n\n            let paramsAreaOffset := paramsAreaStart\n\n\n\n            /////// Setup Data Area ///////\n\n            let dataAreaStart := paramsAreaEnd\n\n            let dataAreaEnd := dataAreaStart\n\n\n\n            // Offset from the source data we're reading from\n\n            let sourceOffset := order\n\n            // arrayLenBytes and arrayLenWords track the length of a dynamically-allocated bytes array.\n\n            let arrayLenBytes := 0\n\n            let arrayLenWords := 0\n\n\n\n            /////// Write order Struct ///////\n\n            // Write memory location of Order, relative to the start of the\n\n            // parameter list, then increment the paramsAreaOffset respectively.\n\n            mstore(paramsAreaOffset, sub(dataAreaEnd, paramsAreaStart))\n\n            paramsAreaOffset := add(paramsAreaOffset, 0x20)\n\n\n\n            // Write values for each field in the order\n\n            // It would be nice to use a loop, but we save on gas by writing\n\n            // the stores sequentially.\n\n            mstore(dataAreaEnd, mload(sourceOffset))                            // makerAddress\n\n            mstore(add(dataAreaEnd, 0x20), mload(add(sourceOffset, 0x20)))      // takerAddress\n\n            mstore(add(dataAreaEnd, 0x40), mload(add(sourceOffset, 0x40)))      // feeRecipientAddress\n\n            mstore(add(dataAreaEnd, 0x60), mload(add(sourceOffset, 0x60)))      // senderAddress\n\n            mstore(add(dataAreaEnd, 0x80), mload(add(sourceOffset, 0x80)))      // makerAssetAmount\n\n            mstore(add(dataAreaEnd, 0xA0), mload(add(sourceOffset, 0xA0)))      // takerAssetAmount\n\n            mstore(add(dataAreaEnd, 0xC0), mload(add(sourceOffset, 0xC0)))      // makerFeeAmount\n\n            mstore(add(dataAreaEnd, 0xE0), mload(add(sourceOffset, 0xE0)))      // takerFeeAmount\n\n            mstore(add(dataAreaEnd, 0x100), mload(add(sourceOffset, 0x100)))    // expirationTimeSeconds\n\n            mstore(add(dataAreaEnd, 0x120), mload(add(sourceOffset, 0x120)))    // salt\n\n            mstore(add(dataAreaEnd, 0x140), mload(add(sourceOffset, 0x140)))    // Offset to makerAssetData\n\n            mstore(add(dataAreaEnd, 0x160), mload(add(sourceOffset, 0x160)))    // Offset to takerAssetData\n\n            dataAreaEnd := add(dataAreaEnd, 0x180)\n\n            sourceOffset := add(sourceOffset, 0x180)\n\n\n\n            // Write offset to <order.makerAssetData>\n\n            mstore(add(dataAreaStart, mul(10, 0x20)), sub(dataAreaEnd, dataAreaStart))\n\n\n\n            // Calculate length of <order.makerAssetData>\n\n            sourceOffset := mload(add(order, 0x140)) // makerAssetData\n\n            arrayLenBytes := mload(sourceOffset)\n\n            sourceOffset := add(sourceOffset, 0x20)\n\n            arrayLenWords := div(add(arrayLenBytes, 0x1F), 0x20)\n\n\n\n            // Write length of <order.makerAssetData>\n\n            mstore(dataAreaEnd, arrayLenBytes)\n\n            dataAreaEnd := add(dataAreaEnd, 0x20)\n\n\n\n            // Write contents of <order.makerAssetData>\n\n            for {let i := 0} lt(i, arrayLenWords) {i := add(i, 1)} {\n\n                mstore(dataAreaEnd, mload(sourceOffset))\n\n                dataAreaEnd := add(dataAreaEnd, 0x20)\n\n                sourceOffset := add(sourceOffset, 0x20)\n\n            }\n\n\n\n            // Write offset to <order.takerAssetData>\n\n            mstore(add(dataAreaStart, mul(11, 0x20)), sub(dataAreaEnd, dataAreaStart))\n\n\n\n            // Calculate length of <order.takerAssetData>\n\n            sourceOffset := mload(add(order, 0x160)) // takerAssetData\n\n            arrayLenBytes := mload(sourceOffset)\n\n            sourceOffset := add(sourceOffset, 0x20)\n\n            arrayLenWords := div(add(arrayLenBytes, 0x1F), 0x20)\n\n\n\n            // Write length of <order.takerAssetData>\n\n            mstore(dataAreaEnd, arrayLenBytes)\n\n            dataAreaEnd := add(dataAreaEnd, 0x20)\n\n\n\n            // Write contents of  <order.takerAssetData>\n\n            for {let i := 0} lt(i, arrayLenWords) {i := add(i, 1)} {\n\n                mstore(dataAreaEnd, mload(sourceOffset))\n\n                dataAreaEnd := add(dataAreaEnd, 0x20)\n\n                sourceOffset := add(sourceOffset, 0x20)\n\n            }\n\n\n\n            /////// Write takerAssetFillAmount ///////\n\n            mstore(paramsAreaOffset, takerAssetFillAmount)\n\n            paramsAreaOffset := add(paramsAreaOffset, 0x20)\n\n\n\n            /////// Write signature ///////\n\n            // Write offset to paramsArea\n\n            mstore(paramsAreaOffset, sub(dataAreaEnd, paramsAreaStart))\n\n\n\n            // Calculate length of signature\n\n            sourceOffset := signature\n\n            arrayLenBytes := mload(sourceOffset)\n\n            sourceOffset := add(sourceOffset, 0x20)\n\n            arrayLenWords := div(add(arrayLenBytes, 0x1F), 0x20)\n\n\n\n            // Write length of signature\n\n            mstore(dataAreaEnd, arrayLenBytes)\n\n            dataAreaEnd := add(dataAreaEnd, 0x20)\n\n\n\n            // Write contents of signature\n\n            for {let i := 0} lt(i, arrayLenWords) {i := add(i, 1)} {\n\n                mstore(dataAreaEnd, mload(sourceOffset))\n\n                dataAreaEnd := add(dataAreaEnd, 0x20)\n\n                sourceOffset := add(sourceOffset, 0x20)\n\n            }\n\n\n\n            // Set length of calldata\n\n            mstore(\n\n                fillOrderCalldata,\n\n                sub(dataAreaEnd, add(fillOrderCalldata, 0x20))\n\n            )\n\n        }\n\n\n\n        return fillOrderCalldata;\n",
                    "message": "LibAbiEncoder.abiEncodeFillOrder (LibAbiEncoder.sol#246-428) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (LibAbiEncoder.sol#45) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function abiEncodeFillOrder(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/libs/LibFillResults.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c / a == b,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b <= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_UNDERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c >= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/libs/LibMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c / a == b,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b <= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_UNDERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c >= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/interfaces/ITransactions.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/interfaces/IWallet.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/interfaces/IWrapperFunctions.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c / a == b,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b <= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_UNDERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c >= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_15"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
                    "message": "LibOrder.hashOrder (IWrapperFunctions.sol#164-210) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
                    "message": "LibOrder.hashOrder uses assembly (IWrapperFunctions.sol#164-210)\n\t- IWrapperFunctions.sol#189-209\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.24;\n",
                    "message": "Different versions of Solidity is used in IWrapperFunctions.sol:\n\t- Version used: ['0.4.24', 'ABIEncoderV2']\n\t- IWrapperFunctions.sol#21 declares pragma solidity0.4.24\n\t- IWrapperFunctions.sol#90 declares pragma solidity0.4.24\n\t- IWrapperFunctions.sol#215 declares pragma solidity0.4.24\n\t- IWrapperFunctions.sol#322 declares pragma solidity0.4.24\n\t- IWrapperFunctions.sol#376 declares pragma solidity0.4.24\n\t- IWrapperFunctions.sol#377 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": 392,
                    "vulnerability_code": "    function fillOrKillOrder(\n\n        LibOrder.Order memory order,\n\n        uint256 takerAssetFillAmount,\n\n        bytes memory signature\n\n    )\n\n        public\n",
                    "message": "IWrapperFunctions.fillOrKillOrder (IWrapperFunctions.sol#386-392) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": 406,
                    "vulnerability_code": "    function fillOrderNoThrow(\n\n        LibOrder.Order memory order,\n\n        uint256 takerAssetFillAmount,\n\n        bytes memory signature\n\n    )\n\n        public\n",
                    "message": "IWrapperFunctions.fillOrderNoThrow (IWrapperFunctions.sol#400-406) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": 419,
                    "vulnerability_code": "    function batchFillOrders(\n\n        LibOrder.Order[] memory orders,\n\n        uint256[] memory takerAssetFillAmounts,\n\n        bytes[] memory signatures\n\n    )\n\n        public\n",
                    "message": "IWrapperFunctions.batchFillOrders (IWrapperFunctions.sol#413-419) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 426,
                    "vulnerability_to_line": 432,
                    "vulnerability_code": "    function batchFillOrKillOrders(\n\n        LibOrder.Order[] memory orders,\n\n        uint256[] memory takerAssetFillAmounts,\n\n        bytes[] memory signatures\n\n    )\n\n        public\n",
                    "message": "IWrapperFunctions.batchFillOrKillOrders (IWrapperFunctions.sol#426-432) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": 446,
                    "vulnerability_code": "    function batchFillOrdersNoThrow(\n\n        LibOrder.Order[] memory orders,\n\n        uint256[] memory takerAssetFillAmounts,\n\n        bytes[] memory signatures\n\n    )\n\n        public\n",
                    "message": "IWrapperFunctions.batchFillOrdersNoThrow (IWrapperFunctions.sol#440-446) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 459,
                    "vulnerability_code": "    function marketSellOrders(\n\n        LibOrder.Order[] memory orders,\n\n        uint256 takerAssetFillAmount,\n\n        bytes[] memory signatures\n\n    )\n\n        public\n",
                    "message": "IWrapperFunctions.marketSellOrders (IWrapperFunctions.sol#453-459) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 467,
                    "vulnerability_to_line": 473,
                    "vulnerability_code": "    function marketSellOrdersNoThrow(\n\n        LibOrder.Order[] memory orders,\n\n        uint256 takerAssetFillAmount,\n\n        bytes[] memory signatures\n\n    )\n\n        public\n",
                    "message": "IWrapperFunctions.marketSellOrdersNoThrow (IWrapperFunctions.sol#467-473) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": 486,
                    "vulnerability_code": "    function marketBuyOrders(\n\n        LibOrder.Order[] memory orders,\n\n        uint256 makerAssetFillAmount,\n\n        bytes[] memory signatures\n\n    )\n\n        public\n",
                    "message": "IWrapperFunctions.marketBuyOrders (IWrapperFunctions.sol#480-486) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 500,
                    "vulnerability_code": "    function marketBuyOrdersNoThrow(\n\n        LibOrder.Order[] memory orders,\n\n        uint256 makerAssetFillAmount,\n\n        bytes[] memory signatures\n\n    )\n\n        public\n",
                    "message": "IWrapperFunctions.marketBuyOrdersNoThrow (IWrapperFunctions.sol#494-500) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": 505,
                    "vulnerability_code": "    function batchCancelOrders(LibOrder.Order[] memory orders)\n",
                    "message": "IWrapperFunctions.batchCancelOrders (IWrapperFunctions.sol#504-505) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": 513,
                    "vulnerability_code": "    function getOrdersInfo(LibOrder.Order[] memory orders)\n\n        public\n\n        view\n",
                    "message": "IWrapperFunctions.getOrdersInfo (IWrapperFunctions.sol#510-513) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (IWrapperFunctions.sol#45) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/interfaces/IValidator.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/interfaces/ISignatureValidator.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": 58,
                    "vulnerability_code": "    function isValidSignature(\n\n        bytes32 hash,\n\n        address signerAddress,\n\n        bytes memory signature\n\n    )\n\n        public\n\n        view\n",
                    "message": "ISignatureValidator.isValidSignature (ISignatureValidator.sol#51-58) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/interfaces/IExchangeCore.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c / a == b,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b <= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_UNDERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c >= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
                    "message": "LibOrder.hashOrder (IExchangeCore.sol#164-210) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
                    "message": "LibOrder.hashOrder uses assembly (IExchangeCore.sol#164-210)\n\t- IExchangeCore.sol#189-209\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.24;\n",
                    "message": "Different versions of Solidity is used in IExchangeCore.sol:\n\t- Version used: ['0.4.24', 'ABIEncoderV2']\n\t- IExchangeCore.sol#21 declares pragma solidity0.4.24\n\t- IExchangeCore.sol#90 declares pragma solidity0.4.24\n\t- IExchangeCore.sol#215 declares pragma solidity0.4.24\n\t- IExchangeCore.sol#322 declares pragma solidity0.4.24\n\t- IExchangeCore.sol#376 declares pragma solidity0.4.24\n\t- IExchangeCore.sol#377 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 393,
                    "vulnerability_to_line": 399,
                    "vulnerability_code": "    function fillOrder(\n\n        LibOrder.Order memory order,\n\n        uint256 takerAssetFillAmount,\n\n        bytes memory signature\n\n    )\n\n        public\n",
                    "message": "IExchangeCore.fillOrder (IExchangeCore.sol#393-399) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 403,
                    "vulnerability_to_line": 404,
                    "vulnerability_code": "    function cancelOrder(LibOrder.Order memory order)\n",
                    "message": "IExchangeCore.cancelOrder (IExchangeCore.sol#403-404) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": 413,
                    "vulnerability_code": "    function getOrderInfo(LibOrder.Order memory order)\n\n        public\n\n        view\n",
                    "message": "IExchangeCore.getOrderInfo (IExchangeCore.sol#410-413) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (IExchangeCore.sol#45) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/interfaces/IMatchOrders.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c / a == b,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b <= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_UNDERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c >= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
                    "message": "LibOrder.hashOrder (IMatchOrders.sol#164-210) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encode(\n\n        //     order.makerAddress,\n\n        //     order.takerAddress,\n\n        //     order.feeRecipientAddress,\n\n        //     order.senderAddress,\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Backup\n\n            // solhint-disable-next-line space-after-comma\n\n            let temp1 := mload(sub(order,  32))\n\n            let temp2 := mload(add(order, 320))\n\n            let temp3 := mload(add(order, 352))\n\n            \n\n            // Hash in place\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), schemaHash)\n\n            mstore(add(order, 320), makerAssetDataHash)\n\n            mstore(add(order, 352), takerAssetDataHash)\n\n            result := keccak256(sub(order, 32), 416)\n\n            \n\n            // Restore\n\n            // solhint-disable-next-line space-after-comma\n\n            mstore(sub(order,  32), temp1)\n\n            mstore(add(order, 320), temp2)\n\n            mstore(add(order, 352), temp3)\n\n        }\n\n        return result;\n",
                    "message": "LibOrder.hashOrder uses assembly (IMatchOrders.sol#164-210)\n\t- IMatchOrders.sol#189-209\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.24;\n",
                    "message": "Different versions of Solidity is used in IMatchOrders.sol:\n\t- Version used: ['0.4.24', 'ABIEncoderV2']\n\t- IMatchOrders.sol#21 declares pragma solidity0.4.24\n\t- IMatchOrders.sol#90 declares pragma solidity0.4.24\n\t- IMatchOrders.sol#215 declares pragma solidity0.4.24\n\t- IMatchOrders.sol#322 declares pragma solidity0.4.24\n\t- IMatchOrders.sol#375 declares pragma solidity0.4.24\n\t- IMatchOrders.sol#376 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": 397,
                    "vulnerability_code": "    function matchOrders(\n\n        LibOrder.Order memory leftOrder,\n\n        LibOrder.Order memory rightOrder,\n\n        bytes memory leftSignature,\n\n        bytes memory rightSignature\n\n    )\n\n        public\n",
                    "message": "IMatchOrders.matchOrders (IMatchOrders.sol#390-397) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (IMatchOrders.sol#45) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashOrder(Order memory order)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/interfaces/IAssetProxyDispatcher.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/AssetProxy/MixinAuthorizable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (authorities[i] == target) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[msg.sender],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SENDER_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_ALREADY_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index < authorities.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INDEX_OUT_OF_BOUNDS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorities[index] == target,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"AUTHORIZED_ADDRESS_MISMATCH\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": 14,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n",
                    "message": "IOwnable.transferOwnership (MixinAuthorizable.sol#13-14) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": 52,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable.transferOwnership (MixinAuthorizable.sol#45-52) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/AssetProxy/ERC721Proxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 737,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 783,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 784,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 782,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (authorities[i] == target) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 783,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 783,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 783,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 784,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 601,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 603,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 743,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 744,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[msg.sender],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SENDER_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 746,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 759,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 760,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_ALREADY_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 775,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 778,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 801,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 802,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 805,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 806,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index < authorities.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 807,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INDEX_OUT_OF_BOUNDS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 808,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 809,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 810,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorities[index] == target,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"AUTHORIZED_ADDRESS_MISMATCH\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 812,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_27"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (ERC721Proxy.sol#33-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (ERC721Proxy.sol#47-56) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (ERC721Proxy.sol#62-163) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (ERC721Proxy.sol#203-227) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (ERC721Proxy.sol#232-251) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 275,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes (ERC721Proxy.sol#256-275) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (ERC721Proxy.sol#299-325) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (ERC721Proxy.sol#331-371) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (ERC721Proxy.sol#377-398) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": 424,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (ERC721Proxy.sol#404-424) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": 479,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (ERC721Proxy.sol#460-479) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 511,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength (ERC721Proxy.sol#487-511) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (ERC721Proxy.sol#33-42)\n\t- ERC721Proxy.sol#38-41\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (ERC721Proxy.sol#47-56)\n\t- ERC721Proxy.sol#52-55\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (ERC721Proxy.sol#62-163)\n\t- ERC721Proxy.sol#74-80\n\t- ERC721Proxy.sol#102-130\n\t- ERC721Proxy.sol#131-161\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (ERC721Proxy.sol#203-227)\n\t- ERC721Proxy.sol#222-226\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (ERC721Proxy.sol#232-251)\n\t- ERC721Proxy.sol#245-250\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 275,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes uses assembly (ERC721Proxy.sol#256-275)\n\t- ERC721Proxy.sol#269-274\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (ERC721Proxy.sol#299-325)\n\t- ERC721Proxy.sol#318-324\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (ERC721Proxy.sol#331-371)\n\t- ERC721Proxy.sol#350-371\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (ERC721Proxy.sol#377-398)\n\t- ERC721Proxy.sol#394-397\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": 424,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (ERC721Proxy.sol#404-424)\n\t- ERC721Proxy.sol#421-424\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": 479,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (ERC721Proxy.sol#460-479)\n\t- ERC721Proxy.sol#472-478\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 511,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength uses assembly (ERC721Proxy.sol#487-511)\n\t- ERC721Proxy.sol#507-510\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": 985,
                    "vulnerability_code": "    function () \n\n        external\n\n    {\n\n        assembly {\n\n            // The first 4 bytes of calldata holds the function selector\n\n            let selector := and(calldataload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n\n\n            // `transferFrom` will be called with the following parameters:\n\n            // assetData Encoded byte array.\n\n            // from Address to transfer asset from.\n\n            // to Address to transfer asset to.\n\n            // amount Amount of asset to transfer.\n\n            // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n\n            if eq(selector, 0xa85e59e400000000000000000000000000000000000000000000000000000000) {\n\n\n\n                // To lookup a value in a mapping, we load from the storage location keccak256(k, p),\n\n                // where k is the key left padded to 32 bytes and p is the storage slot\n\n                let start := mload(64)\n\n                mstore(start, and(caller, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(start, 32), authorized_slot)\n\n\n\n                // Revert if authorized[msg.sender] == false\n\n                if iszero(sload(keccak256(start, 64))) {\n\n                    // Revert with `Error(\"SENDER_NOT_AUTHORIZED\")`\n\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\n                    mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\n\n                    mstore(64, 0x0000001553454e4445525f4e4f545f415554484f52495a454400000000000000)\n\n                    mstore(96, 0)\n\n                    revert(0, 100)\n\n                }\n\n\n\n                // `transferFrom`.\n\n                // The function is marked `external`, so no abi decodeding is done for\n\n                // us. Instead, we expect the `calldata` memory to contain the\n\n                // following:\n\n                //\n\n                // | Area     | Offset | Length  | Contents                            |\n\n                // |----------|--------|---------|-------------------------------------|\n\n                // | Header   | 0      | 4       | function selector                   |\n\n                // | Params   |        | 4 * 32  | function parameters:                |\n\n                // |          | 4      |         |   1. offset to assetData (*)        |\n\n                // |          | 36     |         |   2. from                           |\n\n                // |          | 68     |         |   3. to                             |\n\n                // |          | 100    |         |   4. amount                         |\n\n                // | Data     |        |         | assetData:                          |\n\n                // |          | 132    | 32      | assetData Length                    |\n\n                // |          | 164    | **      | assetData Contents                  |\n\n                //\n\n                // (*): offset is computed from start of function parameters, so offset\n\n                //      by an additional 4 bytes in the calldata.\n\n                //\n\n                // WARNING: The ABIv2 specification allows additional padding between\n\n                //          the Params and Data section. This will result in a larger\n\n                //          offset to assetData.\n\n\n\n                // Asset data itself is encoded as follows:\n\n                //\n\n                // | Area     | Offset | Length  | Contents                            |\n\n                // |----------|--------|---------|-------------------------------------|\n\n                // | Header   | 0      | 4       | function selector                   |\n\n                // | Params   |        | 2 * 32  | function parameters:                |\n\n                // |          | 4      | 12 + 20 |   1. token address                  |\n\n                // |          | 36     |         |   2. tokenId                        |\n\n                \n\n                // We construct calldata for the `token.transferFrom` ABI.\n\n                // The layout of this calldata is in the table below.\n\n                // \n\n                // | Area     | Offset | Length  | Contents                            |\n\n                // |----------|--------|---------|-------------------------------------|\n\n                // | Header   | 0      | 4       | function selector                   |\n\n                // | Params   |        | 3 * 32  | function parameters:                |\n\n                // |          | 4      |         |   1. from                           |\n\n                // |          | 36     |         |   2. to                             |\n\n                // |          | 68     |         |   3. tokenId                        |\n\n\n\n                // There exists only 1 of each token.\n\n                // require(amount == 1, \"INVALID_AMOUNT\")\n\n                if sub(calldataload(100), 1) {\n\n                    // Revert with `Error(\"INVALID_AMOUNT\")`\n\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\n                    mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\n\n                    mstore(64, 0x0000000e494e56414c49445f414d4f554e540000000000000000000000000000)\n\n                    mstore(96, 0)\n\n                    revert(0, 100)\n\n                }\n\n\n\n                /////// Setup Header Area ///////\n\n                // This area holds the 4-byte `transferFrom` selector.\n\n                // Any trailing data in transferFromSelector will be\n\n                // overwritten in the next `mstore` call.\n\n                mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n\n                \n\n                /////// Setup Params Area ///////\n\n                // We copy the fields `from` and `to` in bulk\n\n                // from our own calldata to the new calldata.\n\n                calldatacopy(4, 36, 64)\n\n\n\n                // Copy `tokenId` field from our own calldata to the new calldata.\n\n                let assetDataOffset := calldataload(4)\n\n                calldatacopy(68, add(assetDataOffset, 72), 32)\n\n\n\n                /////// Call `token.transferFrom` using the calldata ///////\n\n                let token := calldataload(add(assetDataOffset, 40))\n\n                let success := call(\n\n                    gas,            // forward all gas\n\n                    token,          // call address of token contract\n\n                    0,              // don't send any ETH\n\n                    0,              // pointer to start of input\n\n                    100,            // length of input\n\n                    0,              // write output to null\n\n                    0               // output size is 0 bytes\n\n                )\n\n                if success {\n\n                    return(0, 0)\n\n                }\n\n                \n\n                // Revert with `Error(\"TRANSFER_FAILED\")`\n\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\n                mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\n\n                mstore(64, 0x0000000f5452414e534645525f4641494c454400000000000000000000000000)\n\n                mstore(96, 0)\n\n                revert(0, 100)\n\n            }\n\n        }\n",
                    "message": "ERC721Proxy.fallback uses assembly (ERC721Proxy.sol#861-985)\n\t- ERC721Proxy.sol#864-985\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": 577,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n",
                    "message": "IOwnable.transferOwnership (ERC721Proxy.sol#576-577) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": 615,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable.transferOwnership (ERC721Proxy.sol#608-615) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 784,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 816,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytesWithLength(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 507,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 864,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/AssetProxy/ERC20Proxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 737,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 783,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 784,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 782,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (authorities[i] == target) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 783,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 783,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 783,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 784,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 601,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 603,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 743,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 744,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[msg.sender],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SENDER_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 746,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 759,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 760,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_ALREADY_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 775,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 778,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 801,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 802,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 805,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 806,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index < authorities.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 807,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INDEX_OUT_OF_BOUNDS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 808,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 809,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 810,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorities[index] == target,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"AUTHORIZED_ADDRESS_MISMATCH\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 812,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_27"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (ERC20Proxy.sol#33-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (ERC20Proxy.sol#47-56) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (ERC20Proxy.sol#62-163) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (ERC20Proxy.sol#203-227) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (ERC20Proxy.sol#232-251) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 275,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes (ERC20Proxy.sol#256-275) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (ERC20Proxy.sol#299-325) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (ERC20Proxy.sol#331-371) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (ERC20Proxy.sol#377-398) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": 424,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (ERC20Proxy.sol#404-424) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": 479,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (ERC20Proxy.sol#460-479) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 511,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength (ERC20Proxy.sol#487-511) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (ERC20Proxy.sol#33-42)\n\t- ERC20Proxy.sol#38-41\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (ERC20Proxy.sol#47-56)\n\t- ERC20Proxy.sol#52-55\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (ERC20Proxy.sol#62-163)\n\t- ERC20Proxy.sol#74-80\n\t- ERC20Proxy.sol#102-130\n\t- ERC20Proxy.sol#131-161\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (ERC20Proxy.sol#203-227)\n\t- ERC20Proxy.sol#222-226\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (ERC20Proxy.sol#232-251)\n\t- ERC20Proxy.sol#245-250\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 275,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes uses assembly (ERC20Proxy.sol#256-275)\n\t- ERC20Proxy.sol#269-274\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (ERC20Proxy.sol#299-325)\n\t- ERC20Proxy.sol#318-324\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (ERC20Proxy.sol#331-371)\n\t- ERC20Proxy.sol#350-371\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (ERC20Proxy.sol#377-398)\n\t- ERC20Proxy.sol#394-397\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": 424,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (ERC20Proxy.sol#404-424)\n\t- ERC20Proxy.sol#421-424\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": 479,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (ERC20Proxy.sol#460-479)\n\t- ERC20Proxy.sol#472-478\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 511,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength uses assembly (ERC20Proxy.sol#487-511)\n\t- ERC20Proxy.sol#507-510\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 862,
                    "vulnerability_to_line": 952,
                    "vulnerability_code": "    function () \n\n        external\n\n    {\n\n        assembly {\n\n            // The first 4 bytes of calldata holds the function selector\n\n            let selector := and(calldataload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n\n\n            // `transferFrom` will be called with the following parameters:\n\n            // assetData Encoded byte array.\n\n            // from Address to transfer asset from.\n\n            // to Address to transfer asset to.\n\n            // amount Amount of asset to transfer.\n\n            // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n\n            if eq(selector, 0xa85e59e400000000000000000000000000000000000000000000000000000000) {\n\n\n\n                // To lookup a value in a mapping, we load from the storage location keccak256(k, p),\n\n                // where k is the key left padded to 32 bytes and p is the storage slot\n\n                let start := mload(64)\n\n                mstore(start, and(caller, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(start, 32), authorized_slot)\n\n\n\n                // Revert if authorized[msg.sender] == false\n\n                if iszero(sload(keccak256(start, 64))) {\n\n                    // Revert with `Error(\"SENDER_NOT_AUTHORIZED\")`\n\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\n                    mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\n\n                    mstore(64, 0x0000001553454e4445525f4e4f545f415554484f52495a454400000000000000)\n\n                    mstore(96, 0)\n\n                    revert(0, 100)\n\n                }\n\n                \n\n                /////// Token contract address ///////\n\n                // The token address is found as follows:\n\n                // * It is stored at offset 4 in `assetData` contents.\n\n                // * This is stored at offset 32 from `assetData`.\n\n                // * The offset to `assetData` from Params is stored at offset\n\n                //   4 in calldata.\n\n                // * The offset of Params in calldata is 4.\n\n                // So we read location 4 and add 32 + 4 + 4 to it.\n\n                let token := calldataload(add(calldataload(4), 40))\n\n                \n\n                /////// Setup Header Area ///////\n\n                // This area holds the 4-byte `transferFrom` selector.\n\n                // Any trailing data in transferFromSelector will be\n\n                // overwritten in the next `mstore` call.\n\n                mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n\n                \n\n                /////// Setup Params Area ///////\n\n                // We copy the fields `from`, `to` and `amount` in bulk\n\n                // from our own calldata to the new calldata.\n\n                calldatacopy(4, 36, 96)\n\n\n\n                /////// Call `token.transferFrom` using the calldata ///////\n\n                let success := call(\n\n                    gas,            // forward all gas\n\n                    token,          // call address of token contract\n\n                    0,              // don't send any ETH\n\n                    0,              // pointer to start of input\n\n                    100,            // length of input\n\n                    0,              // write output over input\n\n                    32              // output size should be 32 bytes\n\n                )\n\n\n\n                /////// Check return data. ///////\n\n                // If there is no return data, we assume the token incorrectly\n\n                // does not return a bool. In this case we expect it to revert\n\n                // on failure, which was handled above.\n\n                // If the token does return data, we require that it is a single\n\n                // nonzero 32 bytes value.\n\n                // So the transfer succeeded if the call succeeded and either\n\n                // returned nothing, or returned a non-zero 32 byte value. \n\n                success := and(success, or(\n\n                    iszero(returndatasize),\n\n                    and(\n\n                        eq(returndatasize, 32),\n\n                        gt(mload(0), 0)\n\n                    )\n\n                ))\n\n                if success {\n\n                    return(0, 0)\n\n                }\n\n                \n\n                // Revert with `Error(\"TRANSFER_FAILED\")`\n\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\n                mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\n\n                mstore(64, 0x0000000f5452414e534645525f4641494c454400000000000000000000000000)\n\n                mstore(96, 0)\n\n                revert(0, 100)\n\n            }\n\n        }\n",
                    "message": "ERC20Proxy.fallback uses assembly (ERC20Proxy.sol#862-952)\n\t- ERC20Proxy.sol#865-952\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": 577,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n",
                    "message": "IOwnable.transferOwnership (ERC20Proxy.sol#576-577) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": 615,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable.transferOwnership (ERC20Proxy.sol#608-615) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 784,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 816,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytesWithLength(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 507,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 865,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/AssetProxy/mixins/MAuthorizable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": 14,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n",
                    "message": "IOwnable.transferOwnership (MAuthorizable.sol#13-14) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/AssetProxy/libs/LibAssetProxyErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant SENDER_NOT_AUTHORIZED = \"SENDER_NOT_AUTHORIZED\";                        // Sender not authorized to call this method.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant TARGET_NOT_AUTHORIZED = \"TARGET_NOT_AUTHORIZED\";                        // Target address not authorized to call this method.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant TARGET_ALREADY_AUTHORIZED = \"TARGET_ALREADY_AUTHORIZED\";                // Target address must not already be authorized.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INDEX_OUT_OF_BOUNDS = \"INDEX_OUT_OF_BOUNDS\";                            // Specified array index is out of bounds.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant AUTHORIZED_ADDRESS_MISMATCH = \"AUTHORIZED_ADDRESS_MISMATCH\";            // Address at index does not match given target address.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_AMOUNT = \"INVALID_AMOUNT\";                                      // Transfer amount must equal 1.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant TRANSFER_FAILED = \"TRANSFER_FAILED\";                                    // Transfer failed.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant LENGTH_GREATER_THAN_131_REQUIRED = \"LENGTH_GREATER_THAN_131_REQUIRED\";  // Byte array must have a length greater than 0.\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/AssetProxy/interfaces/IAuthorizable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": 14,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n",
                    "message": "IOwnable.transferOwnership (IAuthorizable.sol#13-14) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/AssetProxy/interfaces/IAssetProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": 14,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n",
                    "message": "IOwnable.transferOwnership (IAssetProxy.sol#13-14) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/AssetProxy/interfaces/IAssetData.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": 32,
                    "vulnerability_code": "    function ERC20Token(address tokenContract)\n\n        external\n",
                    "message": "Function 'IAssetData.ERC20Token' (IAssetData.sol#30-32) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": 40,
                    "vulnerability_code": "    function ERC721Token(\n\n        address tokenContract,\n\n        uint256 tokenId,\n\n        bytes receiverData\n\n    )\n\n        external\n",
                    "message": "Function 'IAssetData.ERC721Token' (IAssetData.sol#34-40) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/examples/Validator/Validator.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (address validSigner) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        VALID_SIGNER = validSigner;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal VALID_SIGNER;\n",
                    "message": "Variable 'Validator.VALID_SIGNER' (Validator.sol#69) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/examples/Wallet/Wallet.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 636,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (address walletOwner) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        WALLET_OWNER = walletOwner;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 638,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from <= to,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"FROM_LESS_THAN_TO_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to < b.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 346,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 426,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 507,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 508,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 567,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 590,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 592,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 653,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            eip712Signature.length == 65,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 655,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"LENGTH_65_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length > 0,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= 20,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 346,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 20,  // 20 is length of address\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 426,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 507,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 4,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 508,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + nestedBytesLength,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b.length >= index + 32 + input.length,  // 32 bytes to store length\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 567,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 590,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            dest.length >= sourceLen,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 592,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_25"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": 80,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (Wallet.sol#71-80) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (Wallet.sol#85-94) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": 201,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (Wallet.sol#100-201) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": 265,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (Wallet.sol#241-265) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": 289,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (Wallet.sol#270-289) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": 313,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes (Wallet.sol#294-313) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": 363,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (Wallet.sol#337-363) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 409,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (Wallet.sol#369-409) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": 436,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (Wallet.sol#415-436) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": 462,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (Wallet.sol#442-462) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (Wallet.sol#498-517) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 525,
                    "vulnerability_to_line": 549,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength (Wallet.sol#525-549) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": 80,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (Wallet.sol#71-80)\n\t- Wallet.sol#76-79\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (Wallet.sol#85-94)\n\t- Wallet.sol#90-93\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": 201,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n                    \n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n                    \n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (Wallet.sol#100-201)\n\t- Wallet.sol#112-118\n\t- Wallet.sol#140-168\n\t- Wallet.sol#169-199\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": 265,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        require(\n\n            from <= to,\n\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n\n        );\n\n        require(\n\n            to < b.length,\n\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (Wallet.sol#241-265)\n\t- Wallet.sol#260-264\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": 289,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        require(\n\n            b.length > 0,\n\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (Wallet.sol#270-289)\n\t- Wallet.sol#283-288\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": 313,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= 20,\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Store last 20 bytes.\n\n        result = readAddress(b, b.length - 20);\n\n\n\n        assembly {\n\n            // Subtract 20 from byte array length.\n\n            let newLen := sub(mload(b), 20)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLast20Bytes uses assembly (Wallet.sol#294-313)\n\t- Wallet.sol#307-312\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": 363,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (Wallet.sol#337-363)\n\t- Wallet.sol#356-362\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 409,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 20,  // 20 is length of address\n\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n            \n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (Wallet.sol#369-409)\n\t- Wallet.sol#388-409\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": 436,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (Wallet.sol#415-436)\n\t- Wallet.sol#432-435\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": 462,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        require(\n\n            b.length >= index + 32,\n\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n\n        );\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (Wallet.sol#442-462)\n\t- Wallet.sol#459-462\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        require(\n\n            b.length >= index + 4,\n\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n\n        );\n\n        assembly {\n\n            result := mload(add(b, 32))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (Wallet.sol#498-517)\n\t- Wallet.sol#510-516\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 525,
                    "vulnerability_to_line": 549,
                    "vulnerability_code": "    function readBytesWithLength(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Read length of nested bytes\n\n        uint256 nestedBytesLength = readUint256(b, index);\n\n        index += 32;\n\n\n\n        // Assert length of <b> is valid, given\n\n        // length of nested bytes\n\n        require(\n\n            b.length >= index + nestedBytesLength,\n\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n\n        );\n\n        \n\n        // Return a pointer to the byte array as it exists inside `b`\n\n        assembly {\n\n            result := add(b, index)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytesWithLength uses assembly (Wallet.sol#525-549)\n\t- Wallet.sol#545-548\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal WALLET_OWNER;\n",
                    "message": "Variable 'Wallet.WALLET_OWNER' (Wallet.sol#632) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLast20Bytes(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytesWithLength(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 459,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/tokens/ERC20Token/ERC20Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowed[_from][msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_21"
            ],
            "vulnerability_findings": [
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 public totalSupply;\n",
                    "message": "ERC20Token.totalSupply should be constant (ERC20Token.sol#105)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": 32,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n\n        public\n",
                    "message": "IERC20Token.transfer (ERC20Token.sol#30-32) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 123,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n\n        public\n\n        returns (bool)\n\n    {\n\n        require(\n\n            balances[msg.sender] >= _value,\n\n            \"ERC20_INSUFFICIENT_BALANCE\"\n\n        );\n\n        require(\n\n            balances[_to] + _value >= balances[_to],\n\n            \"OVERFLOW\"\n\n        );\n\n        balances[msg.sender] -= _value;\n\n        balances[_to] += _value;\n\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n",
                    "message": "ERC20Token.transfer (ERC20Token.sol#107-123) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": 146,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n\n        public\n\n        returns (bool)\n\n    {\n\n        require(\n\n            balances[_from] >= _value,\n\n            \"ERC20_INSUFFICIENT_BALANCE\"\n\n        );\n\n        require(\n\n            allowed[_from][msg.sender] >= _value,\n\n            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n\n        );\n\n        require(\n\n            balances[_to] + _value >= balances[_to],\n\n            \"OVERFLOW\"\n\n        );\n\n        balances[_to] += _value;\n\n        balances[_from] -= _value;\n\n        allowed[_from][msg.sender] -= _value;\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n",
                    "message": "ERC20Token.transferFrom (ERC20Token.sol#125-146) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n\n        public\n",
                    "message": "IERC20Token.transferFrom (ERC20Token.sol#39-41) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": 155,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n\n        public\n\n        returns (bool)\n\n    {\n\n        allowed[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n",
                    "message": "ERC20Token.approve (ERC20Token.sol#148-155) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 49,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n\n        public\n",
                    "message": "IERC20Token.approve (ERC20Token.sol#47-49) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "    function balanceOf(address _owner)\n\n        public view\n",
                    "message": "IERC20Token.balanceOf (ERC20Token.sol#53-55) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function balanceOf(address _owner)\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        return balances[_owner];\n",
                    "message": "ERC20Token.balanceOf (ERC20Token.sol#157-163) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": 171,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        return allowed[_owner][_spender];\n",
                    "message": "ERC20Token.allowance (ERC20Token.sol#165-171) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": 62,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n\n        public view\n",
                    "message": "IERC20Token.allowance (ERC20Token.sol#60-62) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of ERC20Token.transfer (ERC20Token.sol#107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.transfer (ERC20Token.sol#107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_from' of ERC20Token.transferFrom (ERC20Token.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of ERC20Token.transferFrom (ERC20Token.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.transferFrom (ERC20Token.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_spender' of ERC20Token.approve (ERC20Token.sol#148) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.approve (ERC20Token.sol#148) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner)\n",
                    "message": "Parameter '_owner' of ERC20Token.balanceOf (ERC20Token.sol#157) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_owner' of ERC20Token.allowance (ERC20Token.sol#165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_spender' of ERC20Token.allowance (ERC20Token.sol#165) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/tokens/ERC20Token/IERC20Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": 32,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n\n        public\n",
                    "message": "IERC20Token.transfer (IERC20Token.sol#30-32) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n\n        public\n",
                    "message": "IERC20Token.transferFrom (IERC20Token.sol#39-41) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 49,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n\n        public\n",
                    "message": "IERC20Token.approve (IERC20Token.sol#47-49) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "    function balanceOf(address _owner)\n\n        public view\n",
                    "message": "IERC20Token.balanceOf (IERC20Token.sol#53-55) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": 62,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n\n        public view\n",
                    "message": "IERC20Token.allowance (IERC20Token.sol#60-62) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/tokens/ERC721Token/ERC721Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string _symbol)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        name_ = _name;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        symbol_ = _symbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c / a == b,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b <= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_UNDERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            c >= a,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_59"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": 679,
                    "vulnerability_code": "    function isContract(address addr)\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n\n        return size > 0;\n",
                    "message": "ERC721Token.isContract (ERC721Token.sol#665-679) is declared view but contains assembly code\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 120,
                    "vulnerability_code": "contract IERC721Token {\n\n    string internal name_;\n\n    string internal symbol_;\n\n\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 _tokenId\n\n    );\n\n\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 _tokenId\n\n    );\n\n\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    function name()\n\n        public\n\n        view\n\n        returns (string);\n\n\n\n    function symbol()\n\n        public\n\n        view\n\n        returns (string);\n\n\n\n    function balanceOf(address _owner)\n\n        public\n\n        view\n\n        returns (uint256 _balance);\n\n\n\n    function ownerOf(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address _owner);\n\n\n\n    function exists(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (bool _exists);\n\n\n\n    function approve(address _to, uint256 _tokenId)\n\n        public;\n\n\n\n    function getApproved(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address _operator);\n\n\n\n    function setApprovalForAll(address _operator, bool _approved)\n\n        public;\n\n\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        public\n\n        view\n\n        returns (bool);\n\n\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        public;\n\n\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        public;\n\n\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes _data\n\n    )\n\n        public;\n",
                    "message": "IERC721Token (ERC721Token.sol#36-120) has incorrect ERC20 function interface(s):\n\t-approve (ERC721Token.sol#83-84)\n\t-transferFrom (ERC721Token.sol#99-104)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": 680,
                    "vulnerability_code": "contract ERC721Token is\n\n    IERC721Token,\n\n    SafeMath\n\n{\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\n\n    // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n\n    bytes4 constant internal ERC721_RECEIVED = 0xf0b9e5ba;\n\n\n\n    // Mapping from token ID to owner\n\n    mapping (uint256 => address) internal tokenOwner;\n\n\n\n    // Mapping from token ID to approved address\n\n    mapping (uint256 => address) internal tokenApprovals;\n\n\n\n    // Mapping from owner to number of owned token\n\n    mapping (address => uint256) internal ownedTokensCount;\n\n\n\n    // Mapping from owner to operator approvals\n\n    mapping (address => mapping (address => bool)) internal operatorApprovals;\n\n\n\n    /**\n\n    * @dev Guarantees msg.sender is owner of the given token\n\n    * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n\n    */\n\n    modifier onlyOwnerOf(uint256 _tokenId) {\n\n        require(ownerOf(_tokenId) == msg.sender);\n\n        _;\n\n    }\n\n\n\n    /**\n\n    * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\n\n    * @param _tokenId uint256 ID of the token to validate\n\n    */\n\n    modifier canTransfer(uint256 _tokenId) {\n\n        require(isApprovedOrOwner(msg.sender, _tokenId));\n\n        _;\n\n    }\n\n\n\n    constructor (\n\n        string _name,\n\n        string _symbol)\n\n        public\n\n    {\n\n        name_ = _name;\n\n        symbol_ = _symbol;\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the token name\n\n    * @return string representing the token name\n\n    */\n\n    function name()\n\n        public\n\n        view\n\n        returns (string)\n\n    {\n\n        return name_;\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the token symbol\n\n    * @return string representing the token symbol\n\n    */\n\n    function symbol()\n\n        public\n\n        view\n\n        returns (string)\n\n    {\n\n        return symbol_;\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the balance of the specified address\n\n    * @param _owner address to query the balance of\n\n    * @return uint256 representing the amount owned by the passed address\n\n    */\n\n    function balanceOf(address _owner)\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        require(_owner != address(0));\n\n        return ownedTokensCount[_owner];\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the owner of the specified token ID\n\n    * @param _tokenId uint256 ID of the token to query the owner of\n\n    * @return owner address currently marked as the owner of the given token ID\n\n    */\n\n    function ownerOf(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address)\n\n    {\n\n        address owner = tokenOwner[_tokenId];\n\n        require(owner != address(0));\n\n        return owner;\n\n    }\n\n\n\n    /**\n\n    * @dev Returns whether the specified token exists\n\n    * @param _tokenId uint256 ID of the token to query the existance of\n\n    * @return whether the token exists\n\n    */\n\n    function exists(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (bool)\n\n    {\n\n        address owner = tokenOwner[_tokenId];\n\n        return owner != address(0);\n\n    }\n\n\n\n    /**\n\n    * @dev Approves another address to transfer the given token ID\n\n    * @dev The zero address indicates there is no approved address.\n\n    * @dev There can only be one approved address per token at a given time.\n\n    * @dev Can only be called by the token owner or an approved operator.\n\n    * @param _to address to be approved for the given token ID\n\n    * @param _tokenId uint256 ID of the token to be approved\n\n    */\n\n    function approve(address _to, uint256 _tokenId)\n\n        public\n\n    {\n\n        address owner = ownerOf(_tokenId);\n\n        require(_to != owner);\n\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n\n\n        if (getApproved(_tokenId) != address(0) || _to != address(0)) {\n\n            tokenApprovals[_tokenId] = _to;\n\n            emit Approval(owner, _to, _tokenId);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the approved address for a token ID, or zero if no address set\n\n    * @param _tokenId uint256 ID of the token to query the approval of\n\n    * @return address currently approved for a the given token ID\n\n    */\n\n    function getApproved(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address)\n\n    {\n\n        return tokenApprovals[_tokenId];\n\n    }\n\n\n\n    /**\n\n    * @dev Sets or unsets the approval of a given operator\n\n    * @dev An operator is allowed to transfer all tokens of the sender on their behalf\n\n    * @param _to operator address to set the approval\n\n    * @param _approved representing the status of the approval to be set\n\n    */\n\n    function setApprovalForAll(address _to, bool _approved)\n\n        public\n\n    {\n\n        require(_to != msg.sender);\n\n        operatorApprovals[msg.sender][_to] = _approved;\n\n        emit ApprovalForAll(msg.sender, _to, _approved);\n\n    }\n\n\n\n    /**\n\n    * @dev Tells whether an operator is approved by a given owner\n\n    * @param _owner owner address which you want to query the approval of\n\n    * @param _operator operator address which you want to query the approval of\n\n    * @return bool whether the given operator is approved by the given owner\n\n    */\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        public\n\n        view\n\n        returns (bool)\n\n    {\n\n        return operatorApprovals[_owner][_operator];\n\n    }\n\n\n\n    /**\n\n    * @dev Transfers the ownership of a given token ID to another address\n\n    * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n\n    * @dev Requires the msg sender to be the owner, approved, or operator\n\n    * @param _from current owner of the token\n\n    * @param _to address to receive the ownership of the given token ID\n\n    * @param _tokenId uint256 ID of the token to be transferred\n\n    */\n\n    function transferFrom(address _from, address _to, uint256 _tokenId)\n\n        public\n\n        canTransfer(_tokenId)\n\n    {\n\n        require(_from != address(0));\n\n        require(_to != address(0));\n\n\n\n        clearApproval(_from, _tokenId);\n\n        removeTokenFrom(_from, _tokenId);\n\n        addTokenTo(_to, _tokenId);\n\n\n\n        emit Transfer(_from, _to, _tokenId);\n\n    }\n\n\n\n    /**\n\n    * @dev Safely transfers the ownership of a given token ID to another address\n\n    * @dev If the target address is a contract, it must implement `onERC721Received`,\n\n    *  which is called upon a safe transfer, and return the magic value\n\n    *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\n\n    *  the transfer is reverted.\n\n    * @dev Requires the msg sender to be the owner, approved, or operator\n\n    * @param _from current owner of the token\n\n    * @param _to address to receive the ownership of the given token ID\n\n    * @param _tokenId uint256 ID of the token to be transferred\n\n    */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId)\n\n        public\n\n        canTransfer(_tokenId)\n\n    {\n\n        // solium-disable-next-line arg-overflow\n\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n\n    }\n\n\n\n    /**\n\n    * @dev Safely transfers the ownership of a given token ID to another address\n\n    * @dev If the target address is a contract, it must implement `onERC721Received`,\n\n    *  which is called upon a safe transfer, and return the magic value\n\n    *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\n\n    *  the transfer is reverted.\n\n    * @dev Requires the msg sender to be the owner, approved, or operator\n\n    * @param _from current owner of the token\n\n    * @param _to address to receive the ownership of the given token ID\n\n    * @param _tokenId uint256 ID of the token to be transferred\n\n    * @param _data bytes data to send along with a safe transfer check\n\n    */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes _data)\n\n        public\n\n        canTransfer(_tokenId)\n\n    {\n\n        transferFrom(_from, _to, _tokenId);\n\n        // solium-disable-next-line arg-overflow\n\n        require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n\n    }\n\n\n\n    /**\n\n    * @dev Returns whether the given spender can transfer a given token ID\n\n    * @param _spender address of the spender to query\n\n    * @param _tokenId uint256 ID of the token to be transferred\n\n    * @return bool whether the msg.sender is approved for the given token ID,\n\n    *  is an operator of the owner, or is the owner of the token\n\n    */\n\n    function isApprovedOrOwner(address _spender, uint256 _tokenId)\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        address owner = ownerOf(_tokenId);\n\n        return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function to mint a new token\n\n    * @dev Reverts if the given token ID already exists\n\n    * @param _to The address that will own the minted token\n\n    * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n\n    */\n\n    function _mint(address _to, uint256 _tokenId)\n\n        internal\n\n    {\n\n        require(_to != address(0));\n\n        addTokenTo(_to, _tokenId);\n\n        emit Transfer(address(0), _to, _tokenId);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function to burn a specific token\n\n    * @dev Reverts if the token does not exist\n\n    * @param _tokenId uint256 ID of the token being burned by the msg.sender\n\n    */\n\n    function _burn(address _owner, uint256 _tokenId)\n\n        internal\n\n    {\n\n        clearApproval(_owner, _tokenId);\n\n        removeTokenFrom(_owner, _tokenId);\n\n        emit Transfer(_owner, address(0), _tokenId);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function to clear current approval of a given token ID\n\n    * @dev Reverts if the given address is not indeed the owner of the token\n\n    * @param _owner owner of the token\n\n    * @param _tokenId uint256 ID of the token to be transferred\n\n    */\n\n    function clearApproval(address _owner, uint256 _tokenId)\n\n        internal\n\n    {\n\n        require(ownerOf(_tokenId) == _owner);\n\n        if (tokenApprovals[_tokenId] != address(0)) {\n\n            tokenApprovals[_tokenId] = address(0);\n\n            emit Approval(_owner, address(0), _tokenId);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function to add a token ID to the list of a given address\n\n    * @param _to address representing the new owner of the given token ID\n\n    * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n\n    */\n\n    function addTokenTo(address _to, uint256 _tokenId)\n\n        internal\n\n    {\n\n        require(tokenOwner[_tokenId] == address(0));\n\n        tokenOwner[_tokenId] = _to;\n\n        ownedTokensCount[_to] = safeAdd(ownedTokensCount[_to], 1);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function to remove a token ID from the list of a given address\n\n    * @param _from address representing the previous owner of the given token ID\n\n    * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n\n    */\n\n    function removeTokenFrom(address _from, uint256 _tokenId)\n\n        internal\n\n    {\n\n        require(ownerOf(_tokenId) == _from);\n\n        ownedTokensCount[_from] = safeSub(ownedTokensCount[_from], 1);\n\n        tokenOwner[_tokenId] = address(0);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function to invoke `onERC721Received` on a target address\n\n    * @dev The call is not executed if the target address is not a contract\n\n    * @param _from address representing the previous owner of the given token ID\n\n    * @param _to target address that will receive the tokens\n\n    * @param _tokenId uint256 ID of the token to be transferred\n\n    * @param _data bytes optional data to send along with the call\n\n    * @return whether the call correctly returned the expected magic value\n\n    */\n\n    function checkAndCallSafeTransfer(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes _data)\n\n        internal\n\n        returns (bool)\n\n    {\n\n        if (!isContract(_to)) {\n\n            return true;\n\n        }\n\n        bytes4 retval = IERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\n\n        return (retval == ERC721_RECEIVED);\n\n    }\n\n\n\n    function isContract(address addr)\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n\n        return size > 0;\n\n    }\n",
                    "message": "ERC721Token (ERC721Token.sol#311-680) has incorrect ERC20 function interface(s):\n\t-approve (ERC721Token.sol#433-444)\n\t-transferFrom (ERC721Token.sol#495-507)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": 679,
                    "vulnerability_code": "    function isContract(address addr)\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n\n        return size > 0;\n",
                    "message": "ERC721Token.isContract uses assembly (ERC721Token.sol#665-679)\n\t- ERC721Token.sol#677-678\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": 61,
                    "vulnerability_code": "    function name()\n\n        public\n\n        view\n",
                    "message": "IERC721Token.name (ERC721Token.sol#58-61) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": 368,
                    "vulnerability_code": "    function name()\n\n        public\n\n        view\n\n        returns (string)\n\n    {\n\n        return name_;\n",
                    "message": "ERC721Token.name (ERC721Token.sol#362-368) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": 66,
                    "vulnerability_code": "    function symbol()\n\n        public\n\n        view\n",
                    "message": "IERC721Token.symbol (ERC721Token.sol#63-66) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": 380,
                    "vulnerability_code": "    function symbol()\n\n        public\n\n        view\n\n        returns (string)\n\n    {\n\n        return symbol_;\n",
                    "message": "ERC721Token.symbol (ERC721Token.sol#374-380) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": 394,
                    "vulnerability_code": "    function balanceOf(address _owner)\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        require(_owner != address(0));\n\n        return ownedTokensCount[_owner];\n",
                    "message": "ERC721Token.balanceOf (ERC721Token.sol#387-394) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "    function balanceOf(address _owner)\n\n        public\n\n        view\n",
                    "message": "IERC721Token.balanceOf (ERC721Token.sol#68-71) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": 423,
                    "vulnerability_code": "    function exists(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (bool)\n\n    {\n\n        address owner = tokenOwner[_tokenId];\n\n        return owner != address(0);\n",
                    "message": "ERC721Token.exists (ERC721Token.sol#416-423) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 81,
                    "vulnerability_code": "    function exists(uint256 _tokenId)\n\n        public\n\n        view\n",
                    "message": "IERC721Token.exists (ERC721Token.sol#78-81) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": 84,
                    "vulnerability_code": "    function approve(address _to, uint256 _tokenId)\n",
                    "message": "IERC721Token.approve (ERC721Token.sol#83-84) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": 444,
                    "vulnerability_code": "    function approve(address _to, uint256 _tokenId)\n\n        public\n\n    {\n\n        address owner = ownerOf(_tokenId);\n\n        require(_to != owner);\n\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n\n\n        if (getApproved(_tokenId) != address(0) || _to != address(0)) {\n\n            tokenApprovals[_tokenId] = _to;\n\n            emit Approval(owner, _to, _tokenId);\n\n        }\n",
                    "message": "ERC721Token.approve (ERC721Token.sol#433-444) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 465,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function setApprovalForAll(address _to, bool _approved)\n\n        public\n\n    {\n\n        require(_to != msg.sender);\n\n        operatorApprovals[msg.sender][_to] = _approved;\n\n        emit ApprovalForAll(msg.sender, _to, _approved);\n",
                    "message": "ERC721Token.setApprovalForAll (ERC721Token.sol#465-471) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 92,
                    "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved)\n",
                    "message": "IERC721Token.setApprovalForAll (ERC721Token.sol#91-92) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n",
                    "message": "IERC721Token.safeTransferFrom (ERC721Token.sol#106-111) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": 529,
                    "vulnerability_code": "    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId)\n\n        public\n\n        canTransfer(_tokenId)\n\n    {\n\n        // solium-disable-next-line arg-overflow\n\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n",
                    "message": "ERC721Token.safeTransferFrom (ERC721Token.sol#520-529) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": 183,
                    "vulnerability_code": "    function onERC721Received(\n\n        address _from,\n\n        uint256 _tokenId,\n\n        bytes _data)\n\n        public\n",
                    "message": "IERC721Receiver.onERC721Received (ERC721Token.sol#178-183) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner)\n",
                    "message": "Parameter '_owner' of ERC721Token.balanceOf (ERC721Token.sol#387) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ownerOf(uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.ownerOf (ERC721Token.sol#401) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exists(uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.exists (ERC721Token.sol#416) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_to' of ERC721Token.approve (ERC721Token.sol#433) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.approve (ERC721Token.sol#433) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getApproved(uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.getApproved (ERC721Token.sol#451) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 465,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setApprovalForAll(address _to, bool _approved)\n",
                    "message": "Parameter '_to' of ERC721Token.setApprovalForAll (ERC721Token.sol#465) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 465,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setApprovalForAll(address _to, bool _approved)\n",
                    "message": "Parameter '_approved' of ERC721Token.setApprovalForAll (ERC721Token.sol#465) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 479,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
                    "message": "Parameter '_owner' of ERC721Token.isApprovedForAll (ERC721Token.sol#479) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 479,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
                    "message": "Parameter '_operator' of ERC721Token.isApprovedForAll (ERC721Token.sol#479) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 495,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_from' of ERC721Token.transferFrom (ERC721Token.sol#495) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 495,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_to' of ERC721Token.transferFrom (ERC721Token.sol#495) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 495,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.transferFrom (ERC721Token.sol#495) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of ERC721Token.safeTransferFrom (ERC721Token.sol#521) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of ERC721Token.safeTransferFrom (ERC721Token.sol#522) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.safeTransferFrom (ERC721Token.sol#523) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 544,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of ERC721Token.safeTransferFrom (ERC721Token.sol#544) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of ERC721Token.safeTransferFrom (ERC721Token.sol#545) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 546,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId,\n",
                    "message": "Parameter '_tokenId' of ERC721Token.safeTransferFrom (ERC721Token.sol#546) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _data)\n",
                    "message": "Parameter '_data' of ERC721Token.safeTransferFrom (ERC721Token.sol#547) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string _name,\n",
                    "message": "Parameter '_name' of ERC721Token. (ERC721Token.sol#350) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string _symbol)\n",
                    "message": "Parameter '_symbol' of ERC721Token. (ERC721Token.sol#351) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 563,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isApprovedOrOwner(address _spender, uint256 _tokenId)\n",
                    "message": "Parameter '_spender' of ERC721Token.isApprovedOrOwner (ERC721Token.sol#563) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 563,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isApprovedOrOwner(address _spender, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.isApprovedOrOwner (ERC721Token.sol#563) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": 584,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId)\n\n        internal\n\n    {\n\n        require(_to != address(0));\n\n        addTokenTo(_to, _tokenId);\n\n        emit Transfer(address(0), _to, _tokenId);\n",
                    "message": "Function 'ERC721Token._mint' (ERC721Token.sol#578-584) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_to' of ERC721Token._mint (ERC721Token.sol#578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token._mint (ERC721Token.sol#578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": 597,
                    "vulnerability_code": "    function _burn(address _owner, uint256 _tokenId)\n\n        internal\n\n    {\n\n        clearApproval(_owner, _tokenId);\n\n        removeTokenFrom(_owner, _tokenId);\n\n        emit Transfer(_owner, address(0), _tokenId);\n",
                    "message": "Function 'ERC721Token._burn' (ERC721Token.sol#591-597) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _burn(address _owner, uint256 _tokenId)\n",
                    "message": "Parameter '_owner' of ERC721Token._burn (ERC721Token.sol#591) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _burn(address _owner, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token._burn (ERC721Token.sol#591) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearApproval(address _owner, uint256 _tokenId)\n",
                    "message": "Parameter '_owner' of ERC721Token.clearApproval (ERC721Token.sol#605) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearApproval(address _owner, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.clearApproval (ERC721Token.sol#605) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokenTo(address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_to' of ERC721Token.addTokenTo (ERC721Token.sol#620) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokenTo(address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.addTokenTo (ERC721Token.sol#620) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 633,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeTokenFrom(address _from, uint256 _tokenId)\n",
                    "message": "Parameter '_from' of ERC721Token.removeTokenFrom (ERC721Token.sol#633) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 633,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeTokenFrom(address _from, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.removeTokenFrom (ERC721Token.sol#633) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 651,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of ERC721Token.checkAndCallSafeTransfer (ERC721Token.sol#651) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of ERC721Token.checkAndCallSafeTransfer (ERC721Token.sol#652) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 653,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId,\n",
                    "message": "Parameter '_tokenId' of ERC721Token.checkAndCallSafeTransfer (ERC721Token.sol#653) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _data)\n",
                    "message": "Parameter '_data' of ERC721Token.checkAndCallSafeTransfer (ERC721Token.sol#654) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant internal ERC721_RECEIVED = 0xf0b9e5ba;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant internal ERC721_RECEIVED = 0xf0b9e5ba;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            tokenApprovals[_tokenId] = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 638,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        tokenOwner[_tokenId] = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _to, uint256 _tokenId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (string);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (string);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string _name,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string _symbol)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (string)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (string)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _data)\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/tokens/ERC721Token/IERC721Receiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 62,
                    "vulnerability_code": "    function onERC721Received(\n\n        address _from,\n\n        uint256 _tokenId,\n\n        bytes _data)\n\n        public\n",
                    "message": "IERC721Receiver.onERC721Received (IERC721Receiver.sol#57-62) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant internal ERC721_RECEIVED = 0xf0b9e5ba;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _data)\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/tokens/ERC721Token/IERC721Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_14"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 120,
                    "vulnerability_code": "contract IERC721Token {\n\n    string internal name_;\n\n    string internal symbol_;\n\n\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 _tokenId\n\n    );\n\n\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 _tokenId\n\n    );\n\n\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    function name()\n\n        public\n\n        view\n\n        returns (string);\n\n\n\n    function symbol()\n\n        public\n\n        view\n\n        returns (string);\n\n\n\n    function balanceOf(address _owner)\n\n        public\n\n        view\n\n        returns (uint256 _balance);\n\n\n\n    function ownerOf(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address _owner);\n\n\n\n    function exists(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (bool _exists);\n\n\n\n    function approve(address _to, uint256 _tokenId)\n\n        public;\n\n\n\n    function getApproved(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address _operator);\n\n\n\n    function setApprovalForAll(address _operator, bool _approved)\n\n        public;\n\n\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        public\n\n        view\n\n        returns (bool);\n\n\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        public;\n\n\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        public;\n\n\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes _data\n\n    )\n\n        public;\n",
                    "message": "IERC721Token (IERC721Token.sol#36-120) has incorrect ERC20 function interface(s):\n\t-approve (IERC721Token.sol#83-84)\n\t-transferFrom (IERC721Token.sol#99-104)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string internal name_;\n",
                    "message": "IERC721Token.name_ should be constant (IERC721Token.sol#37)\nIERC721Token.symbol_ should be constant (IERC721Token.sol#38)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": 61,
                    "vulnerability_code": "    function name()\n\n        public\n\n        view\n",
                    "message": "IERC721Token.name (IERC721Token.sol#58-61) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": 66,
                    "vulnerability_code": "    function symbol()\n\n        public\n\n        view\n",
                    "message": "IERC721Token.symbol (IERC721Token.sol#63-66) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "    function balanceOf(address _owner)\n\n        public\n\n        view\n",
                    "message": "IERC721Token.balanceOf (IERC721Token.sol#68-71) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": 76,
                    "vulnerability_code": "    function ownerOf(uint256 _tokenId)\n\n        public\n\n        view\n",
                    "message": "IERC721Token.ownerOf (IERC721Token.sol#73-76) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 81,
                    "vulnerability_code": "    function exists(uint256 _tokenId)\n\n        public\n\n        view\n",
                    "message": "IERC721Token.exists (IERC721Token.sol#78-81) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": 84,
                    "vulnerability_code": "    function approve(address _to, uint256 _tokenId)\n",
                    "message": "IERC721Token.approve (IERC721Token.sol#83-84) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": 89,
                    "vulnerability_code": "    function getApproved(uint256 _tokenId)\n\n        public\n\n        view\n",
                    "message": "IERC721Token.getApproved (IERC721Token.sol#86-89) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 92,
                    "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved)\n",
                    "message": "IERC721Token.setApprovalForAll (IERC721Token.sol#91-92) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 97,
                    "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n\n        public\n\n        view\n",
                    "message": "IERC721Token.isApprovedForAll (IERC721Token.sol#94-97) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": 104,
                    "vulnerability_code": "    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n",
                    "message": "IERC721Token.transferFrom (IERC721Token.sol#99-104) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n",
                    "message": "IERC721Token.safeTransferFrom (IERC721Token.sol#106-111) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 113,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes _data\n\n    )\n",
                    "message": "IERC721Token.safeTransferFrom (IERC721Token.sol#113-119) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (string);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (string);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _data\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/tokens/UnlimitedAllowanceToken/UnlimitedAllowanceToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowed[_from][msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_26"
            ],
            "vulnerability_findings": [
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 allowance = allowed[_from][msg.sender];\n",
                    "message": "UnlimitedAllowanceToken.transferFrom.allowance (local variable @ UnlimitedAllowanceToken.sol#209) shadows:\n\t- ERC20Token.allowance (function @ UnlimitedAllowanceToken.sol#165-171)\n\t- IERC20Token.allowance (function @ UnlimitedAllowanceToken.sol#60-62)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 public totalSupply;\n",
                    "message": "ERC20Token.totalSupply should be constant (UnlimitedAllowanceToken.sol#105)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": 32,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n\n        public\n",
                    "message": "IERC20Token.transfer (UnlimitedAllowanceToken.sol#30-32) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 123,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n\n        public\n\n        returns (bool)\n\n    {\n\n        require(\n\n            balances[msg.sender] >= _value,\n\n            \"ERC20_INSUFFICIENT_BALANCE\"\n\n        );\n\n        require(\n\n            balances[_to] + _value >= balances[_to],\n\n            \"OVERFLOW\"\n\n        );\n\n        balances[msg.sender] -= _value;\n\n        balances[_to] += _value;\n\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n",
                    "message": "ERC20Token.transfer (UnlimitedAllowanceToken.sol#107-123) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": 146,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n\n        public\n\n        returns (bool)\n\n    {\n\n        require(\n\n            balances[_from] >= _value,\n\n            \"ERC20_INSUFFICIENT_BALANCE\"\n\n        );\n\n        require(\n\n            allowed[_from][msg.sender] >= _value,\n\n            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n\n        );\n\n        require(\n\n            balances[_to] + _value >= balances[_to],\n\n            \"OVERFLOW\"\n\n        );\n\n        balances[_to] += _value;\n\n        balances[_from] -= _value;\n\n        allowed[_from][msg.sender] -= _value;\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n",
                    "message": "ERC20Token.transferFrom (UnlimitedAllowanceToken.sol#125-146) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": 229,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n\n        public\n\n        returns (bool)\n\n    {\n\n        uint256 allowance = allowed[_from][msg.sender];\n\n        require(\n\n            balances[_from] >= _value,\n\n            \"ERC20_INSUFFICIENT_BALANCE\"\n\n        );\n\n        require(\n\n            allowance >= _value,\n\n            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n\n        );\n\n        require(\n\n            balances[_to] + _value >= balances[_to],\n\n            \"OVERFLOW\"\n\n        );\n\n        balances[_to] += _value;\n\n        balances[_from] -= _value;\n\n        if (allowance < MAX_UINT) {\n\n            allowed[_from][msg.sender] -= _value;\n\n        }\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n",
                    "message": "UnlimitedAllowanceToken.transferFrom (UnlimitedAllowanceToken.sol#205-229) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n\n        public\n",
                    "message": "IERC20Token.transferFrom (UnlimitedAllowanceToken.sol#39-41) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": 155,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n\n        public\n\n        returns (bool)\n\n    {\n\n        allowed[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n",
                    "message": "ERC20Token.approve (UnlimitedAllowanceToken.sol#148-155) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 49,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n\n        public\n",
                    "message": "IERC20Token.approve (UnlimitedAllowanceToken.sol#47-49) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "    function balanceOf(address _owner)\n\n        public view\n",
                    "message": "IERC20Token.balanceOf (UnlimitedAllowanceToken.sol#53-55) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function balanceOf(address _owner)\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        return balances[_owner];\n",
                    "message": "ERC20Token.balanceOf (UnlimitedAllowanceToken.sol#157-163) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": 62,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n\n        public view\n",
                    "message": "IERC20Token.allowance (UnlimitedAllowanceToken.sol#60-62) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": 171,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        return allowed[_owner][_spender];\n",
                    "message": "ERC20Token.allowance (UnlimitedAllowanceToken.sol#165-171) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of ERC20Token.transfer (UnlimitedAllowanceToken.sol#107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.transfer (UnlimitedAllowanceToken.sol#107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_from' of ERC20Token.transferFrom (UnlimitedAllowanceToken.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of ERC20Token.transferFrom (UnlimitedAllowanceToken.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.transferFrom (UnlimitedAllowanceToken.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_spender' of ERC20Token.approve (UnlimitedAllowanceToken.sol#148) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.approve (UnlimitedAllowanceToken.sol#148) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner)\n",
                    "message": "Parameter '_owner' of ERC20Token.balanceOf (UnlimitedAllowanceToken.sol#157) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_owner' of ERC20Token.allowance (UnlimitedAllowanceToken.sol#165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_spender' of ERC20Token.allowance (UnlimitedAllowanceToken.sol#165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_from' of UnlimitedAllowanceToken.transferFrom (UnlimitedAllowanceToken.sol#205) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of UnlimitedAllowanceToken.transferFrom (UnlimitedAllowanceToken.sol#205) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of UnlimitedAllowanceToken.transferFrom (UnlimitedAllowanceToken.sol#205) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/tokens/EtherToken/WETH9.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(allowance[src][msg.sender] >= wad);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance[src][msg.sender] -= wad;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8  public decimals = 18;\n",
                    "message": "WETH9.decimals should be constant (WETH9.sol#25)\nWETH9.name should be constant (WETH9.sol#23)\nWETH9.symbol should be constant (WETH9.sol#24)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": 37,
                    "vulnerability_code": "    function() public payable {\n\n        deposit();\n",
                    "message": "WETH9.fallback (WETH9.sol#35-37) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function withdraw(uint wad) public {\n\n        require(balanceOf[msg.sender] >= wad);\n\n        balanceOf[msg.sender] -= wad;\n\n        msg.sender.transfer(wad);\n\n        Withdrawal(msg.sender, wad);\n",
                    "message": "WETH9.withdraw (WETH9.sol#42-47) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": 51,
                    "vulnerability_code": "    function totalSupply() public view returns (uint) {\n\n        return this.balance;\n",
                    "message": "WETH9.totalSupply (WETH9.sol#49-51) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": 57,
                    "vulnerability_code": "    function approve(address guy, uint wad) public returns (bool) {\n\n        allowance[msg.sender][guy] = wad;\n\n        Approval(msg.sender, guy, wad);\n\n        return true;\n",
                    "message": "WETH9.approve (WETH9.sol#53-57) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": 61,
                    "vulnerability_code": "    function transfer(address dst, uint wad) public returns (bool) {\n\n        return transferFrom(msg.sender, dst, wad);\n",
                    "message": "WETH9.transfer (WETH9.sol#59-61) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.18;\n",
                    "message": "Detected issues with version pragma in WETH9.sol:\n\t- pragma solidity^0.4.18 (WETH9.sol#19): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function() public payable {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/tokens/EtherToken/IEtherToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": 32,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n\n        public\n",
                    "message": "IERC20Token.transfer (IEtherToken.sol#30-32) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n\n        public\n",
                    "message": "IERC20Token.transferFrom (IEtherToken.sol#39-41) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 49,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n\n        public\n",
                    "message": "IERC20Token.approve (IEtherToken.sol#47-49) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "    function balanceOf(address _owner)\n\n        public view\n",
                    "message": "IERC20Token.balanceOf (IEtherToken.sol#53-55) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": 62,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n\n        public view\n",
                    "message": "IERC20Token.allowance (IEtherToken.sol#60-62) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": 105,
                    "vulnerability_code": "    function deposit()\n\n        public\n",
                    "message": "IEtherToken.deposit (IEtherToken.sol#103-105) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 108,
                    "vulnerability_code": "    function withdraw(uint256 amount)\n",
                    "message": "IEtherToken.withdraw (IEtherToken.sol#107-108) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract IEtherToken is\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/sol-cov/test/fixtures/contracts/SimpleStorage.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": 9,
                    "vulnerability_code": "    function set(uint x) {\n\n        storedData = x;\n",
                    "message": "SimpleStorage.set (SimpleStorage.sol#7-9) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 12,
                    "vulnerability_code": "    function get() constant returns (uint retVal) {\n\n        return storedData;\n",
                    "message": "SimpleStorage.get (SimpleStorage.sol#10-12) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.21;\n",
                    "message": "Detected issues with version pragma in SimpleStorage.sol:\n\t- pragma solidity^0.4.21 (SimpleStorage.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function get() constant returns (uint retVal) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.21;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function set(uint x) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function get() constant returns (uint retVal) {\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/sol-cov/test/fixtures/contracts/SolcovIgnore.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": 11,
                    "vulnerability_code": "    function set(uint x) public {\n\n        /* solcov ignore next */\n\n        storedData = x;\n",
                    "message": "SolcovIgnore.set (SolcovIgnore.sol#8-11) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": 16,
                    "vulnerability_code": "    function get() constant public returns (uint retVal) {\n\n        return storedData;\n",
                    "message": "SolcovIgnore.get (SolcovIgnore.sol#14-16) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": 23,
                    "vulnerability_code": "    function ignored() public returns (bool) {\n\n        return false;\n",
                    "message": "Ignore.ignored (SolcovIgnore.sol#21-23) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.21;\n",
                    "message": "Detected issues with version pragma in SolcovIgnore.sol:\n\t- pragma solidity^0.4.21 (SolcovIgnore.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function get() constant public returns (uint retVal) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.21;\n",
                    "message": null
                }
            ]
        }
    },
    "0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/metacoin/contracts/Metacoin.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        balances[msg.sender] = 10000;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": "Different versions of Solidity is used in Metacoin.sol:\n\t- Version used: ['ABIEncoderV2', '^0.4.24']\n\t- Metacoin.sol#3 declares pragma solidity^0.4.24\n\t- Metacoin.sol#4 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 40,
                    "vulnerability_code": "    function transfer(NestedTransferData nestedTransferData) public returns (int) {\n\n        return transfer(nestedTransferData.transferData, nestedTransferData.callback);\n",
                    "message": "Metacoin.transfer (Metacoin.sol#38-40) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(TransferData transferData) public returns (bool success) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(TransferData transferData, uint32 callback) public returns (int) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(NestedTransferData nestedTransferData) public returns (int) {\n",
                    "message": null
                }
            ]
        }
    }
}