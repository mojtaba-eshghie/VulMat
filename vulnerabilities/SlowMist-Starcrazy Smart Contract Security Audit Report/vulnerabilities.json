{
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/token/IApproveAndCallFallBack.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": 11,
                    "vulnerability_code": "    function receiveApproval(\n\n        address from,\n\n        uint256 amount_,\n\n        address token_,\n\n        bytes memory data_\n",
                    "message": "IApproveAndCallFallBack.receiveApproval (IApproveAndCallFallBack.sol#6-11) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in IApproveAndCallFallBack.sol:\n\t- pragma solidity^0.5.0 (IApproveAndCallFallBack.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/token/ITokenController.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 14,
                    "vulnerability_code": "    function proxyPayment(\n\n        address owner_,\n\n        bytes4 sig,\n\n        bytes memory data\n",
                    "message": "ITokenController.proxyPayment (ITokenController.sol#10-14) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 26,
                    "vulnerability_code": "    function onTransfer(\n\n        address from_,\n\n        address to_,\n\n        uint256 amount_\n",
                    "message": "ITokenController.onTransfer (ITokenController.sol#22-26) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": 38,
                    "vulnerability_code": "    function onApprove(\n\n        address owner_,\n\n        address spender_,\n\n        uint256 amount_\n",
                    "message": "ITokenController.onApprove (ITokenController.sol#34-38) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in ITokenController.sol:\n\t- pragma solidity^0.5.0 (ITokenController.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract ITokenController {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/token/IERC223Receiving.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in IERC223Receiving.sol:\n\t- pragma solidity^0.5.0 (IERC223Receiving.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/aliana/IGeneScience.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isGeneScience() public pure returns (bool);\n",
                    "message": "IGeneScience.isGeneScience (IGeneScience.sol#8) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": 21,
                    "vulnerability_code": "    function mixGenes(\n\n        int256 _id1,\n\n        int256 _id2,\n\n        uint256 _genes1,\n\n        uint256 _genes2,\n\n        uint256 _targetBlock\n",
                    "message": "IGeneScience.mixGenes (IGeneScience.sol#15-21) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": 26,
                    "vulnerability_code": "    function geneLpLabor(int256 _id, uint256 _genes)\n\n        public\n\n        pure\n",
                    "message": "IGeneScience.geneLpLabor (IGeneScience.sol#23-26) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValid(int256 _id, uint256 _genes) public pure returns (bool);\n",
                    "message": "IGeneScience.isValid (IGeneScience.sol#28) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": 33,
                    "vulnerability_code": "    function totalQuality(int256 _id, uint256 _genes)\n\n        public\n\n        pure\n",
                    "message": "IGeneScience.totalQuality (IGeneScience.sol#30-33) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAuctionGene(uint256 _id) public pure returns (uint256);\n",
                    "message": "IGeneScience.getAuctionGene (IGeneScience.sol#35) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in IGeneScience.sol:\n\t- pragma solidity^0.5.0 (IGeneScience.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/aliana/IFlashSale.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isFlashSale() public returns (bool);\n",
                    "message": "IFlashSale.isFlashSale (IFlashSale.sol#7) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in IFlashSale.sol:\n\t- pragma solidity^0.5.0 (IFlashSale.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/aliana/IAuction.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isAuction() public returns (bool);\n",
                    "message": "IAuction.isAuction (IAuction.sol#7) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in IAuction.sol:\n\t- pragma solidity^0.5.0 (IAuction.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/aliana/IAlianaMint.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": 10,
                    "vulnerability_code": "    function depositedTokens(address _owner)\n\n        public\n\n        view\n",
                    "message": "IAlianaMint.depositedTokens (IAlianaMint.sol#7-10) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in IAlianaMint.sol:\n\t- pragma solidity^0.5.0 (IAlianaMint.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/aliana/IAlianaSale.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSale() public view returns (uint256);\n",
                    "message": "IAlianaSale.totalSale (IAlianaSale.sol#28) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in IAlianaSale.sol:\n\t- pragma solidity^0.5.0 (IAlianaSale.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/aliana/ISaleClockAuction.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isAuction() public pure returns (bool);\n",
                    "message": "ISaleClockAuction.isAuction (ISaleClockAuction.sol#8) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claimTokens(address token_) public;\n",
                    "message": "ISaleClockAuction.claimTokens (ISaleClockAuction.sol#18) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in ISaleClockAuction.sol:\n\t- pragma solidity^0.5.0 (ISaleClockAuction.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/utils/Address.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": 30,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        uint256 size;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            size := extcodesize(account)\n\n        }\n\n        return size > 0;\n",
                    "message": "Address.isContract (Address.sol#19-30) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": 30,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        uint256 size;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            size := extcodesize(account)\n\n        }\n\n        return size > 0;\n",
                    "message": "Address.isContract uses assembly (Address.sol#19-30)\n\t- Address.sol#26-28\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in Address.sol:\n\t- pragma solidity^0.5.0 (Address.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/ownership/DSAuth.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit LogSetOwner(msg.sender);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function setOwner(address owner_) public auth {\n\n        _owner = owner_;\n\n        emit LogSetOwner(_owner);\n",
                    "message": "DSAuth.setOwner (DSAuth.sol#31-34) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 39,
                    "vulnerability_code": "    function setAuthority(DSAuthority authority_) public auth {\n\n        _authority = authority_;\n\n        emit LogSetAuthority(address(_authority));\n",
                    "message": "DSAuth.setAuthority (DSAuth.sol#36-39) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in DSAuth.sol:\n\t- pragma solidity^0.5.0 (DSAuth.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (DSAuth.sol#15): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    DSAuthority public _authority;\n",
                    "message": "Variable 'DSAuth._authority' (DSAuth.sol#23) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public _owner;\n",
                    "message": "Variable 'DSAuth._owner' (DSAuth.sol#24) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/ownership/DSAuthority.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in DSAuthority.sol:\n\t- pragma solidity^0.5.0 (DSAuthority.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/gfc/utils/supports-interface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in supports-interface.sol:\n\t- pragma solidity^0.5.0 (supports-interface.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (supports-interface.sol#24): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function supportsInterface(bytes4 _interfaceID)\n",
                    "message": "Parameter '_interfaceID' of SupportsInterface.supportsInterface (supports-interface.sol#48) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/gfc/utils/address-utils.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": 35,
                    "vulnerability_code": "    function isContract(address _addr)\n\n        internal\n\n        view\n\n        returns (bool addressCheck)\n\n    {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        assembly {\n\n            codehash := extcodehash(_addr)\n\n        } // solhint-disable-line\n\n        addressCheck = (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "AddressUtils.isContract (address-utils.sol#17-35) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": 35,
                    "vulnerability_code": "    function isContract(address _addr)\n\n        internal\n\n        view\n\n        returns (bool addressCheck)\n\n    {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        assembly {\n\n            codehash := extcodehash(_addr)\n\n        } // solhint-disable-line\n\n        addressCheck = (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "AddressUtils.isContract uses assembly (address-utils.sol#17-35)\n\t- address-utils.sol#31-33\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in address-utils.sol:\n\t- pragma solidity^0.5.0 (address-utils.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address _addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/gfc/utils/erc165.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in erc165.sol:\n\t- pragma solidity^0.5.0 (erc165.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/gfc/math/safe-math.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(product / _factor1 == _factor2, OVERFLOW);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_divisor > 0, DIVISION_BY_ZERO);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_subtrahend <= _minuend, SUBTRAHEND_GREATER_THEN_MINUEND);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sum >= _addend1, OVERFLOW);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_divisor != 0, DIVISION_BY_ZERO);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_11"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in safe-math.sol:\n\t- pragma solidity^0.5.0 (safe-math.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _factor1, uint256 _factor2)\n",
                    "message": "Parameter '_factor1' of SafeMath.mul (safe-math.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _factor1, uint256 _factor2)\n",
                    "message": "Parameter '_factor2' of SafeMath.mul (safe-math.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _dividend, uint256 _divisor)\n",
                    "message": "Parameter '_dividend' of SafeMath.div (safe-math.sol#47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _dividend, uint256 _divisor)\n",
                    "message": "Parameter '_divisor' of SafeMath.div (safe-math.sol#47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _minuend, uint256 _subtrahend)\n",
                    "message": "Parameter '_minuend' of SafeMath.sub (safe-math.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _minuend, uint256 _subtrahend)\n",
                    "message": "Parameter '_subtrahend' of SafeMath.sub (safe-math.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _addend1, uint256 _addend2)\n",
                    "message": "Parameter '_addend1' of SafeMath.add (safe-math.sol#79) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _addend1, uint256 _addend2)\n",
                    "message": "Parameter '_addend2' of SafeMath.add (safe-math.sol#79) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mod(uint256 _dividend, uint256 _divisor)\n",
                    "message": "Parameter '_dividend' of SafeMath.mod (safe-math.sol#95) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mod(uint256 _dividend, uint256 _divisor)\n",
                    "message": "Parameter '_divisor' of SafeMath.mod (safe-math.sol#95) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant OVERFLOW = \"008001\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant SUBTRAHEND_GREATER_THEN_MINUEND = \"008002\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant DIVISION_BY_ZERO = \"008003\";\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/gfc/ownership/ownable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "    function transferOwnership(address _newOwner) public onlyOwner {\n\n        require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);\n\n        emit OwnershipTransferred(owner, _newOwner);\n\n        owner = _newOwner;\n",
                    "message": "Ownable.transferOwnership (ownable.sol#51-55) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in ownable.sol:\n\t- pragma solidity^0.5.0 (ownable.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address _newOwner) public onlyOwner {\n",
                    "message": "Parameter '_newOwner' of Ownable.transferOwnership (ownable.sol#51) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/gfc/tokens/erc721-metadata.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in erc721-metadata.sol:\n\t- pragma solidity^0.5.0 (erc721-metadata.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/gfc/tokens/nf-token-enumerable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[0x80ac58cd] = true; // ERC721\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 863,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 864,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(product / _factor1 == _factor2, OVERFLOW);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_divisor > 0, DIVISION_BY_ZERO);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_subtrahend <= _minuend, SUBTRAHEND_GREATER_THEN_MINUEND);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sum >= _addend1, OVERFLOW);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_divisor != 0, DIVISION_BY_ZERO);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_77"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function isContract(address _addr)\n\n        internal\n\n        view\n\n        returns (bool addressCheck)\n\n    {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        assembly {\n\n            codehash := extcodehash(_addr)\n\n        } // solhint-disable-line\n\n        addressCheck = (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "AddressUtils.isContract (nf-token-enumerable.sol#353-371) is declared view but contains assembly code\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "interface ERC721 {\n\n    /**\n\n     * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n\n     * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n\n     * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n\n     * transfer, the approved address for that NFT (if any) is reset to none.\n\n     */\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n\n     * address indicates there is no approved address. When a Transfer event emits, this also\n\n     * indicates that the approved address for that NFT (if any) is reset to none.\n\n     */\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n\n     * all NFTs of the owner.\n\n     */\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address.\n\n     * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n\n     * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n\n     * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n\n     * function checks if `_to` is a smart contract (code size > 0). If so, it calls\n\n     * `onERC721Received` on `_to` and throws if the return value is not\n\n     * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     * @param _data Additional data with no specified format, sent in call to `_to`.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address.\n\n     * @notice This works identically to the other function with an extra data parameter, except this\n\n     * function just sets data to \"\"\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n\n     * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n\n     * address. Throws if `_tokenId` is not a valid NFT.\n\n     * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n\n     * they mayb be permanently lost.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Set or reaffirm the approved address for an NFT.\n\n     * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n\n     * the current NFT owner, or an authorized operator of the current owner.\n\n     * @param _approved The new approved NFT controller.\n\n     * @param _tokenId The NFT to approve.\n\n     */\n\n    function approve(address _approved, uint256 _tokenId) external;\n\n\n\n    /**\n\n     * @dev Enables or disables approval for a third party (\"operator\") to manage all of\n\n     * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n\n     * @notice The contract MUST allow multiple operators per owner.\n\n     * @param _operator Address to add to the set of authorized operators.\n\n     * @param _approved True if the operators is approved, false to revoke approval.\n\n     */\n\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n\n\n    /**\n\n     * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n\n     * considered invalid, and this function throws for queries about the zero address.\n\n     * @param _owner Address for whom to query the balance.\n\n     * @return Balance of _owner.\n\n     */\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n\n     * invalid, and queries about them do throw.\n\n     * @param _tokenId The identifier for an NFT.\n\n     * @return Address of _tokenId owner.\n\n     */\n\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n\n\n    /**\n\n     * @dev Get the approved address for a single NFT.\n\n     * @notice Throws if `_tokenId` is not a valid NFT.\n\n     * @param _tokenId The NFT to find the approved address for.\n\n     * @return Address that _tokenId is approved for.\n\n     */\n\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n\n\n    /**\n\n     * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\n\n     * @param _owner The address that owns the NFTs.\n\n     * @param _operator The address that acts on behalf of the owner.\n\n     * @return True if approved for all, false otherwise.\n\n     */\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        external\n\n        view\n\n        returns (bool);\n",
                    "message": "ERC721 (nf-token-enumerable.sol#9-145) has incorrect ERC20 function interface(s):\n\t-transferFrom (nf-token-enumerable.sol#87-91)\n\t-approve (nf-token-enumerable.sol#100)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": 786,
                    "vulnerability_code": "contract NFToken is ERC721, SupportsInterface {\n\n    using SafeMath for uint256;\n\n    using AddressUtils for address;\n\n\n\n    /**\n\n     * List of revert message codes. Implementing dApp should handle showing the correct message.\n\n     * Based on 0xcert framework error codes.\n\n     */\n\n    string constant ZERO_ADDRESS = \"003001\";\n\n    string constant NOT_VALID_NFT = \"003002\";\n\n    string constant NOT_OWNER_OR_OPERATOR = \"003003\";\n\n    string constant NOT_OWNER_APPROWED_OR_OPERATOR = \"003004\";\n\n    string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\n\n    string constant NFT_ALREADY_EXISTS = \"003006\";\n\n    string constant NOT_OWNER = \"003007\";\n\n    string constant IS_OWNER = \"003008\";\n\n\n\n    /**\n\n     * @dev Magic value of a smart contract that can recieve NFT.\n\n     * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\n\n     */\n\n    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n\n\n\n    /**\n\n     * @dev A mapping from NFT ID to the address that owns it.\n\n     */\n\n    mapping(uint256 => address) internal idToOwner;\n\n\n\n    /**\n\n     * @dev Mapping from NFT ID to approved address.\n\n     */\n\n    mapping(uint256 => address) internal idToApproval;\n\n\n\n    /**\n\n     * @dev Mapping from owner address to count of his tokens.\n\n     */\n\n    mapping(address => uint256) private ownerToNFTokenCount;\n\n\n\n    /**\n\n     * @dev Mapping from owner address to mapping of operator addresses.\n\n     */\n\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\n\n\n\n    /**\n\n     * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n\n     * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n\n     * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n\n     * transfer, the approved address for that NFT (if any) is reset to none.\n\n     * @param _from Sender of NFT (if address is zero address it indicates token creation).\n\n     * @param _to Receiver of NFT (if address is zero address it indicates token destruction).\n\n     * @param _tokenId The NFT that got transfered.\n\n     */\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n\n     * address indicates there is no approved address. When a Transfer event emits, this also\n\n     * indicates that the approved address for that NFT (if any) is reset to none.\n\n     * @param _owner Owner of NFT.\n\n     * @param _approved Address that we are approving.\n\n     * @param _tokenId NFT which we are approving.\n\n     */\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n\n     * all NFTs of the owner.\n\n     * @param _owner Owner of NFT.\n\n     * @param _operator Address to which we are setting operator rights.\n\n     * @param _approved Status of operator rights(true if operator rights are given and false if\n\n     * revoked).\n\n     */\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    /**\n\n     * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\n\n     * @param _tokenId ID of the NFT to validate.\n\n     */\n\n    modifier canOperate(uint256 _tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(\n\n            tokenOwner == msg.sender ||\n\n                ownerToOperators[tokenOwner][msg.sender],\n\n            NOT_OWNER_OR_OPERATOR\n\n        );\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Guarantees that the msg.sender is allowed to transfer NFT.\n\n     * @param _tokenId ID of the NFT to transfer.\n\n     */\n\n    modifier canTransfer(uint256 _tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(\n\n            tokenOwner == msg.sender ||\n\n                idToApproval[_tokenId] == msg.sender ||\n\n                ownerToOperators[tokenOwner][msg.sender],\n\n            NOT_OWNER_APPROWED_OR_OPERATOR\n\n        );\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Guarantees that _tokenId is a valid Token.\n\n     * @param _tokenId ID of the NFT to validate.\n\n     */\n\n    modifier validNFToken(uint256 _tokenId) {\n\n        require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Contract constructor.\n\n     */\n\n    constructor() public {\n\n        supportedInterfaces[0x80ac58cd] = true; // ERC721\n\n    }\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address. This function can\n\n     * be changed to payable.\n\n     * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n\n     * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n\n     * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n\n     * function checks if `_to` is a smart contract (code size > 0). If so, it calls\n\n     * `onERC721Received` on `_to` and throws if the return value is not\n\n     * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     * @param _data Additional data with no specified format, sent in call to `_to`.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    ) external {\n\n        _safeTransferFrom(_from, _to, _tokenId, _data);\n\n    }\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address. This function can\n\n     * be changed to payable.\n\n     * @notice This works identically to the other function with an extra data parameter, except this\n\n     * function just sets data to \"\"\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external {\n\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\n\n    }\n\n\n\n    /**\n\n     * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n\n     * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n\n     * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.\n\n     * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n\n     * they maybe be permanently lost.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external canTransfer(_tokenId) validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(tokenOwner == _from, NOT_OWNER);\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n\n\n        _transfer(_to, _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\n\n     * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n\n     * the current NFT owner, or an authorized operator of the current owner.\n\n     * @param _approved Address to be approved for the given NFT ID.\n\n     * @param _tokenId ID of the token to be approved.\n\n     */\n\n    function approve(address _approved, uint256 _tokenId)\n\n        external\n\n        canOperate(_tokenId)\n\n        validNFToken(_tokenId)\n\n    {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(_approved != tokenOwner, IS_OWNER);\n\n\n\n        idToApproval[_tokenId] = _approved;\n\n        emit Approval(tokenOwner, _approved, _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Enables or disables approval for a third party (\"operator\") to manage all of\n\n     * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n\n     * @notice This works even if sender doesn't own any tokens at the time.\n\n     * @param _operator Address to add to the set of authorized operators.\n\n     * @param _approved True if the operators is approved, false to revoke approval.\n\n     */\n\n    function setApprovalForAll(address _operator, bool _approved) external {\n\n        ownerToOperators[msg.sender][_operator] = _approved;\n\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n\n     * considered invalid, and this function throws for queries about the zero address.\n\n     * @param _owner Address for whom to query the balance.\n\n     * @return Balance of _owner.\n\n     */\n\n    function balanceOf(address _owner) external view returns (uint256) {\n\n        require(_owner != address(0), ZERO_ADDRESS);\n\n        return _getOwnerNFTCount(_owner);\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n\n     * invalid, and queries about them do throw.\n\n     * @param _tokenId The identifier for an NFT.\n\n     * @return _owner Address of _tokenId owner.\n\n     */\n\n    function ownerOf(uint256 _tokenId) external view returns (address _owner) {\n\n        _owner = idToOwner[_tokenId];\n\n        require(_owner != address(0), NOT_VALID_NFT);\n\n    }\n\n\n\n    /**\n\n     * @dev Get the approved address for a single NFT.\n\n     * @notice Throws if `_tokenId` is not a valid NFT.\n\n     * @param _tokenId ID of the NFT to query the approval of.\n\n     * @return Address that _tokenId is approved for.\n\n     */\n\n    function getApproved(uint256 _tokenId)\n\n        external\n\n        view\n\n        validNFToken(_tokenId)\n\n        returns (address)\n\n    {\n\n        return idToApproval[_tokenId];\n\n    }\n\n\n\n    /**\n\n     * @dev Checks if `_operator` is an approved operator for `_owner`.\n\n     * @param _owner The address that owns the NFTs.\n\n     * @param _operator The address that acts on behalf of the owner.\n\n     * @return True if approved for all, false otherwise.\n\n     */\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        external\n\n        view\n\n        returns (bool)\n\n    {\n\n        return ownerToOperators[_owner][_operator];\n\n    }\n\n\n\n    /**\n\n     * @dev Actually preforms the transfer.\n\n     * @notice Does NO checks.\n\n     * @param _to Address of a new owner.\n\n     * @param _tokenId The NFT that is being transferred.\n\n     */\n\n    function _transfer(address _to, uint256 _tokenId) internal {\n\n        address from = idToOwner[_tokenId];\n\n        _clearApproval(_tokenId);\n\n\n\n        _removeNFToken(from, _tokenId);\n\n        _addNFToken(_to, _tokenId);\n\n\n\n        emit Transfer(from, _to, _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Mints a new NFT.\n\n     * @notice This is an internal function which should be called from user-implemented external\n\n     * mint function. Its purpose is to show and properly initialize data structures when using this\n\n     * implementation.\n\n     * @param _to The address that will own the minted NFT.\n\n     * @param _tokenId of the NFT to be minted by the msg.sender.\n\n     */\n\n    function _mint(address _to, uint256 _tokenId) internal {\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n\n\n        _addNFToken(_to, _tokenId);\n\n\n\n        emit Transfer(address(0), _to, _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Burns a NFT.\n\n     * @notice This is an internal function which should be called from user-implemented external burn\n\n     * function. Its purpose is to show and properly initialize data structures when using this\n\n     * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\n\n     * NFT.\n\n     * @param _tokenId ID of the NFT to be burned.\n\n     */\n\n    function _burn(uint256 _tokenId) internal validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        _clearApproval(_tokenId);\n\n        _removeNFToken(tokenOwner, _tokenId);\n\n        emit Transfer(tokenOwner, address(0), _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Removes a NFT from owner.\n\n     * @notice Use and  this function with caution. Wrong usage can have serious consequences.\n\n     * @param _from Address from wich we want to remove the NFT.\n\n     * @param _tokenId Which NFT we want to remove.\n\n     */\n\n    function _removeNFToken(address _from, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == _from, NOT_OWNER);\n\n        ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1;\n\n        delete idToOwner[_tokenId];\n\n    }\n\n\n\n    /**\n\n     * @dev Assignes a new NFT to owner.\n\n     * @notice Use and  this function with caution. Wrong usage can have serious consequences.\n\n     * @param _to Address to wich we want to add the NFT.\n\n     * @param _tokenId Which NFT we want to add.\n\n     */\n\n    function _addNFToken(address _to, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n\n\n        idToOwner[_tokenId] = _to;\n\n        ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to].add(1);\n\n    }\n\n\n\n    /**\n\n     *\u00a0@dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\n\n     * extension to remove double storage (gas optimization) of owner nft count.\n\n     * @param _owner Address for whom to query the count.\n\n     * @return Number of _owner NFTs.\n\n     */\n\n    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\n\n        return ownerToNFTokenCount[_owner];\n\n    }\n\n\n\n    /**\n\n     * @dev Actually perform the safeTransferFrom.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     * @param _data Additional data with no specified format, sent in call to `_to`.\n\n     */\n\n    function _safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes memory _data\n\n    ) private canTransfer(_tokenId) validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(tokenOwner == _from, NOT_OWNER);\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n\n\n        _transfer(_to, _tokenId);\n\n\n\n        if (_to.isContract()) {\n\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                _data\n\n            );\n\n            require(\n\n                retval == MAGIC_ON_ERC721_RECEIVED,\n\n                NOT_ABLE_TO_RECEIVE_NFT\n\n            );\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev Clears the current approval of a given NFT ID.\n\n     * @param _tokenId ID of the NFT to be transferred.\n\n     */\n\n    function _clearApproval(uint256 _tokenId) private {\n\n        if (idToApproval[_tokenId] != address(0)) {\n\n            delete idToApproval[_tokenId];\n\n        }\n\n    }\n\n}\n",
                    "message": "NFToken (nf-token-enumerable.sol#385-786) has incorrect ERC20 function interface(s):\n\t-transferFrom (nf-token-enumerable.sol#566-576)\n\t-approve (nf-token-enumerable.sol#585-595)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 921,
                    "vulnerability_to_line": 935,
                    "vulnerability_code": "    function _burn(uint256 _tokenId) internal {\n\n        super._burn(_tokenId);\n\n\n\n        uint256 tokenIndex = idToIndex[_tokenId];\n\n        uint256 lastTokenIndex = tokens.length - 1;\n\n        uint256 lastToken = tokens[lastTokenIndex];\n\n\n\n        tokens[tokenIndex] = lastToken;\n\n\n\n        tokens.pop();\n\n        // This wastes gas if you are burning the last token but saves a little gas if you are not.\n\n        idToIndex[lastToken] = tokenIndex;\n\n        idToIndex[_tokenId] = 0;\n\n    }\n",
                    "message": "Reentrancy in NFTokenEnumerable._burn (nf-token-enumerable.sol#921-935):\n\tExternal calls:\n\t- tokens.pop() (nf-token-enumerable.sol#930)\n\tState variables written after the call(s):\n\t- idToIndex (nf-token-enumerable.sol#932)\n\t- idToIndex (nf-token-enumerable.sol#933)\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 921,
                    "vulnerability_to_line": 935,
                    "vulnerability_code": "    function _burn(uint256 _tokenId) internal {\n\n        super._burn(_tokenId);\n\n\n\n        uint256 tokenIndex = idToIndex[_tokenId];\n\n        uint256 lastTokenIndex = tokens.length - 1;\n\n        uint256 lastToken = tokens[lastTokenIndex];\n\n\n\n        tokens[tokenIndex] = lastToken;\n\n\n\n        tokens.pop();\n\n        // This wastes gas if you are burning the last token but saves a little gas if you are not.\n\n        idToIndex[lastToken] = tokenIndex;\n\n        idToIndex[_tokenId] = 0;\n\n    }\n",
                    "message": "NFTokenEnumerable._burn (nf-token-enumerable.sol#921-935) does not use the value returned by external calls:\n\t-tokens.pop() (nf-token-enumerable.sol#930)\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 942,
                    "vulnerability_to_line": 957,
                    "vulnerability_code": "    function _removeNFToken(address _from, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == _from, NOT_OWNER);\n\n        delete idToOwner[_tokenId];\n\n\n\n        uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\n\n        uint256 lastTokenIndex = ownerToIds[_from].length - 1;\n\n\n\n        if (lastTokenIndex != tokenToRemoveIndex) {\n\n            uint256 lastToken = ownerToIds[_from][lastTokenIndex];\n\n            ownerToIds[_from][tokenToRemoveIndex] = lastToken;\n\n            idToOwnerIndex[lastToken] = tokenToRemoveIndex;\n\n        }\n\n\n\n        ownerToIds[_from].pop();\n\n    }\n",
                    "message": "NFTokenEnumerable._removeNFToken (nf-token-enumerable.sol#942-957) does not use the value returned by external calls:\n\t-ownerToIds[_from].pop() (nf-token-enumerable.sol#955)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function isContract(address _addr)\n\n        internal\n\n        view\n\n        returns (bool addressCheck)\n\n    {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        assembly {\n\n            codehash := extcodehash(_addr)\n\n        } // solhint-disable-line\n\n        addressCheck = (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "AddressUtils.isContract uses assembly (nf-token-enumerable.sol#353-371)\n\t- nf-token-enumerable.sol#367-369\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in nf-token-enumerable.sol:\n\t- pragma solidity^0.5.0 (nf-token-enumerable.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-enumerable.sol#149): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-enumerable.sol#179): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-enumerable.sol#283): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-enumerable.sol#304): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-enumerable.sol#339): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-enumerable.sol#376): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-enumerable.sol#789-790): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-enumerable.sol#826-827): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _factor1, uint256 _factor2)\n",
                    "message": "Parameter '_factor1' of SafeMath.mul (nf-token-enumerable.sol#201) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _factor1, uint256 _factor2)\n",
                    "message": "Parameter '_factor2' of SafeMath.mul (nf-token-enumerable.sol#201) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _dividend, uint256 _divisor)\n",
                    "message": "Parameter '_dividend' of SafeMath.div (nf-token-enumerable.sol#223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _dividend, uint256 _divisor)\n",
                    "message": "Parameter '_divisor' of SafeMath.div (nf-token-enumerable.sol#223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _minuend, uint256 _subtrahend)\n",
                    "message": "Parameter '_minuend' of SafeMath.sub (nf-token-enumerable.sol#240) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _minuend, uint256 _subtrahend)\n",
                    "message": "Parameter '_subtrahend' of SafeMath.sub (nf-token-enumerable.sol#240) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _addend1, uint256 _addend2)\n",
                    "message": "Parameter '_addend1' of SafeMath.add (nf-token-enumerable.sol#255) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _addend1, uint256 _addend2)\n",
                    "message": "Parameter '_addend2' of SafeMath.add (nf-token-enumerable.sol#255) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mod(uint256 _dividend, uint256 _divisor)\n",
                    "message": "Parameter '_dividend' of SafeMath.mod (nf-token-enumerable.sol#271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mod(uint256 _dividend, uint256 _divisor)\n",
                    "message": "Parameter '_divisor' of SafeMath.mod (nf-token-enumerable.sol#271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function supportsInterface(bytes4 _interfaceID)\n",
                    "message": "Parameter '_interfaceID' of SupportsInterface.supportsInterface (nf-token-enumerable.sol#328) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of NFToken.safeTransferFrom (nf-token-enumerable.sol#531) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 532,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of NFToken.safeTransferFrom (nf-token-enumerable.sol#532) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId,\n",
                    "message": "Parameter '_tokenId' of NFToken.safeTransferFrom (nf-token-enumerable.sol#533) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata _data\n",
                    "message": "Parameter '_data' of NFToken.safeTransferFrom (nf-token-enumerable.sol#534) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of NFToken.safeTransferFrom (nf-token-enumerable.sol#549) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of NFToken.safeTransferFrom (nf-token-enumerable.sol#550) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId\n",
                    "message": "Parameter '_tokenId' of NFToken.safeTransferFrom (nf-token-enumerable.sol#551) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 567,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of NFToken.transferFrom (nf-token-enumerable.sol#567) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of NFToken.transferFrom (nf-token-enumerable.sol#568) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId\n",
                    "message": "Parameter '_tokenId' of NFToken.transferFrom (nf-token-enumerable.sol#569) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 585,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
                    "message": "Parameter '_approved' of NFToken.approve (nf-token-enumerable.sol#585) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 585,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of NFToken.approve (nf-token-enumerable.sol#585) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved) external {\n",
                    "message": "Parameter '_operator' of NFToken.setApprovalForAll (nf-token-enumerable.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved) external {\n",
                    "message": "Parameter '_approved' of NFToken.setApprovalForAll (nf-token-enumerable.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 615,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) external view returns (uint256) {\n",
                    "message": "Parameter '_owner' of NFToken.balanceOf (nf-token-enumerable.sol#615) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ownerOf(uint256 _tokenId) external view returns (address _owner) {\n",
                    "message": "Parameter '_tokenId' of NFToken.ownerOf (nf-token-enumerable.sol#626) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getApproved(uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of NFToken.getApproved (nf-token-enumerable.sol#637) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
                    "message": "Parameter '_owner' of NFToken.isApprovedForAll (nf-token-enumerable.sol#652) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
                    "message": "Parameter '_operator' of NFToken.isApprovedForAll (nf-token-enumerable.sol#652) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": 674,
                    "vulnerability_code": "    function _transfer(address _to, uint256 _tokenId) internal {\n\n        address from = idToOwner[_tokenId];\n\n        _clearApproval(_tokenId);\n\n\n\n        _removeNFToken(from, _tokenId);\n\n        _addNFToken(_to, _tokenId);\n\n\n\n        emit Transfer(from, _to, _tokenId);\n",
                    "message": "Function 'NFToken._transfer' (nf-token-enumerable.sol#666-674) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _transfer(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_to' of NFToken._transfer (nf-token-enumerable.sol#666) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _transfer(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_tokenId' of NFToken._transfer (nf-token-enumerable.sol#666) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": 691,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId) internal {\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n\n\n        _addNFToken(_to, _tokenId);\n\n\n\n        emit Transfer(address(0), _to, _tokenId);\n",
                    "message": "Function 'NFToken._mint' (nf-token-enumerable.sol#684-691) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_to' of NFToken._mint (nf-token-enumerable.sol#684) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_tokenId' of NFToken._mint (nf-token-enumerable.sol#684) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": 706,
                    "vulnerability_code": "    function _burn(uint256 _tokenId) internal validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        _clearApproval(_tokenId);\n\n        _removeNFToken(tokenOwner, _tokenId);\n\n        emit Transfer(tokenOwner, address(0), _tokenId);\n",
                    "message": "Function 'NFToken._burn' (nf-token-enumerable.sol#701-706) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _burn(uint256 _tokenId) internal validNFToken(_tokenId) {\n",
                    "message": "Parameter '_tokenId' of NFToken._burn (nf-token-enumerable.sol#701) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": 718,
                    "vulnerability_code": "    function _removeNFToken(address _from, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == _from, NOT_OWNER);\n\n        ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1;\n\n        delete idToOwner[_tokenId];\n",
                    "message": "Function 'NFToken._removeNFToken' (nf-token-enumerable.sol#714-718) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeNFToken(address _from, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_from' of NFToken._removeNFToken (nf-token-enumerable.sol#714) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeNFToken(address _from, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_tokenId' of NFToken._removeNFToken (nf-token-enumerable.sol#714) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": 731,
                    "vulnerability_code": "    function _addNFToken(address _to, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n\n\n        idToOwner[_tokenId] = _to;\n\n        ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to].add(1);\n",
                    "message": "Function 'NFToken._addNFToken' (nf-token-enumerable.sol#726-731) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addNFToken(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_to' of NFToken._addNFToken (nf-token-enumerable.sol#726) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addNFToken(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_tokenId' of NFToken._addNFToken (nf-token-enumerable.sol#726) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 739,
                    "vulnerability_to_line": 742,
                    "vulnerability_code": "    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\n\n        return ownerToNFTokenCount[_owner];\n\n    }\n",
                    "message": "Function 'NFToken._getOwnerNFTCount' (nf-token-enumerable.sol#739-742) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 739,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\n",
                    "message": "Parameter '_owner' of NFToken._getOwnerNFTCount (nf-token-enumerable.sol#739) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 750,
                    "vulnerability_to_line": 775,
                    "vulnerability_code": "    function _safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes memory _data\n\n    ) private canTransfer(_tokenId) validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(tokenOwner == _from, NOT_OWNER);\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n\n\n        _transfer(_to, _tokenId);\n\n\n\n        if (_to.isContract()) {\n\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                _data\n\n            );\n\n            require(\n\n                retval == MAGIC_ON_ERC721_RECEIVED,\n\n                NOT_ABLE_TO_RECEIVE_NFT\n\n            );\n\n        }\n\n    }\n",
                    "message": "Function 'NFToken._safeTransferFrom' (nf-token-enumerable.sol#750-775) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 751,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of NFToken._safeTransferFrom (nf-token-enumerable.sol#751) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 752,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of NFToken._safeTransferFrom (nf-token-enumerable.sol#752) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 753,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId,\n",
                    "message": "Parameter '_tokenId' of NFToken._safeTransferFrom (nf-token-enumerable.sol#753) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 754,
                    "vulnerability_to_line": 755,
                    "vulnerability_code": "        bytes memory _data\n",
                    "message": "Parameter '_data' of NFToken._safeTransferFrom (nf-token-enumerable.sol#754-755) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 780,
                    "vulnerability_to_line": 785,
                    "vulnerability_code": "    function _clearApproval(uint256 _tokenId) private {\n\n        if (idToApproval[_tokenId] != address(0)) {\n\n            delete idToApproval[_tokenId];\n\n        }\n\n    }\n",
                    "message": "Function 'NFToken._clearApproval' (nf-token-enumerable.sol#780-785) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 780,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _clearApproval(uint256 _tokenId) private {\n",
                    "message": "Parameter '_tokenId' of NFToken._clearApproval (nf-token-enumerable.sol#780) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 907,
                    "vulnerability_to_line": 912,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId) internal {\n\n        super._mint(_to, _tokenId);\n\n        tokens.push(_tokenId);\n\n        idToIndex[_tokenId] = tokens.length - 1;\n\n    }\n",
                    "message": "Function 'NFTokenEnumerable._mint' (nf-token-enumerable.sol#907-912) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 907,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_to' of NFTokenEnumerable._mint (nf-token-enumerable.sol#907) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 907,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_tokenId' of NFTokenEnumerable._mint (nf-token-enumerable.sol#907) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 921,
                    "vulnerability_to_line": 935,
                    "vulnerability_code": "    function _burn(uint256 _tokenId) internal {\n\n        super._burn(_tokenId);\n\n\n\n        uint256 tokenIndex = idToIndex[_tokenId];\n\n        uint256 lastTokenIndex = tokens.length - 1;\n\n        uint256 lastToken = tokens[lastTokenIndex];\n\n\n\n        tokens[tokenIndex] = lastToken;\n\n\n\n        tokens.pop();\n\n        // This wastes gas if you are burning the last token but saves a little gas if you are not.\n\n        idToIndex[lastToken] = tokenIndex;\n\n        idToIndex[_tokenId] = 0;\n\n    }\n",
                    "message": "Function 'NFTokenEnumerable._burn' (nf-token-enumerable.sol#921-935) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 921,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _burn(uint256 _tokenId) internal {\n",
                    "message": "Parameter '_tokenId' of NFTokenEnumerable._burn (nf-token-enumerable.sol#921) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 942,
                    "vulnerability_to_line": 957,
                    "vulnerability_code": "    function _removeNFToken(address _from, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == _from, NOT_OWNER);\n\n        delete idToOwner[_tokenId];\n\n\n\n        uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\n\n        uint256 lastTokenIndex = ownerToIds[_from].length - 1;\n\n\n\n        if (lastTokenIndex != tokenToRemoveIndex) {\n\n            uint256 lastToken = ownerToIds[_from][lastTokenIndex];\n\n            ownerToIds[_from][tokenToRemoveIndex] = lastToken;\n\n            idToOwnerIndex[lastToken] = tokenToRemoveIndex;\n\n        }\n\n\n\n        ownerToIds[_from].pop();\n\n    }\n",
                    "message": "Function 'NFTokenEnumerable._removeNFToken' (nf-token-enumerable.sol#942-957) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 942,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeNFToken(address _from, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_from' of NFTokenEnumerable._removeNFToken (nf-token-enumerable.sol#942) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 942,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeNFToken(address _from, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_tokenId' of NFTokenEnumerable._removeNFToken (nf-token-enumerable.sol#942) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 964,
                    "vulnerability_to_line": 971,
                    "vulnerability_code": "    function _addNFToken(address _to, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n        idToOwner[_tokenId] = _to;\n\n\n\n        ownerToIds[_to].push(_tokenId);\n\n        idToOwnerIndex[_tokenId] = ownerToIds[_to].length - 1;\n\n    }\n",
                    "message": "Function 'NFTokenEnumerable._addNFToken' (nf-token-enumerable.sol#964-971) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 964,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addNFToken(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_to' of NFTokenEnumerable._addNFToken (nf-token-enumerable.sol#964) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 964,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addNFToken(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_tokenId' of NFTokenEnumerable._addNFToken (nf-token-enumerable.sol#964) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 978,
                    "vulnerability_to_line": 981,
                    "vulnerability_code": "    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\n\n        return ownerToIds[_owner].length;\n\n    }\n",
                    "message": "Function 'NFTokenEnumerable._getOwnerNFTCount' (nf-token-enumerable.sol#978-981) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 978,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\n",
                    "message": "Parameter '_owner' of NFTokenEnumerable._getOwnerNFTCount (nf-token-enumerable.sol#978) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 879,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tokenByIndex(uint256 _index) external view returns (uint256) {\n",
                    "message": "Parameter '_index' of NFTokenEnumerable.tokenByIndex (nf-token-enumerable.sol#879) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 890,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tokenOfOwnerByIndex(address _owner, uint256 _index)\n",
                    "message": "Parameter '_owner' of NFTokenEnumerable.tokenOfOwnerByIndex (nf-token-enumerable.sol#890) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 890,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tokenOfOwnerByIndex(address _owner, uint256 _index)\n",
                    "message": "Parameter '_index' of NFTokenEnumerable.tokenOfOwnerByIndex (nf-token-enumerable.sol#890) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[0x80ac58cd] = true; // ERC721\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 863,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 585,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 789,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 826,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) private ownerToNFTokenCount;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address _addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant OVERFLOW = \"008001\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant SUBTRAHEND_GREATER_THEN_MINUEND = \"008002\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant DIVISION_BY_ZERO = \"008003\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 393,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant ZERO_ADDRESS = \"003001\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NOT_VALID_NFT = \"003002\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 395,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NOT_OWNER_OR_OPERATOR = \"003003\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NOT_OWNER_APPROWED_OR_OPERATOR = \"003004\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NFT_ALREADY_EXISTS = \"003006\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NOT_OWNER = \"003007\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant IS_OWNER = \"003008\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant INVALID_INDEX = \"005007\";\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/gfc/tokens/nf-token-metadata.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[0x80ac58cd] = true; // ERC721\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 846,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(product / _factor1 == _factor2, OVERFLOW);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_divisor > 0, DIVISION_BY_ZERO);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_subtrahend <= _minuend, SUBTRAHEND_GREATER_THEN_MINUEND);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sum >= _addend1, OVERFLOW);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_divisor != 0, DIVISION_BY_ZERO);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_67"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 829,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string internal nftName;\n",
                    "message": "NFTokenMetadata.nftName (nf-token-metadata.sol#829) is never initialized. It is used in:\n\t- name (nf-token-metadata.sol#853-856)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 834,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string internal nftSymbol;\n",
                    "message": "NFTokenMetadata.nftSymbol (nf-token-metadata.sol#834) is never initialized. It is used in:\n\t- symbol (nf-token-metadata.sol#861-864)\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function isContract(address _addr)\n\n        internal\n\n        view\n\n        returns (bool addressCheck)\n\n    {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        assembly {\n\n            codehash := extcodehash(_addr)\n\n        } // solhint-disable-line\n\n        addressCheck = (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "AddressUtils.isContract (nf-token-metadata.sol#353-371) is declared view but contains assembly code\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "interface ERC721 {\n\n    /**\n\n     * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n\n     * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n\n     * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n\n     * transfer, the approved address for that NFT (if any) is reset to none.\n\n     */\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n\n     * address indicates there is no approved address. When a Transfer event emits, this also\n\n     * indicates that the approved address for that NFT (if any) is reset to none.\n\n     */\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n\n     * all NFTs of the owner.\n\n     */\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address.\n\n     * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n\n     * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n\n     * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n\n     * function checks if `_to` is a smart contract (code size > 0). If so, it calls\n\n     * `onERC721Received` on `_to` and throws if the return value is not\n\n     * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     * @param _data Additional data with no specified format, sent in call to `_to`.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address.\n\n     * @notice This works identically to the other function with an extra data parameter, except this\n\n     * function just sets data to \"\"\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n\n     * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n\n     * address. Throws if `_tokenId` is not a valid NFT.\n\n     * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n\n     * they mayb be permanently lost.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Set or reaffirm the approved address for an NFT.\n\n     * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n\n     * the current NFT owner, or an authorized operator of the current owner.\n\n     * @param _approved The new approved NFT controller.\n\n     * @param _tokenId The NFT to approve.\n\n     */\n\n    function approve(address _approved, uint256 _tokenId) external;\n\n\n\n    /**\n\n     * @dev Enables or disables approval for a third party (\"operator\") to manage all of\n\n     * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n\n     * @notice The contract MUST allow multiple operators per owner.\n\n     * @param _operator Address to add to the set of authorized operators.\n\n     * @param _approved True if the operators is approved, false to revoke approval.\n\n     */\n\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n\n\n    /**\n\n     * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n\n     * considered invalid, and this function throws for queries about the zero address.\n\n     * @param _owner Address for whom to query the balance.\n\n     * @return Balance of _owner.\n\n     */\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n\n     * invalid, and queries about them do throw.\n\n     * @param _tokenId The identifier for an NFT.\n\n     * @return Address of _tokenId owner.\n\n     */\n\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n\n\n    /**\n\n     * @dev Get the approved address for a single NFT.\n\n     * @notice Throws if `_tokenId` is not a valid NFT.\n\n     * @param _tokenId The NFT to find the approved address for.\n\n     * @return Address that _tokenId is approved for.\n\n     */\n\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n\n\n    /**\n\n     * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\n\n     * @param _owner The address that owns the NFTs.\n\n     * @param _operator The address that acts on behalf of the owner.\n\n     * @return True if approved for all, false otherwise.\n\n     */\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        external\n\n        view\n\n        returns (bool);\n",
                    "message": "ERC721 (nf-token-metadata.sol#9-145) has incorrect ERC20 function interface(s):\n\t-transferFrom (nf-token-metadata.sol#87-91)\n\t-approve (nf-token-metadata.sol#100)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": 786,
                    "vulnerability_code": "contract NFToken is ERC721, SupportsInterface {\n\n    using SafeMath for uint256;\n\n    using AddressUtils for address;\n\n\n\n    /**\n\n     * List of revert message codes. Implementing dApp should handle showing the correct message.\n\n     * Based on 0xcert framework error codes.\n\n     */\n\n    string constant ZERO_ADDRESS = \"003001\";\n\n    string constant NOT_VALID_NFT = \"003002\";\n\n    string constant NOT_OWNER_OR_OPERATOR = \"003003\";\n\n    string constant NOT_OWNER_APPROWED_OR_OPERATOR = \"003004\";\n\n    string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\n\n    string constant NFT_ALREADY_EXISTS = \"003006\";\n\n    string constant NOT_OWNER = \"003007\";\n\n    string constant IS_OWNER = \"003008\";\n\n\n\n    /**\n\n     * @dev Magic value of a smart contract that can recieve NFT.\n\n     * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\n\n     */\n\n    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n\n\n\n    /**\n\n     * @dev A mapping from NFT ID to the address that owns it.\n\n     */\n\n    mapping(uint256 => address) internal idToOwner;\n\n\n\n    /**\n\n     * @dev Mapping from NFT ID to approved address.\n\n     */\n\n    mapping(uint256 => address) internal idToApproval;\n\n\n\n    /**\n\n     * @dev Mapping from owner address to count of his tokens.\n\n     */\n\n    mapping(address => uint256) private ownerToNFTokenCount;\n\n\n\n    /**\n\n     * @dev Mapping from owner address to mapping of operator addresses.\n\n     */\n\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\n\n\n\n    /**\n\n     * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n\n     * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n\n     * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n\n     * transfer, the approved address for that NFT (if any) is reset to none.\n\n     * @param _from Sender of NFT (if address is zero address it indicates token creation).\n\n     * @param _to Receiver of NFT (if address is zero address it indicates token destruction).\n\n     * @param _tokenId The NFT that got transfered.\n\n     */\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n\n     * address indicates there is no approved address. When a Transfer event emits, this also\n\n     * indicates that the approved address for that NFT (if any) is reset to none.\n\n     * @param _owner Owner of NFT.\n\n     * @param _approved Address that we are approving.\n\n     * @param _tokenId NFT which we are approving.\n\n     */\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n\n     * all NFTs of the owner.\n\n     * @param _owner Owner of NFT.\n\n     * @param _operator Address to which we are setting operator rights.\n\n     * @param _approved Status of operator rights(true if operator rights are given and false if\n\n     * revoked).\n\n     */\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    /**\n\n     * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\n\n     * @param _tokenId ID of the NFT to validate.\n\n     */\n\n    modifier canOperate(uint256 _tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(\n\n            tokenOwner == msg.sender ||\n\n                ownerToOperators[tokenOwner][msg.sender],\n\n            NOT_OWNER_OR_OPERATOR\n\n        );\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Guarantees that the msg.sender is allowed to transfer NFT.\n\n     * @param _tokenId ID of the NFT to transfer.\n\n     */\n\n    modifier canTransfer(uint256 _tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(\n\n            tokenOwner == msg.sender ||\n\n                idToApproval[_tokenId] == msg.sender ||\n\n                ownerToOperators[tokenOwner][msg.sender],\n\n            NOT_OWNER_APPROWED_OR_OPERATOR\n\n        );\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Guarantees that _tokenId is a valid Token.\n\n     * @param _tokenId ID of the NFT to validate.\n\n     */\n\n    modifier validNFToken(uint256 _tokenId) {\n\n        require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Contract constructor.\n\n     */\n\n    constructor() public {\n\n        supportedInterfaces[0x80ac58cd] = true; // ERC721\n\n    }\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address. This function can\n\n     * be changed to payable.\n\n     * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n\n     * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n\n     * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n\n     * function checks if `_to` is a smart contract (code size > 0). If so, it calls\n\n     * `onERC721Received` on `_to` and throws if the return value is not\n\n     * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     * @param _data Additional data with no specified format, sent in call to `_to`.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    ) external {\n\n        _safeTransferFrom(_from, _to, _tokenId, _data);\n\n    }\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address. This function can\n\n     * be changed to payable.\n\n     * @notice This works identically to the other function with an extra data parameter, except this\n\n     * function just sets data to \"\"\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external {\n\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\n\n    }\n\n\n\n    /**\n\n     * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n\n     * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n\n     * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.\n\n     * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n\n     * they maybe be permanently lost.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external canTransfer(_tokenId) validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(tokenOwner == _from, NOT_OWNER);\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n\n\n        _transfer(_to, _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\n\n     * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n\n     * the current NFT owner, or an authorized operator of the current owner.\n\n     * @param _approved Address to be approved for the given NFT ID.\n\n     * @param _tokenId ID of the token to be approved.\n\n     */\n\n    function approve(address _approved, uint256 _tokenId)\n\n        external\n\n        canOperate(_tokenId)\n\n        validNFToken(_tokenId)\n\n    {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(_approved != tokenOwner, IS_OWNER);\n\n\n\n        idToApproval[_tokenId] = _approved;\n\n        emit Approval(tokenOwner, _approved, _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Enables or disables approval for a third party (\"operator\") to manage all of\n\n     * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n\n     * @notice This works even if sender doesn't own any tokens at the time.\n\n     * @param _operator Address to add to the set of authorized operators.\n\n     * @param _approved True if the operators is approved, false to revoke approval.\n\n     */\n\n    function setApprovalForAll(address _operator, bool _approved) external {\n\n        ownerToOperators[msg.sender][_operator] = _approved;\n\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n\n     * considered invalid, and this function throws for queries about the zero address.\n\n     * @param _owner Address for whom to query the balance.\n\n     * @return Balance of _owner.\n\n     */\n\n    function balanceOf(address _owner) external view returns (uint256) {\n\n        require(_owner != address(0), ZERO_ADDRESS);\n\n        return _getOwnerNFTCount(_owner);\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n\n     * invalid, and queries about them do throw.\n\n     * @param _tokenId The identifier for an NFT.\n\n     * @return _owner Address of _tokenId owner.\n\n     */\n\n    function ownerOf(uint256 _tokenId) external view returns (address _owner) {\n\n        _owner = idToOwner[_tokenId];\n\n        require(_owner != address(0), NOT_VALID_NFT);\n\n    }\n\n\n\n    /**\n\n     * @dev Get the approved address for a single NFT.\n\n     * @notice Throws if `_tokenId` is not a valid NFT.\n\n     * @param _tokenId ID of the NFT to query the approval of.\n\n     * @return Address that _tokenId is approved for.\n\n     */\n\n    function getApproved(uint256 _tokenId)\n\n        external\n\n        view\n\n        validNFToken(_tokenId)\n\n        returns (address)\n\n    {\n\n        return idToApproval[_tokenId];\n\n    }\n\n\n\n    /**\n\n     * @dev Checks if `_operator` is an approved operator for `_owner`.\n\n     * @param _owner The address that owns the NFTs.\n\n     * @param _operator The address that acts on behalf of the owner.\n\n     * @return True if approved for all, false otherwise.\n\n     */\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        external\n\n        view\n\n        returns (bool)\n\n    {\n\n        return ownerToOperators[_owner][_operator];\n\n    }\n\n\n\n    /**\n\n     * @dev Actually preforms the transfer.\n\n     * @notice Does NO checks.\n\n     * @param _to Address of a new owner.\n\n     * @param _tokenId The NFT that is being transferred.\n\n     */\n\n    function _transfer(address _to, uint256 _tokenId) internal {\n\n        address from = idToOwner[_tokenId];\n\n        _clearApproval(_tokenId);\n\n\n\n        _removeNFToken(from, _tokenId);\n\n        _addNFToken(_to, _tokenId);\n\n\n\n        emit Transfer(from, _to, _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Mints a new NFT.\n\n     * @notice This is an internal function which should be called from user-implemented external\n\n     * mint function. Its purpose is to show and properly initialize data structures when using this\n\n     * implementation.\n\n     * @param _to The address that will own the minted NFT.\n\n     * @param _tokenId of the NFT to be minted by the msg.sender.\n\n     */\n\n    function _mint(address _to, uint256 _tokenId) internal {\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n\n\n        _addNFToken(_to, _tokenId);\n\n\n\n        emit Transfer(address(0), _to, _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Burns a NFT.\n\n     * @notice This is an internal function which should be called from user-implemented external burn\n\n     * function. Its purpose is to show and properly initialize data structures when using this\n\n     * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\n\n     * NFT.\n\n     * @param _tokenId ID of the NFT to be burned.\n\n     */\n\n    function _burn(uint256 _tokenId) internal validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        _clearApproval(_tokenId);\n\n        _removeNFToken(tokenOwner, _tokenId);\n\n        emit Transfer(tokenOwner, address(0), _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Removes a NFT from owner.\n\n     * @notice Use and  this function with caution. Wrong usage can have serious consequences.\n\n     * @param _from Address from wich we want to remove the NFT.\n\n     * @param _tokenId Which NFT we want to remove.\n\n     */\n\n    function _removeNFToken(address _from, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == _from, NOT_OWNER);\n\n        ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1;\n\n        delete idToOwner[_tokenId];\n\n    }\n\n\n\n    /**\n\n     * @dev Assignes a new NFT to owner.\n\n     * @notice Use and  this function with caution. Wrong usage can have serious consequences.\n\n     * @param _to Address to wich we want to add the NFT.\n\n     * @param _tokenId Which NFT we want to add.\n\n     */\n\n    function _addNFToken(address _to, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n\n\n        idToOwner[_tokenId] = _to;\n\n        ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to].add(1);\n\n    }\n\n\n\n    /**\n\n     *\u00a0@dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\n\n     * extension to remove double storage (gas optimization) of owner nft count.\n\n     * @param _owner Address for whom to query the count.\n\n     * @return Number of _owner NFTs.\n\n     */\n\n    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\n\n        return ownerToNFTokenCount[_owner];\n\n    }\n\n\n\n    /**\n\n     * @dev Actually perform the safeTransferFrom.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     * @param _data Additional data with no specified format, sent in call to `_to`.\n\n     */\n\n    function _safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes memory _data\n\n    ) private canTransfer(_tokenId) validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(tokenOwner == _from, NOT_OWNER);\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n\n\n        _transfer(_to, _tokenId);\n\n\n\n        if (_to.isContract()) {\n\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                _data\n\n            );\n\n            require(\n\n                retval == MAGIC_ON_ERC721_RECEIVED,\n\n                NOT_ABLE_TO_RECEIVE_NFT\n\n            );\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev Clears the current approval of a given NFT ID.\n\n     * @param _tokenId ID of the NFT to be transferred.\n\n     */\n\n    function _clearApproval(uint256 _tokenId) private {\n\n        if (idToApproval[_tokenId] != address(0)) {\n\n            delete idToApproval[_tokenId];\n\n        }\n\n    }\n\n}\n",
                    "message": "NFToken (nf-token-metadata.sol#385-786) has incorrect ERC20 function interface(s):\n\t-transferFrom (nf-token-metadata.sol#566-576)\n\t-approve (nf-token-metadata.sol#585-595)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function isContract(address _addr)\n\n        internal\n\n        view\n\n        returns (bool addressCheck)\n\n    {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        assembly {\n\n            codehash := extcodehash(_addr)\n\n        } // solhint-disable-line\n\n        addressCheck = (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "AddressUtils.isContract uses assembly (nf-token-metadata.sol#353-371)\n\t- nf-token-metadata.sol#367-369\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 829,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string internal nftName;\n",
                    "message": "NFTokenMetadata.nftName should be constant (nf-token-metadata.sol#829)\nNFTokenMetadata.nftSymbol should be constant (nf-token-metadata.sol#834)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in nf-token-metadata.sol:\n\t- pragma solidity^0.5.0 (nf-token-metadata.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-metadata.sol#149): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-metadata.sol#179): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-metadata.sol#283): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-metadata.sol#304): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-metadata.sol#339): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-metadata.sol#376): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-metadata.sol#789-790): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token-metadata.sol#819-820): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _factor1, uint256 _factor2)\n",
                    "message": "Parameter '_factor1' of SafeMath.mul (nf-token-metadata.sol#201) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _factor1, uint256 _factor2)\n",
                    "message": "Parameter '_factor2' of SafeMath.mul (nf-token-metadata.sol#201) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _dividend, uint256 _divisor)\n",
                    "message": "Parameter '_dividend' of SafeMath.div (nf-token-metadata.sol#223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _dividend, uint256 _divisor)\n",
                    "message": "Parameter '_divisor' of SafeMath.div (nf-token-metadata.sol#223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _minuend, uint256 _subtrahend)\n",
                    "message": "Parameter '_minuend' of SafeMath.sub (nf-token-metadata.sol#240) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _minuend, uint256 _subtrahend)\n",
                    "message": "Parameter '_subtrahend' of SafeMath.sub (nf-token-metadata.sol#240) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _addend1, uint256 _addend2)\n",
                    "message": "Parameter '_addend1' of SafeMath.add (nf-token-metadata.sol#255) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _addend1, uint256 _addend2)\n",
                    "message": "Parameter '_addend2' of SafeMath.add (nf-token-metadata.sol#255) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mod(uint256 _dividend, uint256 _divisor)\n",
                    "message": "Parameter '_dividend' of SafeMath.mod (nf-token-metadata.sol#271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mod(uint256 _dividend, uint256 _divisor)\n",
                    "message": "Parameter '_divisor' of SafeMath.mod (nf-token-metadata.sol#271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function supportsInterface(bytes4 _interfaceID)\n",
                    "message": "Parameter '_interfaceID' of SupportsInterface.supportsInterface (nf-token-metadata.sol#328) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of NFToken.safeTransferFrom (nf-token-metadata.sol#531) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 532,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of NFToken.safeTransferFrom (nf-token-metadata.sol#532) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId,\n",
                    "message": "Parameter '_tokenId' of NFToken.safeTransferFrom (nf-token-metadata.sol#533) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata _data\n",
                    "message": "Parameter '_data' of NFToken.safeTransferFrom (nf-token-metadata.sol#534) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of NFToken.safeTransferFrom (nf-token-metadata.sol#549) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of NFToken.safeTransferFrom (nf-token-metadata.sol#550) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId\n",
                    "message": "Parameter '_tokenId' of NFToken.safeTransferFrom (nf-token-metadata.sol#551) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 567,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of NFToken.transferFrom (nf-token-metadata.sol#567) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of NFToken.transferFrom (nf-token-metadata.sol#568) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId\n",
                    "message": "Parameter '_tokenId' of NFToken.transferFrom (nf-token-metadata.sol#569) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 585,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
                    "message": "Parameter '_approved' of NFToken.approve (nf-token-metadata.sol#585) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 585,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of NFToken.approve (nf-token-metadata.sol#585) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved) external {\n",
                    "message": "Parameter '_operator' of NFToken.setApprovalForAll (nf-token-metadata.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved) external {\n",
                    "message": "Parameter '_approved' of NFToken.setApprovalForAll (nf-token-metadata.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 615,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) external view returns (uint256) {\n",
                    "message": "Parameter '_owner' of NFToken.balanceOf (nf-token-metadata.sol#615) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ownerOf(uint256 _tokenId) external view returns (address _owner) {\n",
                    "message": "Parameter '_tokenId' of NFToken.ownerOf (nf-token-metadata.sol#626) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getApproved(uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of NFToken.getApproved (nf-token-metadata.sol#637) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
                    "message": "Parameter '_owner' of NFToken.isApprovedForAll (nf-token-metadata.sol#652) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
                    "message": "Parameter '_operator' of NFToken.isApprovedForAll (nf-token-metadata.sol#652) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": 674,
                    "vulnerability_code": "    function _transfer(address _to, uint256 _tokenId) internal {\n\n        address from = idToOwner[_tokenId];\n\n        _clearApproval(_tokenId);\n\n\n\n        _removeNFToken(from, _tokenId);\n\n        _addNFToken(_to, _tokenId);\n\n\n\n        emit Transfer(from, _to, _tokenId);\n",
                    "message": "Function 'NFToken._transfer' (nf-token-metadata.sol#666-674) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _transfer(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_to' of NFToken._transfer (nf-token-metadata.sol#666) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _transfer(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_tokenId' of NFToken._transfer (nf-token-metadata.sol#666) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": 691,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId) internal {\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n\n\n        _addNFToken(_to, _tokenId);\n\n\n\n        emit Transfer(address(0), _to, _tokenId);\n",
                    "message": "Function 'NFToken._mint' (nf-token-metadata.sol#684-691) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_to' of NFToken._mint (nf-token-metadata.sol#684) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_tokenId' of NFToken._mint (nf-token-metadata.sol#684) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": 706,
                    "vulnerability_code": "    function _burn(uint256 _tokenId) internal validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        _clearApproval(_tokenId);\n\n        _removeNFToken(tokenOwner, _tokenId);\n\n        emit Transfer(tokenOwner, address(0), _tokenId);\n",
                    "message": "Function 'NFToken._burn' (nf-token-metadata.sol#701-706) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _burn(uint256 _tokenId) internal validNFToken(_tokenId) {\n",
                    "message": "Parameter '_tokenId' of NFToken._burn (nf-token-metadata.sol#701) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": 718,
                    "vulnerability_code": "    function _removeNFToken(address _from, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == _from, NOT_OWNER);\n\n        ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1;\n\n        delete idToOwner[_tokenId];\n",
                    "message": "Function 'NFToken._removeNFToken' (nf-token-metadata.sol#714-718) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeNFToken(address _from, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_from' of NFToken._removeNFToken (nf-token-metadata.sol#714) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeNFToken(address _from, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_tokenId' of NFToken._removeNFToken (nf-token-metadata.sol#714) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": 731,
                    "vulnerability_code": "    function _addNFToken(address _to, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n\n\n        idToOwner[_tokenId] = _to;\n\n        ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to].add(1);\n",
                    "message": "Function 'NFToken._addNFToken' (nf-token-metadata.sol#726-731) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addNFToken(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_to' of NFToken._addNFToken (nf-token-metadata.sol#726) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addNFToken(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_tokenId' of NFToken._addNFToken (nf-token-metadata.sol#726) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 739,
                    "vulnerability_to_line": 742,
                    "vulnerability_code": "    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\n\n        return ownerToNFTokenCount[_owner];\n\n    }\n",
                    "message": "Function 'NFToken._getOwnerNFTCount' (nf-token-metadata.sol#739-742) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 739,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\n",
                    "message": "Parameter '_owner' of NFToken._getOwnerNFTCount (nf-token-metadata.sol#739) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 750,
                    "vulnerability_to_line": 775,
                    "vulnerability_code": "    function _safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes memory _data\n\n    ) private canTransfer(_tokenId) validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(tokenOwner == _from, NOT_OWNER);\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n\n\n        _transfer(_to, _tokenId);\n\n\n\n        if (_to.isContract()) {\n\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                _data\n\n            );\n\n            require(\n\n                retval == MAGIC_ON_ERC721_RECEIVED,\n\n                NOT_ABLE_TO_RECEIVE_NFT\n\n            );\n\n        }\n\n    }\n",
                    "message": "Function 'NFToken._safeTransferFrom' (nf-token-metadata.sol#750-775) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 751,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of NFToken._safeTransferFrom (nf-token-metadata.sol#751) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 752,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of NFToken._safeTransferFrom (nf-token-metadata.sol#752) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 753,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId,\n",
                    "message": "Parameter '_tokenId' of NFToken._safeTransferFrom (nf-token-metadata.sol#753) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 754,
                    "vulnerability_to_line": 755,
                    "vulnerability_code": "        bytes memory _data\n",
                    "message": "Parameter '_data' of NFToken._safeTransferFrom (nf-token-metadata.sol#754-755) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 780,
                    "vulnerability_to_line": 785,
                    "vulnerability_code": "    function _clearApproval(uint256 _tokenId) private {\n\n        if (idToApproval[_tokenId] != address(0)) {\n\n            delete idToApproval[_tokenId];\n\n        }\n\n    }\n",
                    "message": "Function 'NFToken._clearApproval' (nf-token-metadata.sol#780-785) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 780,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _clearApproval(uint256 _tokenId) private {\n",
                    "message": "Parameter '_tokenId' of NFToken._clearApproval (nf-token-metadata.sol#780) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 887,
                    "vulnerability_to_line": 894,
                    "vulnerability_code": "    function _burn(uint256 _tokenId) internal {\n\n        super._burn(_tokenId);\n\n\n\n        if (bytes(idToUri[_tokenId]).length != 0) {\n\n            delete idToUri[_tokenId];\n\n        }\n\n    }\n",
                    "message": "Function 'NFTokenMetadata._burn' (nf-token-metadata.sol#887-894) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 887,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _burn(uint256 _tokenId) internal {\n",
                    "message": "Parameter '_tokenId' of NFTokenMetadata._burn (nf-token-metadata.sol#887) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 870,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tokenURI(uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of NFTokenMetadata.tokenURI (nf-token-metadata.sol#870) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 903,
                    "vulnerability_to_line": 909,
                    "vulnerability_code": "    function _setTokenUri(uint256 _tokenId, string memory _uri)\n\n        internal\n\n        validNFToken(_tokenId)\n\n    {\n\n        idToUri[_tokenId] = _uri;\n\n    }\n",
                    "message": "Function 'NFTokenMetadata._setTokenUri' (nf-token-metadata.sol#903-909) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 903,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setTokenUri(uint256 _tokenId, string memory _uri)\n",
                    "message": "Parameter '_tokenId' of NFTokenMetadata._setTokenUri (nf-token-metadata.sol#903) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 903,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setTokenUri(uint256 _tokenId, string memory _uri)\n",
                    "message": "Parameter '_uri' of NFTokenMetadata._setTokenUri (nf-token-metadata.sol#903) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[0x80ac58cd] = true; // ERC721\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 846,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 585,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 789,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 819,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) private ownerToNFTokenCount;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address _addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant OVERFLOW = \"008001\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant SUBTRAHEND_GREATER_THEN_MINUEND = \"008002\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant DIVISION_BY_ZERO = \"008003\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 393,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant ZERO_ADDRESS = \"003001\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NOT_VALID_NFT = \"003002\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 395,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NOT_OWNER_OR_OPERATOR = \"003003\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NOT_OWNER_APPROWED_OR_OPERATOR = \"003004\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NFT_ALREADY_EXISTS = \"003006\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NOT_OWNER = \"003007\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant IS_OWNER = \"003008\";\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/gfc/tokens/erc721.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "interface ERC721 {\n\n    /**\n\n     * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n\n     * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n\n     * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n\n     * transfer, the approved address for that NFT (if any) is reset to none.\n\n     */\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n\n     * address indicates there is no approved address. When a Transfer event emits, this also\n\n     * indicates that the approved address for that NFT (if any) is reset to none.\n\n     */\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n\n     * all NFTs of the owner.\n\n     */\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address.\n\n     * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n\n     * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n\n     * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n\n     * function checks if `_to` is a smart contract (code size > 0). If so, it calls\n\n     * `onERC721Received` on `_to` and throws if the return value is not\n\n     * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     * @param _data Additional data with no specified format, sent in call to `_to`.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address.\n\n     * @notice This works identically to the other function with an extra data parameter, except this\n\n     * function just sets data to \"\"\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n\n     * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n\n     * address. Throws if `_tokenId` is not a valid NFT.\n\n     * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n\n     * they mayb be permanently lost.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Set or reaffirm the approved address for an NFT.\n\n     * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n\n     * the current NFT owner, or an authorized operator of the current owner.\n\n     * @param _approved The new approved NFT controller.\n\n     * @param _tokenId The NFT to approve.\n\n     */\n\n    function approve(address _approved, uint256 _tokenId) external;\n\n\n\n    /**\n\n     * @dev Enables or disables approval for a third party (\"operator\") to manage all of\n\n     * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n\n     * @notice The contract MUST allow multiple operators per owner.\n\n     * @param _operator Address to add to the set of authorized operators.\n\n     * @param _approved True if the operators is approved, false to revoke approval.\n\n     */\n\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n\n\n    /**\n\n     * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n\n     * considered invalid, and this function throws for queries about the zero address.\n\n     * @param _owner Address for whom to query the balance.\n\n     * @return Balance of _owner.\n\n     */\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n\n     * invalid, and queries about them do throw.\n\n     * @param _tokenId The identifier for an NFT.\n\n     * @return Address of _tokenId owner.\n\n     */\n\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n\n\n    /**\n\n     * @dev Get the approved address for a single NFT.\n\n     * @notice Throws if `_tokenId` is not a valid NFT.\n\n     * @param _tokenId The NFT to find the approved address for.\n\n     * @return Address that _tokenId is approved for.\n\n     */\n\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n\n\n    /**\n\n     * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\n\n     * @param _owner The address that owns the NFTs.\n\n     * @param _operator The address that acts on behalf of the owner.\n\n     * @return True if approved for all, false otherwise.\n\n     */\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        external\n\n        view\n\n        returns (bool);\n",
                    "message": "ERC721 (erc721.sol#9-145) has incorrect ERC20 function interface(s):\n\t-transferFrom (erc721.sol#87-91)\n\t-approve (erc721.sol#100)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in erc721.sol:\n\t- pragma solidity^0.5.0 (erc721.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/gfc/tokens/nf-token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[0x80ac58cd] = true; // ERC721\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(product / _factor1 == _factor2, OVERFLOW);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_divisor > 0, DIVISION_BY_ZERO);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_subtrahend <= _minuend, SUBTRAHEND_GREATER_THEN_MINUEND);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sum >= _addend1, OVERFLOW);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_divisor != 0, DIVISION_BY_ZERO);\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_58"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function isContract(address _addr)\n\n        internal\n\n        view\n\n        returns (bool addressCheck)\n\n    {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        assembly {\n\n            codehash := extcodehash(_addr)\n\n        } // solhint-disable-line\n\n        addressCheck = (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "AddressUtils.isContract (nf-token.sol#353-371) is declared view but contains assembly code\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "interface ERC721 {\n\n    /**\n\n     * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n\n     * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n\n     * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n\n     * transfer, the approved address for that NFT (if any) is reset to none.\n\n     */\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n\n     * address indicates there is no approved address. When a Transfer event emits, this also\n\n     * indicates that the approved address for that NFT (if any) is reset to none.\n\n     */\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n\n     * all NFTs of the owner.\n\n     */\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address.\n\n     * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n\n     * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n\n     * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n\n     * function checks if `_to` is a smart contract (code size > 0). If so, it calls\n\n     * `onERC721Received` on `_to` and throws if the return value is not\n\n     * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     * @param _data Additional data with no specified format, sent in call to `_to`.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address.\n\n     * @notice This works identically to the other function with an extra data parameter, except this\n\n     * function just sets data to \"\"\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n\n     * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n\n     * address. Throws if `_tokenId` is not a valid NFT.\n\n     * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n\n     * they mayb be permanently lost.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Set or reaffirm the approved address for an NFT.\n\n     * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n\n     * the current NFT owner, or an authorized operator of the current owner.\n\n     * @param _approved The new approved NFT controller.\n\n     * @param _tokenId The NFT to approve.\n\n     */\n\n    function approve(address _approved, uint256 _tokenId) external;\n\n\n\n    /**\n\n     * @dev Enables or disables approval for a third party (\"operator\") to manage all of\n\n     * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n\n     * @notice The contract MUST allow multiple operators per owner.\n\n     * @param _operator Address to add to the set of authorized operators.\n\n     * @param _approved True if the operators is approved, false to revoke approval.\n\n     */\n\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n\n\n    /**\n\n     * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n\n     * considered invalid, and this function throws for queries about the zero address.\n\n     * @param _owner Address for whom to query the balance.\n\n     * @return Balance of _owner.\n\n     */\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n\n     * invalid, and queries about them do throw.\n\n     * @param _tokenId The identifier for an NFT.\n\n     * @return Address of _tokenId owner.\n\n     */\n\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n\n\n    /**\n\n     * @dev Get the approved address for a single NFT.\n\n     * @notice Throws if `_tokenId` is not a valid NFT.\n\n     * @param _tokenId The NFT to find the approved address for.\n\n     * @return Address that _tokenId is approved for.\n\n     */\n\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n\n\n    /**\n\n     * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\n\n     * @param _owner The address that owns the NFTs.\n\n     * @param _operator The address that acts on behalf of the owner.\n\n     * @return True if approved for all, false otherwise.\n\n     */\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        external\n\n        view\n\n        returns (bool);\n",
                    "message": "ERC721 (nf-token.sol#9-145) has incorrect ERC20 function interface(s):\n\t-transferFrom (nf-token.sol#87-91)\n\t-approve (nf-token.sol#100)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": 785,
                    "vulnerability_code": "contract NFToken is ERC721, SupportsInterface {\n\n    using SafeMath for uint256;\n\n    using AddressUtils for address;\n\n\n\n    /**\n\n     * List of revert message codes. Implementing dApp should handle showing the correct message.\n\n     * Based on 0xcert framework error codes.\n\n     */\n\n    string constant ZERO_ADDRESS = \"003001\";\n\n    string constant NOT_VALID_NFT = \"003002\";\n\n    string constant NOT_OWNER_OR_OPERATOR = \"003003\";\n\n    string constant NOT_OWNER_APPROWED_OR_OPERATOR = \"003004\";\n\n    string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\n\n    string constant NFT_ALREADY_EXISTS = \"003006\";\n\n    string constant NOT_OWNER = \"003007\";\n\n    string constant IS_OWNER = \"003008\";\n\n\n\n    /**\n\n     * @dev Magic value of a smart contract that can recieve NFT.\n\n     * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\n\n     */\n\n    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n\n\n\n    /**\n\n     * @dev A mapping from NFT ID to the address that owns it.\n\n     */\n\n    mapping(uint256 => address) internal idToOwner;\n\n\n\n    /**\n\n     * @dev Mapping from NFT ID to approved address.\n\n     */\n\n    mapping(uint256 => address) internal idToApproval;\n\n\n\n    /**\n\n     * @dev Mapping from owner address to count of his tokens.\n\n     */\n\n    mapping(address => uint256) private ownerToNFTokenCount;\n\n\n\n    /**\n\n     * @dev Mapping from owner address to mapping of operator addresses.\n\n     */\n\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\n\n\n\n    /**\n\n     * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n\n     * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n\n     * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n\n     * transfer, the approved address for that NFT (if any) is reset to none.\n\n     * @param _from Sender of NFT (if address is zero address it indicates token creation).\n\n     * @param _to Receiver of NFT (if address is zero address it indicates token destruction).\n\n     * @param _tokenId The NFT that got transfered.\n\n     */\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n\n     * address indicates there is no approved address. When a Transfer event emits, this also\n\n     * indicates that the approved address for that NFT (if any) is reset to none.\n\n     * @param _owner Owner of NFT.\n\n     * @param _approved Address that we are approving.\n\n     * @param _tokenId NFT which we are approving.\n\n     */\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /**\n\n     * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n\n     * all NFTs of the owner.\n\n     * @param _owner Owner of NFT.\n\n     * @param _operator Address to which we are setting operator rights.\n\n     * @param _approved Status of operator rights(true if operator rights are given and false if\n\n     * revoked).\n\n     */\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    /**\n\n     * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\n\n     * @param _tokenId ID of the NFT to validate.\n\n     */\n\n    modifier canOperate(uint256 _tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(\n\n            tokenOwner == msg.sender ||\n\n                ownerToOperators[tokenOwner][msg.sender],\n\n            NOT_OWNER_OR_OPERATOR\n\n        );\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Guarantees that the msg.sender is allowed to transfer NFT.\n\n     * @param _tokenId ID of the NFT to transfer.\n\n     */\n\n    modifier canTransfer(uint256 _tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(\n\n            tokenOwner == msg.sender ||\n\n                idToApproval[_tokenId] == msg.sender ||\n\n                ownerToOperators[tokenOwner][msg.sender],\n\n            NOT_OWNER_APPROWED_OR_OPERATOR\n\n        );\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Guarantees that _tokenId is a valid Token.\n\n     * @param _tokenId ID of the NFT to validate.\n\n     */\n\n    modifier validNFToken(uint256 _tokenId) {\n\n        require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\n\n        _;\n\n    }\n\n\n\n    /**\n\n     * @dev Contract constructor.\n\n     */\n\n    constructor() public {\n\n        supportedInterfaces[0x80ac58cd] = true; // ERC721\n\n    }\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address. This function can\n\n     * be changed to payable.\n\n     * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n\n     * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n\n     * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n\n     * function checks if `_to` is a smart contract (code size > 0). If so, it calls\n\n     * `onERC721Received` on `_to` and throws if the return value is not\n\n     * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     * @param _data Additional data with no specified format, sent in call to `_to`.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    ) external {\n\n        _safeTransferFrom(_from, _to, _tokenId, _data);\n\n    }\n\n\n\n    /**\n\n     * @dev Transfers the ownership of an NFT from one address to another address. This function can\n\n     * be changed to payable.\n\n     * @notice This works identically to the other function with an extra data parameter, except this\n\n     * function just sets data to \"\"\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external {\n\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\n\n    }\n\n\n\n    /**\n\n     * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n\n     * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n\n     * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.\n\n     * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n\n     * they maybe be permanently lost.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     */\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    ) external canTransfer(_tokenId) validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(tokenOwner == _from, NOT_OWNER);\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n\n\n        _transfer(_to, _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\n\n     * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n\n     * the current NFT owner, or an authorized operator of the current owner.\n\n     * @param _approved Address to be approved for the given NFT ID.\n\n     * @param _tokenId ID of the token to be approved.\n\n     */\n\n    function approve(address _approved, uint256 _tokenId)\n\n        external\n\n        canOperate(_tokenId)\n\n        validNFToken(_tokenId)\n\n    {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(_approved != tokenOwner, IS_OWNER);\n\n\n\n        idToApproval[_tokenId] = _approved;\n\n        emit Approval(tokenOwner, _approved, _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Enables or disables approval for a third party (\"operator\") to manage all of\n\n     * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n\n     * @notice This works even if sender doesn't own any tokens at the time.\n\n     * @param _operator Address to add to the set of authorized operators.\n\n     * @param _approved True if the operators is approved, false to revoke approval.\n\n     */\n\n    function setApprovalForAll(address _operator, bool _approved) external {\n\n        ownerToOperators[msg.sender][_operator] = _approved;\n\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n\n     * considered invalid, and this function throws for queries about the zero address.\n\n     * @param _owner Address for whom to query the balance.\n\n     * @return Balance of _owner.\n\n     */\n\n    function balanceOf(address _owner) external view returns (uint256) {\n\n        require(_owner != address(0), ZERO_ADDRESS);\n\n        return _getOwnerNFTCount(_owner);\n\n    }\n\n\n\n    /**\n\n     * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n\n     * invalid, and queries about them do throw.\n\n     * @param _tokenId The identifier for an NFT.\n\n     * @return _owner Address of _tokenId owner.\n\n     */\n\n    function ownerOf(uint256 _tokenId) external view returns (address _owner) {\n\n        _owner = idToOwner[_tokenId];\n\n        require(_owner != address(0), NOT_VALID_NFT);\n\n    }\n\n\n\n    /**\n\n     * @dev Get the approved address for a single NFT.\n\n     * @notice Throws if `_tokenId` is not a valid NFT.\n\n     * @param _tokenId ID of the NFT to query the approval of.\n\n     * @return Address that _tokenId is approved for.\n\n     */\n\n    function getApproved(uint256 _tokenId)\n\n        external\n\n        view\n\n        validNFToken(_tokenId)\n\n        returns (address)\n\n    {\n\n        return idToApproval[_tokenId];\n\n    }\n\n\n\n    /**\n\n     * @dev Checks if `_operator` is an approved operator for `_owner`.\n\n     * @param _owner The address that owns the NFTs.\n\n     * @param _operator The address that acts on behalf of the owner.\n\n     * @return True if approved for all, false otherwise.\n\n     */\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        external\n\n        view\n\n        returns (bool)\n\n    {\n\n        return ownerToOperators[_owner][_operator];\n\n    }\n\n\n\n    /**\n\n     * @dev Actually preforms the transfer.\n\n     * @notice Does NO checks.\n\n     * @param _to Address of a new owner.\n\n     * @param _tokenId The NFT that is being transferred.\n\n     */\n\n    function _transfer(address _to, uint256 _tokenId) internal {\n\n        address from = idToOwner[_tokenId];\n\n        _clearApproval(_tokenId);\n\n\n\n        _removeNFToken(from, _tokenId);\n\n        _addNFToken(_to, _tokenId);\n\n\n\n        emit Transfer(from, _to, _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Mints a new NFT.\n\n     * @notice This is an internal function which should be called from user-implemented external\n\n     * mint function. Its purpose is to show and properly initialize data structures when using this\n\n     * implementation.\n\n     * @param _to The address that will own the minted NFT.\n\n     * @param _tokenId of the NFT to be minted by the msg.sender.\n\n     */\n\n    function _mint(address _to, uint256 _tokenId) internal {\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n\n\n        _addNFToken(_to, _tokenId);\n\n\n\n        emit Transfer(address(0), _to, _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Burns a NFT.\n\n     * @notice This is an internal function which should be called from user-implemented external burn\n\n     * function. Its purpose is to show and properly initialize data structures when using this\n\n     * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\n\n     * NFT.\n\n     * @param _tokenId ID of the NFT to be burned.\n\n     */\n\n    function _burn(uint256 _tokenId) internal validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        _clearApproval(_tokenId);\n\n        _removeNFToken(tokenOwner, _tokenId);\n\n        emit Transfer(tokenOwner, address(0), _tokenId);\n\n    }\n\n\n\n    /**\n\n     * @dev Removes a NFT from owner.\n\n     * @notice Use and  this function with caution. Wrong usage can have serious consequences.\n\n     * @param _from Address from wich we want to remove the NFT.\n\n     * @param _tokenId Which NFT we want to remove.\n\n     */\n\n    function _removeNFToken(address _from, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == _from, NOT_OWNER);\n\n        ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1;\n\n        delete idToOwner[_tokenId];\n\n    }\n\n\n\n    /**\n\n     * @dev Assignes a new NFT to owner.\n\n     * @notice Use and  this function with caution. Wrong usage can have serious consequences.\n\n     * @param _to Address to wich we want to add the NFT.\n\n     * @param _tokenId Which NFT we want to add.\n\n     */\n\n    function _addNFToken(address _to, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n\n\n        idToOwner[_tokenId] = _to;\n\n        ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to].add(1);\n\n    }\n\n\n\n    /**\n\n     *\u00a0@dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\n\n     * extension to remove double storage (gas optimization) of owner nft count.\n\n     * @param _owner Address for whom to query the count.\n\n     * @return Number of _owner NFTs.\n\n     */\n\n    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\n\n        return ownerToNFTokenCount[_owner];\n\n    }\n\n\n\n    /**\n\n     * @dev Actually perform the safeTransferFrom.\n\n     * @param _from The current owner of the NFT.\n\n     * @param _to The new owner.\n\n     * @param _tokenId The NFT to transfer.\n\n     * @param _data Additional data with no specified format, sent in call to `_to`.\n\n     */\n\n    function _safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes memory _data\n\n    ) private canTransfer(_tokenId) validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(tokenOwner == _from, NOT_OWNER);\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n\n\n        _transfer(_to, _tokenId);\n\n\n\n        if (_to.isContract()) {\n\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                _data\n\n            );\n\n            require(\n\n                retval == MAGIC_ON_ERC721_RECEIVED,\n\n                NOT_ABLE_TO_RECEIVE_NFT\n\n            );\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @dev Clears the current approval of a given NFT ID.\n\n     * @param _tokenId ID of the NFT to be transferred.\n\n     */\n\n    function _clearApproval(uint256 _tokenId) private {\n\n        if (idToApproval[_tokenId] != address(0)) {\n\n            delete idToApproval[_tokenId];\n\n        }\n\n    }\n",
                    "message": "NFToken (nf-token.sol#385-785) has incorrect ERC20 function interface(s):\n\t-transferFrom (nf-token.sol#566-576)\n\t-approve (nf-token.sol#585-595)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function isContract(address _addr)\n\n        internal\n\n        view\n\n        returns (bool addressCheck)\n\n    {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        assembly {\n\n            codehash := extcodehash(_addr)\n\n        } // solhint-disable-line\n\n        addressCheck = (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "AddressUtils.isContract uses assembly (nf-token.sol#353-371)\n\t- nf-token.sol#367-369\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in nf-token.sol:\n\t- pragma solidity^0.5.0 (nf-token.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token.sol#149): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token.sol#179): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token.sol#283): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token.sol#304): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token.sol#339): it allows old versions\n\t- pragma solidity^0.5.0 (nf-token.sol#376): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _factor1, uint256 _factor2)\n",
                    "message": "Parameter '_factor1' of SafeMath.mul (nf-token.sol#201) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _factor1, uint256 _factor2)\n",
                    "message": "Parameter '_factor2' of SafeMath.mul (nf-token.sol#201) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _dividend, uint256 _divisor)\n",
                    "message": "Parameter '_dividend' of SafeMath.div (nf-token.sol#223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _dividend, uint256 _divisor)\n",
                    "message": "Parameter '_divisor' of SafeMath.div (nf-token.sol#223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _minuend, uint256 _subtrahend)\n",
                    "message": "Parameter '_minuend' of SafeMath.sub (nf-token.sol#240) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _minuend, uint256 _subtrahend)\n",
                    "message": "Parameter '_subtrahend' of SafeMath.sub (nf-token.sol#240) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _addend1, uint256 _addend2)\n",
                    "message": "Parameter '_addend1' of SafeMath.add (nf-token.sol#255) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _addend1, uint256 _addend2)\n",
                    "message": "Parameter '_addend2' of SafeMath.add (nf-token.sol#255) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mod(uint256 _dividend, uint256 _divisor)\n",
                    "message": "Parameter '_dividend' of SafeMath.mod (nf-token.sol#271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mod(uint256 _dividend, uint256 _divisor)\n",
                    "message": "Parameter '_divisor' of SafeMath.mod (nf-token.sol#271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function supportsInterface(bytes4 _interfaceID)\n",
                    "message": "Parameter '_interfaceID' of SupportsInterface.supportsInterface (nf-token.sol#328) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of NFToken.safeTransferFrom (nf-token.sol#531) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 532,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of NFToken.safeTransferFrom (nf-token.sol#532) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId,\n",
                    "message": "Parameter '_tokenId' of NFToken.safeTransferFrom (nf-token.sol#533) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata _data\n",
                    "message": "Parameter '_data' of NFToken.safeTransferFrom (nf-token.sol#534) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of NFToken.safeTransferFrom (nf-token.sol#549) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of NFToken.safeTransferFrom (nf-token.sol#550) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId\n",
                    "message": "Parameter '_tokenId' of NFToken.safeTransferFrom (nf-token.sol#551) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 567,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of NFToken.transferFrom (nf-token.sol#567) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of NFToken.transferFrom (nf-token.sol#568) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId\n",
                    "message": "Parameter '_tokenId' of NFToken.transferFrom (nf-token.sol#569) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 585,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
                    "message": "Parameter '_approved' of NFToken.approve (nf-token.sol#585) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 585,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of NFToken.approve (nf-token.sol#585) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved) external {\n",
                    "message": "Parameter '_operator' of NFToken.setApprovalForAll (nf-token.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved) external {\n",
                    "message": "Parameter '_approved' of NFToken.setApprovalForAll (nf-token.sol#604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 615,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) external view returns (uint256) {\n",
                    "message": "Parameter '_owner' of NFToken.balanceOf (nf-token.sol#615) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ownerOf(uint256 _tokenId) external view returns (address _owner) {\n",
                    "message": "Parameter '_tokenId' of NFToken.ownerOf (nf-token.sol#626) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getApproved(uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of NFToken.getApproved (nf-token.sol#637) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
                    "message": "Parameter '_owner' of NFToken.isApprovedForAll (nf-token.sol#652) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
                    "message": "Parameter '_operator' of NFToken.isApprovedForAll (nf-token.sol#652) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": 674,
                    "vulnerability_code": "    function _transfer(address _to, uint256 _tokenId) internal {\n\n        address from = idToOwner[_tokenId];\n\n        _clearApproval(_tokenId);\n\n\n\n        _removeNFToken(from, _tokenId);\n\n        _addNFToken(_to, _tokenId);\n\n\n\n        emit Transfer(from, _to, _tokenId);\n",
                    "message": "Function 'NFToken._transfer' (nf-token.sol#666-674) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _transfer(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_to' of NFToken._transfer (nf-token.sol#666) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _transfer(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_tokenId' of NFToken._transfer (nf-token.sol#666) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": 691,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId) internal {\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n\n\n        _addNFToken(_to, _tokenId);\n\n\n\n        emit Transfer(address(0), _to, _tokenId);\n",
                    "message": "Function 'NFToken._mint' (nf-token.sol#684-691) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_to' of NFToken._mint (nf-token.sol#684) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_tokenId' of NFToken._mint (nf-token.sol#684) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": 706,
                    "vulnerability_code": "    function _burn(uint256 _tokenId) internal validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        _clearApproval(_tokenId);\n\n        _removeNFToken(tokenOwner, _tokenId);\n\n        emit Transfer(tokenOwner, address(0), _tokenId);\n",
                    "message": "Function 'NFToken._burn' (nf-token.sol#701-706) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _burn(uint256 _tokenId) internal validNFToken(_tokenId) {\n",
                    "message": "Parameter '_tokenId' of NFToken._burn (nf-token.sol#701) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": 718,
                    "vulnerability_code": "    function _removeNFToken(address _from, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == _from, NOT_OWNER);\n\n        ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1;\n\n        delete idToOwner[_tokenId];\n",
                    "message": "Function 'NFToken._removeNFToken' (nf-token.sol#714-718) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeNFToken(address _from, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_from' of NFToken._removeNFToken (nf-token.sol#714) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeNFToken(address _from, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_tokenId' of NFToken._removeNFToken (nf-token.sol#714) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": 731,
                    "vulnerability_code": "    function _addNFToken(address _to, uint256 _tokenId) internal {\n\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n\n\n        idToOwner[_tokenId] = _to;\n\n        ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to].add(1);\n",
                    "message": "Function 'NFToken._addNFToken' (nf-token.sol#726-731) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addNFToken(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_to' of NFToken._addNFToken (nf-token.sol#726) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addNFToken(address _to, uint256 _tokenId) internal {\n",
                    "message": "Parameter '_tokenId' of NFToken._addNFToken (nf-token.sol#726) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 739,
                    "vulnerability_to_line": 742,
                    "vulnerability_code": "    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\n\n        return ownerToNFTokenCount[_owner];\n\n    }\n",
                    "message": "Function 'NFToken._getOwnerNFTCount' (nf-token.sol#739-742) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 739,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\n",
                    "message": "Parameter '_owner' of NFToken._getOwnerNFTCount (nf-token.sol#739) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 750,
                    "vulnerability_to_line": 775,
                    "vulnerability_code": "    function _safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes memory _data\n\n    ) private canTransfer(_tokenId) validNFToken(_tokenId) {\n\n        address tokenOwner = idToOwner[_tokenId];\n\n        require(tokenOwner == _from, NOT_OWNER);\n\n        require(_to != address(0), ZERO_ADDRESS);\n\n\n\n        _transfer(_to, _tokenId);\n\n\n\n        if (_to.isContract()) {\n\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                _data\n\n            );\n\n            require(\n\n                retval == MAGIC_ON_ERC721_RECEIVED,\n\n                NOT_ABLE_TO_RECEIVE_NFT\n\n            );\n\n        }\n\n    }\n",
                    "message": "Function 'NFToken._safeTransferFrom' (nf-token.sol#750-775) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 751,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of NFToken._safeTransferFrom (nf-token.sol#751) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 752,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of NFToken._safeTransferFrom (nf-token.sol#752) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 753,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId,\n",
                    "message": "Parameter '_tokenId' of NFToken._safeTransferFrom (nf-token.sol#753) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 754,
                    "vulnerability_to_line": 755,
                    "vulnerability_code": "        bytes memory _data\n",
                    "message": "Parameter '_data' of NFToken._safeTransferFrom (nf-token.sol#754-755) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 780,
                    "vulnerability_to_line": 785,
                    "vulnerability_code": "    function _clearApproval(uint256 _tokenId) private {\n\n        if (idToApproval[_tokenId] != address(0)) {\n\n            delete idToApproval[_tokenId];\n\n        }\n\n    }\n",
                    "message": "Function 'NFToken._clearApproval' (nf-token.sol#780-785) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 780,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _clearApproval(uint256 _tokenId) private {\n",
                    "message": "Parameter '_tokenId' of NFToken._clearApproval (nf-token.sol#780) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[0x80ac58cd] = true; // ERC721\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 585,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) private ownerToNFTokenCount;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address _addr)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant OVERFLOW = \"008001\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant SUBTRAHEND_GREATER_THEN_MINUEND = \"008002\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant DIVISION_BY_ZERO = \"008003\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 393,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant ZERO_ADDRESS = \"003001\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NOT_VALID_NFT = \"003002\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 395,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NOT_OWNER_OR_OPERATOR = \"003003\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NOT_OWNER_APPROWED_OR_OPERATOR = \"003004\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NFT_ALREADY_EXISTS = \"003006\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant NOT_OWNER = \"003007\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string constant IS_OWNER = \"003008\";\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/gfc/tokens/erc721-enumerable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in erc721-enumerable.sol:\n\t- pragma solidity^0.5.0 (erc721-enumerable.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/gfc/tokens/erc721-token-receiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in erc721-token-receiver.sol:\n\t- pragma solidity^0.5.0 (erc721-token-receiver.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    }
}