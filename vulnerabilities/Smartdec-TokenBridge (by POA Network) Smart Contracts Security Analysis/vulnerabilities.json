{
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/test/testContracts/RevertFallback.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": 9,
                    "vulnerability_code": "    function () public payable {\n\n        revert();\n",
                    "message": "Contract locking ether found in RevertFallback.sol:\n\tContract RevertFallback has payable functions:\n\t - fallback (RevertFallback.sol#7-9)\n\t - receiveEth (RevertFallback.sol#11-13)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": 9,
                    "vulnerability_code": "    function () public payable {\n\n        revert();\n",
                    "message": "RevertFallback.fallback (RevertFallback.sol#7-9) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": 13,
                    "vulnerability_code": "    function receiveEth() public payable {\n\n\n",
                    "message": "RevertFallback.receiveEth (RevertFallback.sol#11-13) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RevertFallback {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REDUNDANT_FALLBACK_REJECT",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function () public payable {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function () public payable {\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/test/testContracts/ERC677ReceiverTest.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint public someVar = 0;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.4.24;\n",
                    "message": "Different versions of Solidity is used in ERC677ReceiverTest.sol:\n\t- Version used: ['0.4.24', '^0.4.19']\n\t- ERC677ReceiverTest.sol#3 declares pragma solidity0.4.24\n\t- ERC677ReceiverTest.sol#12 declares pragma solidity^0.4.19\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": 30,
                    "vulnerability_code": "    function doSomething(uint _value) public {\n\n        someVar = _value;\n",
                    "message": "ERC677ReceiverTest.doSomething (ERC677ReceiverTest.sol#28-30) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.19;\n",
                    "message": "Detected issues with version pragma in ERC677ReceiverTest.sol:\n\t- pragma solidity^0.4.19 (ERC677ReceiverTest.sol#12): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": 26,
                    "vulnerability_code": "    function onTokenTransfer(address _from, uint256 _value, bytes _data) external returns(bool) {\n\n        from = _from;\n\n        value = _value;\n\n        data = _data;\n\n        address(this).call(_data);\n\n        return true;\n",
                    "message": "Low level call in ERC677ReceiverTest.onTokenTransfer (ERC677ReceiverTest.sol#20-26):\n\t-address(this).call(_data) ERC677ReceiverTest.sol#24\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onTokenTransfer(address _from, uint256 _value, bytes _data) external returns(bool) {\n",
                    "message": "Parameter '_from' of ERC677ReceiverTest.onTokenTransfer (ERC677ReceiverTest.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onTokenTransfer(address _from, uint256 _value, bytes _data) external returns(bool) {\n",
                    "message": "Parameter '_value' of ERC677ReceiverTest.onTokenTransfer (ERC677ReceiverTest.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onTokenTransfer(address _from, uint256 _value, bytes _data) external returns(bool) {\n",
                    "message": "Parameter '_data' of ERC677ReceiverTest.onTokenTransfer (ERC677ReceiverTest.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doSomething(uint _value) public {\n",
                    "message": "Parameter '_value' of ERC677ReceiverTest.doSomething (ERC677ReceiverTest.sol#28) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.19;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address(this).call(_data);\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/ERC677Receiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/IOwnedUpgradeabilityProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function proxyOwner() public view returns (address);\n",
                    "message": "IOwnedUpgradeabilityProxy.proxyOwner (IOwnedUpgradeabilityProxy.sol#7) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function proxyOwner() public view returns (address);\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/Migrations.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": 19,
                    "vulnerability_code": "  function setCompleted(uint completed) public restricted {\n\n    last_completed_migration = completed;\n",
                    "message": "Migrations.setCompleted (Migrations.sol#17-19) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": 24,
                    "vulnerability_code": "  function upgrade(address new_address) public restricted {\n\n    Migrations upgraded = Migrations(new_address);\n\n    upgraded.setCompleted(last_completed_migration);\n",
                    "message": "Migrations.upgrade (Migrations.sol#21-24) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function upgrade(address new_address) public restricted {\n",
                    "message": "Parameter 'new_address' of Migrations.upgrade (Migrations.sol#21) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  uint public last_completed_migration;\n",
                    "message": "Variable 'Migrations.last_completed_migration' (Migrations.sol#7) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/IRewardableValidators.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": "IRewardableValidators.isValidator (IRewardableValidators.sol#7) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": "IRewardableValidators.requiredSignatures (IRewardableValidators.sol#8) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": "IRewardableValidators.owner (IRewardableValidators.sol#9) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": "IRewardableValidators.validatorList (IRewardableValidators.sol#10) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns(address);\n",
                    "message": "IRewardableValidators.getValidatorRewardAddress (IRewardableValidators.sol#11) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCount() public view returns (uint256);\n",
                    "message": "IRewardableValidators.validatorCount (IRewardableValidators.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address);\n",
                    "message": "IRewardableValidators.getNextValidator (IRewardableValidators.sol#13) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns(address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCount() public view returns (uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address);\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/IBlockReward.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotally() public view returns (uint256);\n",
                    "message": "IBlockReward.mintedTotally (IBlockReward.sol#8) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256);\n",
                    "message": "IBlockReward.mintedTotallyByBridge (IBlockReward.sol#9) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotally() public view returns (uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256);\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/IBurnableMintableERC677Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name_, string memory symbol_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _name = name_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _symbol = symbol_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _decimals = 18;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(b <= a, \"SafeMath: subtraction overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(b > 0, \"SafeMath: division by zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(b > 0, \"SafeMath: modulo by zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: mint to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _beforeTokenTransfer(address(0), account, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _beforeTokenTransfer(account, address(0), amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) private _balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) private _allowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _totalSupply;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _name;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _symbol;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private _decimals;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/ERC677.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name_, string memory symbol_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _name = name_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _symbol = symbol_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _decimals = 18;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(b <= a, \"SafeMath: subtraction overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(b > 0, \"SafeMath: division by zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(b > 0, \"SafeMath: modulo by zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: mint to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _beforeTokenTransfer(address(0), account, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _beforeTokenTransfer(account, address(0), amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) private _balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) private _allowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _totalSupply;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _name;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _symbol;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private _decimals;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/IBridgeValidators.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": "IBridgeValidators.isValidator (IBridgeValidators.sol#7) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": "IBridgeValidators.requiredSignatures (IBridgeValidators.sol#8) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": "IBridgeValidators.owner (IBridgeValidators.sol#9) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/BlockRewardFeeManager.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_23"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => address) internal addressStorage;\n",
                    "message": "EternalStorage.addressStorage (BlockRewardFeeManager.sol#14) is never initialized. It is used in:\n\t- _blockRewardContract (BlockRewardFeeManager.sol#177-179)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": "IRewardableValidators.isValidator (BlockRewardFeeManager.sol#78) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": "IRewardableValidators.requiredSignatures (BlockRewardFeeManager.sol#79) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": "IRewardableValidators.owner (BlockRewardFeeManager.sol#80) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": "IRewardableValidators.validatorList (BlockRewardFeeManager.sol#81) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns(address);\n",
                    "message": "IRewardableValidators.getValidatorRewardAddress (BlockRewardFeeManager.sol#82) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCount() public view returns (uint256);\n",
                    "message": "IRewardableValidators.validatorCount (BlockRewardFeeManager.sol#83) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address);\n",
                    "message": "IRewardableValidators.getNextValidator (BlockRewardFeeManager.sol#84) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": 117,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n\n        uint256 fee = _feeType == HOME_FEE ? getHomeFee() : getForeignFee();\n\n        uint256 eth = 1 ether;\n\n        if (!_recover) {\n\n            return _value.mul(fee).div(eth);\n\n        }\n\n        return _value.mul(fee).div(eth.sub(fee));\n",
                    "message": "BaseFeeManager.calculateFee (BlockRewardFeeManager.sol#110-117) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getFeeManagerMode() public pure returns(bytes4);\n",
                    "message": "BaseFeeManager.getFeeManagerMode (BlockRewardFeeManager.sol#141) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function random(uint256 _count) public view returns(uint256) {\n\n        return uint256(blockhash(block.number.sub(1))) % _count;\n",
                    "message": "BaseFeeManager.random (BlockRewardFeeManager.sol#143-145) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotally() public view returns (uint256);\n",
                    "message": "IBlockReward.mintedTotally (BlockRewardFeeManager.sol#155) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256);\n",
                    "message": "IBlockReward.mintedTotallyByBridge (BlockRewardFeeManager.sol#156) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_value' of BaseFeeManager.calculateFee (BlockRewardFeeManager.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_recover' of BaseFeeManager.calculateFee (BlockRewardFeeManager.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_feeType' of BaseFeeManager.calculateFee (BlockRewardFeeManager.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setHomeFee(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BaseFeeManager.setHomeFee (BlockRewardFeeManager.sol#119) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setForeignFee(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BaseFeeManager.setForeignFee (BlockRewardFeeManager.sol#128) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function random(uint256 _count) public view returns(uint256) {\n",
                    "message": "Parameter '_count' of BaseFeeManager.random (BlockRewardFeeManager.sol#143) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BlockRewardFeeManager.distributeFeeFromAffirmation (BlockRewardFeeManager.sol#169) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BlockRewardFeeManager.distributeFeeFromSignatures (BlockRewardFeeManager.sol#173) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "    function _blockRewardContract() internal view returns(IBlockReward) {\n\n        return IBlockReward(addressStorage[keccak256(abi.encodePacked(\"blockRewardContract\"))]);\n",
                    "message": "Function 'BlockRewardFeeManager._blockRewardContract' (BlockRewardFeeManager.sol#177-179) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (BlockRewardFeeManager.sol#13) is never used in BlockRewardFeeManager\nEternalStorage.bytesStorage (BlockRewardFeeManager.sol#15) is never used in BlockRewardFeeManager\nEternalStorage.boolStorage (BlockRewardFeeManager.sol#16) is never used in BlockRewardFeeManager\nEternalStorage.intStorage (BlockRewardFeeManager.sol#17) is never used in BlockRewardFeeManager\nFeeTypes.FOREIGN_FEE (BlockRewardFeeManager.sol#94) is never used in BlockRewardFeeManager\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns(address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCount() public view returns (uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotally() public view returns (uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256);\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/Sacrifice.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _recipient) public payable {\n",
                    "message": "Parameter '_recipient' of Sacrifice. (Sacrifice.sol#7) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/Ownable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 60,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        require(newOwner != address(0));\n\n        setOwner(newOwner);\n",
                    "message": "Ownable.transferOwnership (Ownable.sol#57-60) should be declared external\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => uint256) internal uintStorage;\n",
                    "message": "EternalStorage.uintStorage (Ownable.sol#12) is never used in Ownable\nEternalStorage.stringStorage (Ownable.sol#13) is never used in Ownable\nEternalStorage.bytesStorage (Ownable.sol#15) is never used in Ownable\nEternalStorage.boolStorage (Ownable.sol#16) is never used in Ownable\nEternalStorage.intStorage (Ownable.sol#17) is never used in Ownable\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/RewardableValidators.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract BaseBridgeValidators is EternalStorage, Ownable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialValidators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (_initialValidators.length == 1) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if (i == _initialValidators.length - 1) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialValidators.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_validator != address(0) && _validator != F_ADDR);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_initialValidators[i] != address(0) && _initialValidators[i] != F_ADDR);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            counter++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialValidators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_30"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 60,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        require(newOwner != address(0));\n\n        setOwner(newOwner);\n",
                    "message": "Ownable.transferOwnership (RewardableValidators.sol#57-60) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "    function getBridgeValidatorsInterfacesVersion()\n\n    public\n\n    pure\n\n    returns (uint64 major, uint64 minor, uint64 patch)\n\n    {\n\n        return (2, 2, 0);\n",
                    "message": "BaseBridgeValidators.getBridgeValidatorsInterfacesVersion (RewardableValidators.sol#147-153) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": 172,
                    "vulnerability_code": "    function validatorList() public view returns (address[]) {\n\n        address [] memory list = new address[](validatorCount());\n\n        uint256 counter = 0;\n\n        address nextValidator = getNextValidator(F_ADDR);\n\n        require(nextValidator != address(0));\n\n\n\n        while (nextValidator != F_ADDR) {\n\n            list[counter] = nextValidator;\n\n            nextValidator = getNextValidator(nextValidator);\n\n            counter++;\n\n\n\n            if (nextValidator == address(0) ) {\n\n                revert();\n\n            }\n\n        }\n\n\n\n        return list;\n",
                    "message": "BaseBridgeValidators.validatorList (RewardableValidators.sol#155-172) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": 225,
                    "vulnerability_code": "    function deployedAtBlock() public view returns (uint256) {\n\n        return uintStorage[keccak256(\"deployedAtBlock\")];\n",
                    "message": "BaseBridgeValidators.deployedAtBlock (RewardableValidators.sol#223-225) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": 298,
                    "vulnerability_code": "    function initialize(\n\n        uint256 _requiredSignatures,\n\n        address[] _initialValidators,\n\n        address[] _initialRewards,\n\n        address _owner\n\n    )\n\n    public\n\n    returns (bool)\n\n    {\n\n        require(!isInitialized());\n\n        require(_owner != address(0));\n\n        setOwner(_owner);\n\n        require(_requiredSignatures != 0);\n\n        require(_initialValidators.length >= _requiredSignatures);\n\n        require(_initialValidators.length == _initialRewards.length);\n\n\n\n        for (uint256 i = 0; i < _initialValidators.length; i++) {\n\n            require(_initialValidators[i] != address(0) && _initialValidators[i] != F_ADDR);\n\n            require(_initialRewards[i] != address(0));\n\n            require(!isValidator(_initialValidators[i]));\n\n\n\n            if (i == 0) {\n\n                setNextValidator(F_ADDR, _initialValidators[i]);\n\n                if (_initialValidators.length == 1) {\n\n                    setNextValidator(_initialValidators[i], F_ADDR);\n\n                }\n\n            } else if (i == _initialValidators.length - 1) {\n\n                setNextValidator(_initialValidators[i - 1], _initialValidators[i]);\n\n                setNextValidator(_initialValidators[i], F_ADDR);\n\n            } else {\n\n                setNextValidator(_initialValidators[i - 1], _initialValidators[i]);\n\n            }\n\n\n\n            setValidatorCount(validatorCount().add(1));\n\n            setValidatorRewardAddress(_initialValidators[i], _initialRewards[i]);\n\n            emit ValidatorAdded(_initialValidators[i]);\n\n        }\n\n\n\n        uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))] = _requiredSignatures;\n\n        uintStorage[keccak256(\"deployedAtBlock\")] = block.number;\n\n        setInitialize(true);\n\n        emit RequiredSignaturesChanged(_requiredSignatures);\n\n\n\n        return isInitialized();\n",
                    "message": "RewardableValidators.initialize (RewardableValidators.sol#254-298) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": 315,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns (address) {\n\n        return addressStorage[keccak256(abi.encodePacked(\"validatorsRewards\", _validator))];\n",
                    "message": "RewardableValidators.getValidatorRewardAddress (RewardableValidators.sol#313-315) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRequiredSignatures(uint256 _requiredSignatures)\n",
                    "message": "Parameter '_requiredSignatures' of BaseBridgeValidators.setRequiredSignatures (RewardableValidators.sol#137) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": 183,
                    "vulnerability_code": "    function _addValidator(address _validator) internal {\n\n        require(_validator != address(0) && _validator != F_ADDR);\n\n        require(!isValidator(_validator));\n\n\n\n        address firstValidator = getNextValidator(F_ADDR);\n\n        require(firstValidator != address(0));\n\n        setNextValidator(_validator, firstValidator);\n\n        setNextValidator(F_ADDR, _validator);\n\n        setValidatorCount(validatorCount().add(1));\n",
                    "message": "Function 'BaseBridgeValidators._addValidator' (RewardableValidators.sol#174-183) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addValidator(address _validator) internal {\n",
                    "message": "Parameter '_validator' of BaseBridgeValidators._addValidator (RewardableValidators.sol#174) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": 205,
                    "vulnerability_code": "    function _removeValidator(address _validator) internal {\n\n        require(validatorCount() > requiredSignatures());\n\n        require(isValidator(_validator));\n\n        address validatorsNext = getNextValidator(_validator);\n\n        address index = F_ADDR;\n\n        address next = getNextValidator(index);\n\n        require(next != address(0));\n\n\n\n        while (next != _validator) {\n\n            index = next;\n\n            next = getNextValidator(index);\n\n\n\n            if (next == F_ADDR || next == address(0) ) {\n\n                revert();\n\n            }\n\n        }\n\n\n\n        setNextValidator(index, validatorsNext);\n\n        deleteItemFromAddressStorage(\"validatorsList\", _validator);\n\n        setValidatorCount(validatorCount().sub(1));\n",
                    "message": "Function 'BaseBridgeValidators._removeValidator' (RewardableValidators.sol#185-205) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeValidator(address _validator) internal {\n",
                    "message": "Parameter '_validator' of BaseBridgeValidators._removeValidator (RewardableValidators.sol#185) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns (bool) {\n",
                    "message": "Parameter '_validator' of BaseBridgeValidators.isValidator (RewardableValidators.sol#215) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address) {\n",
                    "message": "Parameter '_address' of BaseBridgeValidators.getNextValidator (RewardableValidators.sol#227) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function deleteItemFromAddressStorage(string _mapName, address _address) internal {\n",
                    "message": "Parameter '_mapName' of BaseBridgeValidators.deleteItemFromAddressStorage (RewardableValidators.sol#231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function deleteItemFromAddressStorage(string _mapName, address _address) internal {\n",
                    "message": "Parameter '_address' of BaseBridgeValidators.deleteItemFromAddressStorage (RewardableValidators.sol#231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setValidatorCount(uint256 _validatorCount) internal {\n",
                    "message": "Parameter '_validatorCount' of BaseBridgeValidators.setValidatorCount (RewardableValidators.sol#235) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setNextValidator(address _prevValidator, address _validator) internal {\n",
                    "message": "Parameter '_prevValidator' of BaseBridgeValidators.setNextValidator (RewardableValidators.sol#239) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setNextValidator(address _prevValidator, address _validator) internal {\n",
                    "message": "Parameter '_validator' of BaseBridgeValidators.setNextValidator (RewardableValidators.sol#239) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setInitialize(bool _status) internal {\n",
                    "message": "Parameter '_status' of BaseBridgeValidators.setInitialize (RewardableValidators.sol#243) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _requiredSignatures,\n",
                    "message": "Parameter '_requiredSignatures' of RewardableValidators.initialize (RewardableValidators.sol#255) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] _initialValidators,\n",
                    "message": "Parameter '_initialValidators' of RewardableValidators.initialize (RewardableValidators.sol#256) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] _initialRewards,\n",
                    "message": "Parameter '_initialRewards' of RewardableValidators.initialize (RewardableValidators.sol#257) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _owner\n",
                    "message": "Parameter '_owner' of RewardableValidators.initialize (RewardableValidators.sol#258) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addRewardableValidator(address _validator, address _reward) external onlyOwner {\n",
                    "message": "Parameter '_validator' of RewardableValidators.addRewardableValidator (RewardableValidators.sol#300) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addRewardableValidator(address _validator, address _reward) external onlyOwner {\n",
                    "message": "Parameter '_reward' of RewardableValidators.addRewardableValidator (RewardableValidators.sol#300) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeValidator(address _validator) external onlyOwner {\n",
                    "message": "Parameter '_validator' of RewardableValidators.removeValidator (RewardableValidators.sol#307) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns (address) {\n",
                    "message": "Parameter '_validator' of RewardableValidators.getValidatorRewardAddress (RewardableValidators.sol#313) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setValidatorRewardAddress(address _validator, address _reward) internal {\n",
                    "message": "Parameter '_validator' of RewardableValidators.setValidatorRewardAddress (RewardableValidators.sol#317) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setValidatorRewardAddress(address _validator, address _reward) internal {\n",
                    "message": "Parameter '_reward' of RewardableValidators.setValidatorRewardAddress (RewardableValidators.sol#317) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (RewardableValidators.sol#13) is never used in RewardableValidators\nEternalStorage.bytesStorage (RewardableValidators.sol#15) is never used in RewardableValidators\nEternalStorage.intStorage (RewardableValidators.sol#17) is never used in RewardableValidators\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public constant F_ADDR = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialValidators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (nextValidator != F_ADDR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialValidators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (nextValidator != F_ADDR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (next != _validator) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRequiredSignatures(uint256 _requiredSignatures)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (nextValidator == address(0) ) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (next == F_ADDR || next == address(0) ) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function deleteItemFromAddressStorage(string _mapName, address _address) internal {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] _initialValidators,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] _initialRewards,\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/BridgeValidators.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract BaseBridgeValidators is EternalStorage, Ownable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialValidators.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (_initialValidators.length == 1) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if (i == _initialValidators.length - 1) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialValidators.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_validator != address(0) && _validator != F_ADDR);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_initialValidators[i] != address(0) && _initialValidators[i] != F_ADDR);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            counter++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialValidators.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_24"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 60,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        require(newOwner != address(0));\n\n        setOwner(newOwner);\n",
                    "message": "Ownable.transferOwnership (BridgeValidators.sol#57-60) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "    function getBridgeValidatorsInterfacesVersion()\n\n    public\n\n    pure\n\n    returns (uint64 major, uint64 minor, uint64 patch)\n\n    {\n\n        return (2, 2, 0);\n",
                    "message": "BaseBridgeValidators.getBridgeValidatorsInterfacesVersion (BridgeValidators.sol#147-153) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": 172,
                    "vulnerability_code": "    function validatorList() public view returns (address[]) {\n\n        address [] memory list = new address[](validatorCount());\n\n        uint256 counter = 0;\n\n        address nextValidator = getNextValidator(F_ADDR);\n\n        require(nextValidator != address(0));\n\n\n\n        while (nextValidator != F_ADDR) {\n\n            list[counter] = nextValidator;\n\n            nextValidator = getNextValidator(nextValidator);\n\n            counter++;\n\n\n\n            if (nextValidator == address(0) ) {\n\n                revert();\n\n            }\n\n        }\n\n\n\n        return list;\n",
                    "message": "BaseBridgeValidators.validatorList (BridgeValidators.sol#155-172) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": 225,
                    "vulnerability_code": "    function deployedAtBlock() public view returns (uint256) {\n\n        return uintStorage[keccak256(\"deployedAtBlock\")];\n",
                    "message": "BaseBridgeValidators.deployedAtBlock (BridgeValidators.sol#223-225) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": 294,
                    "vulnerability_code": "    function initialize(\n\n        uint256 _requiredSignatures,\n\n        address[] _initialValidators,\n\n        address _owner\n\n    )\n\n        public\n\n        returns (bool)\n\n    {\n\n        require(!isInitialized());\n\n        require(_owner != address(0));\n\n        setOwner(_owner);\n\n        require(_requiredSignatures != 0);\n\n        require(_initialValidators.length >= _requiredSignatures);\n\n\n\n        for (uint256 i = 0; i < _initialValidators.length; i++) {\n\n            require(_initialValidators[i] != address(0) && _initialValidators[i] != F_ADDR);\n\n            require(!isValidator(_initialValidators[i]));\n\n\n\n            if (i == 0) {\n\n                setNextValidator(F_ADDR, _initialValidators[i]);\n\n                if (_initialValidators.length == 1) {\n\n                    setNextValidator(_initialValidators[i], F_ADDR);\n\n                }\n\n            } else if (i == _initialValidators.length - 1) {\n\n                setNextValidator(_initialValidators[i - 1], _initialValidators[i]);\n\n                setNextValidator(_initialValidators[i], F_ADDR);\n\n            } else {\n\n                setNextValidator(_initialValidators[i - 1], _initialValidators[i]);\n\n            }\n\n\n\n            setValidatorCount(validatorCount().add(1));\n\n            emit ValidatorAdded(_initialValidators[i]);\n\n        }\n\n\n\n        uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))] = _requiredSignatures;\n\n        uintStorage[keccak256(\"deployedAtBlock\")] = block.number;\n\n        setInitialize(true);\n\n        emit RequiredSignaturesChanged(_requiredSignatures);\n\n\n\n        return isInitialized();\n",
                    "message": "BridgeValidators.initialize (BridgeValidators.sol#254-294) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRequiredSignatures(uint256 _requiredSignatures)\n",
                    "message": "Parameter '_requiredSignatures' of BaseBridgeValidators.setRequiredSignatures (BridgeValidators.sol#137) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": 183,
                    "vulnerability_code": "    function _addValidator(address _validator) internal {\n\n        require(_validator != address(0) && _validator != F_ADDR);\n\n        require(!isValidator(_validator));\n\n\n\n        address firstValidator = getNextValidator(F_ADDR);\n\n        require(firstValidator != address(0));\n\n        setNextValidator(_validator, firstValidator);\n\n        setNextValidator(F_ADDR, _validator);\n\n        setValidatorCount(validatorCount().add(1));\n",
                    "message": "Function 'BaseBridgeValidators._addValidator' (BridgeValidators.sol#174-183) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addValidator(address _validator) internal {\n",
                    "message": "Parameter '_validator' of BaseBridgeValidators._addValidator (BridgeValidators.sol#174) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": 205,
                    "vulnerability_code": "    function _removeValidator(address _validator) internal {\n\n        require(validatorCount() > requiredSignatures());\n\n        require(isValidator(_validator));\n\n        address validatorsNext = getNextValidator(_validator);\n\n        address index = F_ADDR;\n\n        address next = getNextValidator(index);\n\n        require(next != address(0));\n\n\n\n        while (next != _validator) {\n\n            index = next;\n\n            next = getNextValidator(index);\n\n\n\n            if (next == F_ADDR || next == address(0) ) {\n\n                revert();\n\n            }\n\n        }\n\n\n\n        setNextValidator(index, validatorsNext);\n\n        deleteItemFromAddressStorage(\"validatorsList\", _validator);\n\n        setValidatorCount(validatorCount().sub(1));\n",
                    "message": "Function 'BaseBridgeValidators._removeValidator' (BridgeValidators.sol#185-205) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeValidator(address _validator) internal {\n",
                    "message": "Parameter '_validator' of BaseBridgeValidators._removeValidator (BridgeValidators.sol#185) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns (bool) {\n",
                    "message": "Parameter '_validator' of BaseBridgeValidators.isValidator (BridgeValidators.sol#215) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address) {\n",
                    "message": "Parameter '_address' of BaseBridgeValidators.getNextValidator (BridgeValidators.sol#227) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function deleteItemFromAddressStorage(string _mapName, address _address) internal {\n",
                    "message": "Parameter '_mapName' of BaseBridgeValidators.deleteItemFromAddressStorage (BridgeValidators.sol#231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function deleteItemFromAddressStorage(string _mapName, address _address) internal {\n",
                    "message": "Parameter '_address' of BaseBridgeValidators.deleteItemFromAddressStorage (BridgeValidators.sol#231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setValidatorCount(uint256 _validatorCount) internal {\n",
                    "message": "Parameter '_validatorCount' of BaseBridgeValidators.setValidatorCount (BridgeValidators.sol#235) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setNextValidator(address _prevValidator, address _validator) internal {\n",
                    "message": "Parameter '_prevValidator' of BaseBridgeValidators.setNextValidator (BridgeValidators.sol#239) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setNextValidator(address _prevValidator, address _validator) internal {\n",
                    "message": "Parameter '_validator' of BaseBridgeValidators.setNextValidator (BridgeValidators.sol#239) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setInitialize(bool _status) internal {\n",
                    "message": "Parameter '_status' of BaseBridgeValidators.setInitialize (BridgeValidators.sol#243) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _requiredSignatures,\n",
                    "message": "Parameter '_requiredSignatures' of BridgeValidators.initialize (BridgeValidators.sol#255) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] _initialValidators,\n",
                    "message": "Parameter '_initialValidators' of BridgeValidators.initialize (BridgeValidators.sol#256) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _owner\n",
                    "message": "Parameter '_owner' of BridgeValidators.initialize (BridgeValidators.sol#257) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addValidator(address _validator) external onlyOwner {\n",
                    "message": "Parameter '_validator' of BridgeValidators.addValidator (BridgeValidators.sol#296) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeValidator(address _validator) external onlyOwner {\n",
                    "message": "Parameter '_validator' of BridgeValidators.removeValidator (BridgeValidators.sol#301) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (BridgeValidators.sol#13) is never used in BridgeValidators\nEternalStorage.bytesStorage (BridgeValidators.sol#15) is never used in BridgeValidators\nEternalStorage.intStorage (BridgeValidators.sol#17) is never used in BridgeValidators\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public constant F_ADDR = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialValidators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (nextValidator != F_ADDR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _initialValidators.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (nextValidator != F_ADDR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (next != _validator) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRequiredSignatures(uint256 _requiredSignatures)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (nextValidator == address(0) ) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (next == F_ADDR || next == address(0) ) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function deleteItemFromAddressStorage(string _mapName, address _address) internal {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] _initialValidators,\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/ValidatorsFeeManager.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require((nextValidator != F_ADDR) && (nextValidator != address(0)));\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (diff > 0 && randomValidatorIndex == i) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                feeToDistribute = feeToDistribute.add(diff);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_27"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => address) internal addressStorage;\n",
                    "message": "EternalStorage.addressStorage (ValidatorsFeeManager.sol#14) is never initialized. It is used in:\n\t- rewardableValidatorContract (ValidatorsFeeManager.sol#167-169)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 randomValidatorIndex;\n",
                    "message": "randomValidatorIndex in ValidatorsFeeManager.distributeFeeProportionally (ValidatorsFeeManager.sol#178) is a local variable never initialiazed\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address rewardAddress = validators.getValidatorRewardAddress(nextValidator);\n",
                    "message": "ValidatorsFeeManager.distributeFeeProportionally has external calls inside a loop:\n\t- rewardAddress = validators.getValidatorRewardAddress(nextValidator) (ValidatorsFeeManager.sol#194)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            nextValidator = validators.getNextValidator(nextValidator);\n",
                    "message": "ValidatorsFeeManager.distributeFeeProportionally has external calls inside a loop:\n\t- nextValidator = validators.getNextValidator(nextValidator) (ValidatorsFeeManager.sol#197)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": "IRewardableValidators.isValidator (ValidatorsFeeManager.sol#78) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": "IRewardableValidators.requiredSignatures (ValidatorsFeeManager.sol#79) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": "IRewardableValidators.owner (ValidatorsFeeManager.sol#80) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": "IRewardableValidators.validatorList (ValidatorsFeeManager.sol#81) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns(address);\n",
                    "message": "IRewardableValidators.getValidatorRewardAddress (ValidatorsFeeManager.sol#82) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCount() public view returns (uint256);\n",
                    "message": "IRewardableValidators.validatorCount (ValidatorsFeeManager.sol#83) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address);\n",
                    "message": "IRewardableValidators.getNextValidator (ValidatorsFeeManager.sol#84) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": 117,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n\n        uint256 fee = _feeType == HOME_FEE ? getHomeFee() : getForeignFee();\n\n        uint256 eth = 1 ether;\n\n        if (!_recover) {\n\n            return _value.mul(fee).div(eth);\n\n        }\n\n        return _value.mul(fee).div(eth.sub(fee));\n",
                    "message": "BaseFeeManager.calculateFee (ValidatorsFeeManager.sol#110-117) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getFeeManagerMode() public pure returns(bytes4);\n",
                    "message": "BaseFeeManager.getFeeManagerMode (ValidatorsFeeManager.sol#141) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_value' of BaseFeeManager.calculateFee (ValidatorsFeeManager.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_recover' of BaseFeeManager.calculateFee (ValidatorsFeeManager.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_feeType' of BaseFeeManager.calculateFee (ValidatorsFeeManager.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setHomeFee(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BaseFeeManager.setHomeFee (ValidatorsFeeManager.sol#119) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setForeignFee(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BaseFeeManager.setForeignFee (ValidatorsFeeManager.sol#128) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function random(uint256 _count) public view returns(uint256) {\n",
                    "message": "Parameter '_count' of BaseFeeManager.random (ValidatorsFeeManager.sol#143) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of ValidatorsFeeManager.distributeFeeFromAffirmation (ValidatorsFeeManager.sol#159) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of ValidatorsFeeManager.distributeFeeFromSignatures (ValidatorsFeeManager.sol#163) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeProportionally(uint256 _fee, bytes32 _direction) internal {\n",
                    "message": "Parameter '_fee' of ValidatorsFeeManager.distributeFeeProportionally (ValidatorsFeeManager.sol#171) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeProportionally(uint256 _fee, bytes32 _direction) internal {\n",
                    "message": "Parameter '_direction' of ValidatorsFeeManager.distributeFeeProportionally (ValidatorsFeeManager.sol#171) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onFeeDistribution(address _rewardAddress, uint256 _fee, bytes32 _direction) internal {\n",
                    "message": "Parameter '_rewardAddress' of ValidatorsFeeManager.onFeeDistribution (ValidatorsFeeManager.sol#203) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onFeeDistribution(address _rewardAddress, uint256 _fee, bytes32 _direction) internal {\n",
                    "message": "Parameter '_fee' of ValidatorsFeeManager.onFeeDistribution (ValidatorsFeeManager.sol#203) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onFeeDistribution(address _rewardAddress, uint256 _fee, bytes32 _direction) internal {\n",
                    "message": "Parameter '_direction' of ValidatorsFeeManager.onFeeDistribution (ValidatorsFeeManager.sol#203) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (ValidatorsFeeManager.sol#13) is never used in ValidatorsFeeManager\nEternalStorage.bytesStorage (ValidatorsFeeManager.sol#15) is never used in ValidatorsFeeManager\nEternalStorage.boolStorage (ValidatorsFeeManager.sol#16) is never used in ValidatorsFeeManager\nEternalStorage.intStorage (ValidatorsFeeManager.sol#17) is never used in ValidatorsFeeManager\nFeeTypes.FOREIGN_FEE (ValidatorsFeeManager.sol#94) is never used in ValidatorsFeeManager\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address F_ADDR = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (nextValidator != F_ADDR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns(address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCount() public view returns (uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address);\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/BaseBridgeValidators.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract BaseBridgeValidators is EternalStorage, Ownable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_validator != address(0) && _validator != F_ADDR);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            counter++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_19"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 60,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        require(newOwner != address(0));\n\n        setOwner(newOwner);\n",
                    "message": "Ownable.transferOwnership (BaseBridgeValidators.sol#57-60) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "    function getBridgeValidatorsInterfacesVersion()\n\n    public\n\n    pure\n\n    returns (uint64 major, uint64 minor, uint64 patch)\n\n    {\n\n        return (2, 2, 0);\n",
                    "message": "BaseBridgeValidators.getBridgeValidatorsInterfacesVersion (BaseBridgeValidators.sol#147-153) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": 172,
                    "vulnerability_code": "    function validatorList() public view returns (address[]) {\n\n        address [] memory list = new address[](validatorCount());\n\n        uint256 counter = 0;\n\n        address nextValidator = getNextValidator(F_ADDR);\n\n        require(nextValidator != address(0));\n\n\n\n        while (nextValidator != F_ADDR) {\n\n            list[counter] = nextValidator;\n\n            nextValidator = getNextValidator(nextValidator);\n\n            counter++;\n\n\n\n            if (nextValidator == address(0) ) {\n\n                revert();\n\n            }\n\n        }\n\n\n\n        return list;\n",
                    "message": "BaseBridgeValidators.validatorList (BaseBridgeValidators.sol#155-172) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": 221,
                    "vulnerability_code": "    function isInitialized() public view returns (bool) {\n\n        return boolStorage[keccak256(abi.encodePacked(\"isInitialized\"))];\n",
                    "message": "BaseBridgeValidators.isInitialized (BaseBridgeValidators.sol#219-221) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": 225,
                    "vulnerability_code": "    function deployedAtBlock() public view returns (uint256) {\n\n        return uintStorage[keccak256(\"deployedAtBlock\")];\n",
                    "message": "BaseBridgeValidators.deployedAtBlock (BaseBridgeValidators.sol#223-225) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRequiredSignatures(uint256 _requiredSignatures)\n",
                    "message": "Parameter '_requiredSignatures' of BaseBridgeValidators.setRequiredSignatures (BaseBridgeValidators.sol#137) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": 183,
                    "vulnerability_code": "    function _addValidator(address _validator) internal {\n\n        require(_validator != address(0) && _validator != F_ADDR);\n\n        require(!isValidator(_validator));\n\n\n\n        address firstValidator = getNextValidator(F_ADDR);\n\n        require(firstValidator != address(0));\n\n        setNextValidator(_validator, firstValidator);\n\n        setNextValidator(F_ADDR, _validator);\n\n        setValidatorCount(validatorCount().add(1));\n",
                    "message": "Function 'BaseBridgeValidators._addValidator' (BaseBridgeValidators.sol#174-183) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addValidator(address _validator) internal {\n",
                    "message": "Parameter '_validator' of BaseBridgeValidators._addValidator (BaseBridgeValidators.sol#174) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": 205,
                    "vulnerability_code": "    function _removeValidator(address _validator) internal {\n\n        require(validatorCount() > requiredSignatures());\n\n        require(isValidator(_validator));\n\n        address validatorsNext = getNextValidator(_validator);\n\n        address index = F_ADDR;\n\n        address next = getNextValidator(index);\n\n        require(next != address(0));\n\n\n\n        while (next != _validator) {\n\n            index = next;\n\n            next = getNextValidator(index);\n\n\n\n            if (next == F_ADDR || next == address(0) ) {\n\n                revert();\n\n            }\n\n        }\n\n\n\n        setNextValidator(index, validatorsNext);\n\n        deleteItemFromAddressStorage(\"validatorsList\", _validator);\n\n        setValidatorCount(validatorCount().sub(1));\n",
                    "message": "Function 'BaseBridgeValidators._removeValidator' (BaseBridgeValidators.sol#185-205) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeValidator(address _validator) internal {\n",
                    "message": "Parameter '_validator' of BaseBridgeValidators._removeValidator (BaseBridgeValidators.sol#185) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns (bool) {\n",
                    "message": "Parameter '_validator' of BaseBridgeValidators.isValidator (BaseBridgeValidators.sol#215) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address) {\n",
                    "message": "Parameter '_address' of BaseBridgeValidators.getNextValidator (BaseBridgeValidators.sol#227) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function deleteItemFromAddressStorage(string _mapName, address _address) internal {\n",
                    "message": "Parameter '_mapName' of BaseBridgeValidators.deleteItemFromAddressStorage (BaseBridgeValidators.sol#231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function deleteItemFromAddressStorage(string _mapName, address _address) internal {\n",
                    "message": "Parameter '_address' of BaseBridgeValidators.deleteItemFromAddressStorage (BaseBridgeValidators.sol#231) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setValidatorCount(uint256 _validatorCount) internal {\n",
                    "message": "Parameter '_validatorCount' of BaseBridgeValidators.setValidatorCount (BaseBridgeValidators.sol#235) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setNextValidator(address _prevValidator, address _validator) internal {\n",
                    "message": "Parameter '_prevValidator' of BaseBridgeValidators.setNextValidator (BaseBridgeValidators.sol#239) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setNextValidator(address _prevValidator, address _validator) internal {\n",
                    "message": "Parameter '_validator' of BaseBridgeValidators.setNextValidator (BaseBridgeValidators.sol#239) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setInitialize(bool _status) internal {\n",
                    "message": "Parameter '_status' of BaseBridgeValidators.setInitialize (BaseBridgeValidators.sol#243) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (BaseBridgeValidators.sol#13) is never used in BaseBridgeValidators\nEternalStorage.bytesStorage (BaseBridgeValidators.sol#15) is never used in BaseBridgeValidators\nEternalStorage.intStorage (BaseBridgeValidators.sol#17) is never used in BaseBridgeValidators\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public constant F_ADDR = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (nextValidator != F_ADDR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (nextValidator != F_ADDR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (next != _validator) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRequiredSignatures(uint256 _requiredSignatures)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (nextValidator == address(0) ) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (next == F_ADDR || next == address(0) ) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function deleteItemFromAddressStorage(string _mapName, address _address) internal {\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/Validatable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => address) internal addressStorage;\n",
                    "message": "EternalStorage.addressStorage (Validatable.sol#25) is never initialized. It is used in:\n\t- validatorContract (Validatable.sol#38-40)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": "IBridgeValidators.isValidator (Validatable.sol#7) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": "IBridgeValidators.requiredSignatures (Validatable.sol#8) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": "IBridgeValidators.owner (Validatable.sol#9) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 49,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256) {\n\n        return validatorContract().requiredSignatures();\n",
                    "message": "Validatable.requiredSignatures (Validatable.sol#47-49) should be declared external\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => uint256) internal uintStorage;\n",
                    "message": "EternalStorage.uintStorage (Validatable.sol#23) is never used in Validatable\nEternalStorage.stringStorage (Validatable.sol#24) is never used in Validatable\nEternalStorage.bytesStorage (Validatable.sol#26) is never used in Validatable\nEternalStorage.boolStorage (Validatable.sol#27) is never used in Validatable\nEternalStorage.intStorage (Validatable.sol#28) is never used in Validatable\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/OverdrawManagement.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0) && value > 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_10"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function proxyOwner() public view returns (address);\n",
                    "message": "IOwnedUpgradeabilityProxy.proxyOwner (OverdrawManagement.sol#78) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function fixedAssets(bytes32 _txHash) public view returns(bool) {\n",
                    "message": "Parameter '_txHash' of OverdrawManagement.fixedAssets (OverdrawManagement.sol#126) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setOutOfLimitAmount(uint256 _value) internal {\n",
                    "message": "Parameter '_value' of OverdrawManagement.setOutOfLimitAmount (OverdrawManagement.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function txAboveLimits(bytes32 _txHash) internal view returns(address recipient, uint256 value) {\n",
                    "message": "Parameter '_txHash' of OverdrawManagement.txAboveLimits (OverdrawManagement.sol#134) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setTxAboveLimits(address _recipient, uint256 _value, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_recipient' of OverdrawManagement.setTxAboveLimits (OverdrawManagement.sol#139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setTxAboveLimits(address _recipient, uint256 _value, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_value' of OverdrawManagement.setTxAboveLimits (OverdrawManagement.sol#139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setTxAboveLimits(address _recipient, uint256 _value, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_txHash' of OverdrawManagement.setTxAboveLimits (OverdrawManagement.sol#139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setFixedAssets(bytes32 _txHash, bool _status) internal {\n",
                    "message": "Parameter '_txHash' of OverdrawManagement.setFixedAssets (OverdrawManagement.sol#144) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setFixedAssets(bytes32 _txHash, bool _status) internal {\n",
                    "message": "Parameter '_status' of OverdrawManagement.setFixedAssets (OverdrawManagement.sol#144) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (OverdrawManagement.sol#13) is never used in OverdrawManagement\nEternalStorage.bytesStorage (OverdrawManagement.sol#15) is never used in OverdrawManagement\nEternalStorage.intStorage (OverdrawManagement.sol#17) is never used in OverdrawManagement\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function txAboveLimits(bytes32 _txHash) internal view returns(address recipient, uint256 value) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function proxyOwner() public view returns (address);\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/RewardableBridge.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RewardableBridge is Ownable, FeeTypes {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_31"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 105,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        address feeManager = feeManagerContract();\n\n        string memory method = _feeType == HOME_FEE ? \"getHomeFee()\" : \"getForeignFee()\";\n\n        bytes memory callData = abi.encodeWithSignature(method);\n\n\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge._getFee (RewardableBridge.sol#91-105) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n\n        bytes4 mode;\n\n        bytes memory callData = abi.encodeWithSignature(\"getFeeManagerMode()\");\n\n        address feeManager = feeManagerContract();\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 4)\n\n            mode := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return mode;\n",
                    "message": "RewardableBridge.getFeeManagerMode (RewardableBridge.sol#107-119) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": 140,
                    "vulnerability_code": "    function isContract(address _addr) internal view returns (bool)\n\n    {\n\n        uint length;\n\n        assembly { length := extcodesize(_addr) }\n\n        return length > 0;\n",
                    "message": "RewardableBridge.isContract (RewardableBridge.sol#135-140) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        bytes memory callData = abi.encodeWithSignature(\"calculateFee(uint256,bool,bytes32)\", _value, _recover, _feeType);\n\n        assembly {\n\n            let result := callcode(gas, _impl, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge.calculateFee (RewardableBridge.sol#142-153) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 105,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        address feeManager = feeManagerContract();\n\n        string memory method = _feeType == HOME_FEE ? \"getHomeFee()\" : \"getForeignFee()\";\n\n        bytes memory callData = abi.encodeWithSignature(method);\n\n\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge._getFee uses assembly (RewardableBridge.sol#91-105)\n\t- RewardableBridge.sol#97-104\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n\n        bytes4 mode;\n\n        bytes memory callData = abi.encodeWithSignature(\"getFeeManagerMode()\");\n\n        address feeManager = feeManagerContract();\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 4)\n\n            mode := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return mode;\n",
                    "message": "RewardableBridge.getFeeManagerMode uses assembly (RewardableBridge.sol#107-119)\n\t- RewardableBridge.sol#111-118\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": 140,
                    "vulnerability_code": "    function isContract(address _addr) internal view returns (bool)\n\n    {\n\n        uint length;\n\n        assembly { length := extcodesize(_addr) }\n\n        return length > 0;\n",
                    "message": "RewardableBridge.isContract uses assembly (RewardableBridge.sol#135-140)\n\t- RewardableBridge.sol#138-139\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        bytes memory callData = abi.encodeWithSignature(\"calculateFee(uint256,bool,bytes32)\", _value, _recover, _feeType);\n\n        assembly {\n\n            let result := callcode(gas, _impl, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge.calculateFee uses assembly (RewardableBridge.sol#142-153)\n\t- RewardableBridge.sol#145-152\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 60,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        require(newOwner != address(0));\n\n        setOwner(newOwner);\n",
                    "message": "Ownable.transferOwnership (RewardableBridge.sol#57-60) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n\n        bytes4 mode;\n\n        bytes memory callData = abi.encodeWithSignature(\"getFeeManagerMode()\");\n\n        address feeManager = feeManagerContract();\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 4)\n\n            mode := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return mode;\n",
                    "message": "RewardableBridge.getFeeManagerMode (RewardableBridge.sol#107-119) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": 128,
                    "vulnerability_code": "    function setFeeManagerContract(address _feeManager) public onlyOwner {\n\n        require(_feeManager == address(0) || isContract(_feeManager));\n\n        addressStorage[keccak256(abi.encodePacked(\"feeManagerContract\"))] = _feeManager;\n",
                    "message": "RewardableBridge.setFeeManagerContract (RewardableBridge.sol#125-128) should be declared external\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n\n        string memory method = _feeType == HOME_FEE ? \"setHomeFee(uint256)\" : \"setForeignFee(uint256)\";\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(method, _fee)));\n",
                    "message": "Low level call in RewardableBridge._setFee (RewardableBridge.sol#130-133):\n\t-require(bool)(_feeManager.delegatecall(abi.encodeWithSignature(method,_fee))) RewardableBridge.sol#132\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": 158,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(\"distributeFeeFromSignatures(uint256)\", _fee)));\n\n        emit FeeDistributedFromSignatures(_fee, _txHash);\n",
                    "message": "Low level call in RewardableBridge.distributeFeeFromSignatures (RewardableBridge.sol#155-158):\n\t-require(bool)(_feeManager.delegatecall(abi.encodeWithSignature(distributeFeeFromSignatures(uint256),_fee))) RewardableBridge.sol#156\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(\"distributeFeeFromAffirmation(uint256)\", _fee)));\n\n        emit FeeDistributedFromAffirmation(_fee, _txHash);\n",
                    "message": "Low level call in RewardableBridge.distributeFeeFromAffirmation (RewardableBridge.sol#160-163):\n\t-require(bool)(_feeManager.delegatecall(abi.encodeWithSignature(distributeFeeFromAffirmation(uint256),_fee))) RewardableBridge.sol#161\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 105,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        address feeManager = feeManagerContract();\n\n        string memory method = _feeType == HOME_FEE ? \"getHomeFee()\" : \"getForeignFee()\";\n\n        bytes memory callData = abi.encodeWithSignature(method);\n\n\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "Function 'RewardableBridge._getFee' (RewardableBridge.sol#91-105) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_feeType' of RewardableBridge._getFee (RewardableBridge.sol#91) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setFeeManagerContract(address _feeManager) public onlyOwner {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge.setFeeManagerContract (RewardableBridge.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n\n        string memory method = _feeType == HOME_FEE ? \"setHomeFee(uint256)\" : \"setForeignFee(uint256)\";\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(method, _fee)));\n",
                    "message": "Function 'RewardableBridge._setFee' (RewardableBridge.sol#130-133) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge._setFee (RewardableBridge.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n",
                    "message": "Parameter '_fee' of RewardableBridge._setFee (RewardableBridge.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n",
                    "message": "Parameter '_feeType' of RewardableBridge._setFee (RewardableBridge.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_value' of RewardableBridge.calculateFee (RewardableBridge.sol#142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_recover' of RewardableBridge.calculateFee (RewardableBridge.sol#142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_feeType' of RewardableBridge.calculateFee (RewardableBridge.sol#142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_fee' of RewardableBridge.distributeFeeFromSignatures (RewardableBridge.sol#155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge.distributeFeeFromSignatures (RewardableBridge.sol#155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_txHash' of RewardableBridge.distributeFeeFromSignatures (RewardableBridge.sol#155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_fee' of RewardableBridge.distributeFeeFromAffirmation (RewardableBridge.sol#160) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge.distributeFeeFromAffirmation (RewardableBridge.sol#160) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_txHash' of RewardableBridge.distributeFeeFromAffirmation (RewardableBridge.sol#160) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => uint256) internal uintStorage;\n",
                    "message": "EternalStorage.uintStorage (RewardableBridge.sol#12) is never used in RewardableBridge\nEternalStorage.stringStorage (RewardableBridge.sol#13) is never used in RewardableBridge\nEternalStorage.bytesStorage (RewardableBridge.sol#15) is never used in RewardableBridge\nEternalStorage.boolStorage (RewardableBridge.sol#16) is never used in RewardableBridge\nEternalStorage.intStorage (RewardableBridge.sol#17) is never used in RewardableBridge\nFeeTypes.FOREIGN_FEE (RewardableBridge.sol#78) is never used in RewardableBridge\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setFeeManagerContract(address _feeManager) public onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address _addr) internal view returns (bool)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/OwnedUpgradeability.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function proxyOwner() public view returns (address);\n",
                    "message": "IOwnedUpgradeabilityProxy.proxyOwner (OwnedUpgradeability.sol#7) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function proxyOwner() public view returns (address);\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/BaseFeeManager.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_17"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": "IRewardableValidators.isValidator (BaseFeeManager.sol#78) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": "IRewardableValidators.requiredSignatures (BaseFeeManager.sol#79) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": "IRewardableValidators.owner (BaseFeeManager.sol#80) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": "IRewardableValidators.validatorList (BaseFeeManager.sol#81) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns(address);\n",
                    "message": "IRewardableValidators.getValidatorRewardAddress (BaseFeeManager.sol#82) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCount() public view returns (uint256);\n",
                    "message": "IRewardableValidators.validatorCount (BaseFeeManager.sol#83) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address);\n",
                    "message": "IRewardableValidators.getNextValidator (BaseFeeManager.sol#84) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": 117,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n\n        uint256 fee = _feeType == HOME_FEE ? getHomeFee() : getForeignFee();\n\n        uint256 eth = 1 ether;\n\n        if (!_recover) {\n\n            return _value.mul(fee).div(eth);\n\n        }\n\n        return _value.mul(fee).div(eth.sub(fee));\n",
                    "message": "BaseFeeManager.calculateFee (BaseFeeManager.sol#110-117) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getFeeManagerMode() public pure returns(bytes4);\n",
                    "message": "BaseFeeManager.getFeeManagerMode (BaseFeeManager.sol#141) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function random(uint256 _count) public view returns(uint256) {\n\n        return uint256(blockhash(block.number.sub(1))) % _count;\n",
                    "message": "BaseFeeManager.random (BaseFeeManager.sol#143-145) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_value' of BaseFeeManager.calculateFee (BaseFeeManager.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_recover' of BaseFeeManager.calculateFee (BaseFeeManager.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_feeType' of BaseFeeManager.calculateFee (BaseFeeManager.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setHomeFee(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BaseFeeManager.setHomeFee (BaseFeeManager.sol#119) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setForeignFee(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BaseFeeManager.setForeignFee (BaseFeeManager.sol#128) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function random(uint256 _count) public view returns(uint256) {\n",
                    "message": "Parameter '_count' of BaseFeeManager.random (BaseFeeManager.sol#143) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (BaseFeeManager.sol#13) is never used in BaseFeeManager\nEternalStorage.addressStorage (BaseFeeManager.sol#14) is never used in BaseFeeManager\nEternalStorage.bytesStorage (BaseFeeManager.sol#15) is never used in BaseFeeManager\nEternalStorage.boolStorage (BaseFeeManager.sol#16) is never used in BaseFeeManager\nEternalStorage.intStorage (BaseFeeManager.sol#17) is never used in BaseFeeManager\nFeeTypes.FOREIGN_FEE (BaseFeeManager.sol#94) is never used in BaseFeeManager\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns(address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCount() public view returns (uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address);\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/FeeTypes.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/native_to_erc20/RewardableHomeBridgeNativeToErc.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RewardableBridge is Ownable, FeeTypes {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_35"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 105,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        address feeManager = feeManagerContract();\n\n        string memory method = _feeType == HOME_FEE ? \"getHomeFee()\" : \"getForeignFee()\";\n\n        bytes memory callData = abi.encodeWithSignature(method);\n\n\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge._getFee (RewardableHomeBridgeNativeToErc.sol#91-105) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n\n        bytes4 mode;\n\n        bytes memory callData = abi.encodeWithSignature(\"getFeeManagerMode()\");\n\n        address feeManager = feeManagerContract();\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 4)\n\n            mode := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return mode;\n",
                    "message": "RewardableBridge.getFeeManagerMode (RewardableHomeBridgeNativeToErc.sol#107-119) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": 140,
                    "vulnerability_code": "    function isContract(address _addr) internal view returns (bool)\n\n    {\n\n        uint length;\n\n        assembly { length := extcodesize(_addr) }\n\n        return length > 0;\n",
                    "message": "RewardableBridge.isContract (RewardableHomeBridgeNativeToErc.sol#135-140) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        bytes memory callData = abi.encodeWithSignature(\"calculateFee(uint256,bool,bytes32)\", _value, _recover, _feeType);\n\n        assembly {\n\n            let result := callcode(gas, _impl, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge.calculateFee (RewardableHomeBridgeNativeToErc.sol#142-153) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 105,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        address feeManager = feeManagerContract();\n\n        string memory method = _feeType == HOME_FEE ? \"getHomeFee()\" : \"getForeignFee()\";\n\n        bytes memory callData = abi.encodeWithSignature(method);\n\n\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge._getFee uses assembly (RewardableHomeBridgeNativeToErc.sol#91-105)\n\t- RewardableHomeBridgeNativeToErc.sol#97-104\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n\n        bytes4 mode;\n\n        bytes memory callData = abi.encodeWithSignature(\"getFeeManagerMode()\");\n\n        address feeManager = feeManagerContract();\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 4)\n\n            mode := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return mode;\n",
                    "message": "RewardableBridge.getFeeManagerMode uses assembly (RewardableHomeBridgeNativeToErc.sol#107-119)\n\t- RewardableHomeBridgeNativeToErc.sol#111-118\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": 140,
                    "vulnerability_code": "    function isContract(address _addr) internal view returns (bool)\n\n    {\n\n        uint length;\n\n        assembly { length := extcodesize(_addr) }\n\n        return length > 0;\n",
                    "message": "RewardableBridge.isContract uses assembly (RewardableHomeBridgeNativeToErc.sol#135-140)\n\t- RewardableHomeBridgeNativeToErc.sol#138-139\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        bytes memory callData = abi.encodeWithSignature(\"calculateFee(uint256,bool,bytes32)\", _value, _recover, _feeType);\n\n        assembly {\n\n            let result := callcode(gas, _impl, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge.calculateFee uses assembly (RewardableHomeBridgeNativeToErc.sol#142-153)\n\t- RewardableHomeBridgeNativeToErc.sol#145-152\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 60,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        require(newOwner != address(0));\n\n        setOwner(newOwner);\n",
                    "message": "Ownable.transferOwnership (RewardableHomeBridgeNativeToErc.sol#57-60) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n\n        bytes4 mode;\n\n        bytes memory callData = abi.encodeWithSignature(\"getFeeManagerMode()\");\n\n        address feeManager = feeManagerContract();\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 4)\n\n            mode := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return mode;\n",
                    "message": "RewardableBridge.getFeeManagerMode (RewardableHomeBridgeNativeToErc.sol#107-119) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": 128,
                    "vulnerability_code": "    function setFeeManagerContract(address _feeManager) public onlyOwner {\n\n        require(_feeManager == address(0) || isContract(_feeManager));\n\n        addressStorage[keccak256(abi.encodePacked(\"feeManagerContract\"))] = _feeManager;\n",
                    "message": "RewardableBridge.setFeeManagerContract (RewardableHomeBridgeNativeToErc.sol#125-128) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": 182,
                    "vulnerability_code": "    function getForeignFee() public view returns(uint256) {\n\n        return _getFee(FOREIGN_FEE);\n",
                    "message": "RewardableHomeBridgeNativeToErc.getForeignFee (RewardableHomeBridgeNativeToErc.sol#180-182) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": 186,
                    "vulnerability_code": "    function getHomeFee() public view returns(uint256) {\n\n        return _getFee(HOME_FEE);\n",
                    "message": "RewardableHomeBridgeNativeToErc.getHomeFee (RewardableHomeBridgeNativeToErc.sol#184-186) should be declared external\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n\n        string memory method = _feeType == HOME_FEE ? \"setHomeFee(uint256)\" : \"setForeignFee(uint256)\";\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(method, _fee)));\n",
                    "message": "Low level call in RewardableBridge._setFee (RewardableHomeBridgeNativeToErc.sol#130-133):\n\t-require(bool)(_feeManager.delegatecall(abi.encodeWithSignature(method,_fee))) RewardableHomeBridgeNativeToErc.sol#132\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": 158,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(\"distributeFeeFromSignatures(uint256)\", _fee)));\n\n        emit FeeDistributedFromSignatures(_fee, _txHash);\n",
                    "message": "Low level call in RewardableBridge.distributeFeeFromSignatures (RewardableHomeBridgeNativeToErc.sol#155-158):\n\t-require(bool)(_feeManager.delegatecall(abi.encodeWithSignature(distributeFeeFromSignatures(uint256),_fee))) RewardableHomeBridgeNativeToErc.sol#156\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(\"distributeFeeFromAffirmation(uint256)\", _fee)));\n\n        emit FeeDistributedFromAffirmation(_fee, _txHash);\n",
                    "message": "Low level call in RewardableBridge.distributeFeeFromAffirmation (RewardableHomeBridgeNativeToErc.sol#160-163):\n\t-require(bool)(_feeManager.delegatecall(abi.encodeWithSignature(distributeFeeFromAffirmation(uint256),_fee))) RewardableHomeBridgeNativeToErc.sol#161\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 105,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        address feeManager = feeManagerContract();\n\n        string memory method = _feeType == HOME_FEE ? \"getHomeFee()\" : \"getForeignFee()\";\n\n        bytes memory callData = abi.encodeWithSignature(method);\n\n\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "Function 'RewardableBridge._getFee' (RewardableHomeBridgeNativeToErc.sol#91-105) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_feeType' of RewardableBridge._getFee (RewardableHomeBridgeNativeToErc.sol#91) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setFeeManagerContract(address _feeManager) public onlyOwner {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge.setFeeManagerContract (RewardableHomeBridgeNativeToErc.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n\n        string memory method = _feeType == HOME_FEE ? \"setHomeFee(uint256)\" : \"setForeignFee(uint256)\";\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(method, _fee)));\n",
                    "message": "Function 'RewardableBridge._setFee' (RewardableHomeBridgeNativeToErc.sol#130-133) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge._setFee (RewardableHomeBridgeNativeToErc.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n",
                    "message": "Parameter '_fee' of RewardableBridge._setFee (RewardableHomeBridgeNativeToErc.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n",
                    "message": "Parameter '_feeType' of RewardableBridge._setFee (RewardableHomeBridgeNativeToErc.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_value' of RewardableBridge.calculateFee (RewardableHomeBridgeNativeToErc.sol#142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_recover' of RewardableBridge.calculateFee (RewardableHomeBridgeNativeToErc.sol#142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_feeType' of RewardableBridge.calculateFee (RewardableHomeBridgeNativeToErc.sol#142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_fee' of RewardableBridge.distributeFeeFromSignatures (RewardableHomeBridgeNativeToErc.sol#155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge.distributeFeeFromSignatures (RewardableHomeBridgeNativeToErc.sol#155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_txHash' of RewardableBridge.distributeFeeFromSignatures (RewardableHomeBridgeNativeToErc.sol#155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_fee' of RewardableBridge.distributeFeeFromAffirmation (RewardableHomeBridgeNativeToErc.sol#160) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge.distributeFeeFromAffirmation (RewardableHomeBridgeNativeToErc.sol#160) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_txHash' of RewardableBridge.distributeFeeFromAffirmation (RewardableHomeBridgeNativeToErc.sol#160) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setForeignFee(uint256 _fee) external onlyOwner {\n",
                    "message": "Parameter '_fee' of RewardableHomeBridgeNativeToErc.setForeignFee (RewardableHomeBridgeNativeToErc.sol#172) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setHomeFee(uint256 _fee) external onlyOwner {\n",
                    "message": "Parameter '_fee' of RewardableHomeBridgeNativeToErc.setHomeFee (RewardableHomeBridgeNativeToErc.sol#176) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => uint256) internal uintStorage;\n",
                    "message": "EternalStorage.uintStorage (RewardableHomeBridgeNativeToErc.sol#12) is never used in RewardableHomeBridgeNativeToErc\nEternalStorage.stringStorage (RewardableHomeBridgeNativeToErc.sol#13) is never used in RewardableHomeBridgeNativeToErc\nEternalStorage.bytesStorage (RewardableHomeBridgeNativeToErc.sol#15) is never used in RewardableHomeBridgeNativeToErc\nEternalStorage.boolStorage (RewardableHomeBridgeNativeToErc.sol#16) is never used in RewardableHomeBridgeNativeToErc\nEternalStorage.intStorage (RewardableHomeBridgeNativeToErc.sol#17) is never used in RewardableHomeBridgeNativeToErc\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setFeeManagerContract(address _feeManager) public onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setForeignFee(uint256 _fee) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setHomeFee(uint256 _fee) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address _addr) internal view returns (bool)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/native_to_erc20/FeeManagerNativeToErcBothDirections.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require((nextValidator != F_ADDR) && (nextValidator != address(0)));\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (diff > 0 && randomValidatorIndex == i) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                feeToDistribute = feeToDistribute.add(diff);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_34"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => address) internal addressStorage;\n",
                    "message": "EternalStorage.addressStorage (FeeManagerNativeToErcBothDirections.sol#25) is never initialized. It is used in:\n\t- rewardableValidatorContract (FeeManagerNativeToErcBothDirections.sol#178-180)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 randomValidatorIndex;\n",
                    "message": "randomValidatorIndex in ValidatorsFeeManager.distributeFeeProportionally (FeeManagerNativeToErcBothDirections.sol#189) is a local variable never initialiazed\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": "IRewardableValidators.isValidator (FeeManagerNativeToErcBothDirections.sol#89) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": "IRewardableValidators.requiredSignatures (FeeManagerNativeToErcBothDirections.sol#90) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": "IRewardableValidators.owner (FeeManagerNativeToErcBothDirections.sol#91) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": "IRewardableValidators.validatorList (FeeManagerNativeToErcBothDirections.sol#92) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns(address);\n",
                    "message": "IRewardableValidators.getValidatorRewardAddress (FeeManagerNativeToErcBothDirections.sol#93) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCount() public view returns (uint256);\n",
                    "message": "IRewardableValidators.validatorCount (FeeManagerNativeToErcBothDirections.sol#94) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address);\n",
                    "message": "IRewardableValidators.getNextValidator (FeeManagerNativeToErcBothDirections.sol#95) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": 128,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n\n        uint256 fee = _feeType == HOME_FEE ? getHomeFee() : getForeignFee();\n\n        uint256 eth = 1 ether;\n\n        if (!_recover) {\n\n            return _value.mul(fee).div(eth);\n\n        }\n\n        return _value.mul(fee).div(eth.sub(fee));\n",
                    "message": "BaseFeeManager.calculateFee (FeeManagerNativeToErcBothDirections.sol#121-128) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 234,
                    "vulnerability_to_line": 236,
                    "vulnerability_code": "    function getFeeManagerMode() public pure returns(bytes4) {\n\n        return bytes4(keccak256(abi.encodePacked(\"manages-both-directions\")));\n",
                    "message": "FeeManagerNativeToErcBothDirections.getFeeManagerMode (FeeManagerNativeToErcBothDirections.sol#234-236) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getFeeManagerMode() public pure returns(bytes4);\n",
                    "message": "BaseFeeManager.getFeeManagerMode (FeeManagerNativeToErcBothDirections.sol#152) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _recipient) public payable {\n",
                    "message": "Parameter '_recipient' of Sacrifice. (FeeManagerNativeToErcBothDirections.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_value' of BaseFeeManager.calculateFee (FeeManagerNativeToErcBothDirections.sol#121) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_recover' of BaseFeeManager.calculateFee (FeeManagerNativeToErcBothDirections.sol#121) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_feeType' of BaseFeeManager.calculateFee (FeeManagerNativeToErcBothDirections.sol#121) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setHomeFee(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BaseFeeManager.setHomeFee (FeeManagerNativeToErcBothDirections.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setForeignFee(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BaseFeeManager.setForeignFee (FeeManagerNativeToErcBothDirections.sol#139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function random(uint256 _count) public view returns(uint256) {\n",
                    "message": "Parameter '_count' of BaseFeeManager.random (FeeManagerNativeToErcBothDirections.sol#154) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of ValidatorsFeeManager.distributeFeeFromAffirmation (FeeManagerNativeToErcBothDirections.sol#170) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of ValidatorsFeeManager.distributeFeeFromSignatures (FeeManagerNativeToErcBothDirections.sol#174) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeProportionally(uint256 _fee, bytes32 _direction) internal {\n",
                    "message": "Parameter '_fee' of ValidatorsFeeManager.distributeFeeProportionally (FeeManagerNativeToErcBothDirections.sol#182) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeProportionally(uint256 _fee, bytes32 _direction) internal {\n",
                    "message": "Parameter '_direction' of ValidatorsFeeManager.distributeFeeProportionally (FeeManagerNativeToErcBothDirections.sol#182) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onFeeDistribution(address _rewardAddress, uint256 _fee, bytes32 _direction) internal {\n",
                    "message": "Parameter '_rewardAddress' of ValidatorsFeeManager.onFeeDistribution (FeeManagerNativeToErcBothDirections.sol#214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onFeeDistribution(address _rewardAddress, uint256 _fee, bytes32 _direction) internal {\n",
                    "message": "Parameter '_fee' of ValidatorsFeeManager.onFeeDistribution (FeeManagerNativeToErcBothDirections.sol#214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onFeeDistribution(address _rewardAddress, uint256 _fee, bytes32 _direction) internal {\n",
                    "message": "Parameter '_direction' of ValidatorsFeeManager.onFeeDistribution (FeeManagerNativeToErcBothDirections.sol#214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onAffirmationFeeDistribution(address _rewardAddress, uint256 _fee) internal {\n",
                    "message": "Parameter '_rewardAddress' of FeeManagerNativeToErcBothDirections.onAffirmationFeeDistribution (FeeManagerNativeToErcBothDirections.sol#238) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onAffirmationFeeDistribution(address _rewardAddress, uint256 _fee) internal {\n",
                    "message": "Parameter '_fee' of FeeManagerNativeToErcBothDirections.onAffirmationFeeDistribution (FeeManagerNativeToErcBothDirections.sol#238) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onSignatureFeeDistribution(address _rewardAddress, uint256 _fee) internal {\n",
                    "message": "Parameter '_rewardAddress' of FeeManagerNativeToErcBothDirections.onSignatureFeeDistribution (FeeManagerNativeToErcBothDirections.sol#242) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onSignatureFeeDistribution(address _rewardAddress, uint256 _fee) internal {\n",
                    "message": "Parameter '_fee' of FeeManagerNativeToErcBothDirections.onSignatureFeeDistribution (FeeManagerNativeToErcBothDirections.sol#242) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": 250,
                    "vulnerability_code": "    function _sendReward(address _rewardAddress, uint256 _fee) internal {\n\n        if (!_rewardAddress.send(_fee)) {\n\n            (new Sacrifice).value(_fee)(_rewardAddress);\n\n        }\n",
                    "message": "Function 'FeeManagerNativeToErcBothDirections._sendReward' (FeeManagerNativeToErcBothDirections.sol#246-250) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _sendReward(address _rewardAddress, uint256 _fee) internal {\n",
                    "message": "Parameter '_rewardAddress' of FeeManagerNativeToErcBothDirections._sendReward (FeeManagerNativeToErcBothDirections.sol#246) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _sendReward(address _rewardAddress, uint256 _fee) internal {\n",
                    "message": "Parameter '_fee' of FeeManagerNativeToErcBothDirections._sendReward (FeeManagerNativeToErcBothDirections.sol#246) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (FeeManagerNativeToErcBothDirections.sol#24) is never used in FeeManagerNativeToErcBothDirections\nEternalStorage.bytesStorage (FeeManagerNativeToErcBothDirections.sol#26) is never used in FeeManagerNativeToErcBothDirections\nEternalStorage.boolStorage (FeeManagerNativeToErcBothDirections.sol#27) is never used in FeeManagerNativeToErcBothDirections\nEternalStorage.intStorage (FeeManagerNativeToErcBothDirections.sol#28) is never used in FeeManagerNativeToErcBothDirections\nFeeTypes.FOREIGN_FEE (FeeManagerNativeToErcBothDirections.sol#105) is never used in FeeManagerNativeToErcBothDirections\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address F_ADDR = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (nextValidator != F_ADDR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _sendReward(_rewardAddress, _fee);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _sendReward(_rewardAddress, _fee);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns(address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCount() public view returns (uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address);\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/native_to_erc20/FeeManagerNativeToErc.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (string memory name_, string memory symbol_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _name = name_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _symbol = symbol_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _decimals = 18;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(b <= a, \"SafeMath: subtraction overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(b > 0, \"SafeMath: division by zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(b > 0, \"SafeMath: modulo by zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: mint to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require((nextValidator != F_ADDR) && (nextValidator != address(0)));\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (diff > 0 && randomValidatorIndex == i) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 855,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                feeToDistribute = feeToDistribute.add(diff);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 856,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(sender != address(0), \"ERC20: transfer from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(account != address(0), \"ERC20: burn from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(owner != address(0), \"ERC20: approve from the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(spender != address(0), \"ERC20: approve to the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address F_ADDR = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _beforeTokenTransfer(address(0), account, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _beforeTokenTransfer(account, address(0), amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (nextValidator != F_ADDR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.6.0 <0.8.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) private _balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) private _allowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _totalSupply;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _name;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string private _symbol;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private _decimals;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 769,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 742,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 743,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 744,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 746,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns(address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 747,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCount() public view returns (uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 748,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address);\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/native_to_erc20/RewardableForeignBridgeNativeToErc.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RewardableBridge is Ownable, FeeTypes {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_33"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 105,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        address feeManager = feeManagerContract();\n\n        string memory method = _feeType == HOME_FEE ? \"getHomeFee()\" : \"getForeignFee()\";\n\n        bytes memory callData = abi.encodeWithSignature(method);\n\n\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge._getFee (RewardableForeignBridgeNativeToErc.sol#91-105) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n\n        bytes4 mode;\n\n        bytes memory callData = abi.encodeWithSignature(\"getFeeManagerMode()\");\n\n        address feeManager = feeManagerContract();\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 4)\n\n            mode := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return mode;\n",
                    "message": "RewardableBridge.getFeeManagerMode (RewardableForeignBridgeNativeToErc.sol#107-119) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": 140,
                    "vulnerability_code": "    function isContract(address _addr) internal view returns (bool)\n\n    {\n\n        uint length;\n\n        assembly { length := extcodesize(_addr) }\n\n        return length > 0;\n",
                    "message": "RewardableBridge.isContract (RewardableForeignBridgeNativeToErc.sol#135-140) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        bytes memory callData = abi.encodeWithSignature(\"calculateFee(uint256,bool,bytes32)\", _value, _recover, _feeType);\n\n        assembly {\n\n            let result := callcode(gas, _impl, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge.calculateFee (RewardableForeignBridgeNativeToErc.sol#142-153) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 105,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        address feeManager = feeManagerContract();\n\n        string memory method = _feeType == HOME_FEE ? \"getHomeFee()\" : \"getForeignFee()\";\n\n        bytes memory callData = abi.encodeWithSignature(method);\n\n\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge._getFee uses assembly (RewardableForeignBridgeNativeToErc.sol#91-105)\n\t- RewardableForeignBridgeNativeToErc.sol#97-104\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n\n        bytes4 mode;\n\n        bytes memory callData = abi.encodeWithSignature(\"getFeeManagerMode()\");\n\n        address feeManager = feeManagerContract();\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 4)\n\n            mode := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return mode;\n",
                    "message": "RewardableBridge.getFeeManagerMode uses assembly (RewardableForeignBridgeNativeToErc.sol#107-119)\n\t- RewardableForeignBridgeNativeToErc.sol#111-118\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": 140,
                    "vulnerability_code": "    function isContract(address _addr) internal view returns (bool)\n\n    {\n\n        uint length;\n\n        assembly { length := extcodesize(_addr) }\n\n        return length > 0;\n",
                    "message": "RewardableBridge.isContract uses assembly (RewardableForeignBridgeNativeToErc.sol#135-140)\n\t- RewardableForeignBridgeNativeToErc.sol#138-139\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        bytes memory callData = abi.encodeWithSignature(\"calculateFee(uint256,bool,bytes32)\", _value, _recover, _feeType);\n\n        assembly {\n\n            let result := callcode(gas, _impl, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge.calculateFee uses assembly (RewardableForeignBridgeNativeToErc.sol#142-153)\n\t- RewardableForeignBridgeNativeToErc.sol#145-152\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 60,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        require(newOwner != address(0));\n\n        setOwner(newOwner);\n",
                    "message": "Ownable.transferOwnership (RewardableForeignBridgeNativeToErc.sol#57-60) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n\n        bytes4 mode;\n\n        bytes memory callData = abi.encodeWithSignature(\"getFeeManagerMode()\");\n\n        address feeManager = feeManagerContract();\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 4)\n\n            mode := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return mode;\n",
                    "message": "RewardableBridge.getFeeManagerMode (RewardableForeignBridgeNativeToErc.sol#107-119) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": 128,
                    "vulnerability_code": "    function setFeeManagerContract(address _feeManager) public onlyOwner {\n\n        require(_feeManager == address(0) || isContract(_feeManager));\n\n        addressStorage[keccak256(abi.encodePacked(\"feeManagerContract\"))] = _feeManager;\n",
                    "message": "RewardableBridge.setFeeManagerContract (RewardableForeignBridgeNativeToErc.sol#125-128) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": 178,
                    "vulnerability_code": "    function getHomeFee() public view returns(uint256) {\n\n        return _getFee(HOME_FEE);\n",
                    "message": "RewardableForeignBridgeNativeToErc.getHomeFee (RewardableForeignBridgeNativeToErc.sol#176-178) should be declared external\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n\n        string memory method = _feeType == HOME_FEE ? \"setHomeFee(uint256)\" : \"setForeignFee(uint256)\";\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(method, _fee)));\n",
                    "message": "Low level call in RewardableBridge._setFee (RewardableForeignBridgeNativeToErc.sol#130-133):\n\t-require(bool)(_feeManager.delegatecall(abi.encodeWithSignature(method,_fee))) RewardableForeignBridgeNativeToErc.sol#132\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": 158,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(\"distributeFeeFromSignatures(uint256)\", _fee)));\n\n        emit FeeDistributedFromSignatures(_fee, _txHash);\n",
                    "message": "Low level call in RewardableBridge.distributeFeeFromSignatures (RewardableForeignBridgeNativeToErc.sol#155-158):\n\t-require(bool)(_feeManager.delegatecall(abi.encodeWithSignature(distributeFeeFromSignatures(uint256),_fee))) RewardableForeignBridgeNativeToErc.sol#156\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(\"distributeFeeFromAffirmation(uint256)\", _fee)));\n\n        emit FeeDistributedFromAffirmation(_fee, _txHash);\n",
                    "message": "Low level call in RewardableBridge.distributeFeeFromAffirmation (RewardableForeignBridgeNativeToErc.sol#160-163):\n\t-require(bool)(_feeManager.delegatecall(abi.encodeWithSignature(distributeFeeFromAffirmation(uint256),_fee))) RewardableForeignBridgeNativeToErc.sol#161\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 105,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        address feeManager = feeManagerContract();\n\n        string memory method = _feeType == HOME_FEE ? \"getHomeFee()\" : \"getForeignFee()\";\n\n        bytes memory callData = abi.encodeWithSignature(method);\n\n\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "Function 'RewardableBridge._getFee' (RewardableForeignBridgeNativeToErc.sol#91-105) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_feeType' of RewardableBridge._getFee (RewardableForeignBridgeNativeToErc.sol#91) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setFeeManagerContract(address _feeManager) public onlyOwner {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge.setFeeManagerContract (RewardableForeignBridgeNativeToErc.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n\n        string memory method = _feeType == HOME_FEE ? \"setHomeFee(uint256)\" : \"setForeignFee(uint256)\";\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(method, _fee)));\n",
                    "message": "Function 'RewardableBridge._setFee' (RewardableForeignBridgeNativeToErc.sol#130-133) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge._setFee (RewardableForeignBridgeNativeToErc.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n",
                    "message": "Parameter '_fee' of RewardableBridge._setFee (RewardableForeignBridgeNativeToErc.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n",
                    "message": "Parameter '_feeType' of RewardableBridge._setFee (RewardableForeignBridgeNativeToErc.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_value' of RewardableBridge.calculateFee (RewardableForeignBridgeNativeToErc.sol#142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_recover' of RewardableBridge.calculateFee (RewardableForeignBridgeNativeToErc.sol#142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_feeType' of RewardableBridge.calculateFee (RewardableForeignBridgeNativeToErc.sol#142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_fee' of RewardableBridge.distributeFeeFromSignatures (RewardableForeignBridgeNativeToErc.sol#155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge.distributeFeeFromSignatures (RewardableForeignBridgeNativeToErc.sol#155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_txHash' of RewardableBridge.distributeFeeFromSignatures (RewardableForeignBridgeNativeToErc.sol#155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_fee' of RewardableBridge.distributeFeeFromAffirmation (RewardableForeignBridgeNativeToErc.sol#160) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge.distributeFeeFromAffirmation (RewardableForeignBridgeNativeToErc.sol#160) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_txHash' of RewardableBridge.distributeFeeFromAffirmation (RewardableForeignBridgeNativeToErc.sol#160) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setHomeFee(uint256 _fee) external onlyOwner {\n",
                    "message": "Parameter '_fee' of RewardableForeignBridgeNativeToErc.setHomeFee (RewardableForeignBridgeNativeToErc.sol#172) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => uint256) internal uintStorage;\n",
                    "message": "EternalStorage.uintStorage (RewardableForeignBridgeNativeToErc.sol#12) is never used in RewardableForeignBridgeNativeToErc\nEternalStorage.stringStorage (RewardableForeignBridgeNativeToErc.sol#13) is never used in RewardableForeignBridgeNativeToErc\nEternalStorage.bytesStorage (RewardableForeignBridgeNativeToErc.sol#15) is never used in RewardableForeignBridgeNativeToErc\nEternalStorage.boolStorage (RewardableForeignBridgeNativeToErc.sol#16) is never used in RewardableForeignBridgeNativeToErc\nEternalStorage.intStorage (RewardableForeignBridgeNativeToErc.sol#17) is never used in RewardableForeignBridgeNativeToErc\nFeeTypes.FOREIGN_FEE (RewardableForeignBridgeNativeToErc.sol#78) is never used in RewardableForeignBridgeNativeToErc\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setFeeManagerContract(address _feeManager) public onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setHomeFee(uint256 _fee) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address _addr) internal view returns (bool)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/erc20_to_erc20/FeeManagerErcToErcPOSDAO.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_blockReward != address(0) && isContract(_blockReward) && (IBlockReward(_blockReward).bridgesAllowedLength() != 0));\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_29"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": 213,
                    "vulnerability_code": "    function isContract(address _addr) internal view returns (bool)\n\n    {\n\n        uint length;\n\n        assembly { length := extcodesize(_addr) }\n\n        return length > 0;\n",
                    "message": "FeeManagerErcToErcPOSDAO.isContract (FeeManagerErcToErcPOSDAO.sol#208-213) is declared view but contains assembly code\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": 201,
                    "vulnerability_code": "    function setBlockRewardContract(address _blockReward) external {\n\n        require(_blockReward != address(0) && isContract(_blockReward) && (IBlockReward(_blockReward).bridgesAllowedLength() != 0));\n\n        addressStorage[keccak256(abi.encodePacked(\"blockRewardContract\"))] = _blockReward;\n",
                    "message": "Reentrancy in FeeManagerErcToErcPOSDAO.setBlockRewardContract (FeeManagerErcToErcPOSDAO.sol#198-201):\n\tExternal calls:\n\t- require(bool)(_blockReward != address(0) && isContract(_blockReward) && (IBlockReward(_blockReward).bridgesAllowedLength() != 0)) (FeeManagerErcToErcPOSDAO.sol#199)\n\tState variables written after the call(s):\n\t- addressStorage (FeeManagerErcToErcPOSDAO.sol#200)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": 213,
                    "vulnerability_code": "    function isContract(address _addr) internal view returns (bool)\n\n    {\n\n        uint length;\n\n        assembly { length := extcodesize(_addr) }\n\n        return length > 0;\n",
                    "message": "FeeManagerErcToErcPOSDAO.isContract uses assembly (FeeManagerErcToErcPOSDAO.sol#208-213)\n\t- FeeManagerErcToErcPOSDAO.sol#211-212\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": "IRewardableValidators.isValidator (FeeManagerErcToErcPOSDAO.sol#78) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": "IRewardableValidators.requiredSignatures (FeeManagerErcToErcPOSDAO.sol#79) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": "IRewardableValidators.owner (FeeManagerErcToErcPOSDAO.sol#80) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": "IRewardableValidators.validatorList (FeeManagerErcToErcPOSDAO.sol#81) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns(address);\n",
                    "message": "IRewardableValidators.getValidatorRewardAddress (FeeManagerErcToErcPOSDAO.sol#82) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCount() public view returns (uint256);\n",
                    "message": "IRewardableValidators.validatorCount (FeeManagerErcToErcPOSDAO.sol#83) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address);\n",
                    "message": "IRewardableValidators.getNextValidator (FeeManagerErcToErcPOSDAO.sol#84) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": 117,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n\n        uint256 fee = _feeType == HOME_FEE ? getHomeFee() : getForeignFee();\n\n        uint256 eth = 1 ether;\n\n        if (!_recover) {\n\n            return _value.mul(fee).div(eth);\n\n        }\n\n        return _value.mul(fee).div(eth.sub(fee));\n",
                    "message": "BaseFeeManager.calculateFee (FeeManagerErcToErcPOSDAO.sol#110-117) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getFeeManagerMode() public pure returns(bytes4);\n",
                    "message": "BaseFeeManager.getFeeManagerMode (FeeManagerErcToErcPOSDAO.sol#141) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 190,
                    "vulnerability_to_line": 192,
                    "vulnerability_code": "    function getFeeManagerMode() public pure returns(bytes4) {\n\n        return bytes4(keccak256(abi.encodePacked(\"manages-both-directions\")));\n",
                    "message": "FeeManagerErcToErcPOSDAO.getFeeManagerMode (FeeManagerErcToErcPOSDAO.sol#190-192) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function random(uint256 _count) public view returns(uint256) {\n\n        return uint256(blockhash(block.number.sub(1))) % _count;\n",
                    "message": "BaseFeeManager.random (FeeManagerErcToErcPOSDAO.sol#143-145) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotally() public view returns (uint256);\n",
                    "message": "IBlockReward.mintedTotally (FeeManagerErcToErcPOSDAO.sol#155) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256);\n",
                    "message": "IBlockReward.mintedTotallyByBridge (FeeManagerErcToErcPOSDAO.sol#156) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": 196,
                    "vulnerability_code": "    function blockRewardContract() public view returns(address) {\n\n        return _blockRewardContract();\n",
                    "message": "FeeManagerErcToErcPOSDAO.blockRewardContract (FeeManagerErcToErcPOSDAO.sol#194-196) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_value' of BaseFeeManager.calculateFee (FeeManagerErcToErcPOSDAO.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_recover' of BaseFeeManager.calculateFee (FeeManagerErcToErcPOSDAO.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_feeType' of BaseFeeManager.calculateFee (FeeManagerErcToErcPOSDAO.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setHomeFee(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BaseFeeManager.setHomeFee (FeeManagerErcToErcPOSDAO.sol#119) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setForeignFee(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BaseFeeManager.setForeignFee (FeeManagerErcToErcPOSDAO.sol#128) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function random(uint256 _count) public view returns(uint256) {\n",
                    "message": "Parameter '_count' of BaseFeeManager.random (FeeManagerErcToErcPOSDAO.sol#143) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BlockRewardFeeManager.distributeFeeFromAffirmation (FeeManagerErcToErcPOSDAO.sol#169) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BlockRewardFeeManager.distributeFeeFromSignatures (FeeManagerErcToErcPOSDAO.sol#173) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "    function _blockRewardContract() internal view returns(IBlockReward) {\n\n        return IBlockReward(addressStorage[keccak256(abi.encodePacked(\"blockRewardContract\"))]);\n",
                    "message": "Function 'BlockRewardFeeManager._blockRewardContract' (FeeManagerErcToErcPOSDAO.sol#177-179) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromBlockReward(uint256 _fee) internal {\n",
                    "message": "Parameter '_fee' of FeeManagerErcToErcPOSDAO.distributeFeeFromBlockReward (FeeManagerErcToErcPOSDAO.sol#203) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBlockRewardContract(address _blockReward) external {\n",
                    "message": "Parameter '_blockReward' of FeeManagerErcToErcPOSDAO.setBlockRewardContract (FeeManagerErcToErcPOSDAO.sol#198) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (FeeManagerErcToErcPOSDAO.sol#13) is never used in FeeManagerErcToErcPOSDAO\nEternalStorage.bytesStorage (FeeManagerErcToErcPOSDAO.sol#15) is never used in FeeManagerErcToErcPOSDAO\nEternalStorage.boolStorage (FeeManagerErcToErcPOSDAO.sol#16) is never used in FeeManagerErcToErcPOSDAO\nEternalStorage.intStorage (FeeManagerErcToErcPOSDAO.sol#17) is never used in FeeManagerErcToErcPOSDAO\nFeeTypes.FOREIGN_FEE (FeeManagerErcToErcPOSDAO.sol#94) is never used in FeeManagerErcToErcPOSDAO\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address _addr) internal view returns (bool)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns(address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCount() public view returns (uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotally() public view returns (uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256);\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/erc20_to_erc20/RewardableHomeBridgeErcToErc.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RewardableBridge is Ownable, FeeTypes {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_35"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 105,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        address feeManager = feeManagerContract();\n\n        string memory method = _feeType == HOME_FEE ? \"getHomeFee()\" : \"getForeignFee()\";\n\n        bytes memory callData = abi.encodeWithSignature(method);\n\n\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge._getFee (RewardableHomeBridgeErcToErc.sol#91-105) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n\n        bytes4 mode;\n\n        bytes memory callData = abi.encodeWithSignature(\"getFeeManagerMode()\");\n\n        address feeManager = feeManagerContract();\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 4)\n\n            mode := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return mode;\n",
                    "message": "RewardableBridge.getFeeManagerMode (RewardableHomeBridgeErcToErc.sol#107-119) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": 140,
                    "vulnerability_code": "    function isContract(address _addr) internal view returns (bool)\n\n    {\n\n        uint length;\n\n        assembly { length := extcodesize(_addr) }\n\n        return length > 0;\n",
                    "message": "RewardableBridge.isContract (RewardableHomeBridgeErcToErc.sol#135-140) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        bytes memory callData = abi.encodeWithSignature(\"calculateFee(uint256,bool,bytes32)\", _value, _recover, _feeType);\n\n        assembly {\n\n            let result := callcode(gas, _impl, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge.calculateFee (RewardableHomeBridgeErcToErc.sol#142-153) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 105,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        address feeManager = feeManagerContract();\n\n        string memory method = _feeType == HOME_FEE ? \"getHomeFee()\" : \"getForeignFee()\";\n\n        bytes memory callData = abi.encodeWithSignature(method);\n\n\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge._getFee uses assembly (RewardableHomeBridgeErcToErc.sol#91-105)\n\t- RewardableHomeBridgeErcToErc.sol#97-104\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n\n        bytes4 mode;\n\n        bytes memory callData = abi.encodeWithSignature(\"getFeeManagerMode()\");\n\n        address feeManager = feeManagerContract();\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 4)\n\n            mode := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return mode;\n",
                    "message": "RewardableBridge.getFeeManagerMode uses assembly (RewardableHomeBridgeErcToErc.sol#107-119)\n\t- RewardableHomeBridgeErcToErc.sol#111-118\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": 140,
                    "vulnerability_code": "    function isContract(address _addr) internal view returns (bool)\n\n    {\n\n        uint length;\n\n        assembly { length := extcodesize(_addr) }\n\n        return length > 0;\n",
                    "message": "RewardableBridge.isContract uses assembly (RewardableHomeBridgeErcToErc.sol#135-140)\n\t- RewardableHomeBridgeErcToErc.sol#138-139\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        bytes memory callData = abi.encodeWithSignature(\"calculateFee(uint256,bool,bytes32)\", _value, _recover, _feeType);\n\n        assembly {\n\n            let result := callcode(gas, _impl, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge.calculateFee uses assembly (RewardableHomeBridgeErcToErc.sol#142-153)\n\t- RewardableHomeBridgeErcToErc.sol#145-152\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 60,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        require(newOwner != address(0));\n\n        setOwner(newOwner);\n",
                    "message": "Ownable.transferOwnership (RewardableHomeBridgeErcToErc.sol#57-60) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n\n        bytes4 mode;\n\n        bytes memory callData = abi.encodeWithSignature(\"getFeeManagerMode()\");\n\n        address feeManager = feeManagerContract();\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 4)\n\n            mode := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return mode;\n",
                    "message": "RewardableBridge.getFeeManagerMode (RewardableHomeBridgeErcToErc.sol#107-119) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": 128,
                    "vulnerability_code": "    function setFeeManagerContract(address _feeManager) public onlyOwner {\n\n        require(_feeManager == address(0) || isContract(_feeManager));\n\n        addressStorage[keccak256(abi.encodePacked(\"feeManagerContract\"))] = _feeManager;\n",
                    "message": "RewardableBridge.setFeeManagerContract (RewardableHomeBridgeErcToErc.sol#125-128) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": 182,
                    "vulnerability_code": "    function getHomeFee() public view returns(uint256) {\n\n        return _getFee(HOME_FEE);\n",
                    "message": "RewardableHomeBridgeErcToErc.getHomeFee (RewardableHomeBridgeErcToErc.sol#180-182) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": 186,
                    "vulnerability_code": "    function getForeignFee() public view returns(uint256) {\n\n        return _getFee(FOREIGN_FEE);\n",
                    "message": "RewardableHomeBridgeErcToErc.getForeignFee (RewardableHomeBridgeErcToErc.sol#184-186) should be declared external\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n\n        string memory method = _feeType == HOME_FEE ? \"setHomeFee(uint256)\" : \"setForeignFee(uint256)\";\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(method, _fee)));\n",
                    "message": "Low level call in RewardableBridge._setFee (RewardableHomeBridgeErcToErc.sol#130-133):\n\t-require(bool)(_feeManager.delegatecall(abi.encodeWithSignature(method,_fee))) RewardableHomeBridgeErcToErc.sol#132\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": 158,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(\"distributeFeeFromSignatures(uint256)\", _fee)));\n\n        emit FeeDistributedFromSignatures(_fee, _txHash);\n",
                    "message": "Low level call in RewardableBridge.distributeFeeFromSignatures (RewardableHomeBridgeErcToErc.sol#155-158):\n\t-require(bool)(_feeManager.delegatecall(abi.encodeWithSignature(distributeFeeFromSignatures(uint256),_fee))) RewardableHomeBridgeErcToErc.sol#156\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(\"distributeFeeFromAffirmation(uint256)\", _fee)));\n\n        emit FeeDistributedFromAffirmation(_fee, _txHash);\n",
                    "message": "Low level call in RewardableBridge.distributeFeeFromAffirmation (RewardableHomeBridgeErcToErc.sol#160-163):\n\t-require(bool)(_feeManager.delegatecall(abi.encodeWithSignature(distributeFeeFromAffirmation(uint256),_fee))) RewardableHomeBridgeErcToErc.sol#161\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 105,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        address feeManager = feeManagerContract();\n\n        string memory method = _feeType == HOME_FEE ? \"getHomeFee()\" : \"getForeignFee()\";\n\n        bytes memory callData = abi.encodeWithSignature(method);\n\n\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "Function 'RewardableBridge._getFee' (RewardableHomeBridgeErcToErc.sol#91-105) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_feeType' of RewardableBridge._getFee (RewardableHomeBridgeErcToErc.sol#91) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setFeeManagerContract(address _feeManager) public onlyOwner {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge.setFeeManagerContract (RewardableHomeBridgeErcToErc.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n\n        string memory method = _feeType == HOME_FEE ? \"setHomeFee(uint256)\" : \"setForeignFee(uint256)\";\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(method, _fee)));\n",
                    "message": "Function 'RewardableBridge._setFee' (RewardableHomeBridgeErcToErc.sol#130-133) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge._setFee (RewardableHomeBridgeErcToErc.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n",
                    "message": "Parameter '_fee' of RewardableBridge._setFee (RewardableHomeBridgeErcToErc.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n",
                    "message": "Parameter '_feeType' of RewardableBridge._setFee (RewardableHomeBridgeErcToErc.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_value' of RewardableBridge.calculateFee (RewardableHomeBridgeErcToErc.sol#142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_recover' of RewardableBridge.calculateFee (RewardableHomeBridgeErcToErc.sol#142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_feeType' of RewardableBridge.calculateFee (RewardableHomeBridgeErcToErc.sol#142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_fee' of RewardableBridge.distributeFeeFromSignatures (RewardableHomeBridgeErcToErc.sol#155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge.distributeFeeFromSignatures (RewardableHomeBridgeErcToErc.sol#155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_txHash' of RewardableBridge.distributeFeeFromSignatures (RewardableHomeBridgeErcToErc.sol#155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_fee' of RewardableBridge.distributeFeeFromAffirmation (RewardableHomeBridgeErcToErc.sol#160) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge.distributeFeeFromAffirmation (RewardableHomeBridgeErcToErc.sol#160) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_txHash' of RewardableBridge.distributeFeeFromAffirmation (RewardableHomeBridgeErcToErc.sol#160) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setHomeFee(uint256 _fee) external onlyOwner {\n",
                    "message": "Parameter '_fee' of RewardableHomeBridgeErcToErc.setHomeFee (RewardableHomeBridgeErcToErc.sol#172) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setForeignFee(uint256 _fee) external onlyOwner {\n",
                    "message": "Parameter '_fee' of RewardableHomeBridgeErcToErc.setForeignFee (RewardableHomeBridgeErcToErc.sol#176) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => uint256) internal uintStorage;\n",
                    "message": "EternalStorage.uintStorage (RewardableHomeBridgeErcToErc.sol#12) is never used in RewardableHomeBridgeErcToErc\nEternalStorage.stringStorage (RewardableHomeBridgeErcToErc.sol#13) is never used in RewardableHomeBridgeErcToErc\nEternalStorage.bytesStorage (RewardableHomeBridgeErcToErc.sol#15) is never used in RewardableHomeBridgeErcToErc\nEternalStorage.boolStorage (RewardableHomeBridgeErcToErc.sol#16) is never used in RewardableHomeBridgeErcToErc\nEternalStorage.intStorage (RewardableHomeBridgeErcToErc.sol#17) is never used in RewardableHomeBridgeErcToErc\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setFeeManagerContract(address _feeManager) public onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setHomeFee(uint256 _fee) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setForeignFee(uint256 _fee) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address _addr) internal view returns (bool)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/erc20_to_native/FeeManagerErcToNativePOSDAO.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_27"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => address) internal addressStorage;\n",
                    "message": "EternalStorage.addressStorage (FeeManagerErcToNativePOSDAO.sol#28) is never initialized. It is used in:\n\t- _blockRewardContract (FeeManagerErcToNativePOSDAO.sol#177-179)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotally() public view returns (uint256);\n",
                    "message": "IBlockReward.mintedTotally (FeeManagerErcToNativePOSDAO.sol#8) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256);\n",
                    "message": "IBlockReward.mintedTotallyByBridge (FeeManagerErcToNativePOSDAO.sol#9) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": "IRewardableValidators.isValidator (FeeManagerErcToNativePOSDAO.sol#92) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": "IRewardableValidators.requiredSignatures (FeeManagerErcToNativePOSDAO.sol#93) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": "IRewardableValidators.owner (FeeManagerErcToNativePOSDAO.sol#94) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": "IRewardableValidators.validatorList (FeeManagerErcToNativePOSDAO.sol#95) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns(address);\n",
                    "message": "IRewardableValidators.getValidatorRewardAddress (FeeManagerErcToNativePOSDAO.sol#96) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCount() public view returns (uint256);\n",
                    "message": "IRewardableValidators.validatorCount (FeeManagerErcToNativePOSDAO.sol#97) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address);\n",
                    "message": "IRewardableValidators.getNextValidator (FeeManagerErcToNativePOSDAO.sol#98) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": 131,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n\n        uint256 fee = _feeType == HOME_FEE ? getHomeFee() : getForeignFee();\n\n        uint256 eth = 1 ether;\n\n        if (!_recover) {\n\n            return _value.mul(fee).div(eth);\n\n        }\n\n        return _value.mul(fee).div(eth.sub(fee));\n",
                    "message": "BaseFeeManager.calculateFee (FeeManagerErcToNativePOSDAO.sol#124-131) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getFeeManagerMode() public pure returns(bytes4);\n",
                    "message": "BaseFeeManager.getFeeManagerMode (FeeManagerErcToNativePOSDAO.sol#155) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": 193,
                    "vulnerability_code": "    function getFeeManagerMode() public pure returns(bytes4) {\n\n        return bytes4(keccak256(abi.encodePacked(\"manages-both-directions\")));\n",
                    "message": "FeeManagerErcToNativePOSDAO.getFeeManagerMode (FeeManagerErcToNativePOSDAO.sol#191-193) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 159,
                    "vulnerability_code": "    function random(uint256 _count) public view returns(uint256) {\n\n        return uint256(blockhash(block.number.sub(1))) % _count;\n",
                    "message": "BaseFeeManager.random (FeeManagerErcToNativePOSDAO.sol#157-159) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": 202,
                    "vulnerability_code": "    function getAmountToBurn(uint256 _value) public view returns(uint256) {\n\n        return _value;\n",
                    "message": "FeeManagerErcToNativePOSDAO.getAmountToBurn (FeeManagerErcToNativePOSDAO.sol#200-202) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_value' of BaseFeeManager.calculateFee (FeeManagerErcToNativePOSDAO.sol#124) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_recover' of BaseFeeManager.calculateFee (FeeManagerErcToNativePOSDAO.sol#124) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_feeType' of BaseFeeManager.calculateFee (FeeManagerErcToNativePOSDAO.sol#124) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setHomeFee(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BaseFeeManager.setHomeFee (FeeManagerErcToNativePOSDAO.sol#133) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setForeignFee(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BaseFeeManager.setForeignFee (FeeManagerErcToNativePOSDAO.sol#142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function random(uint256 _count) public view returns(uint256) {\n",
                    "message": "Parameter '_count' of BaseFeeManager.random (FeeManagerErcToNativePOSDAO.sol#157) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BlockRewardFeeManager.distributeFeeFromAffirmation (FeeManagerErcToNativePOSDAO.sol#169) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BlockRewardFeeManager.distributeFeeFromSignatures (FeeManagerErcToNativePOSDAO.sol#173) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "    function _blockRewardContract() internal view returns(IBlockReward) {\n\n        return IBlockReward(addressStorage[keccak256(abi.encodePacked(\"blockRewardContract\"))]);\n",
                    "message": "Function 'BlockRewardFeeManager._blockRewardContract' (FeeManagerErcToNativePOSDAO.sol#177-179) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromBlockReward(uint256 _fee) internal {\n",
                    "message": "Parameter '_fee' of FeeManagerErcToNativePOSDAO.distributeFeeFromBlockReward (FeeManagerErcToNativePOSDAO.sol#195) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAmountToBurn(uint256 _value) public view returns(uint256) {\n",
                    "message": "Parameter '_value' of FeeManagerErcToNativePOSDAO.getAmountToBurn (FeeManagerErcToNativePOSDAO.sol#200) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (FeeManagerErcToNativePOSDAO.sol#27) is never used in FeeManagerErcToNativePOSDAO\nEternalStorage.bytesStorage (FeeManagerErcToNativePOSDAO.sol#29) is never used in FeeManagerErcToNativePOSDAO\nEternalStorage.boolStorage (FeeManagerErcToNativePOSDAO.sol#30) is never used in FeeManagerErcToNativePOSDAO\nEternalStorage.intStorage (FeeManagerErcToNativePOSDAO.sol#31) is never used in FeeManagerErcToNativePOSDAO\nFeeTypes.FOREIGN_FEE (FeeManagerErcToNativePOSDAO.sol#108) is never used in FeeManagerErcToNativePOSDAO\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotally() public view returns (uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns(address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCount() public view returns (uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address);\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/erc20_to_native/RewardableHomeBridgeErcToNative.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RewardableBridge is Ownable, FeeTypes {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_39"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 105,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        address feeManager = feeManagerContract();\n\n        string memory method = _feeType == HOME_FEE ? \"getHomeFee()\" : \"getForeignFee()\";\n\n        bytes memory callData = abi.encodeWithSignature(method);\n\n\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge._getFee (RewardableHomeBridgeErcToNative.sol#91-105) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n\n        bytes4 mode;\n\n        bytes memory callData = abi.encodeWithSignature(\"getFeeManagerMode()\");\n\n        address feeManager = feeManagerContract();\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 4)\n\n            mode := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return mode;\n",
                    "message": "RewardableBridge.getFeeManagerMode (RewardableHomeBridgeErcToNative.sol#107-119) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": 140,
                    "vulnerability_code": "    function isContract(address _addr) internal view returns (bool)\n\n    {\n\n        uint length;\n\n        assembly { length := extcodesize(_addr) }\n\n        return length > 0;\n",
                    "message": "RewardableBridge.isContract (RewardableHomeBridgeErcToNative.sol#135-140) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        bytes memory callData = abi.encodeWithSignature(\"calculateFee(uint256,bool,bytes32)\", _value, _recover, _feeType);\n\n        assembly {\n\n            let result := callcode(gas, _impl, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge.calculateFee (RewardableHomeBridgeErcToNative.sol#142-153) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": 200,
                    "vulnerability_code": "    function getAmountToBurn(uint256 _value) public view returns(uint256) {\n\n        uint256 amount;\n\n        bytes memory callData = abi.encodeWithSignature(\"getAmountToBurn(uint256)\", _value);\n\n        address feeManager = feeManagerContract();\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            amount := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return amount;\n",
                    "message": "RewardableHomeBridgeErcToNative.getAmountToBurn (RewardableHomeBridgeErcToNative.sol#188-200) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 105,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        address feeManager = feeManagerContract();\n\n        string memory method = _feeType == HOME_FEE ? \"getHomeFee()\" : \"getForeignFee()\";\n\n        bytes memory callData = abi.encodeWithSignature(method);\n\n\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge._getFee uses assembly (RewardableHomeBridgeErcToNative.sol#91-105)\n\t- RewardableHomeBridgeErcToNative.sol#97-104\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n\n        bytes4 mode;\n\n        bytes memory callData = abi.encodeWithSignature(\"getFeeManagerMode()\");\n\n        address feeManager = feeManagerContract();\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 4)\n\n            mode := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return mode;\n",
                    "message": "RewardableBridge.getFeeManagerMode uses assembly (RewardableHomeBridgeErcToNative.sol#107-119)\n\t- RewardableHomeBridgeErcToNative.sol#111-118\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": 140,
                    "vulnerability_code": "    function isContract(address _addr) internal view returns (bool)\n\n    {\n\n        uint length;\n\n        assembly { length := extcodesize(_addr) }\n\n        return length > 0;\n",
                    "message": "RewardableBridge.isContract uses assembly (RewardableHomeBridgeErcToNative.sol#135-140)\n\t- RewardableHomeBridgeErcToNative.sol#138-139\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        bytes memory callData = abi.encodeWithSignature(\"calculateFee(uint256,bool,bytes32)\", _value, _recover, _feeType);\n\n        assembly {\n\n            let result := callcode(gas, _impl, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "RewardableBridge.calculateFee uses assembly (RewardableHomeBridgeErcToNative.sol#142-153)\n\t- RewardableHomeBridgeErcToNative.sol#145-152\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": 200,
                    "vulnerability_code": "    function getAmountToBurn(uint256 _value) public view returns(uint256) {\n\n        uint256 amount;\n\n        bytes memory callData = abi.encodeWithSignature(\"getAmountToBurn(uint256)\", _value);\n\n        address feeManager = feeManagerContract();\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            amount := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return amount;\n",
                    "message": "RewardableHomeBridgeErcToNative.getAmountToBurn uses assembly (RewardableHomeBridgeErcToNative.sol#188-200)\n\t- RewardableHomeBridgeErcToNative.sol#192-199\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 60,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        require(newOwner != address(0));\n\n        setOwner(newOwner);\n",
                    "message": "Ownable.transferOwnership (RewardableHomeBridgeErcToNative.sol#57-60) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n\n        bytes4 mode;\n\n        bytes memory callData = abi.encodeWithSignature(\"getFeeManagerMode()\");\n\n        address feeManager = feeManagerContract();\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 4)\n\n            mode := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return mode;\n",
                    "message": "RewardableBridge.getFeeManagerMode (RewardableHomeBridgeErcToNative.sol#107-119) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": 128,
                    "vulnerability_code": "    function setFeeManagerContract(address _feeManager) public onlyOwner {\n\n        require(_feeManager == address(0) || isContract(_feeManager));\n\n        addressStorage[keccak256(abi.encodePacked(\"feeManagerContract\"))] = _feeManager;\n",
                    "message": "RewardableBridge.setFeeManagerContract (RewardableHomeBridgeErcToNative.sol#125-128) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": 182,
                    "vulnerability_code": "    function getHomeFee() public view returns(uint256) {\n\n        return _getFee(HOME_FEE);\n",
                    "message": "RewardableHomeBridgeErcToNative.getHomeFee (RewardableHomeBridgeErcToNative.sol#180-182) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": 186,
                    "vulnerability_code": "    function getForeignFee() public view returns(uint256) {\n\n        return _getFee(FOREIGN_FEE);\n",
                    "message": "RewardableHomeBridgeErcToNative.getForeignFee (RewardableHomeBridgeErcToNative.sol#184-186) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": 200,
                    "vulnerability_code": "    function getAmountToBurn(uint256 _value) public view returns(uint256) {\n\n        uint256 amount;\n\n        bytes memory callData = abi.encodeWithSignature(\"getAmountToBurn(uint256)\", _value);\n\n        address feeManager = feeManagerContract();\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            amount := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return amount;\n",
                    "message": "RewardableHomeBridgeErcToNative.getAmountToBurn (RewardableHomeBridgeErcToNative.sol#188-200) should be declared external\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n\n        string memory method = _feeType == HOME_FEE ? \"setHomeFee(uint256)\" : \"setForeignFee(uint256)\";\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(method, _fee)));\n",
                    "message": "Low level call in RewardableBridge._setFee (RewardableHomeBridgeErcToNative.sol#130-133):\n\t-require(bool)(_feeManager.delegatecall(abi.encodeWithSignature(method,_fee))) RewardableHomeBridgeErcToNative.sol#132\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": 158,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(\"distributeFeeFromSignatures(uint256)\", _fee)));\n\n        emit FeeDistributedFromSignatures(_fee, _txHash);\n",
                    "message": "Low level call in RewardableBridge.distributeFeeFromSignatures (RewardableHomeBridgeErcToNative.sol#155-158):\n\t-require(bool)(_feeManager.delegatecall(abi.encodeWithSignature(distributeFeeFromSignatures(uint256),_fee))) RewardableHomeBridgeErcToNative.sol#156\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": 163,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(\"distributeFeeFromAffirmation(uint256)\", _fee)));\n\n        emit FeeDistributedFromAffirmation(_fee, _txHash);\n",
                    "message": "Low level call in RewardableBridge.distributeFeeFromAffirmation (RewardableHomeBridgeErcToNative.sol#160-163):\n\t-require(bool)(_feeManager.delegatecall(abi.encodeWithSignature(distributeFeeFromAffirmation(uint256),_fee))) RewardableHomeBridgeErcToNative.sol#161\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 105,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n\n        uint256 fee;\n\n        address feeManager = feeManagerContract();\n\n        string memory method = _feeType == HOME_FEE ? \"getHomeFee()\" : \"getForeignFee()\";\n\n        bytes memory callData = abi.encodeWithSignature(method);\n\n\n\n        assembly {\n\n            let result := callcode(gas, feeManager, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n\n            fee := mload(0)\n\n\n\n            switch result\n\n            case 0 { revert(0, 0) }\n\n        }\n\n        return fee;\n",
                    "message": "Function 'RewardableBridge._getFee' (RewardableHomeBridgeErcToNative.sol#91-105) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_feeType' of RewardableBridge._getFee (RewardableHomeBridgeErcToNative.sol#91) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setFeeManagerContract(address _feeManager) public onlyOwner {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge.setFeeManagerContract (RewardableHomeBridgeErcToNative.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": 133,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n\n        string memory method = _feeType == HOME_FEE ? \"setHomeFee(uint256)\" : \"setForeignFee(uint256)\";\n\n        require(_feeManager.delegatecall(abi.encodeWithSignature(method, _fee)));\n",
                    "message": "Function 'RewardableBridge._setFee' (RewardableHomeBridgeErcToNative.sol#130-133) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge._setFee (RewardableHomeBridgeErcToNative.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n",
                    "message": "Parameter '_fee' of RewardableBridge._setFee (RewardableHomeBridgeErcToNative.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setFee(address _feeManager, uint256 _fee, bytes32 _feeType) internal {\n",
                    "message": "Parameter '_feeType' of RewardableBridge._setFee (RewardableHomeBridgeErcToNative.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_value' of RewardableBridge.calculateFee (RewardableHomeBridgeErcToNative.sol#142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_recover' of RewardableBridge.calculateFee (RewardableHomeBridgeErcToNative.sol#142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": "Parameter '_feeType' of RewardableBridge.calculateFee (RewardableHomeBridgeErcToNative.sol#142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_fee' of RewardableBridge.distributeFeeFromSignatures (RewardableHomeBridgeErcToNative.sol#155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge.distributeFeeFromSignatures (RewardableHomeBridgeErcToNative.sol#155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_txHash' of RewardableBridge.distributeFeeFromSignatures (RewardableHomeBridgeErcToNative.sol#155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_fee' of RewardableBridge.distributeFeeFromAffirmation (RewardableHomeBridgeErcToNative.sol#160) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_feeManager' of RewardableBridge.distributeFeeFromAffirmation (RewardableHomeBridgeErcToNative.sol#160) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee, address _feeManager, bytes32 _txHash) internal {\n",
                    "message": "Parameter '_txHash' of RewardableBridge.distributeFeeFromAffirmation (RewardableHomeBridgeErcToNative.sol#160) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setHomeFee(uint256 _fee) external onlyOwner {\n",
                    "message": "Parameter '_fee' of RewardableHomeBridgeErcToNative.setHomeFee (RewardableHomeBridgeErcToNative.sol#172) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setForeignFee(uint256 _fee) external onlyOwner {\n",
                    "message": "Parameter '_fee' of RewardableHomeBridgeErcToNative.setForeignFee (RewardableHomeBridgeErcToNative.sol#176) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAmountToBurn(uint256 _value) public view returns(uint256) {\n",
                    "message": "Parameter '_value' of RewardableHomeBridgeErcToNative.getAmountToBurn (RewardableHomeBridgeErcToNative.sol#188) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => uint256) internal uintStorage;\n",
                    "message": "EternalStorage.uintStorage (RewardableHomeBridgeErcToNative.sol#12) is never used in RewardableHomeBridgeErcToNative\nEternalStorage.stringStorage (RewardableHomeBridgeErcToNative.sol#13) is never used in RewardableHomeBridgeErcToNative\nEternalStorage.bytesStorage (RewardableHomeBridgeErcToNative.sol#15) is never used in RewardableHomeBridgeErcToNative\nEternalStorage.boolStorage (RewardableHomeBridgeErcToNative.sol#16) is never used in RewardableHomeBridgeErcToNative\nEternalStorage.intStorage (RewardableHomeBridgeErcToNative.sol#17) is never used in RewardableHomeBridgeErcToNative\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setFeeManagerContract(address _feeManager) public onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setHomeFee(uint256 _fee) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setForeignFee(uint256 _fee) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getFee(bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getFeeManagerMode() public view returns(bytes4) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address _addr) internal view returns (bool)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, address _impl, bytes32 _feeType) internal view returns(uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAmountToBurn(uint256 _value) public view returns(uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/erc20_to_native/FeeManagerErcToNative.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require((nextValidator != F_ADDR) && (nextValidator != address(0)));\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (diff > 0 && randomValidatorIndex == i) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                feeToDistribute = feeToDistribute.add(diff);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_34"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => address) internal addressStorage;\n",
                    "message": "EternalStorage.addressStorage (FeeManagerErcToNative.sol#39) is never initialized. It is used in:\n\t- rewardableValidatorContract (FeeManagerErcToNative.sol#192-194)\n\t- blockRewardContract (FeeManagerErcToNative.sol#253-255)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 randomValidatorIndex;\n",
                    "message": "randomValidatorIndex in ValidatorsFeeManager.distributeFeeProportionally (FeeManagerErcToNative.sol#203) is a local variable never initialiazed\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotally() public view returns (uint256);\n",
                    "message": "IBlockReward.mintedTotally (FeeManagerErcToNative.sol#8) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256);\n",
                    "message": "IBlockReward.mintedTotallyByBridge (FeeManagerErcToNative.sol#9) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": "IRewardableValidators.isValidator (FeeManagerErcToNative.sol#103) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": "IRewardableValidators.requiredSignatures (FeeManagerErcToNative.sol#104) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": "IRewardableValidators.owner (FeeManagerErcToNative.sol#105) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": "IRewardableValidators.validatorList (FeeManagerErcToNative.sol#106) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns(address);\n",
                    "message": "IRewardableValidators.getValidatorRewardAddress (FeeManagerErcToNative.sol#107) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCount() public view returns (uint256);\n",
                    "message": "IRewardableValidators.validatorCount (FeeManagerErcToNative.sol#108) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address);\n",
                    "message": "IRewardableValidators.getNextValidator (FeeManagerErcToNative.sol#109) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getFeeManagerMode() public pure returns(bytes4);\n",
                    "message": "BaseFeeManager.getFeeManagerMode (FeeManagerErcToNative.sol#166) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function getFeeManagerMode() public pure returns(bytes4) {\n\n        return bytes4(keccak256(abi.encodePacked(\"manages-both-directions\")));\n",
                    "message": "FeeManagerErcToNative.getFeeManagerMode (FeeManagerErcToNative.sol#249-251) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": 271,
                    "vulnerability_code": "    function getAmountToBurn(uint256 _value) public view returns(uint256) {\n\n        uint256 fee = calculateFee(_value, false, HOME_FEE);\n\n        return _value.sub(fee);\n",
                    "message": "FeeManagerErcToNative.getAmountToBurn (FeeManagerErcToNative.sol#268-271) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _recipient) public payable {\n",
                    "message": "Parameter '_recipient' of Sacrifice. (FeeManagerErcToNative.sol#21) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_value' of BaseFeeManager.calculateFee (FeeManagerErcToNative.sol#135) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_recover' of BaseFeeManager.calculateFee (FeeManagerErcToNative.sol#135) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns(uint256) {\n",
                    "message": "Parameter '_feeType' of BaseFeeManager.calculateFee (FeeManagerErcToNative.sol#135) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setHomeFee(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BaseFeeManager.setHomeFee (FeeManagerErcToNative.sol#144) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setForeignFee(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of BaseFeeManager.setForeignFee (FeeManagerErcToNative.sol#153) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function random(uint256 _count) public view returns(uint256) {\n",
                    "message": "Parameter '_count' of BaseFeeManager.random (FeeManagerErcToNative.sol#168) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromAffirmation(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of ValidatorsFeeManager.distributeFeeFromAffirmation (FeeManagerErcToNative.sol#184) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeFromSignatures(uint256 _fee) external {\n",
                    "message": "Parameter '_fee' of ValidatorsFeeManager.distributeFeeFromSignatures (FeeManagerErcToNative.sol#188) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeProportionally(uint256 _fee, bytes32 _direction) internal {\n",
                    "message": "Parameter '_fee' of ValidatorsFeeManager.distributeFeeProportionally (FeeManagerErcToNative.sol#196) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function distributeFeeProportionally(uint256 _fee, bytes32 _direction) internal {\n",
                    "message": "Parameter '_direction' of ValidatorsFeeManager.distributeFeeProportionally (FeeManagerErcToNative.sol#196) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onFeeDistribution(address _rewardAddress, uint256 _fee, bytes32 _direction) internal {\n",
                    "message": "Parameter '_rewardAddress' of ValidatorsFeeManager.onFeeDistribution (FeeManagerErcToNative.sol#228) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onFeeDistribution(address _rewardAddress, uint256 _fee, bytes32 _direction) internal {\n",
                    "message": "Parameter '_fee' of ValidatorsFeeManager.onFeeDistribution (FeeManagerErcToNative.sol#228) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onFeeDistribution(address _rewardAddress, uint256 _fee, bytes32 _direction) internal {\n",
                    "message": "Parameter '_direction' of ValidatorsFeeManager.onFeeDistribution (FeeManagerErcToNative.sol#228) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onAffirmationFeeDistribution(address _rewardAddress, uint256 _fee) internal {\n",
                    "message": "Parameter '_rewardAddress' of FeeManagerErcToNative.onAffirmationFeeDistribution (FeeManagerErcToNative.sol#257) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onAffirmationFeeDistribution(address _rewardAddress, uint256 _fee) internal {\n",
                    "message": "Parameter '_fee' of FeeManagerErcToNative.onAffirmationFeeDistribution (FeeManagerErcToNative.sol#257) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onSignatureFeeDistribution(address _rewardAddress, uint256 _fee) internal {\n",
                    "message": "Parameter '_rewardAddress' of FeeManagerErcToNative.onSignatureFeeDistribution (FeeManagerErcToNative.sol#262) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onSignatureFeeDistribution(address _rewardAddress, uint256 _fee) internal {\n",
                    "message": "Parameter '_fee' of FeeManagerErcToNative.onSignatureFeeDistribution (FeeManagerErcToNative.sol#262) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAmountToBurn(uint256 _value) public view returns(uint256) {\n",
                    "message": "Parameter '_value' of FeeManagerErcToNative.getAmountToBurn (FeeManagerErcToNative.sol#268) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (FeeManagerErcToNative.sol#38) is never used in FeeManagerErcToNative\nEternalStorage.bytesStorage (FeeManagerErcToNative.sol#40) is never used in FeeManagerErcToNative\nEternalStorage.boolStorage (FeeManagerErcToNative.sol#41) is never used in FeeManagerErcToNative\nEternalStorage.intStorage (FeeManagerErcToNative.sol#42) is never used in FeeManagerErcToNative\nFeeTypes.FOREIGN_FEE (FeeManagerErcToNative.sol#119) is never used in FeeManagerErcToNative\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address F_ADDR = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (nextValidator != F_ADDR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotally() public view returns (uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorList() public view returns (address[]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getValidatorRewardAddress(address _validator) public view returns(address);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validatorCount() public view returns (uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNextValidator(address _address) public view returns (address);\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/test/BlockReward.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 public mintedCoins = 0;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 public feeAmount = 0;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            this.addExtraReceiver(feeToDistribute, validatorList[i]);\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            receivers[i] = validatorList[i];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (diff > 0 && randomValidatorIndex == i) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                feeToDistribute = feeToDistribute.add(diff);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (diff > 0 && randomValidatorIndex == i) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                feeToDistribute = feeToDistribute.add(diff);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_19"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function addExtraReceiver(uint256 _amount, address _receiver) external {\n\n        require(_amount > 0);\n\n        require(_receiver != address(0));\n\n        mintedCoins = mintedCoins.add(_amount);\n\n        this.addMintedTotallyByBridge(_amount, msg.sender);\n\n        _receiver.transfer(_amount);\n",
                    "message": "BlockReward.addExtraReceiver (BlockReward.sol#88-94) sends eth to arbitrary user\n\tDangerous calls:\n\t- _receiver.transfer(_amount) (BlockReward.sol#93)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 randomValidatorIndex;\n",
                    "message": "randomValidatorIndex in BlockReward.addBridgeNativeFeeReceivers (BlockReward.sol#123) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 randomValidatorIndex;\n",
                    "message": "randomValidatorIndex in BlockReward.addBridgeTokenFeeReceivers (BlockReward.sol#144) is a local variable never initialiazed\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            this.addExtraReceiver(feeToDistribute, validatorList[i]);\n",
                    "message": "BlockReward.addBridgeNativeFeeReceivers has external calls inside a loop:\n\t- this.addExtraReceiver(feeToDistribute,validatorList[i]) (BlockReward.sol#134)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotally() public view returns (uint256);\n",
                    "message": "IBlockReward.mintedTotally (BlockReward.sol#8) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": 98,
                    "vulnerability_code": "    function mintedTotally() public view returns (uint256) {\n\n        return mintedCoins;\n",
                    "message": "BlockReward.mintedTotally (BlockReward.sol#96-98) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256);\n",
                    "message": "IBlockReward.mintedTotallyByBridge (BlockReward.sol#9) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": 104,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256) {\n\n        return uintStorage[\n\n        keccak256(abi.encode(MINTED_TOTALLY_BY_BRIDGE, _bridge))\n\n        ];\n",
                    "message": "BlockReward.mintedTotallyByBridge (BlockReward.sol#100-104) should be declared external\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": 160,
                    "vulnerability_code": "    function addBridgeTokenFeeReceivers(uint256 _amount) external {\n\n        address[] memory receivers = new address[](validatorList.length);\n\n        uint256[] memory rewards = new uint256[](validatorList.length);\n\n        feeAmount = _amount;\n\n        uint256 feePerValidator = _amount.div(validatorList.length);\n\n\n\n        uint256 randomValidatorIndex;\n\n        uint256 diff = _amount.sub(feePerValidator.mul(validatorList.length));\n\n        if (diff > 0) {\n\n            randomValidatorIndex = random(validatorList.length);\n\n        }\n\n\n\n        for (uint256 i = 0; i < validatorList.length; i++) {\n\n            uint256 feeToDistribute = feePerValidator;\n\n            if (diff > 0 && randomValidatorIndex == i) {\n\n                feeToDistribute = feeToDistribute.add(diff);\n\n            }\n\n            receivers[i] = validatorList[i];\n\n            rewards[i] = feeToDistribute;\n\n        }\n\n\n\n        require(token.call(abi.encodeWithSignature(\"mintReward(address[],uint256[])\", receivers, rewards)));\n",
                    "message": "Low level call in BlockReward.addBridgeTokenFeeReceivers (BlockReward.sol#138-160):\n\t-require(bool)(token.call(abi.encodeWithSignature(mintReward(address[],uint256[]),receivers,rewards))) BlockReward.sol#159\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExtraReceiver(uint256 _amount, address _receiver) external {\n",
                    "message": "Parameter '_amount' of BlockReward.addExtraReceiver (BlockReward.sol#88) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExtraReceiver(uint256 _amount, address _receiver) external {\n",
                    "message": "Parameter '_receiver' of BlockReward.addExtraReceiver (BlockReward.sol#88) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256) {\n",
                    "message": "Parameter '_bridge' of BlockReward.mintedTotallyByBridge (BlockReward.sol#100) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addBridgeTokenFeeReceivers(uint256 _amount) external {\n",
                    "message": "Parameter '_amount' of BlockReward.addBridgeTokenFeeReceivers (BlockReward.sol#138) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addBridgeNativeFeeReceivers(uint256 _amount) external {\n",
                    "message": "Parameter '_amount' of BlockReward.addBridgeNativeFeeReceivers (BlockReward.sol#119) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addMintedTotallyByBridge(uint256 _amount, address _bridge) external {\n",
                    "message": "Parameter '_amount' of BlockReward.addMintedTotallyByBridge (BlockReward.sol#106) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addMintedTotallyByBridge(uint256 _amount, address _bridge) external {\n",
                    "message": "Parameter '_bridge' of BlockReward.addMintedTotallyByBridge (BlockReward.sol#106) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setValidatorsRewards(address[] _initialValidators) external {\n",
                    "message": "Parameter '_initialValidators' of BlockReward.setValidatorsRewards (BlockReward.sol#111) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setToken(address _token) external {\n",
                    "message": "Parameter '_token' of BlockReward.setToken (BlockReward.sol#115) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function random(uint256 _count) public view returns(uint256) {\n",
                    "message": "Parameter '_count' of BlockReward.random (BlockReward.sol#162) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < validatorList.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotally() public view returns (uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintedTotallyByBridge(address _bridge) public view returns(uint256);\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/test/Staking.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {}\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/libraries/SafeMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/libraries/Message.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < array.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < array.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < requiredSignatures; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < array.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < requiredSignatures; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_14"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 74,
                    "vulnerability_code": "    function parseMessage(bytes message)\n\n        internal\n\n        pure\n\n        returns(address recipient, uint256 amount, bytes32 txHash, address contractAddress)\n\n    {\n\n        require(isMessageValid(message));\n\n        assembly {\n\n            recipient := and(mload(add(message, 20)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n\n            amount := mload(add(message, 52))\n\n            txHash := mload(add(message, 84))\n\n            contractAddress := mload(add(message, 104))\n\n        }\n",
                    "message": "Message.parseMessage (Message.sol#62-74) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 96,
                    "vulnerability_code": "    function recoverAddressFromSignedMessage(bytes signature, bytes message) internal pure returns (address) {\n\n        require(signature.length == 65);\n\n        bytes32 r;\n\n        bytes32 s;\n\n        bytes1 v;\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            r := mload(add(signature, 0x20))\n\n            s := mload(add(signature, 0x40))\n\n            v := mload(add(signature, 0x60))\n\n        }\n\n        return ecrecover(hashMessage(message), uint8(v), r, s);\n",
                    "message": "Message.recoverAddressFromSignedMessage (Message.sol#84-96) is declared view but contains assembly code\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_validatorContract.isValidator(recoveredAddress));\n",
                    "message": "Message.hasEnoughValidSignatures has external calls inside a loop:\n\t- require(bool)(_validatorContract.isValidator(recoveredAddress)) (Message.sol#119)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 74,
                    "vulnerability_code": "    function parseMessage(bytes message)\n\n        internal\n\n        pure\n\n        returns(address recipient, uint256 amount, bytes32 txHash, address contractAddress)\n\n    {\n\n        require(isMessageValid(message));\n\n        assembly {\n\n            recipient := and(mload(add(message, 20)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n\n            amount := mload(add(message, 52))\n\n            txHash := mload(add(message, 84))\n\n            contractAddress := mload(add(message, 104))\n\n        }\n",
                    "message": "Message.parseMessage uses assembly (Message.sol#62-74)\n\t- Message.sol#68-74\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 96,
                    "vulnerability_code": "    function recoverAddressFromSignedMessage(bytes signature, bytes message) internal pure returns (address) {\n\n        require(signature.length == 65);\n\n        bytes32 r;\n\n        bytes32 s;\n\n        bytes1 v;\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            r := mload(add(signature, 0x20))\n\n            s := mload(add(signature, 0x40))\n\n            v := mload(add(signature, 0x60))\n\n        }\n\n        return ecrecover(hashMessage(message), uint8(v), r, s);\n",
                    "message": "Message.recoverAddressFromSignedMessage uses assembly (Message.sol#84-96)\n\t- Message.sol#90-95\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": "IBridgeValidators.isValidator (Message.sol#7) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": "IBridgeValidators.requiredSignatures (Message.sol#8) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": "IBridgeValidators.owner (Message.sol#9) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isMessageValid(bytes _msg) internal pure returns(bool) {\n",
                    "message": "Parameter '_msg' of Message.isMessageValid (Message.sol#76) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _message,\n",
                    "message": "Parameter '_message' of Message.hasEnoughValidSignatures (Message.sol#106) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint8[] _vs,\n",
                    "message": "Parameter '_vs' of Message.hasEnoughValidSignatures (Message.sol#107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes32[] _rs,\n",
                    "message": "Parameter '_rs' of Message.hasEnoughValidSignatures (Message.sol#108) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes32[] _ss,\n",
                    "message": "Parameter '_ss' of Message.hasEnoughValidSignatures (Message.sol#109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        IBridgeValidators _validatorContract) internal view {\n",
                    "message": "Parameter '_validatorContract' of Message.hasEnoughValidSignatures (Message.sol#110) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < array.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseMessage(bytes message)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < array.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (addressArrayContains(encounteredAddresses, recoveredAddress)) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseMessage(bytes message)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recoverAddressFromSignedMessage(bytes signature, bytes message) internal pure returns (address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns(address recipient, uint256 amount, bytes32 txHash, address contractAddress)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressArrayContains(address[] array, address value) internal pure returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseMessage(bytes message)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isMessageValid(bytes _msg) internal pure returns(bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recoverAddressFromSignedMessage(bytes signature, bytes message) internal pure returns (address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recoverAddressFromSignedMessage(bytes signature, bytes message) internal pure returns (address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashMessage(bytes message) internal pure returns (bytes32) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes _message,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint8[] _vs,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes32[] _rs,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes32[] _ss,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isValidator(address _validator) public view returns(bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function requiredSignatures() public view returns(uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function owner() public view returns(address);\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeability/OwnedUpgradeabilityProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        setUpgradeabilityOwner(msg.sender);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_15"
            ],
            "vulnerability_findings": [
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _upgradeTo(uint256 version, address implementation) internal {\n",
                    "message": "UpgradeabilityProxy._upgradeTo.version (local variable @ OwnedUpgradeabilityProxy.sol#151) shadows:\n\t- UpgradeabilityStorage.version (function @ OwnedUpgradeabilityProxy.sol#116-118)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _upgradeTo(uint256 version, address implementation) internal {\n",
                    "message": "UpgradeabilityProxy._upgradeTo.implementation (local variable @ OwnedUpgradeabilityProxy.sol#151) shadows:\n\t- UpgradeabilityStorage.implementation (function @ OwnedUpgradeabilityProxy.sol#124-126)\n\t- Proxy.implementation (function @ OwnedUpgradeabilityProxy.sol#16)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeTo(uint256 version, address implementation) public onlyProxyOwner {\n",
                    "message": "OwnedUpgradeabilityProxy.upgradeTo.version (local variable @ OwnedUpgradeabilityProxy.sol#244) shadows:\n\t- UpgradeabilityStorage.version (function @ OwnedUpgradeabilityProxy.sol#116-118)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeTo(uint256 version, address implementation) public onlyProxyOwner {\n",
                    "message": "OwnedUpgradeabilityProxy.upgradeTo.implementation (local variable @ OwnedUpgradeabilityProxy.sol#244) shadows:\n\t- UpgradeabilityStorage.implementation (function @ OwnedUpgradeabilityProxy.sol#124-126)\n\t- Proxy.implementation (function @ OwnedUpgradeabilityProxy.sol#16)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n",
                    "message": "OwnedUpgradeabilityProxy.upgradeToAndCall.version (local variable @ OwnedUpgradeabilityProxy.sol#256) shadows:\n\t- UpgradeabilityStorage.version (function @ OwnedUpgradeabilityProxy.sol#116-118)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n",
                    "message": "OwnedUpgradeabilityProxy.upgradeToAndCall.implementation (local variable @ OwnedUpgradeabilityProxy.sol#256) shadows:\n\t- UpgradeabilityStorage.implementation (function @ OwnedUpgradeabilityProxy.sol#124-126)\n\t- Proxy.implementation (function @ OwnedUpgradeabilityProxy.sol#16)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 93,
                    "vulnerability_code": "    function () payable public {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n        assembly {\n\n            /*\n\n                0x40 is the \"free memory slot\", meaning a pointer to next slot of empty memory. mload(0x40)\n\n                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty\n\n                memory. It's needed because we're going to write the return data of delegatecall to the\n\n                free memory slot.\n\n            */\n\n            let ptr := mload(0x40)\n\n            /*\n\n                `calldatacopy` is copy calldatasize bytes from calldata\n\n                First argument is the destination to which data is copied(ptr)\n\n                Second argument specifies the start position of the copied data.\n\n                    Since calldata is sort of its own unique location in memory,\n\n                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.\n\n                    That's always going to be the zeroth byte of the function selector.\n\n                Third argument, calldatasize, specifies how much data will be copied.\n\n                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)\n\n            */\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            /*\n\n                delegatecall params explained:\n\n                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives\n\n                    us the amount of gas still available to execution\n\n\n\n                _impl: address of the contract to delegate to\n\n\n\n                ptr: to pass copied data\n\n\n\n                calldatasize: loads the size of `bytes memory data`, same as msg.data.length\n\n\n\n                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,\n\n                        these are set to 0, 0 so the output data will not be written to memory. The output\n\n                        data will be read using `returndatasize` and `returdatacopy` instead.\n\n\n\n                result: This will be 0 if the call fails and 1 if it succeeds\n\n            */\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n\n            /*\n\n\n\n            */\n\n            /*\n\n                ptr current points to the value stored at 0x40,\n\n                because we assigned it like ptr := mload(0x40).\n\n                Because we use 0x40 as a free memory pointer,\n\n                we want to make sure that the next time we want to allocate memory,\n\n                we aren't overwriting anything important.\n\n                So, by adding ptr and returndatasize,\n\n                we get a memory location beyond the end of the data we will be copying to ptr.\n\n                We place this in at 0x40, and any reads from 0x40 will now read from free memory\n\n            */\n\n            mstore(0x40, add(ptr, returndatasize))\n\n            /*\n\n                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the\n\n                    slot it will copy to, 0 means copy from the beginning of the return data, and size is\n\n                    the amount of data to copy.\n\n                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall\n\n            */\n\n            returndatacopy(ptr, 0, returndatasize)\n\n\n\n            /*\n\n                if `result` is 0, revert.\n\n                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was\n\n                copied to `ptr` from the delegatecall return data\n\n            */\n\n            switch result\n\n            case 0 { revert(ptr, returndatasize) }\n\n            default { return(ptr, returndatasize) }\n\n        }\n",
                    "message": "Proxy.fallback uses assembly (OwnedUpgradeabilityProxy.sol#22-93)\n\t- OwnedUpgradeabilityProxy.sol#25-93\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 93,
                    "vulnerability_code": "    function () payable public {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n        assembly {\n\n            /*\n\n                0x40 is the \"free memory slot\", meaning a pointer to next slot of empty memory. mload(0x40)\n\n                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty\n\n                memory. It's needed because we're going to write the return data of delegatecall to the\n\n                free memory slot.\n\n            */\n\n            let ptr := mload(0x40)\n\n            /*\n\n                `calldatacopy` is copy calldatasize bytes from calldata\n\n                First argument is the destination to which data is copied(ptr)\n\n                Second argument specifies the start position of the copied data.\n\n                    Since calldata is sort of its own unique location in memory,\n\n                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.\n\n                    That's always going to be the zeroth byte of the function selector.\n\n                Third argument, calldatasize, specifies how much data will be copied.\n\n                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)\n\n            */\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            /*\n\n                delegatecall params explained:\n\n                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives\n\n                    us the amount of gas still available to execution\n\n\n\n                _impl: address of the contract to delegate to\n\n\n\n                ptr: to pass copied data\n\n\n\n                calldatasize: loads the size of `bytes memory data`, same as msg.data.length\n\n\n\n                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,\n\n                        these are set to 0, 0 so the output data will not be written to memory. The output\n\n                        data will be read using `returndatasize` and `returdatacopy` instead.\n\n\n\n                result: This will be 0 if the call fails and 1 if it succeeds\n\n            */\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n\n            /*\n\n\n\n            */\n\n            /*\n\n                ptr current points to the value stored at 0x40,\n\n                because we assigned it like ptr := mload(0x40).\n\n                Because we use 0x40 as a free memory pointer,\n\n                we want to make sure that the next time we want to allocate memory,\n\n                we aren't overwriting anything important.\n\n                So, by adding ptr and returndatasize,\n\n                we get a memory location beyond the end of the data we will be copying to ptr.\n\n                We place this in at 0x40, and any reads from 0x40 will now read from free memory\n\n            */\n\n            mstore(0x40, add(ptr, returndatasize))\n\n            /*\n\n                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the\n\n                    slot it will copy to, 0 means copy from the beginning of the return data, and size is\n\n                    the amount of data to copy.\n\n                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall\n\n            */\n\n            returndatacopy(ptr, 0, returndatasize)\n\n\n\n            /*\n\n                if `result` is 0, revert.\n\n                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was\n\n                copied to `ptr` from the delegatecall return data\n\n            */\n\n            switch result\n\n            case 0 { revert(ptr, returndatasize) }\n\n            default { return(ptr, returndatasize) }\n\n        }\n",
                    "message": "Proxy.fallback (OwnedUpgradeabilityProxy.sol#22-93) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function version() public view returns (uint256) {\n\n        return _version;\n",
                    "message": "UpgradeabilityStorage.version (OwnedUpgradeabilityProxy.sol#116-118) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": 237,
                    "vulnerability_code": "    function transferProxyOwnership(address newOwner) public onlyProxyOwner {\n\n        require(newOwner != address(0));\n\n        emit ProxyOwnershipTransferred(proxyOwner(), newOwner);\n\n        setUpgradeabilityOwner(newOwner);\n",
                    "message": "OwnedUpgradeabilityProxy.transferProxyOwnership (OwnedUpgradeabilityProxy.sol#233-237) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 259,
                    "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n\n        upgradeTo(version, implementation);\n\n        require(address(this).call.value(msg.value)(data));\n",
                    "message": "OwnedUpgradeabilityProxy.upgradeToAndCall (OwnedUpgradeabilityProxy.sol#256-259) should be declared external\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 259,
                    "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n\n        upgradeTo(version, implementation);\n\n        require(address(this).call.value(msg.value)(data));\n",
                    "message": "Low level call in OwnedUpgradeabilityProxy.upgradeToAndCall (OwnedUpgradeabilityProxy.sol#256-259):\n\t-require(bool)(address(this).call.value(msg.value)(data)) OwnedUpgradeabilityProxy.sol#258\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _version;\n",
                    "message": "Variable 'UpgradeabilityStorage._version' (OwnedUpgradeabilityProxy.sol#107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _implementation;\n",
                    "message": "Variable 'UpgradeabilityStorage._implementation' (OwnedUpgradeabilityProxy.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": 157,
                    "vulnerability_code": "    function _upgradeTo(uint256 version, address implementation) internal {\n\n        require(_implementation != implementation);\n\n        require(version > _version);\n\n        _version = version;\n\n        _implementation = implementation;\n\n        emit Upgraded(version, implementation);\n",
                    "message": "Function 'UpgradeabilityProxy._upgradeTo' (OwnedUpgradeabilityProxy.sol#151-157) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Proxy {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _upgradeabilityOwner;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function () payable public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeability/EternalStorageProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        setUpgradeabilityOwner(msg.sender);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_16"
            ],
            "vulnerability_findings": [
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _upgradeTo(uint256 version, address implementation) internal {\n",
                    "message": "UpgradeabilityProxy._upgradeTo.version (local variable @ EternalStorageProxy.sol#171) shadows:\n\t- UpgradeabilityStorage.version (function @ EternalStorageProxy.sol#136-138)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _upgradeTo(uint256 version, address implementation) internal {\n",
                    "message": "UpgradeabilityProxy._upgradeTo.implementation (local variable @ EternalStorageProxy.sol#171) shadows:\n\t- UpgradeabilityStorage.implementation (function @ EternalStorageProxy.sol#144-146)\n\t- Proxy.implementation (function @ EternalStorageProxy.sol#36)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeTo(uint256 version, address implementation) public onlyProxyOwner {\n",
                    "message": "OwnedUpgradeabilityProxy.upgradeTo.version (local variable @ EternalStorageProxy.sol#264) shadows:\n\t- UpgradeabilityStorage.version (function @ EternalStorageProxy.sol#136-138)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeTo(uint256 version, address implementation) public onlyProxyOwner {\n",
                    "message": "OwnedUpgradeabilityProxy.upgradeTo.implementation (local variable @ EternalStorageProxy.sol#264) shadows:\n\t- UpgradeabilityStorage.implementation (function @ EternalStorageProxy.sol#144-146)\n\t- Proxy.implementation (function @ EternalStorageProxy.sol#36)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n",
                    "message": "OwnedUpgradeabilityProxy.upgradeToAndCall.version (local variable @ EternalStorageProxy.sol#276) shadows:\n\t- UpgradeabilityStorage.version (function @ EternalStorageProxy.sol#136-138)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n",
                    "message": "OwnedUpgradeabilityProxy.upgradeToAndCall.implementation (local variable @ EternalStorageProxy.sol#276) shadows:\n\t- UpgradeabilityStorage.implementation (function @ EternalStorageProxy.sol#144-146)\n\t- Proxy.implementation (function @ EternalStorageProxy.sol#36)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 113,
                    "vulnerability_code": "    function () payable public {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n        assembly {\n\n            /*\n\n                0x40 is the \"free memory slot\", meaning a pointer to next slot of empty memory. mload(0x40)\n\n                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty\n\n                memory. It's needed because we're going to write the return data of delegatecall to the\n\n                free memory slot.\n\n            */\n\n            let ptr := mload(0x40)\n\n            /*\n\n                `calldatacopy` is copy calldatasize bytes from calldata\n\n                First argument is the destination to which data is copied(ptr)\n\n                Second argument specifies the start position of the copied data.\n\n                    Since calldata is sort of its own unique location in memory,\n\n                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.\n\n                    That's always going to be the zeroth byte of the function selector.\n\n                Third argument, calldatasize, specifies how much data will be copied.\n\n                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)\n\n            */\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            /*\n\n                delegatecall params explained:\n\n                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives\n\n                    us the amount of gas still available to execution\n\n\n\n                _impl: address of the contract to delegate to\n\n\n\n                ptr: to pass copied data\n\n\n\n                calldatasize: loads the size of `bytes memory data`, same as msg.data.length\n\n\n\n                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,\n\n                        these are set to 0, 0 so the output data will not be written to memory. The output\n\n                        data will be read using `returndatasize` and `returdatacopy` instead.\n\n\n\n                result: This will be 0 if the call fails and 1 if it succeeds\n\n            */\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n\n            /*\n\n\n\n            */\n\n            /*\n\n                ptr current points to the value stored at 0x40,\n\n                because we assigned it like ptr := mload(0x40).\n\n                Because we use 0x40 as a free memory pointer,\n\n                we want to make sure that the next time we want to allocate memory,\n\n                we aren't overwriting anything important.\n\n                So, by adding ptr and returndatasize,\n\n                we get a memory location beyond the end of the data we will be copying to ptr.\n\n                We place this in at 0x40, and any reads from 0x40 will now read from free memory\n\n            */\n\n            mstore(0x40, add(ptr, returndatasize))\n\n            /*\n\n                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the\n\n                    slot it will copy to, 0 means copy from the beginning of the return data, and size is\n\n                    the amount of data to copy.\n\n                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall\n\n            */\n\n            returndatacopy(ptr, 0, returndatasize)\n\n\n\n            /*\n\n                if `result` is 0, revert.\n\n                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was\n\n                copied to `ptr` from the delegatecall return data\n\n            */\n\n            switch result\n\n            case 0 { revert(ptr, returndatasize) }\n\n            default { return(ptr, returndatasize) }\n\n        }\n",
                    "message": "Proxy.fallback uses assembly (EternalStorageProxy.sol#42-113)\n\t- EternalStorageProxy.sol#45-113\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 113,
                    "vulnerability_code": "    function () payable public {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n        assembly {\n\n            /*\n\n                0x40 is the \"free memory slot\", meaning a pointer to next slot of empty memory. mload(0x40)\n\n                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty\n\n                memory. It's needed because we're going to write the return data of delegatecall to the\n\n                free memory slot.\n\n            */\n\n            let ptr := mload(0x40)\n\n            /*\n\n                `calldatacopy` is copy calldatasize bytes from calldata\n\n                First argument is the destination to which data is copied(ptr)\n\n                Second argument specifies the start position of the copied data.\n\n                    Since calldata is sort of its own unique location in memory,\n\n                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.\n\n                    That's always going to be the zeroth byte of the function selector.\n\n                Third argument, calldatasize, specifies how much data will be copied.\n\n                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)\n\n            */\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            /*\n\n                delegatecall params explained:\n\n                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives\n\n                    us the amount of gas still available to execution\n\n\n\n                _impl: address of the contract to delegate to\n\n\n\n                ptr: to pass copied data\n\n\n\n                calldatasize: loads the size of `bytes memory data`, same as msg.data.length\n\n\n\n                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,\n\n                        these are set to 0, 0 so the output data will not be written to memory. The output\n\n                        data will be read using `returndatasize` and `returdatacopy` instead.\n\n\n\n                result: This will be 0 if the call fails and 1 if it succeeds\n\n            */\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n\n            /*\n\n\n\n            */\n\n            /*\n\n                ptr current points to the value stored at 0x40,\n\n                because we assigned it like ptr := mload(0x40).\n\n                Because we use 0x40 as a free memory pointer,\n\n                we want to make sure that the next time we want to allocate memory,\n\n                we aren't overwriting anything important.\n\n                So, by adding ptr and returndatasize,\n\n                we get a memory location beyond the end of the data we will be copying to ptr.\n\n                We place this in at 0x40, and any reads from 0x40 will now read from free memory\n\n            */\n\n            mstore(0x40, add(ptr, returndatasize))\n\n            /*\n\n                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the\n\n                    slot it will copy to, 0 means copy from the beginning of the return data, and size is\n\n                    the amount of data to copy.\n\n                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall\n\n            */\n\n            returndatacopy(ptr, 0, returndatasize)\n\n\n\n            /*\n\n                if `result` is 0, revert.\n\n                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was\n\n                copied to `ptr` from the delegatecall return data\n\n            */\n\n            switch result\n\n            case 0 { revert(ptr, returndatasize) }\n\n            default { return(ptr, returndatasize) }\n\n        }\n",
                    "message": "Proxy.fallback (EternalStorageProxy.sol#42-113) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": 138,
                    "vulnerability_code": "    function version() public view returns (uint256) {\n\n        return _version;\n",
                    "message": "UpgradeabilityStorage.version (EternalStorageProxy.sol#136-138) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": 257,
                    "vulnerability_code": "    function transferProxyOwnership(address newOwner) public onlyProxyOwner {\n\n        require(newOwner != address(0));\n\n        emit ProxyOwnershipTransferred(proxyOwner(), newOwner);\n\n        setUpgradeabilityOwner(newOwner);\n",
                    "message": "OwnedUpgradeabilityProxy.transferProxyOwnership (EternalStorageProxy.sol#253-257) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": 279,
                    "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n\n        upgradeTo(version, implementation);\n\n        require(address(this).call.value(msg.value)(data));\n",
                    "message": "OwnedUpgradeabilityProxy.upgradeToAndCall (EternalStorageProxy.sol#276-279) should be declared external\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": 279,
                    "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n\n        upgradeTo(version, implementation);\n\n        require(address(this).call.value(msg.value)(data));\n",
                    "message": "Low level call in OwnedUpgradeabilityProxy.upgradeToAndCall (EternalStorageProxy.sol#276-279):\n\t-require(bool)(address(this).call.value(msg.value)(data)) EternalStorageProxy.sol#278\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _version;\n",
                    "message": "Variable 'UpgradeabilityStorage._version' (EternalStorageProxy.sol#127) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _implementation;\n",
                    "message": "Variable 'UpgradeabilityStorage._implementation' (EternalStorageProxy.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": 177,
                    "vulnerability_code": "    function _upgradeTo(uint256 version, address implementation) internal {\n\n        require(_implementation != implementation);\n\n        require(version > _version);\n\n        _version = version;\n\n        _implementation = implementation;\n\n        emit Upgraded(version, implementation);\n",
                    "message": "Function 'UpgradeabilityProxy._upgradeTo' (EternalStorageProxy.sol#171-177) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => uint256) internal uintStorage;\n",
                    "message": "EternalStorage.uintStorage (EternalStorageProxy.sol#12) is never used in EternalStorageProxy\nEternalStorage.stringStorage (EternalStorageProxy.sol#13) is never used in EternalStorageProxy\nEternalStorage.addressStorage (EternalStorageProxy.sol#14) is never used in EternalStorageProxy\nEternalStorage.bytesStorage (EternalStorageProxy.sol#15) is never used in EternalStorageProxy\nEternalStorage.boolStorage (EternalStorageProxy.sol#16) is never used in EternalStorageProxy\nEternalStorage.intStorage (EternalStorageProxy.sol#17) is never used in EternalStorageProxy\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Proxy {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _upgradeabilityOwner;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function () payable public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeability/ClassicEternalStorageProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        setUpgradeabilityOwner(msg.sender);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_19"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => uint256) internal uintStorage;\n",
                    "message": "EternalStorage.uintStorage (ClassicEternalStorageProxy.sol#12) is never initialized. It is used in:\n\t- getSize (ClassicEternalStorageProxy.sol#304-310)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _upgradeTo(uint256 version, address implementation) internal {\n",
                    "message": "UpgradeabilityProxy._upgradeTo.version (local variable @ ClassicEternalStorageProxy.sol#171) shadows:\n\t- UpgradeabilityStorage.version (function @ ClassicEternalStorageProxy.sol#136-138)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _upgradeTo(uint256 version, address implementation) internal {\n",
                    "message": "UpgradeabilityProxy._upgradeTo.implementation (local variable @ ClassicEternalStorageProxy.sol#171) shadows:\n\t- UpgradeabilityStorage.implementation (function @ ClassicEternalStorageProxy.sol#144-146)\n\t- Proxy.implementation (function @ ClassicEternalStorageProxy.sol#36)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeTo(uint256 version, address implementation) public onlyProxyOwner {\n",
                    "message": "OwnedUpgradeabilityProxy.upgradeTo.version (local variable @ ClassicEternalStorageProxy.sol#264) shadows:\n\t- UpgradeabilityStorage.version (function @ ClassicEternalStorageProxy.sol#136-138)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeTo(uint256 version, address implementation) public onlyProxyOwner {\n",
                    "message": "OwnedUpgradeabilityProxy.upgradeTo.implementation (local variable @ ClassicEternalStorageProxy.sol#264) shadows:\n\t- UpgradeabilityStorage.implementation (function @ ClassicEternalStorageProxy.sol#144-146)\n\t- Proxy.implementation (function @ ClassicEternalStorageProxy.sol#36)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n",
                    "message": "OwnedUpgradeabilityProxy.upgradeToAndCall.version (local variable @ ClassicEternalStorageProxy.sol#276) shadows:\n\t- UpgradeabilityStorage.version (function @ ClassicEternalStorageProxy.sol#136-138)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n",
                    "message": "OwnedUpgradeabilityProxy.upgradeToAndCall.implementation (local variable @ ClassicEternalStorageProxy.sol#276) shadows:\n\t- UpgradeabilityStorage.implementation (function @ ClassicEternalStorageProxy.sol#144-146)\n\t- Proxy.implementation (function @ ClassicEternalStorageProxy.sol#36)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 113,
                    "vulnerability_code": "    function () payable public {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n        assembly {\n\n            /*\n\n                0x40 is the \"free memory slot\", meaning a pointer to next slot of empty memory. mload(0x40)\n\n                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty\n\n                memory. It's needed because we're going to write the return data of delegatecall to the\n\n                free memory slot.\n\n            */\n\n            let ptr := mload(0x40)\n\n            /*\n\n                `calldatacopy` is copy calldatasize bytes from calldata\n\n                First argument is the destination to which data is copied(ptr)\n\n                Second argument specifies the start position of the copied data.\n\n                    Since calldata is sort of its own unique location in memory,\n\n                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.\n\n                    That's always going to be the zeroth byte of the function selector.\n\n                Third argument, calldatasize, specifies how much data will be copied.\n\n                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)\n\n            */\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            /*\n\n                delegatecall params explained:\n\n                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives\n\n                    us the amount of gas still available to execution\n\n\n\n                _impl: address of the contract to delegate to\n\n\n\n                ptr: to pass copied data\n\n\n\n                calldatasize: loads the size of `bytes memory data`, same as msg.data.length\n\n\n\n                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,\n\n                        these are set to 0, 0 so the output data will not be written to memory. The output\n\n                        data will be read using `returndatasize` and `returdatacopy` instead.\n\n\n\n                result: This will be 0 if the call fails and 1 if it succeeds\n\n            */\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n\n            /*\n\n\n\n            */\n\n            /*\n\n                ptr current points to the value stored at 0x40,\n\n                because we assigned it like ptr := mload(0x40).\n\n                Because we use 0x40 as a free memory pointer,\n\n                we want to make sure that the next time we want to allocate memory,\n\n                we aren't overwriting anything important.\n\n                So, by adding ptr and returndatasize,\n\n                we get a memory location beyond the end of the data we will be copying to ptr.\n\n                We place this in at 0x40, and any reads from 0x40 will now read from free memory\n\n            */\n\n            mstore(0x40, add(ptr, returndatasize))\n\n            /*\n\n                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the\n\n                    slot it will copy to, 0 means copy from the beginning of the return data, and size is\n\n                    the amount of data to copy.\n\n                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall\n\n            */\n\n            returndatacopy(ptr, 0, returndatasize)\n\n\n\n            /*\n\n                if `result` is 0, revert.\n\n                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was\n\n                copied to `ptr` from the delegatecall return data\n\n            */\n\n            switch result\n\n            case 0 { revert(ptr, returndatasize) }\n\n            default { return(ptr, returndatasize) }\n\n        }\n",
                    "message": "Proxy.fallback uses assembly (ClassicEternalStorageProxy.sol#42-113)\n\t- ClassicEternalStorageProxy.sol#45-113\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": 302,
                    "vulnerability_code": "    function () payable public {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n        uint256 len = getSize(msg.sig);\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, len)\n\n\n\n            switch result\n\n            case 0 { revert(0, len) }\n\n            default { return(0, len) }\n\n        }\n",
                    "message": "ClassicEternalStorageProxy.fallback uses assembly (ClassicEternalStorageProxy.sol#289-302)\n\t- ClassicEternalStorageProxy.sol#293-302\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": 302,
                    "vulnerability_code": "    function () payable public {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n        uint256 len = getSize(msg.sig);\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, len)\n\n\n\n            switch result\n\n            case 0 { revert(0, len) }\n\n            default { return(0, len) }\n\n        }\n",
                    "message": "ClassicEternalStorageProxy.fallback (ClassicEternalStorageProxy.sol#289-302) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 113,
                    "vulnerability_code": "    function () payable public {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n        assembly {\n\n            /*\n\n                0x40 is the \"free memory slot\", meaning a pointer to next slot of empty memory. mload(0x40)\n\n                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty\n\n                memory. It's needed because we're going to write the return data of delegatecall to the\n\n                free memory slot.\n\n            */\n\n            let ptr := mload(0x40)\n\n            /*\n\n                `calldatacopy` is copy calldatasize bytes from calldata\n\n                First argument is the destination to which data is copied(ptr)\n\n                Second argument specifies the start position of the copied data.\n\n                    Since calldata is sort of its own unique location in memory,\n\n                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.\n\n                    That's always going to be the zeroth byte of the function selector.\n\n                Third argument, calldatasize, specifies how much data will be copied.\n\n                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)\n\n            */\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            /*\n\n                delegatecall params explained:\n\n                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives\n\n                    us the amount of gas still available to execution\n\n\n\n                _impl: address of the contract to delegate to\n\n\n\n                ptr: to pass copied data\n\n\n\n                calldatasize: loads the size of `bytes memory data`, same as msg.data.length\n\n\n\n                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,\n\n                        these are set to 0, 0 so the output data will not be written to memory. The output\n\n                        data will be read using `returndatasize` and `returdatacopy` instead.\n\n\n\n                result: This will be 0 if the call fails and 1 if it succeeds\n\n            */\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n\n            /*\n\n\n\n            */\n\n            /*\n\n                ptr current points to the value stored at 0x40,\n\n                because we assigned it like ptr := mload(0x40).\n\n                Because we use 0x40 as a free memory pointer,\n\n                we want to make sure that the next time we want to allocate memory,\n\n                we aren't overwriting anything important.\n\n                So, by adding ptr and returndatasize,\n\n                we get a memory location beyond the end of the data we will be copying to ptr.\n\n                We place this in at 0x40, and any reads from 0x40 will now read from free memory\n\n            */\n\n            mstore(0x40, add(ptr, returndatasize))\n\n            /*\n\n                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the\n\n                    slot it will copy to, 0 means copy from the beginning of the return data, and size is\n\n                    the amount of data to copy.\n\n                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall\n\n            */\n\n            returndatacopy(ptr, 0, returndatasize)\n\n\n\n            /*\n\n                if `result` is 0, revert.\n\n                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was\n\n                copied to `ptr` from the delegatecall return data\n\n            */\n\n            switch result\n\n            case 0 { revert(ptr, returndatasize) }\n\n            default { return(ptr, returndatasize) }\n\n        }\n",
                    "message": "Proxy.fallback (ClassicEternalStorageProxy.sol#42-113) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": 138,
                    "vulnerability_code": "    function version() public view returns (uint256) {\n\n        return _version;\n",
                    "message": "UpgradeabilityStorage.version (ClassicEternalStorageProxy.sol#136-138) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": 257,
                    "vulnerability_code": "    function transferProxyOwnership(address newOwner) public onlyProxyOwner {\n\n        require(newOwner != address(0));\n\n        emit ProxyOwnershipTransferred(proxyOwner(), newOwner);\n\n        setUpgradeabilityOwner(newOwner);\n",
                    "message": "OwnedUpgradeabilityProxy.transferProxyOwnership (ClassicEternalStorageProxy.sol#253-257) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": 279,
                    "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n\n        upgradeTo(version, implementation);\n\n        require(address(this).call.value(msg.value)(data));\n",
                    "message": "OwnedUpgradeabilityProxy.upgradeToAndCall (ClassicEternalStorageProxy.sol#276-279) should be declared external\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": 279,
                    "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n\n        upgradeTo(version, implementation);\n\n        require(address(this).call.value(msg.value)(data));\n",
                    "message": "Low level call in OwnedUpgradeabilityProxy.upgradeToAndCall (ClassicEternalStorageProxy.sol#276-279):\n\t-require(bool)(address(this).call.value(msg.value)(data)) ClassicEternalStorageProxy.sol#278\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _version;\n",
                    "message": "Variable 'UpgradeabilityStorage._version' (ClassicEternalStorageProxy.sol#127) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _implementation;\n",
                    "message": "Variable 'UpgradeabilityStorage._implementation' (ClassicEternalStorageProxy.sol#130) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": 177,
                    "vulnerability_code": "    function _upgradeTo(uint256 version, address implementation) internal {\n\n        require(_implementation != implementation);\n\n        require(version > _version);\n\n        _version = version;\n\n        _implementation = implementation;\n\n        emit Upgraded(version, implementation);\n",
                    "message": "Function 'UpgradeabilityProxy._upgradeTo' (ClassicEternalStorageProxy.sol#171-177) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => string) internal stringStorage;\n",
                    "message": "EternalStorage.stringStorage (ClassicEternalStorageProxy.sol#13) is never used in ClassicEternalStorageProxy\nEternalStorage.addressStorage (ClassicEternalStorageProxy.sol#14) is never used in ClassicEternalStorageProxy\nEternalStorage.bytesStorage (ClassicEternalStorageProxy.sol#15) is never used in ClassicEternalStorageProxy\nEternalStorage.boolStorage (ClassicEternalStorageProxy.sol#16) is never used in ClassicEternalStorageProxy\nEternalStorage.intStorage (ClassicEternalStorageProxy.sol#17) is never used in ClassicEternalStorageProxy\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Proxy {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract ClassicEternalStorageProxy is EternalStorage, OwnedUpgradeabilityProxy {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _upgradeabilityOwner;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function () payable public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function () payable public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeability/Proxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 93,
                    "vulnerability_code": "    function () payable public {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n        assembly {\n\n            /*\n\n                0x40 is the \"free memory slot\", meaning a pointer to next slot of empty memory. mload(0x40)\n\n                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty\n\n                memory. It's needed because we're going to write the return data of delegatecall to the\n\n                free memory slot.\n\n            */\n\n            let ptr := mload(0x40)\n\n            /*\n\n                `calldatacopy` is copy calldatasize bytes from calldata\n\n                First argument is the destination to which data is copied(ptr)\n\n                Second argument specifies the start position of the copied data.\n\n                    Since calldata is sort of its own unique location in memory,\n\n                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.\n\n                    That's always going to be the zeroth byte of the function selector.\n\n                Third argument, calldatasize, specifies how much data will be copied.\n\n                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)\n\n            */\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            /*\n\n                delegatecall params explained:\n\n                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives\n\n                    us the amount of gas still available to execution\n\n\n\n                _impl: address of the contract to delegate to\n\n\n\n                ptr: to pass copied data\n\n\n\n                calldatasize: loads the size of `bytes memory data`, same as msg.data.length\n\n\n\n                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,\n\n                        these are set to 0, 0 so the output data will not be written to memory. The output\n\n                        data will be read using `returndatasize` and `returdatacopy` instead.\n\n\n\n                result: This will be 0 if the call fails and 1 if it succeeds\n\n            */\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n\n            /*\n\n\n\n            */\n\n            /*\n\n                ptr current points to the value stored at 0x40,\n\n                because we assigned it like ptr := mload(0x40).\n\n                Because we use 0x40 as a free memory pointer,\n\n                we want to make sure that the next time we want to allocate memory,\n\n                we aren't overwriting anything important.\n\n                So, by adding ptr and returndatasize,\n\n                we get a memory location beyond the end of the data we will be copying to ptr.\n\n                We place this in at 0x40, and any reads from 0x40 will now read from free memory\n\n            */\n\n            mstore(0x40, add(ptr, returndatasize))\n\n            /*\n\n                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the\n\n                    slot it will copy to, 0 means copy from the beginning of the return data, and size is\n\n                    the amount of data to copy.\n\n                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall\n\n            */\n\n            returndatacopy(ptr, 0, returndatasize)\n\n\n\n            /*\n\n                if `result` is 0, revert.\n\n                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was\n\n                copied to `ptr` from the delegatecall return data\n\n            */\n\n            switch result\n\n            case 0 { revert(ptr, returndatasize) }\n\n            default { return(ptr, returndatasize) }\n\n        }\n",
                    "message": "Contract locking ether found in Proxy.sol:\n\tContract Proxy has payable functions:\n\t - fallback (Proxy.sol#22-93)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 93,
                    "vulnerability_code": "    function () payable public {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n        assembly {\n\n            /*\n\n                0x40 is the \"free memory slot\", meaning a pointer to next slot of empty memory. mload(0x40)\n\n                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty\n\n                memory. It's needed because we're going to write the return data of delegatecall to the\n\n                free memory slot.\n\n            */\n\n            let ptr := mload(0x40)\n\n            /*\n\n                `calldatacopy` is copy calldatasize bytes from calldata\n\n                First argument is the destination to which data is copied(ptr)\n\n                Second argument specifies the start position of the copied data.\n\n                    Since calldata is sort of its own unique location in memory,\n\n                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.\n\n                    That's always going to be the zeroth byte of the function selector.\n\n                Third argument, calldatasize, specifies how much data will be copied.\n\n                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)\n\n            */\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            /*\n\n                delegatecall params explained:\n\n                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives\n\n                    us the amount of gas still available to execution\n\n\n\n                _impl: address of the contract to delegate to\n\n\n\n                ptr: to pass copied data\n\n\n\n                calldatasize: loads the size of `bytes memory data`, same as msg.data.length\n\n\n\n                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,\n\n                        these are set to 0, 0 so the output data will not be written to memory. The output\n\n                        data will be read using `returndatasize` and `returdatacopy` instead.\n\n\n\n                result: This will be 0 if the call fails and 1 if it succeeds\n\n            */\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n\n            /*\n\n\n\n            */\n\n            /*\n\n                ptr current points to the value stored at 0x40,\n\n                because we assigned it like ptr := mload(0x40).\n\n                Because we use 0x40 as a free memory pointer,\n\n                we want to make sure that the next time we want to allocate memory,\n\n                we aren't overwriting anything important.\n\n                So, by adding ptr and returndatasize,\n\n                we get a memory location beyond the end of the data we will be copying to ptr.\n\n                We place this in at 0x40, and any reads from 0x40 will now read from free memory\n\n            */\n\n            mstore(0x40, add(ptr, returndatasize))\n\n            /*\n\n                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the\n\n                    slot it will copy to, 0 means copy from the beginning of the return data, and size is\n\n                    the amount of data to copy.\n\n                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall\n\n            */\n\n            returndatacopy(ptr, 0, returndatasize)\n\n\n\n            /*\n\n                if `result` is 0, revert.\n\n                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was\n\n                copied to `ptr` from the delegatecall return data\n\n            */\n\n            switch result\n\n            case 0 { revert(ptr, returndatasize) }\n\n            default { return(ptr, returndatasize) }\n\n        }\n",
                    "message": "Proxy.fallback uses assembly (Proxy.sol#22-93)\n\t- Proxy.sol#25-93\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 93,
                    "vulnerability_code": "    function () payable public {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n        assembly {\n\n            /*\n\n                0x40 is the \"free memory slot\", meaning a pointer to next slot of empty memory. mload(0x40)\n\n                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty\n\n                memory. It's needed because we're going to write the return data of delegatecall to the\n\n                free memory slot.\n\n            */\n\n            let ptr := mload(0x40)\n\n            /*\n\n                `calldatacopy` is copy calldatasize bytes from calldata\n\n                First argument is the destination to which data is copied(ptr)\n\n                Second argument specifies the start position of the copied data.\n\n                    Since calldata is sort of its own unique location in memory,\n\n                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.\n\n                    That's always going to be the zeroth byte of the function selector.\n\n                Third argument, calldatasize, specifies how much data will be copied.\n\n                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)\n\n            */\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            /*\n\n                delegatecall params explained:\n\n                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives\n\n                    us the amount of gas still available to execution\n\n\n\n                _impl: address of the contract to delegate to\n\n\n\n                ptr: to pass copied data\n\n\n\n                calldatasize: loads the size of `bytes memory data`, same as msg.data.length\n\n\n\n                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,\n\n                        these are set to 0, 0 so the output data will not be written to memory. The output\n\n                        data will be read using `returndatasize` and `returdatacopy` instead.\n\n\n\n                result: This will be 0 if the call fails and 1 if it succeeds\n\n            */\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n\n            /*\n\n\n\n            */\n\n            /*\n\n                ptr current points to the value stored at 0x40,\n\n                because we assigned it like ptr := mload(0x40).\n\n                Because we use 0x40 as a free memory pointer,\n\n                we want to make sure that the next time we want to allocate memory,\n\n                we aren't overwriting anything important.\n\n                So, by adding ptr and returndatasize,\n\n                we get a memory location beyond the end of the data we will be copying to ptr.\n\n                We place this in at 0x40, and any reads from 0x40 will now read from free memory\n\n            */\n\n            mstore(0x40, add(ptr, returndatasize))\n\n            /*\n\n                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the\n\n                    slot it will copy to, 0 means copy from the beginning of the return data, and size is\n\n                    the amount of data to copy.\n\n                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall\n\n            */\n\n            returndatacopy(ptr, 0, returndatasize)\n\n\n\n            /*\n\n                if `result` is 0, revert.\n\n                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was\n\n                copied to `ptr` from the delegatecall return data\n\n            */\n\n            switch result\n\n            case 0 { revert(ptr, returndatasize) }\n\n            default { return(ptr, returndatasize) }\n\n        }\n",
                    "message": "Proxy.fallback (Proxy.sol#22-93) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Proxy {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function () payable public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeability/UpgradeabilityOwnerStorage.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": 20,
                    "vulnerability_code": "    function upgradeabilityOwner() public view returns (address) {\n\n        return _upgradeabilityOwner;\n",
                    "message": "UpgradeabilityOwnerStorage.upgradeabilityOwner (UpgradeabilityOwnerStorage.sol#18-20) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _upgradeabilityOwner;\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeability/EternalStorage.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeability/UpgradeabilityProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_9"
            ],
            "vulnerability_findings": [
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 93,
                    "vulnerability_code": "    function () payable public {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n        assembly {\n\n            /*\n\n                0x40 is the \"free memory slot\", meaning a pointer to next slot of empty memory. mload(0x40)\n\n                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty\n\n                memory. It's needed because we're going to write the return data of delegatecall to the\n\n                free memory slot.\n\n            */\n\n            let ptr := mload(0x40)\n\n            /*\n\n                `calldatacopy` is copy calldatasize bytes from calldata\n\n                First argument is the destination to which data is copied(ptr)\n\n                Second argument specifies the start position of the copied data.\n\n                    Since calldata is sort of its own unique location in memory,\n\n                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.\n\n                    That's always going to be the zeroth byte of the function selector.\n\n                Third argument, calldatasize, specifies how much data will be copied.\n\n                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)\n\n            */\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            /*\n\n                delegatecall params explained:\n\n                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives\n\n                    us the amount of gas still available to execution\n\n\n\n                _impl: address of the contract to delegate to\n\n\n\n                ptr: to pass copied data\n\n\n\n                calldatasize: loads the size of `bytes memory data`, same as msg.data.length\n\n\n\n                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,\n\n                        these are set to 0, 0 so the output data will not be written to memory. The output\n\n                        data will be read using `returndatasize` and `returdatacopy` instead.\n\n\n\n                result: This will be 0 if the call fails and 1 if it succeeds\n\n            */\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n\n            /*\n\n\n\n            */\n\n            /*\n\n                ptr current points to the value stored at 0x40,\n\n                because we assigned it like ptr := mload(0x40).\n\n                Because we use 0x40 as a free memory pointer,\n\n                we want to make sure that the next time we want to allocate memory,\n\n                we aren't overwriting anything important.\n\n                So, by adding ptr and returndatasize,\n\n                we get a memory location beyond the end of the data we will be copying to ptr.\n\n                We place this in at 0x40, and any reads from 0x40 will now read from free memory\n\n            */\n\n            mstore(0x40, add(ptr, returndatasize))\n\n            /*\n\n                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the\n\n                    slot it will copy to, 0 means copy from the beginning of the return data, and size is\n\n                    the amount of data to copy.\n\n                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall\n\n            */\n\n            returndatacopy(ptr, 0, returndatasize)\n\n\n\n            /*\n\n                if `result` is 0, revert.\n\n                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was\n\n                copied to `ptr` from the delegatecall return data\n\n            */\n\n            switch result\n\n            case 0 { revert(ptr, returndatasize) }\n\n            default { return(ptr, returndatasize) }\n\n        }\n",
                    "message": "Contract locking ether found in UpgradeabilityProxy.sol:\n\tContract UpgradeabilityProxy has payable functions:\n\t - fallback (UpgradeabilityProxy.sol#22-93)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _upgradeTo(uint256 version, address implementation) internal {\n",
                    "message": "UpgradeabilityProxy._upgradeTo.version (local variable @ UpgradeabilityProxy.sol#151) shadows:\n\t- UpgradeabilityStorage.version (function @ UpgradeabilityProxy.sol#116-118)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _upgradeTo(uint256 version, address implementation) internal {\n",
                    "message": "UpgradeabilityProxy._upgradeTo.implementation (local variable @ UpgradeabilityProxy.sol#151) shadows:\n\t- UpgradeabilityStorage.implementation (function @ UpgradeabilityProxy.sol#124-126)\n\t- Proxy.implementation (function @ UpgradeabilityProxy.sol#16)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 93,
                    "vulnerability_code": "    function () payable public {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n        assembly {\n\n            /*\n\n                0x40 is the \"free memory slot\", meaning a pointer to next slot of empty memory. mload(0x40)\n\n                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty\n\n                memory. It's needed because we're going to write the return data of delegatecall to the\n\n                free memory slot.\n\n            */\n\n            let ptr := mload(0x40)\n\n            /*\n\n                `calldatacopy` is copy calldatasize bytes from calldata\n\n                First argument is the destination to which data is copied(ptr)\n\n                Second argument specifies the start position of the copied data.\n\n                    Since calldata is sort of its own unique location in memory,\n\n                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.\n\n                    That's always going to be the zeroth byte of the function selector.\n\n                Third argument, calldatasize, specifies how much data will be copied.\n\n                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)\n\n            */\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            /*\n\n                delegatecall params explained:\n\n                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives\n\n                    us the amount of gas still available to execution\n\n\n\n                _impl: address of the contract to delegate to\n\n\n\n                ptr: to pass copied data\n\n\n\n                calldatasize: loads the size of `bytes memory data`, same as msg.data.length\n\n\n\n                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,\n\n                        these are set to 0, 0 so the output data will not be written to memory. The output\n\n                        data will be read using `returndatasize` and `returdatacopy` instead.\n\n\n\n                result: This will be 0 if the call fails and 1 if it succeeds\n\n            */\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n\n            /*\n\n\n\n            */\n\n            /*\n\n                ptr current points to the value stored at 0x40,\n\n                because we assigned it like ptr := mload(0x40).\n\n                Because we use 0x40 as a free memory pointer,\n\n                we want to make sure that the next time we want to allocate memory,\n\n                we aren't overwriting anything important.\n\n                So, by adding ptr and returndatasize,\n\n                we get a memory location beyond the end of the data we will be copying to ptr.\n\n                We place this in at 0x40, and any reads from 0x40 will now read from free memory\n\n            */\n\n            mstore(0x40, add(ptr, returndatasize))\n\n            /*\n\n                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the\n\n                    slot it will copy to, 0 means copy from the beginning of the return data, and size is\n\n                    the amount of data to copy.\n\n                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall\n\n            */\n\n            returndatacopy(ptr, 0, returndatasize)\n\n\n\n            /*\n\n                if `result` is 0, revert.\n\n                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was\n\n                copied to `ptr` from the delegatecall return data\n\n            */\n\n            switch result\n\n            case 0 { revert(ptr, returndatasize) }\n\n            default { return(ptr, returndatasize) }\n\n        }\n",
                    "message": "Proxy.fallback uses assembly (UpgradeabilityProxy.sol#22-93)\n\t- UpgradeabilityProxy.sol#25-93\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 93,
                    "vulnerability_code": "    function () payable public {\n\n        address _impl = implementation();\n\n        require(_impl != address(0));\n\n        assembly {\n\n            /*\n\n                0x40 is the \"free memory slot\", meaning a pointer to next slot of empty memory. mload(0x40)\n\n                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty\n\n                memory. It's needed because we're going to write the return data of delegatecall to the\n\n                free memory slot.\n\n            */\n\n            let ptr := mload(0x40)\n\n            /*\n\n                `calldatacopy` is copy calldatasize bytes from calldata\n\n                First argument is the destination to which data is copied(ptr)\n\n                Second argument specifies the start position of the copied data.\n\n                    Since calldata is sort of its own unique location in memory,\n\n                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.\n\n                    That's always going to be the zeroth byte of the function selector.\n\n                Third argument, calldatasize, specifies how much data will be copied.\n\n                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)\n\n            */\n\n            calldatacopy(ptr, 0, calldatasize)\n\n            /*\n\n                delegatecall params explained:\n\n                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives\n\n                    us the amount of gas still available to execution\n\n\n\n                _impl: address of the contract to delegate to\n\n\n\n                ptr: to pass copied data\n\n\n\n                calldatasize: loads the size of `bytes memory data`, same as msg.data.length\n\n\n\n                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,\n\n                        these are set to 0, 0 so the output data will not be written to memory. The output\n\n                        data will be read using `returndatasize` and `returdatacopy` instead.\n\n\n\n                result: This will be 0 if the call fails and 1 if it succeeds\n\n            */\n\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n\n            /*\n\n\n\n            */\n\n            /*\n\n                ptr current points to the value stored at 0x40,\n\n                because we assigned it like ptr := mload(0x40).\n\n                Because we use 0x40 as a free memory pointer,\n\n                we want to make sure that the next time we want to allocate memory,\n\n                we aren't overwriting anything important.\n\n                So, by adding ptr and returndatasize,\n\n                we get a memory location beyond the end of the data we will be copying to ptr.\n\n                We place this in at 0x40, and any reads from 0x40 will now read from free memory\n\n            */\n\n            mstore(0x40, add(ptr, returndatasize))\n\n            /*\n\n                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the\n\n                    slot it will copy to, 0 means copy from the beginning of the return data, and size is\n\n                    the amount of data to copy.\n\n                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall\n\n            */\n\n            returndatacopy(ptr, 0, returndatasize)\n\n\n\n            /*\n\n                if `result` is 0, revert.\n\n                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was\n\n                copied to `ptr` from the delegatecall return data\n\n            */\n\n            switch result\n\n            case 0 { revert(ptr, returndatasize) }\n\n            default { return(ptr, returndatasize) }\n\n        }\n",
                    "message": "Proxy.fallback (UpgradeabilityProxy.sol#22-93) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function version() public view returns (uint256) {\n\n        return _version;\n",
                    "message": "UpgradeabilityStorage.version (UpgradeabilityProxy.sol#116-118) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _version;\n",
                    "message": "Variable 'UpgradeabilityStorage._version' (UpgradeabilityProxy.sol#107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _implementation;\n",
                    "message": "Variable 'UpgradeabilityStorage._implementation' (UpgradeabilityProxy.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": 157,
                    "vulnerability_code": "    function _upgradeTo(uint256 version, address implementation) internal {\n\n        require(_implementation != implementation);\n\n        require(version > _version);\n\n        _version = version;\n\n        _implementation = implementation;\n\n        emit Upgraded(version, implementation);\n",
                    "message": "Function 'UpgradeabilityProxy._upgradeTo' (UpgradeabilityProxy.sol#151-157) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Proxy {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function () payable public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeability/UpgradeabilityStorage.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _version;\n",
                    "message": "UpgradeabilityStorage._version (UpgradeabilityStorage.sol#12) is never initialized. It is used in:\n\t- version (UpgradeabilityStorage.sol#21-23)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _implementation;\n",
                    "message": "UpgradeabilityStorage._implementation (UpgradeabilityStorage.sol#15) is never initialized. It is used in:\n\t- implementation (UpgradeabilityStorage.sol#29-31)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _implementation;\n",
                    "message": "UpgradeabilityStorage._implementation should be constant (UpgradeabilityStorage.sol#15)\nUpgradeabilityStorage._version should be constant (UpgradeabilityStorage.sol#12)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": 23,
                    "vulnerability_code": "    function version() public view returns (uint256) {\n\n        return _version;\n",
                    "message": "UpgradeabilityStorage.version (UpgradeabilityStorage.sol#21-23) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": 31,
                    "vulnerability_code": "    function implementation() public view returns (address) {\n\n        return _implementation;\n",
                    "message": "UpgradeabilityStorage.implementation (UpgradeabilityStorage.sol#29-31) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _version;\n",
                    "message": "Variable 'UpgradeabilityStorage._version' (UpgradeabilityStorage.sol#12) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address internal _implementation;\n",
                    "message": "Variable 'UpgradeabilityStorage._implementation' (UpgradeabilityStorage.sol#15) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    }
}