{
    "governance-ee5e45a008d65021831de9f3e83053026f2a4dd2/contracts/TreasuryVester.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 207,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address gtc_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address recipient_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint vestingAmount_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint vestingBegin_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint vestingCliff_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint vestingEnd_\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vestingBegin_ >= block.timestamp, 'TreasuryVester::constructor: vesting begin too early');\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vestingCliff_ >= vestingBegin_, 'TreasuryVester::constructor: cliff is too early');\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vestingBegin_ >= block.timestamp, 'TreasuryVester::constructor: vesting begin too early');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vestingCliff_ >= vestingBegin_, 'TreasuryVester::constructor: cliff is too early');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vestingEnd_ > vestingCliff_, 'TreasuryVester::constructor: end is too early');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == recipient, 'TreasuryVester::setRecipient: unauthorized');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(block.timestamp >= vestingCliff, 'TreasuryVester::claim: not time yet');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vestingBegin_ >= block.timestamp, 'TreasuryVester::constructor: vesting begin too early');\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vestingCliff_ >= vestingBegin_, 'TreasuryVester::constructor: cliff is too early');\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vestingEnd_ > vestingCliff_, 'TreasuryVester::constructor: end is too early');\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == recipient, 'TreasuryVester::setRecipient: unauthorized');\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(block.timestamp >= vestingCliff, 'TreasuryVester::claim: not time yet');\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": 245,
                    "vulnerability_code": "    function claim() public {\n\n        require(block.timestamp >= vestingCliff, 'TreasuryVester::claim: not time yet');\n\n        uint amount;\n\n        if (block.timestamp >= vestingEnd) {\n\n            amount = IGtc(gtc).balanceOf(address(this));\n\n        } else {\n\n            amount = vestingAmount.mul(block.timestamp - lastUpdate).div(vestingEnd - vestingBegin);\n\n            lastUpdate = block.timestamp;\n\n        }\n\n        IGtc(gtc).transfer(recipient, amount);\n",
                    "message": "TreasuryVester.claim (TreasuryVester.sol#235-245) does not use the value returned by external calls:\n\t-IGtc(gtc).transfer(recipient,amount) (TreasuryVester.sol#244)\n"
                },
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 207,
                    "vulnerability_to_line": 228,
                    "vulnerability_code": "    constructor(\n\n        address gtc_,\n\n        address recipient_,\n\n        uint vestingAmount_,\n\n        uint vestingBegin_,\n\n        uint vestingCliff_,\n\n        uint vestingEnd_\n\n    ) public {\n\n        require(vestingBegin_ >= block.timestamp, 'TreasuryVester::constructor: vesting begin too early');\n\n        require(vestingCliff_ >= vestingBegin_, 'TreasuryVester::constructor: cliff is too early');\n\n        require(vestingEnd_ > vestingCliff_, 'TreasuryVester::constructor: end is too early');\n\n\n\n        gtc = gtc_;\n\n        recipient = recipient_;\n\n\n\n        vestingAmount = vestingAmount_;\n\n        vestingBegin = vestingBegin_;\n\n        vestingCliff = vestingCliff_;\n\n        vestingEnd = vestingEnd_;\n\n\n\n        lastUpdate = vestingBegin;\n",
                    "message": "TreasuryVester.constructor (TreasuryVester.sol#207-228) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool,string)(vestingBegin_ >= block.timestamp,TreasuryVester::constructor: vesting begin too early) (TreasuryVester.sol#215)\n"
                },
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": 245,
                    "vulnerability_code": "    function claim() public {\n\n        require(block.timestamp >= vestingCliff, 'TreasuryVester::claim: not time yet');\n\n        uint amount;\n\n        if (block.timestamp >= vestingEnd) {\n\n            amount = IGtc(gtc).balanceOf(address(this));\n\n        } else {\n\n            amount = vestingAmount.mul(block.timestamp - lastUpdate).div(vestingEnd - vestingBegin);\n\n            lastUpdate = block.timestamp;\n\n        }\n\n        IGtc(gtc).transfer(recipient, amount);\n",
                    "message": "TreasuryVester.claim (TreasuryVester.sol#235-245) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool,string)(block.timestamp >= vestingCliff,TreasuryVester::claim: not time yet) (TreasuryVester.sol#236)\n\t- block.timestamp >= vestingEnd (TreasuryVester.sol#238-243)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": 233,
                    "vulnerability_code": "    function setRecipient(address recipient_) public {\n\n        require(msg.sender == recipient, 'TreasuryVester::setRecipient: unauthorized');\n\n        recipient = recipient_;\n",
                    "message": "TreasuryVester.setRecipient (TreasuryVester.sol#230-233) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": 245,
                    "vulnerability_code": "    function claim() public {\n\n        require(block.timestamp >= vestingCliff, 'TreasuryVester::claim: not time yet');\n\n        uint amount;\n\n        if (block.timestamp >= vestingEnd) {\n\n            amount = IGtc(gtc).balanceOf(address(this));\n\n        } else {\n\n            amount = vestingAmount.mul(block.timestamp - lastUpdate).div(vestingEnd - vestingBegin);\n\n            lastUpdate = block.timestamp;\n\n        }\n\n        IGtc(gtc).transfer(recipient, amount);\n",
                    "message": "TreasuryVester.claim (TreasuryVester.sol#235-245) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in TreasuryVester.sol:\n\t- pragma solidity^0.5.16 (TreasuryVester.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (TreasuryVester.sol#192): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRecipient(address recipient_) public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint;\n",
                    "message": null
                }
            ]
        }
    },
    "governance-ee5e45a008d65021831de9f3e83053026f2a4dd2/contracts/SafeMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in SafeMath.sol:\n\t- pragma solidity^0.5.16 (SafeMath.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                }
            ]
        }
    },
    "governance-ee5e45a008d65021831de9f3e83053026f2a4dd2/contracts/GovernorAlpha.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address timelock_, address gtc_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        timelock = TimelockInterface(timelock_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        gtc = GTCInterface(gtc_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(gtc.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information parity mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(gtc.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(b <= a, \"subtraction underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information parity mismatch\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        proposalCount++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(gtc.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information parity mismatch\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "          require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(gtc.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_29"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": 205,
                    "vulnerability_code": "    function execute(uint proposalId) public payable {\n\n        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.executed = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n\n        }\n\n        emit ProposalExecuted(proposalId);\n",
                    "message": "GovernorAlpha.execute (GovernorAlpha.sol#197-205) sends eth to arbitrary user\n\tDangerous calls:\n\t- timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i],proposal.values[i],proposal.signatures[i],proposal.calldatas[i],proposal.eta) (GovernorAlpha.sol#202)\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": 301,
                    "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n\n        uint chainId;\n\n        assembly { chainId := chainid() }\n\n        return chainId;\n",
                    "message": "GovernorAlpha.getChainId (GovernorAlpha.sol#297-301) is declared view but contains assembly code\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 266,
                    "vulnerability_to_line": 284,
                    "vulnerability_code": "    function _castVote(address voter, uint proposalId, bool support) internal {\n\n        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        Receipt storage receipt = proposal.receipts[voter];\n\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n\n        uint96 votes = gtc.getPriorVotes(voter, proposal.startBlock);\n\n\n\n        if (support) {\n\n            proposal.forVotes = add256(proposal.forVotes, votes);\n\n        } else {\n\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n\n        }\n\n\n\n        receipt.hasVoted = true;\n\n        receipt.support = support;\n\n        receipt.votes = votes;\n\n\n\n        emit VoteCast(voter, proposalId, support, votes);\n",
                    "message": "Reentrancy in GovernorAlpha._castVote (GovernorAlpha.sol#266-284):\n\tExternal calls:\n\t- require(bool,string)(state(proposalId) == ProposalState.Active,GovernorAlpha::_castVote: voting is closed) (GovernorAlpha.sol#267)\n\t- votes = gtc.getPriorVotes(voter,proposal.startBlock) (GovernorAlpha.sol#271)\n\tState variables written after the call(s):\n\t- proposals (GovernorAlpha.sol#274)\n\t- proposals (GovernorAlpha.sol#276)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 207,
                    "vulnerability_to_line": 220,
                    "vulnerability_code": "    function cancel(uint proposalId) public {\n\n        ProposalState state = state(proposalId);\n\n        require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n\n\n        Proposal storage proposal = proposals[proposalId];\n\n        require(gtc.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\n\n\n\n        proposal.canceled = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n\n        }\n\n\n\n        emit ProposalCanceled(proposalId);\n",
                    "message": "Reentrancy in GovernorAlpha.cancel (GovernorAlpha.sol#207-220):\n\tExternal calls:\n\t- state = state(proposalId) (GovernorAlpha.sol#208)\n\t- require(bool,string)(gtc.getPriorVotes(proposal.proposer,sub256(block.number,1)) < proposalThreshold(),GovernorAlpha::cancel: proposer above threshold) (GovernorAlpha.sol#212)\n\tState variables written after the call(s):\n\t- proposals (GovernorAlpha.sol#214)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": 205,
                    "vulnerability_code": "    function execute(uint proposalId) public payable {\n\n        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.executed = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n\n        }\n\n        emit ProposalExecuted(proposalId);\n",
                    "message": "Reentrancy in GovernorAlpha.execute (GovernorAlpha.sol#197-205):\n\tExternal calls:\n\t- require(bool,string)(state(proposalId) == ProposalState.Queued,GovernorAlpha::execute: proposal can only be executed if it is queued) (GovernorAlpha.sol#198)\n\tState variables written after the call(s):\n\t- proposals (GovernorAlpha.sol#200)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\n\n        require(gtc.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information parity mismatch\");\n\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n\n        if (latestProposalId != 0) {\n\n          ProposalState proposersLatestProposalState = state(latestProposalId);\n\n          require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n\n          require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n\n        }\n\n\n\n        uint startBlock = add256(block.number, votingDelay());\n\n        uint endBlock = add256(startBlock, votingPeriod());\n\n\n\n        proposalCount++;\n\n        Proposal memory newProposal = Proposal({\n\n            id: proposalCount,\n\n            proposer: msg.sender,\n\n            eta: 0,\n\n            targets: targets,\n\n            values: values,\n\n            signatures: signatures,\n\n            calldatas: calldatas,\n\n            startBlock: startBlock,\n\n            endBlock: endBlock,\n\n            forVotes: 0,\n\n            againstVotes: 0,\n\n            canceled: false,\n\n            executed: false\n\n        });\n\n\n\n        proposals[newProposal.id] = newProposal;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n\n        return newProposal.id;\n",
                    "message": "Reentrancy in GovernorAlpha.propose (GovernorAlpha.sol#141-179):\n\tExternal calls:\n\t- require(bool,string)(gtc.getPriorVotes(msg.sender,sub256(block.number,1)) > proposalThreshold(),GovernorAlpha::propose: proposer votes below proposal threshold) (GovernorAlpha.sol#142)\n\t- proposersLatestProposalState = state(latestProposalId) (GovernorAlpha.sol#149)\n\tState variables written after the call(s):\n\t- latestProposalIds (GovernorAlpha.sol#175)\n\t- proposalCount (GovernorAlpha.sol#157)\n\t- proposals (GovernorAlpha.sol#174)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": 190,
                    "vulnerability_code": "    function queue(uint proposalId) public {\n\n        require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        uint eta = add256(block.timestamp, timelock.delay());\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n\n        }\n\n        proposal.eta = eta;\n\n        emit ProposalQueued(proposalId, eta);\n",
                    "message": "Reentrancy in GovernorAlpha.queue (GovernorAlpha.sol#181-190):\n\tExternal calls:\n\t- require(bool,string)(state(proposalId) == ProposalState.Succeeded,GovernorAlpha::queue: proposal can only be queued if it is succeeded) (GovernorAlpha.sol#182)\n\t- eta = add256(block.timestamp,timelock.delay()) (GovernorAlpha.sol#184)\n\tState variables written after the call(s):\n\t- proposals (GovernorAlpha.sol#188)\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": 195,
                    "vulnerability_code": "    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\n\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\n\n        timelock.queueTransaction(target, value, signature, data, eta);\n",
                    "message": "GovernorAlpha._queueOrRevert (GovernorAlpha.sol#192-195) does not use the value returned by external calls:\n\t-timelock.queueTransaction(target,value,signature,data,eta) (GovernorAlpha.sol#194)\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": 205,
                    "vulnerability_code": "    function execute(uint proposalId) public payable {\n\n        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.executed = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n\n        }\n\n        emit ProposalExecuted(proposalId);\n",
                    "message": "GovernorAlpha.execute (GovernorAlpha.sol#197-205) does not use the value returned by external calls:\n\t-timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i],proposal.values[i],proposal.signatures[i],proposal.calldatas[i],proposal.eta) (GovernorAlpha.sol#202)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ProposalState state = state(proposalId);\n",
                    "message": "GovernorAlpha.cancel.state (local variable @ GovernorAlpha.sol#208) shadows:\n\t- GovernorAlpha.state (function @ GovernorAlpha.sol#231-251)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n",
                    "message": "GovernorAlpha.execute has external calls inside a loop:\n\t- timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i],proposal.values[i],proposal.signatures[i],proposal.calldatas[i],proposal.eta) (GovernorAlpha.sol#202)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n",
                    "message": "GovernorAlpha.cancel has external calls inside a loop:\n\t- timelock.cancelTransaction(proposal.targets[i],proposal.values[i],proposal.signatures[i],proposal.calldatas[i],proposal.eta) (GovernorAlpha.sol#216)\n"
                },
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": 195,
                    "vulnerability_code": "    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\n\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\n\n        timelock.queueTransaction(target, value, signature, data, eta);\n",
                    "message": "GovernorAlpha._queueOrRevert (GovernorAlpha.sol#192-195) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool,string)(! timelock.queuedTransactions(keccak256(bytes)(abi.encode(target,value,signature,data,eta))),GovernorAlpha::_queueOrRevert: proposal action already queued at eta) (GovernorAlpha.sol#193)\n"
                },
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function state(uint proposalId) public view returns (ProposalState) {\n\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        if (proposal.canceled) {\n\n            return ProposalState.Canceled;\n\n        } else if (block.number <= proposal.startBlock) {\n\n            return ProposalState.Pending;\n\n        } else if (block.number <= proposal.endBlock) {\n\n            return ProposalState.Active;\n\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\n\n            return ProposalState.Defeated;\n\n        } else if (proposal.eta == 0) {\n\n            return ProposalState.Succeeded;\n\n        } else if (proposal.executed) {\n\n            return ProposalState.Executed;\n\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n\n            return ProposalState.Expired;\n\n        } else {\n\n            return ProposalState.Queued;\n\n        }\n",
                    "message": "GovernorAlpha.state (GovernorAlpha.sol#231-251) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- block.timestamp >= add256(proposal.eta,timelock.GRACE_PERIOD()) (GovernorAlpha.sol#246-250)\n"
                },
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": 290,
                    "vulnerability_code": "    function add256(uint256 a, uint256 b) internal pure returns (uint) {\n\n        uint c = a + b;\n\n        require(c >= a, \"addition overflow\");\n\n        return c;\n",
                    "message": "GovernorAlpha.add256 (GovernorAlpha.sol#286-290) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool,string)(c >= a,addition overflow) (GovernorAlpha.sol#288)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": 301,
                    "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n\n        uint chainId;\n\n        assembly { chainId := chainid() }\n\n        return chainId;\n",
                    "message": "GovernorAlpha.getChainId uses assembly (GovernorAlpha.sol#297-301)\n\t- GovernorAlpha.sol#299\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 4,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Different versions of Solidity is used in GovernorAlpha.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.16']\n\t- GovernorAlpha.sol#4 declares pragma solidity^0.5.16\n\t- GovernorAlpha.sol#5 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\n\n        require(gtc.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information parity mismatch\");\n\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n\n        if (latestProposalId != 0) {\n\n          ProposalState proposersLatestProposalState = state(latestProposalId);\n\n          require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n\n          require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n\n        }\n\n\n\n        uint startBlock = add256(block.number, votingDelay());\n\n        uint endBlock = add256(startBlock, votingPeriod());\n\n\n\n        proposalCount++;\n\n        Proposal memory newProposal = Proposal({\n\n            id: proposalCount,\n\n            proposer: msg.sender,\n\n            eta: 0,\n\n            targets: targets,\n\n            values: values,\n\n            signatures: signatures,\n\n            calldatas: calldatas,\n\n            startBlock: startBlock,\n\n            endBlock: endBlock,\n\n            forVotes: 0,\n\n            againstVotes: 0,\n\n            canceled: false,\n\n            executed: false\n\n        });\n\n\n\n        proposals[newProposal.id] = newProposal;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n\n        return newProposal.id;\n",
                    "message": "GovernorAlpha.propose (GovernorAlpha.sol#141-179) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": 190,
                    "vulnerability_code": "    function queue(uint proposalId) public {\n\n        require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        uint eta = add256(block.timestamp, timelock.delay());\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n\n        }\n\n        proposal.eta = eta;\n\n        emit ProposalQueued(proposalId, eta);\n",
                    "message": "GovernorAlpha.queue (GovernorAlpha.sol#181-190) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": 205,
                    "vulnerability_code": "    function execute(uint proposalId) public payable {\n\n        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.executed = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n\n        }\n\n        emit ProposalExecuted(proposalId);\n",
                    "message": "GovernorAlpha.execute (GovernorAlpha.sol#197-205) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 207,
                    "vulnerability_to_line": 220,
                    "vulnerability_code": "    function cancel(uint proposalId) public {\n\n        ProposalState state = state(proposalId);\n\n        require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n\n\n        Proposal storage proposal = proposals[proposalId];\n\n        require(gtc.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\n\n\n\n        proposal.canceled = true;\n\n        for (uint i = 0; i < proposal.targets.length; i++) {\n\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n\n        }\n\n\n\n        emit ProposalCanceled(proposalId);\n",
                    "message": "GovernorAlpha.cancel (GovernorAlpha.sol#207-220) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": 225,
                    "vulnerability_code": "    function getActions(uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\n\n        Proposal storage p = proposals[proposalId];\n\n        return (p.targets, p.values, p.signatures, p.calldatas);\n",
                    "message": "GovernorAlpha.getActions (GovernorAlpha.sol#222-225) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": 229,
                    "vulnerability_code": "    function getReceipt(uint proposalId, address voter) public view returns (Receipt memory) {\n\n        return proposals[proposalId].receipts[voter];\n",
                    "message": "GovernorAlpha.getReceipt (GovernorAlpha.sol#227-229) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": 255,
                    "vulnerability_code": "    function castVote(uint proposalId, bool support) public {\n\n        return _castVote(msg.sender, proposalId, support);\n",
                    "message": "GovernorAlpha.castVote (GovernorAlpha.sol#253-255) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": 264,
                    "vulnerability_code": "    function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\n\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\n        address signatory = ecrecover(digest, v, r, s);\n\n        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n\n        return _castVote(signatory, proposalId, support);\n",
                    "message": "GovernorAlpha.castVoteBySig (GovernorAlpha.sol#257-264) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 4,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in GovernorAlpha.sol:\n\t- pragma solidity^0.5.16 (GovernorAlpha.sol#4): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": 195,
                    "vulnerability_code": "    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\n\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\n\n        timelock.queueTransaction(target, value, signature, data, eta);\n",
                    "message": "Function 'GovernorAlpha._queueOrRevert' (GovernorAlpha.sol#192-195) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 266,
                    "vulnerability_to_line": 284,
                    "vulnerability_code": "    function _castVote(address voter, uint proposalId, bool support) internal {\n\n        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        Receipt storage receipt = proposal.receipts[voter];\n\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n\n        uint96 votes = gtc.getPriorVotes(voter, proposal.startBlock);\n\n\n\n        if (support) {\n\n            proposal.forVotes = add256(proposal.forVotes, votes);\n\n        } else {\n\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n\n        }\n\n\n\n        receipt.hasVoted = true;\n\n        receipt.support = support;\n\n        receipt.votes = votes;\n\n\n\n        emit VoteCast(voter, proposalId, support, votes);\n",
                    "message": "Function 'GovernorAlpha._castVote' (GovernorAlpha.sol#266-284) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function GRACE_PERIOD() external view returns (uint);\n",
                    "message": "Function 'TimelockInterface.GRACE_PERIOD' (GovernorAlpha.sol#306) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < proposal.targets.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 4,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getChainId() internal pure returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getActions(uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { chainId := chainid() }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n",
                    "message": null
                }
            ]
        }
    },
    "governance-ee5e45a008d65021831de9f3e83053026f2a4dd2/contracts/Timelock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address admin_, uint delay_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(delay_ <= MAXIMUM_DELAY, \"Timelock::constructor: Delay must not exceed maximum delay.\");\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = admin_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        delay = delay_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(delay_ <= MAXIMUM_DELAY, \"Timelock::constructor: Delay must not exceed maximum delay.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(delay_ <= MAXIMUM_DELAY, \"Timelock::constructor: Delay must not exceed maximum delay.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": 236,
                    "vulnerability_code": "    function setDelay(uint delay_) public {\n\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n        delay = delay_;\n\n\n\n        emit NewDelay(delay);\n",
                    "message": "Timelock.setDelay (Timelock.sol#229-236) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": 244,
                    "vulnerability_code": "    function acceptAdmin() public {\n\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n\n        admin = msg.sender;\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(admin);\n",
                    "message": "Timelock.acceptAdmin (Timelock.sol#238-244) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": 251,
                    "vulnerability_code": "    function setPendingAdmin(address pendingAdmin_) public {\n\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n\n        pendingAdmin = pendingAdmin_;\n\n\n\n        emit NewPendingAdmin(pendingAdmin);\n",
                    "message": "Timelock.setPendingAdmin (Timelock.sol#246-251) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": 262,
                    "vulnerability_code": "    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\n        queuedTransactions[txHash] = true;\n\n\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n\n        return txHash;\n",
                    "message": "Timelock.queueTransaction (Timelock.sol#253-262) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": 271,
                    "vulnerability_code": "    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\n\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\n        queuedTransactions[txHash] = false;\n\n\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n",
                    "message": "Timelock.cancelTransaction (Timelock.sol#264-271) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": 298,
                    "vulnerability_code": "    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n\n\n        queuedTransactions[txHash] = false;\n\n\n\n        bytes memory callData;\n\n\n\n        if (bytes(signature).length == 0) {\n\n            callData = data;\n\n        } else {\n\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n\n        }\n\n\n\n        // solium-disable-next-line security/no-call-value\n\n        (bool success, bytes memory returnData) = target.call.value(value)(callData);\n\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n\n\n        return returnData;\n",
                    "message": "Timelock.executeTransaction (Timelock.sol#273-298) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in Timelock.sol:\n\t- pragma solidity^0.5.16 (Timelock.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (Timelock.sol#192): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": 298,
                    "vulnerability_code": "    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n\n\n        queuedTransactions[txHash] = false;\n\n\n\n        bytes memory callData;\n\n\n\n        if (bytes(signature).length == 0) {\n\n            callData = data;\n\n        } else {\n\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n\n        }\n\n\n\n        // solium-disable-next-line security/no-call-value\n\n        (bool success, bytes memory returnData) = target.call.value(value)(callData);\n\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n\n\n        return returnData;\n",
                    "message": "Low level call in Timelock.executeTransaction (Timelock.sol#273-298):\n\t-(success,returnData) = target.call.value(value)(callData) Timelock.sol#292\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingAdmin = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, bytes memory returnData) = target.call.value(value)(callData);\n",
                    "message": null
                }
            ]
        }
    }
}