{
    "EasyPool-master/contracts/Migrations.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": 19,
                    "vulnerability_code": "  function setCompleted(uint completed) public restricted {\n\n    last_completed_migration = completed;\n",
                    "message": "Migrations.setCompleted (Migrations.sol#17-19) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": 24,
                    "vulnerability_code": "  function upgrade(address new_address) public restricted {\n\n    Migrations upgraded = Migrations(new_address);\n\n    upgraded.setCompleted(last_completed_migration);\n",
                    "message": "Migrations.upgrade (Migrations.sol#21-24) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.23;\n",
                    "message": "Detected issues with version pragma in Migrations.sol:\n\t- pragma solidity^0.4.23 (Migrations.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function upgrade(address new_address) public restricted {\n",
                    "message": "Parameter 'new_address' of Migrations.upgrade (Migrations.sol#21) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  uint public last_completed_migration;\n",
                    "message": "Variable 'Migrations.last_completed_migration' (Migrations.sol#7) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.23;\n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/ProPool.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 913,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < exclude.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < include.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1829,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(        \n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1830,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint maxBalance,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1831,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint minContribution,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1832,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint maxContribution,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1833,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint ctorFeePerEther,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1834,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool isRestricted,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1835,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address creatorAddress,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1836,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address presaleAddress,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address feeServiceAddr,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] whitelist,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 877,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 913,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1028,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1079,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {                        \n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < length; i++) {             \n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(poolContribution > 0 && poolContribution >= minPoolBalance);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(pool.groups.length > idx && pool.groups[idx].exists);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!participant.exists && !participant.isAdmin);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1642,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1643,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            minContribution > 0 &&\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            minContribution <= maxContribution &&\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            maxContribution <= maxBalance &&\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            maxBalance <= 1e9 ether            \n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if(ctorFee > 0 && !pool.feeToTokenMode) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            addressTransfer(msg.sender, ctorFee);            \n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1532,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if(currentBalance >= maxBalance || (isRestricted && !participant.whitelist[idx])) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            remaining = totalAmount;            \n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1535,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }        \n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 877,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 913,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1028,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1079,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {                        \n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < length; i++) {             \n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < exclude.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < include.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_48"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 1471,
                    "vulnerability_to_line": 1477,
                    "vulnerability_code": "    function addressTransfer(address destination, uint etherAmount) private {\n\n        emit AddressTransfer(\n\n            destination,\n\n            etherAmount\n\n        );\n\n        destination.transfer(etherAmount);        \n",
                    "message": "ProPoolLib.addressTransfer (ProPool.sol#1471-1477) sends eth to arbitrary user\n\tDangerous calls:\n\t- destination.transfer(etherAmount) (ProPool.sol#1476)\n"
                },
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 1489,
                    "vulnerability_to_line": 1502,
                    "vulnerability_code": "    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n\n        emit AddressCall(\n\n            destination,\n\n            etherAmount,\n\n            gasAmount > 0 ? gasAmount : gasleft(),\n\n            data\n\n        );\n\n        require(\n\n            destination.call\n\n            .gas(gasAmount > 0 ? gasAmount : gasleft())\n\n            .value(etherAmount)\n\n            (data)            \n\n        );\n",
                    "message": "ProPoolLib.addressCall (ProPool.sol#1489-1502) sends eth to arbitrary user\n\tDangerous calls:\n\t- require(bool)(destination.call.gas(gasAmount).value(etherAmount)(data)) (ProPool.sol#1496-1501)\n\t- require(bool)(destination.call.gas(gasleft()()).value(etherAmount)(data)) (ProPool.sol#1496-1501)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1024,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint amount;\n",
                    "message": "amount in ProPoolLib.withdrawAllRemaining1 (ProPool.sol#1024) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint sumRemaining; \n",
                    "message": "sumRemaining in ProPoolLib.withdrawAllRemaining2 (ProPool.sol#1074) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 969,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint amount;\n",
                    "message": "amount in ProPoolLib.withdrawAllContribution (ProPool.sol#969) is a local variable never initialiazed\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint share = calcShare(self, addr, currentAmount, fraction);\n",
                    "message": "QuotaLib.claimShare.share (local variable @ ProPool.sol#155) shadows:\n\t- QuotaLib.share (function @ ProPool.sol#186-188)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n",
                    "message": "ProPoolLib.getPoolDetails2 has external calls inside a loop:\n\t- tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this)) (ProPool.sol#850)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 914,
                    "vulnerability_to_line": 918,
                    "vulnerability_code": "                    tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(\n\n                        addr,\n\n                        IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),\n\n                        [netPartContribution, netPoolContribution]\n",
                    "message": "ProPoolLib.getParticipantShares has external calls inside a loop:\n\t- tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(addr,IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),(netPartContribution,netPoolContribution)) (ProPool.sol#914-918)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 1214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            tokenBalance = tokenContract.balanceOf(address(this));\n",
                    "message": "ProPoolLib.withdrawTokens has external calls inside a loop:\n\t- tokenBalance = tokenContract.balanceOf(address(this)) (ProPool.sol#1214)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 1227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    succeeded = tokenContract.transfer(msg.sender, tokenAmount);\n",
                    "message": "ProPoolLib.withdrawTokens has external calls inside a loop:\n\t- succeeded = tokenContract.transfer(msg.sender,tokenAmount) (ProPool.sol#1227)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tokenFallback(address from, uint value, bytes data) public;\n",
                    "message": "IERC223Receiver.tokenFallback (ProPool.sol#10) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1942,
                    "vulnerability_to_line": 1944,
                    "vulnerability_code": "    function tokenFallback(address from, uint value, bytes data) public {\n\n        pool.tokenFallback(from, value, data);\n",
                    "message": "ProPool.tokenFallback (ProPool.sol#1942-1944) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address to, uint value) public returns (bool success);\n",
                    "message": "IERC20Base.transfer (ProPool.sol#22) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address owner) public view returns (uint balance);\n",
                    "message": "IERC20Base.balanceOf (ProPool.sol#23) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getFeePerEther() public view returns(uint);\n",
                    "message": "IFeeService.getFeePerEther (ProPool.sol#35) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 432,
                    "vulnerability_code": "    function init(\n\n        Pool storage pool,           \n\n        uint maxBalance,\n\n        uint minContribution,\n\n        uint maxContribution,\n\n        uint ctorFeePerEther,\n\n        bool isRestricted,                \n\n        address creatorAddress,        \n\n        address presaleAddress,        \n\n        address feeServiceAddr,\n\n        address[] whitelist,\n\n        address[] admins\n\n    )\n\n        public \n\n    {\n\n\n\n        // Set presale address.\n\n        if(presaleAddress != address(0)) {\n\n            require(presaleAddress != address(this)); \n\n            pool.presaleAddress = presaleAddress;           \n\n            emit PresaleAddressLocked(presaleAddress);            \n\n        }\n\n                \n\n        // Set fee service contract.\n\n        pool.feeService = IFeeService(feeServiceAddr);        \n\n        pool.svcFeePerEther = pool.feeService.getFeePerEther();\n\n        require(pool.svcFeePerEther <= (1 ether / 4));\n\n        emit FeeServiceAttached(\n\n            feeServiceAddr,\n\n            pool.svcFeePerEther\n\n        );  \n\n        \n\n        // Set pool administrators.\n\n        require(creatorAddress != address(0));\n\n        addAdmin(pool, creatorAddress);\n\n        for(uint i = 0; i < admins.length; i++) {\n\n            addAdmin(pool, admins[i]);\n\n        }\n\n        \n\n        // Create first group.\n\n        setGroupSettingsCore(\n\n            pool,\n\n            0,\n\n            maxBalance,\n\n            minContribution,\n\n            maxContribution,\n\n            ctorFeePerEther,\n\n            isRestricted            \n\n        );\n\n        \n\n        // Set whitelist.\n\n        if(whitelist.length > 0) {\n\n            require(isRestricted);\n\n            modifyWhitelistCore(pool, 0, whitelist, new address[](0));\n\n        }\n",
                    "message": "ProPoolLib.init (ProPool.sol#377-432) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 438,
                    "vulnerability_to_line": 469,
                    "vulnerability_code": "    function setGroupSettings(\n\n        Pool storage pool,        \n\n        uint idx,\n\n        uint maxBalance,\n\n        uint minContribution,\n\n        uint maxContribution,\n\n        uint ctorFeePerEther,         \n\n        bool isRestricted\n\n    )\n\n        public     \n\n        onlyAdmin(pool)\n\n        onlyInState(pool, State.Open)      \n\n    {\n\n        // Group existence state.\n\n        bool exists = pool.groups[idx].exists;\n\n\n\n        // Set or update group settings.\n\n        setGroupSettingsCore(\n\n            pool,\n\n            idx,\n\n            maxBalance,\n\n            minContribution,\n\n            maxContribution,\n\n            ctorFeePerEther,\n\n            isRestricted            \n\n        );\n\n                \n\n        if(exists) {            \n\n            // Execute rebalancing.\n\n            groupRebalance(pool, idx);\n\n        }\n",
                    "message": "ProPoolLib.setGroupSettings (ProPool.sol#438-469) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 474,
                    "vulnerability_to_line": 483,
                    "vulnerability_code": "    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n\n        public \n\n        onlyAdmin(pool)\n\n        onlyInState(pool, State.Open)\n\n    {\n\n        // Modify whitelist (without relabancing).\n\n        modifyWhitelistCore(pool, idx, include, exclude); \n\n        // Execute group rebalancing.\n\n        groupRebalance(pool, idx);\n",
                    "message": "ProPoolLib.modifyWhitelist (ProPool.sol#474-483) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": 507,
                    "vulnerability_code": "    function lockPresaleAddress(Pool storage pool, address presaleAddress, bool lock)\n\n        public \n\n        onlyAdmin(pool) \n\n        onlyInState(pool, State.Open) \n\n    {        \n\n        require(presaleAddress != address(0));\n\n        require(presaleAddress != address(this));\n\n        require(pool.presaleAddress == address(0));\n\n        require(!pool.lockPresale);\n\n\n\n        // Set presale address.\n\n        pool.presaleAddress = presaleAddress;\n\n\n\n        // Lock presale address.\n\n        if(lock) {\n\n            pool.lockPresale = true;\n\n        }\n\n\n\n        emit PresaleAddressLocked(presaleAddress);\n",
                    "message": "ProPoolLib.lockPresaleAddress (ProPool.sol#488-507) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": 541,
                    "vulnerability_code": "    function confirmTokenAddress(Pool storage pool, address tokenAddress)\n\n        public\n\n        onlyAdmin(pool)\n\n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)         \n\n    {        \n\n        require(tokenAddress != address(0));\n\n        require(pool.tokenAddresses.length <= 4);\n\n        require(!contains(pool.tokenAddresses, tokenAddress));\n\n\n\n        // Get token balance for the pool address.\n\n        IERC20Base ERC20 = IERC20Base(tokenAddress);\n\n        uint balance = ERC20.balanceOf(address(this));  \n\n\n\n        // When confirming the token balance must be greater than zero.      \n\n        require(balance > 0);\n\n\n\n        // Change state of the pool if this is the first token confirmation.\n\n        if(pool.state == State.PaidToPresale) {\n\n            changeState(pool, State.Distribution);            \n\n            sendFees(pool);\n\n        } \n\n                        \n\n        // Save token address.\n\n        pool.tokenAddresses.push(tokenAddress);\n\n\n\n        emit TokenAddressConfirmed(\n\n            tokenAddress,\n\n            balance\n\n        );\n",
                    "message": "ProPoolLib.confirmTokenAddress (ProPool.sol#512-541) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 546,
                    "vulnerability_to_line": 562,
                    "vulnerability_code": "    function setRefundAddress(Pool storage pool, address refundAddress)\n\n        public\n\n        onlyAdmin(pool)\n\n        onlyInStates3(pool, State.PaidToPresale, State.Distribution, State.FullRefund)\n\n    {        \n\n        require(refundAddress != address(0));\n\n        require(pool.refundAddress != refundAddress);\n\n\n\n        // Set refund sender address.\n\n        pool.refundAddress = refundAddress;\n\n        emit RefundAddressChanged(refundAddress);\n\n\n\n        // This is full refund scenario.\n\n        if(pool.state == State.PaidToPresale) {\n\n            changeState(pool, State.FullRefund);\n\n        }\n",
                    "message": "ProPoolLib.setRefundAddress (ProPool.sol#546-562) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 567,
                    "vulnerability_to_line": 611,
                    "vulnerability_code": "    function payToPresale(\n\n        Pool storage pool,\n\n        address presaleAddress,\n\n        uint minPoolBalance,\n\n        bool feeToToken,\n\n        bytes data\n\n    )\n\n        public\n\n        onlyAdmin(pool) \n\n        onlyInState(pool, State.Open) \n\n    {\n\n        require(presaleAddress != address(0));\n\n                        \n\n        // Check if presale address is locked.\n\n        if(pool.presaleAddress == address(0)) {\n\n            pool.presaleAddress = presaleAddress;\n\n            emit PresaleAddressLocked(presaleAddress);\n\n        } else { \n\n            // If locked then destination address must be same.\n\n            require(pool.presaleAddress == presaleAddress);\n\n        }\n\n        \n\n        uint ctorFee;\n\n        uint poolRemaining;\n\n        uint poolContribution;      \n\n        // Calculate pool summaries.          \n\n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);        \n\n        require(poolContribution > 0 && poolContribution >= minPoolBalance);\n\n\n\n        // Set fee-to-token mode.\n\n        if(feeToToken) {\n\n            pool.feeToTokenMode = true;            \n\n            pool.feeToTokenAddress = msg.sender;\n\n            ctorFee = 0;\n\n        }\n\n\n\n        changeState(pool, State.PaidToPresale);\n\n\n\n        // Transafer funds.\n\n        addressCall(\n\n            pool.presaleAddress,\n\n            poolContribution - ctorFee - calcFee(poolContribution, pool.svcFeePerEther),\n\n            data\n\n        );        \n",
                    "message": "ProPoolLib.payToPresale (ProPool.sol#567-611) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": 622,
                    "vulnerability_code": "    function cancel(Pool storage pool)\n\n        public\n\n        onlyAdmin(pool) \n\n        onlyInState(pool, State.Open)\n\n    {\n\n        changeState(pool, State.Canceled);\n",
                    "message": "ProPoolLib.cancel (ProPool.sol#616-622) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 627,
                    "vulnerability_to_line": 680,
                    "vulnerability_code": "    function deposit(Pool storage pool, uint idx)\n\n        public        \n\n        onlyInState(pool, State.Open)  \n\n    {\n\n        require(msg.value > 0);\n\n        require(pool.groups.length > idx);\n\n        require(pool.groups[idx].exists);\n\n\n\n        // Get group and participant instances.\n\n        Participant storage participant = pool.participantToData[msg.sender];\n\n        Group storage group = pool.groups[idx];        \n\n\n\n        // Calculate contribution and remaining balance.\n\n        uint remaining;\n\n        uint contribution;                \n\n        (contribution, remaining) = calcContribution(\n\n            idx, \n\n            msg.value, \n\n            group.maxBalance, \n\n            group.contribution - participant.contribution[idx], \n\n            group.minContribution, \n\n            group.maxContribution, \n\n            group.isRestricted,            \n\n            participant\n\n        );\n\n\n\n        // Remaining balance must be equal to zero.\n\n        require(remaining == 0);\n\n\n\n        // Set the participant existence state.\n\n        if (!participant.exists) {\n\n            participant.exists = true;   \n\n            pool.participants.push(msg.sender);\n\n        }        \n\n\n\n        // Mark participant as whitelisted.\n\n        if(!participant.whitelist[idx]) {\n\n            participant.whitelist[idx] = true;         \n\n        }\n\n\n\n        // Update contribution and remaining balance.\n\n        group.contribution = group.contribution - participant.contribution[idx] + contribution;\n\n        group.remaining = group.remaining - participant.remaining[idx] + remaining;\n\n        participant.contribution[idx] = contribution;\n\n        participant.remaining[idx] = remaining;\n\n\n\n        emit Contribution(\n\n            msg.sender,\n\n            idx,\n\n            msg.value,\n\n            contribution,\n\n            group.contribution\n\n        );        \n",
                    "message": "ProPoolLib.deposit (ProPool.sol#627-680) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 685,
                    "vulnerability_to_line": 741,
                    "vulnerability_code": "    function withdrawAmount(Pool storage pool, uint amount, uint idx)\n\n        public\n\n        onlyInState(pool, State.Open)\n\n    {\n\n        // Get participant instance.\n\n        Participant storage participant = pool.participantToData[msg.sender];                        \n\n        uint finalAmount;\n\n        \n\n        if(amount == 0) {\n\n            // If withdrawal amount is equal to zero then withdraw entire contribution.\n\n            finalAmount = participant.contribution[idx] + participant.remaining[idx];\n\n        } else {\n\n            // Requested withdrawal amount must be equal or greater than participant \n\n            // remaining balance, but less or equal than his total contribution.\n\n            require(amount >= participant.remaining[idx]);\n\n            require(amount <= participant.contribution[idx] + participant.remaining[idx]);\n\n            finalAmount = amount;\n\n        }\n\n\n\n        require(finalAmount > 0);\n\n        \n\n        // Get group instance.\n\n        Group storage group = pool.groups[idx];\n\n\n\n        // Update group remaining balance.\n\n        group.remaining -= participant.remaining[idx];        \n\n\n\n        // Check if withdrawal amount is greater than remaining balance.\n\n        uint extra = finalAmount - participant.remaining[idx];        \n\n\n\n        // Update participant remaining balance. At this point always zero.\n\n        participant.remaining[idx] = 0;        \n\n\n\n        if(extra > 0) {\n\n            // Update group and participant contribution balance.\n\n            participant.contribution[idx] -= extra;\n\n            group.contribution -= extra;            \n\n\n\n            if(!participant.isAdmin) {\n\n                // Make sure that requested withdrawal amount won't break group settings.\n\n                require(participant.contribution[idx] >= group.minContribution);\n\n            }\n\n        }\n\n\n\n        // Transfer funds.\n\n        addressTransfer(msg.sender, finalAmount);\n\n\n\n        emit Withdrawal(\n\n            msg.sender,\n\n            finalAmount,\n\n            participant.contribution[idx],\n\n            0,\n\n            group.contribution,\n\n            group.remaining,\n\n            idx\n\n        );                        \n",
                    "message": "ProPoolLib.withdrawAmount (ProPool.sol#685-741) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 746,
                    "vulnerability_to_line": 768,
                    "vulnerability_code": "    function withdrawAll(Pool storage pool) public {\n\n\n\n        // Withdraw refund share and tokens share.\n\n        if (pool.state == State.FullRefund || pool.state == State.Distribution) {\n\n            withdrawRefundAndTokens(pool);\n\n            return;\n\n        }\n\n        \n\n        // Withdraw entire contribution balance.\n\n        if(pool.state == State.Canceled || pool.state == State.Open) {\n\n            withdrawAllContribution(pool);\n\n            return;\n\n        }            \n\n        \n\n        // Withdraw remaining balance.\n\n        if (pool.state == State.PaidToPresale) {\n\n            withdrawAllRemaining1(pool);\n\n            return;\n\n        } \n\n\n\n        // Revert transaction.\n\n        revert();\n",
                    "message": "ProPoolLib.withdrawAll (ProPool.sol#746-768) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 773,
                    "vulnerability_to_line": 783,
                    "vulnerability_code": "    function tokenFallback(Pool storage pool, address from, uint value, bytes data)\n\n        public \n\n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)\n\n    {\n\n        emit ERC223Fallback(\n\n            msg.sender,\n\n            from,\n\n            value,\n\n            data\n\n        );\n",
                    "message": "ProPoolLib.tokenFallback (ProPool.sol#773-783) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 788,
                    "vulnerability_to_line": 799,
                    "vulnerability_code": "    function acceptRefundTransfer(Pool storage pool)\n\n        public \n\n        onlyInStates2(pool, State.Distribution, State.FullRefund)  \n\n    {\n\n        require(msg.value > 0);\n\n        require(msg.sender == pool.refundAddress);\n\n\n\n        emit RefundReceived(\n\n            msg.sender, \n\n            msg.value\n\n        );\n",
                    "message": "ProPoolLib.acceptRefundTransfer (ProPool.sol#788-799) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": 827,
                    "vulnerability_code": "    function getPoolDetails1(Pool storage pool) \n\n        public view \n\n        returns (     \n\n            uint libVersion,\n\n            uint groupsCount,\n\n            uint currentState,\n\n            uint svcFeePerEther,\n\n            bool feeToTokenMode,            \n\n            address presaleAddress,\n\n            address feeToTokenAddress,            \n\n            address[] participants,\n\n            address[] admins\n\n        )\n\n    {\n\n        libVersion = version();\n\n        currentState = uint(pool.state);\n\n        groupsCount = pool.groups.length;\n\n        svcFeePerEther = pool.svcFeePerEther;\n\n        feeToTokenMode = pool.feeToTokenMode;        \n\n        presaleAddress = pool.presaleAddress;\n\n        feeToTokenAddress = pool.feeToTokenAddress;        \n\n        participants = pool.participants;\n\n        admins = pool.admins;\n",
                    "message": "ProPoolLib.getPoolDetails1 (ProPool.sol#804-827) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 832,
                    "vulnerability_to_line": 853,
                    "vulnerability_code": "    function getPoolDetails2(Pool storage pool) \n\n        public view \n\n        returns (      \n\n            uint refundBalance,\n\n            address refundAddress,\n\n            address[] tokenAddresses,\n\n            uint[] tokenBalances\n\n        )\n\n    {                                                \n\n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {                 \n\n            uint poolRemaining;\n\n            (,poolRemaining,) = calcPoolSummary(pool);\n\n            refundBalance = address(this).balance - poolRemaining;\n\n            refundAddress = pool.refundAddress;\n\n            \n\n            tokenAddresses = pool.tokenAddresses;\n\n            tokenBalances = new uint[](tokenAddresses.length);\n\n            for(uint i = 0; i < tokenAddresses.length; i++) {\n\n                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n\n            }\n\n        }\n",
                    "message": "ProPoolLib.getPoolDetails2 (ProPool.sol#832-853) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 858,
                    "vulnerability_to_line": 882,
                    "vulnerability_code": "    function getParticipantDetails(Pool storage pool, address addr)\n\n        public view \n\n        returns (\n\n            uint[] contribution,\n\n            uint[] remaining,\n\n            bool[] whitelist,\n\n            bool isAdmin,\n\n            bool exists\n\n        ) \n\n    {\n\n        Participant storage part = pool.participantToData[addr];\n\n        isAdmin = part.isAdmin;                \n\n        exists = part.exists;\n\n\n\n        uint length = pool.groups.length;\n\n        contribution = new uint[](length);\n\n        remaining = new uint[](length);\n\n        whitelist = new bool[](length);        \n\n\n\n        for(uint i = 0; i < length; i++) {\n\n            contribution[i] = part.contribution[i];\n\n            remaining[i] = part.remaining[i];\n\n            whitelist[i] = part.whitelist[i];\n\n        }                      \n",
                    "message": "ProPoolLib.getParticipantDetails (ProPool.sol#858-882) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 887,
                    "vulnerability_to_line": 922,
                    "vulnerability_code": "    function getParticipantShares(Pool storage pool, address addr) public view returns (uint[] tokenShare, uint refundShare) {       \n\n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {\n\n            uint netPoolContribution;\n\n            uint netPartContribution;\n\n            uint poolRemaining;\n\n            uint poolCtorFee;   \n\n\n\n            (netPoolContribution, netPartContribution, poolRemaining, poolCtorFee) = calcPoolSummary3(pool, addr);\n\n            tokenShare = new uint[](pool.tokenAddresses.length);\n\n\n\n            if(netPartContribution > 0) {\n\n                refundShare = pool.refundQuota.calcShare(\n\n                    addr, \n\n                    address(this).balance - poolRemaining,\n\n                    [netPartContribution, netPoolContribution]\n\n                );        \n\n            }     \n\n\n\n            if(pool.feeToTokenMode) {\n\n                netPoolContribution += poolCtorFee;\n\n                if(pool.feeToTokenAddress == addr) {\n\n                    netPartContribution += poolCtorFee;\n\n                }\n\n            }  \n\n\n\n            if(netPartContribution > 0) {\n\n                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n\n                    tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(\n\n                        addr,\n\n                        IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),\n\n                        [netPartContribution, netPoolContribution]\n\n                    );                \n\n                }      \n\n            }\n\n        }  \n",
                    "message": "ProPoolLib.getParticipantShares (ProPool.sol#887-922) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 927,
                    "vulnerability_to_line": 949,
                    "vulnerability_code": "    function getGroupDetails(Pool storage pool, uint idx)\n\n        public view \n\n        returns (\n\n            uint contributionBalance,\n\n            uint remainingBalance,\n\n            uint maxBalance,\n\n            uint minContribution,                 \n\n            uint maxContribution,\n\n            uint ctorFeePerEther,\n\n            bool isRestricted,\n\n            bool exists\n\n        ) \n\n    {\n\n        Group storage group = pool.groups[idx];                                                \n\n        contributionBalance = group.contribution;\n\n        remainingBalance = group.remaining;\n\n        maxBalance = group.maxBalance;\n\n        minContribution = group.minContribution;\n\n        maxContribution = group.maxContribution;\n\n        ctorFeePerEther = group.ctorFeePerEther;\n\n        isRestricted = group.isRestricted;\n\n        exists = group.exists;\n",
                    "message": "ProPoolLib.getGroupDetails (ProPool.sol#927-949) should be declared external\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 1489,
                    "vulnerability_to_line": 1502,
                    "vulnerability_code": "    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n\n        emit AddressCall(\n\n            destination,\n\n            etherAmount,\n\n            gasAmount > 0 ? gasAmount : gasleft(),\n\n            data\n\n        );\n\n        require(\n\n            destination.call\n\n            .gas(gasAmount > 0 ? gasAmount : gasleft())\n\n            .value(etherAmount)\n\n            (data)            \n\n        );\n",
                    "message": "Low level call in ProPoolLib.addressCall (ProPool.sol#1489-1502):\n\t-require(bool)(destination.call.gas(gasAmount).value(etherAmount)(data)) ProPool.sol#1496-1501\n\t-require(bool)(destination.call.gas(gasleft()()).value(etherAmount)(data)) ProPool.sol#1496-1501\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of Math.max (ProPool.sol#49) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of Math.max (ProPool.sol#49) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of Math.min (ProPool.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of Math.min (ProPool.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function average(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of Math.average (ProPool.sol#57) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function average(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of Math.average (ProPool.sol#57) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.mul (ProPool.sol#77) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.mul (ProPool.sol#77) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.div (ProPool.sol#94) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.div (ProPool.sol#94) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.sub (ProPool.sol#105) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.sub (ProPool.sol#105) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.add (ProPool.sol#115) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.add (ProPool.sol#115) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 913,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < exclude.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < include.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function withdrawAllRemaining2(Pool storage pool) \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calcPoolSummary(Pool storage pool) \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1580,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calcPoolSummary2(Pool storage pool, address addr) \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 877,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 913,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1028,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1079,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {                        \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < length; i++) {             \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < exclude.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < include.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract IFeeService {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 1815,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract ProPool is IERC223Receiver {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1808,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1064,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns(uint contribution, uint remaining)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1556,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1583,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tokenFallback(address from, uint value, bytes data) public;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] whitelist,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] admins\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 474,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 474,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 773,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tokenFallback(Pool storage pool, address from, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address[] participants,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 815,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address[] admins\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address[] tokenAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint[] tokenBalances\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint[] contribution,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint[] remaining,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 863,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bool[] whitelist,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 887,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getParticipantShares(Pool storage pool, address addr) public view returns (uint[] tokenShare, uint refundShare) {       \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function modifyWhitelistCore(Pool storage pool, uint idx, address[] include, address[] exclude) private {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function modifyWhitelistCore(Pool storage pool, uint idx, address[] include, address[] exclude) private {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressCall(address destination, uint etherAmount, bytes data) private {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1489,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] whitelist,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1839,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] admins\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1942,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tokenFallback(address from, uint value, bytes data) public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1817,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ProPoolLib.Pool pool;    \n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/abstract/IPoolRegistry.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/abstract/IFeeService.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getFeePerEther() public view returns(uint);\n",
                    "message": "IFeeService.getFeePerEther (IFeeService.sol#10) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract IFeeService {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/abstract/IAffiliate.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract IAffiliate {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/abstract/IPoolFactory.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/abstract/erc/IERC223Receiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tokenFallback(address from, uint value, bytes data) public;\n",
                    "message": "IERC223Receiver.tokenFallback (IERC223Receiver.sol#10) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tokenFallback(address from, uint value, bytes data) public;\n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/abstract/erc/IERC20Base.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address to, uint value) public returns (bool success);\n",
                    "message": "IERC20Base.transfer (IERC20Base.sol#10) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address owner) public view returns (uint balance);\n",
                    "message": "IERC20Base.balanceOf (IERC20Base.sol#11) should be declared external\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/zeppelin/Pausable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Pausable is Ownable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public paused = false;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 45,
                    "vulnerability_code": "    function renounceOwnership() public onlyOwner {        \n\n        emit OwnershipRenounced(owner);\n\n        owner = address(0);\n",
                    "message": "Ownable.renounceOwnership (Pausable.sol#42-45) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": 53,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        _transferOwnership(newOwner);\n",
                    "message": "Ownable.transferOwnership (Pausable.sol#51-53) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": 103,
                    "vulnerability_code": "    function pause() onlyOwner whenNotPaused public {\n\n        paused = true;\n\n        emit Pause();\n",
                    "message": "Pausable.pause (Pausable.sol#100-103) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function unpause() onlyOwner whenPaused public {\n\n        paused = false;\n\n        emit Unpause();\n",
                    "message": "Pausable.unpause (Pausable.sol#108-111) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": 63,
                    "vulnerability_code": "    function _transferOwnership(address newOwner) internal {\n\n        require(newOwner != address(0));\n\n        emit OwnershipTransferred(owner, newOwner);\n\n        owner = newOwner;\n",
                    "message": "Function 'Ownable._transferOwnership' (Pausable.sol#59-63) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/zeppelin/Ownable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 45,
                    "vulnerability_code": "    function renounceOwnership() public onlyOwner {        \n\n        emit OwnershipRenounced(owner);\n\n        owner = address(0);\n",
                    "message": "Ownable.renounceOwnership (Ownable.sol#42-45) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": 53,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        _transferOwnership(newOwner);\n",
                    "message": "Ownable.transferOwnership (Ownable.sol#51-53) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": 63,
                    "vulnerability_code": "    function _transferOwnership(address newOwner) internal {\n\n        require(newOwner != address(0));\n\n        emit OwnershipTransferred(owner, newOwner);\n\n        owner = newOwner;\n",
                    "message": "Function 'Ownable._transferOwnership' (Ownable.sol#59-63) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/zeppelin/SafeMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.mul (SafeMath.sol#15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.mul (SafeMath.sol#15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.div (SafeMath.sol#32) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.div (SafeMath.sol#32) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.sub (SafeMath.sol#43) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.sub (SafeMath.sol#43) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.add (SafeMath.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.add (SafeMath.sol#53) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/zeppelin/Math.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of Math.max (Math.sol#11) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of Math.max (Math.sol#11) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of Math.min (Math.sol#15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of Math.min (Math.sol#15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function average(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of Math.average (Math.sol#19) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function average(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of Math.average (Math.sol#19) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/zeppelin/NoEther.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract HasNoEther is Ownable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 45,
                    "vulnerability_code": "    function renounceOwnership() public onlyOwner {        \n\n        emit OwnershipRenounced(owner);\n\n        owner = address(0);\n",
                    "message": "Ownable.renounceOwnership (NoEther.sol#42-45) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": 53,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        _transferOwnership(newOwner);\n",
                    "message": "Ownable.transferOwnership (NoEther.sol#51-53) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": 63,
                    "vulnerability_code": "    function _transferOwnership(address newOwner) internal {\n\n        require(newOwner != address(0));\n\n        emit OwnershipTransferred(owner, newOwner);\n\n        owner = newOwner;\n",
                    "message": "Function 'Ownable._transferOwnership' (NoEther.sol#59-63) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/library/ProPoolLib.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 901,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < exclude.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < include.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1642,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 865,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 901,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1016,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {                        \n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < length; i++) {             \n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1583,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1642,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 582,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(poolContribution > 0 && poolContribution >= minPoolBalance);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(pool.groups.length > idx && pool.groups[idx].exists);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!participant.exists && !participant.isAdmin);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1630,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1631,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            minContribution > 0 &&\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            minContribution <= maxContribution &&\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1633,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            maxContribution <= maxBalance &&\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1634,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            maxBalance <= 1e9 ether            \n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1635,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if(ctorFee > 0 && !pool.feeToTokenMode) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            addressTransfer(msg.sender, ctorFee);            \n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if(currentBalance >= maxBalance || (isRestricted && !participant.whitelist[idx])) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1521,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            remaining = totalAmount;            \n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }        \n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 865,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 901,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1016,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {                        \n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < length; i++) {             \n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < exclude.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < include.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1583,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1642,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_46"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 1459,
                    "vulnerability_to_line": 1465,
                    "vulnerability_code": "    function addressTransfer(address destination, uint etherAmount) private {\n\n        emit AddressTransfer(\n\n            destination,\n\n            etherAmount\n\n        );\n\n        destination.transfer(etherAmount);        \n",
                    "message": "ProPoolLib.addressTransfer (ProPoolLib.sol#1459-1465) sends eth to arbitrary user\n\tDangerous calls:\n\t- destination.transfer(etherAmount) (ProPoolLib.sol#1464)\n"
                },
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 1477,
                    "vulnerability_to_line": 1490,
                    "vulnerability_code": "    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n\n        emit AddressCall(\n\n            destination,\n\n            etherAmount,\n\n            gasAmount > 0 ? gasAmount : gasleft(),\n\n            data\n\n        );\n\n        require(\n\n            destination.call\n\n            .gas(gasAmount > 0 ? gasAmount : gasleft())\n\n            .value(etherAmount)\n\n            (data)            \n\n        );\n",
                    "message": "ProPoolLib.addressCall (ProPoolLib.sol#1477-1490) sends eth to arbitrary user\n\tDangerous calls:\n\t- require(bool)(destination.call.gas(gasAmount).value(etherAmount)(data)) (ProPoolLib.sol#1484-1489)\n\t- require(bool)(destination.call.gas(gasleft()()).value(etherAmount)(data)) (ProPoolLib.sol#1484-1489)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1062,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint sumRemaining; \n",
                    "message": "sumRemaining in ProPoolLib.withdrawAllRemaining2 (ProPoolLib.sol#1062) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1012,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint amount;\n",
                    "message": "amount in ProPoolLib.withdrawAllRemaining1 (ProPoolLib.sol#1012) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint amount;\n",
                    "message": "amount in ProPoolLib.withdrawAllContribution (ProPoolLib.sol#957) is a local variable never initialiazed\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint share = calcShare(self, addr, currentAmount, fraction);\n",
                    "message": "QuotaLib.claimShare.share (local variable @ ProPoolLib.sol#143) shadows:\n\t- QuotaLib.share (function @ ProPoolLib.sol#174-176)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n",
                    "message": "ProPoolLib.getPoolDetails2 has external calls inside a loop:\n\t- tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this)) (ProPoolLib.sol#838)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 902,
                    "vulnerability_to_line": 906,
                    "vulnerability_code": "                    tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(\n\n                        addr,\n\n                        IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),\n\n                        [netPartContribution, netPoolContribution]\n",
                    "message": "ProPoolLib.getParticipantShares has external calls inside a loop:\n\t- tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(addr,IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),(netPartContribution,netPoolContribution)) (ProPoolLib.sol#902-906)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 1202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            tokenBalance = tokenContract.balanceOf(address(this));\n",
                    "message": "ProPoolLib.withdrawTokens has external calls inside a loop:\n\t- tokenBalance = tokenContract.balanceOf(address(this)) (ProPoolLib.sol#1202)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 1215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    succeeded = tokenContract.transfer(msg.sender, tokenAmount);\n",
                    "message": "ProPoolLib.withdrawTokens has external calls inside a loop:\n\t- succeeded = tokenContract.transfer(msg.sender,tokenAmount) (ProPoolLib.sol#1215)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address to, uint value) public returns (bool success);\n",
                    "message": "IERC20Base.transfer (ProPoolLib.sol#10) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address owner) public view returns (uint balance);\n",
                    "message": "IERC20Base.balanceOf (ProPoolLib.sol#11) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getFeePerEther() public view returns(uint);\n",
                    "message": "IFeeService.getFeePerEther (ProPoolLib.sol#23) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": 420,
                    "vulnerability_code": "    function init(\n\n        Pool storage pool,           \n\n        uint maxBalance,\n\n        uint minContribution,\n\n        uint maxContribution,\n\n        uint ctorFeePerEther,\n\n        bool isRestricted,                \n\n        address creatorAddress,        \n\n        address presaleAddress,        \n\n        address feeServiceAddr,\n\n        address[] whitelist,\n\n        address[] admins\n\n    )\n\n        public \n\n    {\n\n\n\n        // Set presale address.\n\n        if(presaleAddress != address(0)) {\n\n            require(presaleAddress != address(this)); \n\n            pool.presaleAddress = presaleAddress;           \n\n            emit PresaleAddressLocked(presaleAddress);            \n\n        }\n\n                \n\n        // Set fee service contract.\n\n        pool.feeService = IFeeService(feeServiceAddr);        \n\n        pool.svcFeePerEther = pool.feeService.getFeePerEther();\n\n        require(pool.svcFeePerEther <= (1 ether / 4));\n\n        emit FeeServiceAttached(\n\n            feeServiceAddr,\n\n            pool.svcFeePerEther\n\n        );  \n\n        \n\n        // Set pool administrators.\n\n        require(creatorAddress != address(0));\n\n        addAdmin(pool, creatorAddress);\n\n        for(uint i = 0; i < admins.length; i++) {\n\n            addAdmin(pool, admins[i]);\n\n        }\n\n        \n\n        // Create first group.\n\n        setGroupSettingsCore(\n\n            pool,\n\n            0,\n\n            maxBalance,\n\n            minContribution,\n\n            maxContribution,\n\n            ctorFeePerEther,\n\n            isRestricted            \n\n        );\n\n        \n\n        // Set whitelist.\n\n        if(whitelist.length > 0) {\n\n            require(isRestricted);\n\n            modifyWhitelistCore(pool, 0, whitelist, new address[](0));\n\n        }\n",
                    "message": "ProPoolLib.init (ProPoolLib.sol#365-420) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 426,
                    "vulnerability_to_line": 457,
                    "vulnerability_code": "    function setGroupSettings(\n\n        Pool storage pool,        \n\n        uint idx,\n\n        uint maxBalance,\n\n        uint minContribution,\n\n        uint maxContribution,\n\n        uint ctorFeePerEther,         \n\n        bool isRestricted\n\n    )\n\n        public     \n\n        onlyAdmin(pool)\n\n        onlyInState(pool, State.Open)      \n\n    {\n\n        // Group existence state.\n\n        bool exists = pool.groups[idx].exists;\n\n\n\n        // Set or update group settings.\n\n        setGroupSettingsCore(\n\n            pool,\n\n            idx,\n\n            maxBalance,\n\n            minContribution,\n\n            maxContribution,\n\n            ctorFeePerEther,\n\n            isRestricted            \n\n        );\n\n                \n\n        if(exists) {            \n\n            // Execute rebalancing.\n\n            groupRebalance(pool, idx);\n\n        }\n",
                    "message": "ProPoolLib.setGroupSettings (ProPoolLib.sol#426-457) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n\n        public \n\n        onlyAdmin(pool)\n\n        onlyInState(pool, State.Open)\n\n    {\n\n        // Modify whitelist (without relabancing).\n\n        modifyWhitelistCore(pool, idx, include, exclude); \n\n        // Execute group rebalancing.\n\n        groupRebalance(pool, idx);\n",
                    "message": "ProPoolLib.modifyWhitelist (ProPoolLib.sol#462-471) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 476,
                    "vulnerability_to_line": 495,
                    "vulnerability_code": "    function lockPresaleAddress(Pool storage pool, address presaleAddress, bool lock)\n\n        public \n\n        onlyAdmin(pool) \n\n        onlyInState(pool, State.Open) \n\n    {        \n\n        require(presaleAddress != address(0));\n\n        require(presaleAddress != address(this));\n\n        require(pool.presaleAddress == address(0));\n\n        require(!pool.lockPresale);\n\n\n\n        // Set presale address.\n\n        pool.presaleAddress = presaleAddress;\n\n\n\n        // Lock presale address.\n\n        if(lock) {\n\n            pool.lockPresale = true;\n\n        }\n\n\n\n        emit PresaleAddressLocked(presaleAddress);\n",
                    "message": "ProPoolLib.lockPresaleAddress (ProPoolLib.sol#476-495) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 500,
                    "vulnerability_to_line": 529,
                    "vulnerability_code": "    function confirmTokenAddress(Pool storage pool, address tokenAddress)\n\n        public\n\n        onlyAdmin(pool)\n\n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)         \n\n    {        \n\n        require(tokenAddress != address(0));\n\n        require(pool.tokenAddresses.length <= 4);\n\n        require(!contains(pool.tokenAddresses, tokenAddress));\n\n\n\n        // Get token balance for the pool address.\n\n        IERC20Base ERC20 = IERC20Base(tokenAddress);\n\n        uint balance = ERC20.balanceOf(address(this));  \n\n\n\n        // When confirming the token balance must be greater than zero.      \n\n        require(balance > 0);\n\n\n\n        // Change state of the pool if this is the first token confirmation.\n\n        if(pool.state == State.PaidToPresale) {\n\n            changeState(pool, State.Distribution);            \n\n            sendFees(pool);\n\n        } \n\n                        \n\n        // Save token address.\n\n        pool.tokenAddresses.push(tokenAddress);\n\n\n\n        emit TokenAddressConfirmed(\n\n            tokenAddress,\n\n            balance\n\n        );\n",
                    "message": "ProPoolLib.confirmTokenAddress (ProPoolLib.sol#500-529) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": 550,
                    "vulnerability_code": "    function setRefundAddress(Pool storage pool, address refundAddress)\n\n        public\n\n        onlyAdmin(pool)\n\n        onlyInStates3(pool, State.PaidToPresale, State.Distribution, State.FullRefund)\n\n    {        \n\n        require(refundAddress != address(0));\n\n        require(pool.refundAddress != refundAddress);\n\n\n\n        // Set refund sender address.\n\n        pool.refundAddress = refundAddress;\n\n        emit RefundAddressChanged(refundAddress);\n\n\n\n        // This is full refund scenario.\n\n        if(pool.state == State.PaidToPresale) {\n\n            changeState(pool, State.FullRefund);\n\n        }\n",
                    "message": "ProPoolLib.setRefundAddress (ProPoolLib.sol#534-550) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 555,
                    "vulnerability_to_line": 599,
                    "vulnerability_code": "    function payToPresale(\n\n        Pool storage pool,\n\n        address presaleAddress,\n\n        uint minPoolBalance,\n\n        bool feeToToken,\n\n        bytes data\n\n    )\n\n        public\n\n        onlyAdmin(pool) \n\n        onlyInState(pool, State.Open) \n\n    {\n\n        require(presaleAddress != address(0));\n\n                        \n\n        // Check if presale address is locked.\n\n        if(pool.presaleAddress == address(0)) {\n\n            pool.presaleAddress = presaleAddress;\n\n            emit PresaleAddressLocked(presaleAddress);\n\n        } else { \n\n            // If locked then destination address must be same.\n\n            require(pool.presaleAddress == presaleAddress);\n\n        }\n\n        \n\n        uint ctorFee;\n\n        uint poolRemaining;\n\n        uint poolContribution;      \n\n        // Calculate pool summaries.          \n\n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);        \n\n        require(poolContribution > 0 && poolContribution >= minPoolBalance);\n\n\n\n        // Set fee-to-token mode.\n\n        if(feeToToken) {\n\n            pool.feeToTokenMode = true;            \n\n            pool.feeToTokenAddress = msg.sender;\n\n            ctorFee = 0;\n\n        }\n\n\n\n        changeState(pool, State.PaidToPresale);\n\n\n\n        // Transafer funds.\n\n        addressCall(\n\n            pool.presaleAddress,\n\n            poolContribution - ctorFee - calcFee(poolContribution, pool.svcFeePerEther),\n\n            data\n\n        );        \n",
                    "message": "ProPoolLib.payToPresale (ProPoolLib.sol#555-599) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": 610,
                    "vulnerability_code": "    function cancel(Pool storage pool)\n\n        public\n\n        onlyAdmin(pool) \n\n        onlyInState(pool, State.Open)\n\n    {\n\n        changeState(pool, State.Canceled);\n",
                    "message": "ProPoolLib.cancel (ProPoolLib.sol#604-610) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 615,
                    "vulnerability_to_line": 668,
                    "vulnerability_code": "    function deposit(Pool storage pool, uint idx)\n\n        public        \n\n        onlyInState(pool, State.Open)  \n\n    {\n\n        require(msg.value > 0);\n\n        require(pool.groups.length > idx);\n\n        require(pool.groups[idx].exists);\n\n\n\n        // Get group and participant instances.\n\n        Participant storage participant = pool.participantToData[msg.sender];\n\n        Group storage group = pool.groups[idx];        \n\n\n\n        // Calculate contribution and remaining balance.\n\n        uint remaining;\n\n        uint contribution;                \n\n        (contribution, remaining) = calcContribution(\n\n            idx, \n\n            msg.value, \n\n            group.maxBalance, \n\n            group.contribution - participant.contribution[idx], \n\n            group.minContribution, \n\n            group.maxContribution, \n\n            group.isRestricted,            \n\n            participant\n\n        );\n\n\n\n        // Remaining balance must be equal to zero.\n\n        require(remaining == 0);\n\n\n\n        // Set the participant existence state.\n\n        if (!participant.exists) {\n\n            participant.exists = true;   \n\n            pool.participants.push(msg.sender);\n\n        }        \n\n\n\n        // Mark participant as whitelisted.\n\n        if(!participant.whitelist[idx]) {\n\n            participant.whitelist[idx] = true;         \n\n        }\n\n\n\n        // Update contribution and remaining balance.\n\n        group.contribution = group.contribution - participant.contribution[idx] + contribution;\n\n        group.remaining = group.remaining - participant.remaining[idx] + remaining;\n\n        participant.contribution[idx] = contribution;\n\n        participant.remaining[idx] = remaining;\n\n\n\n        emit Contribution(\n\n            msg.sender,\n\n            idx,\n\n            msg.value,\n\n            contribution,\n\n            group.contribution\n\n        );        \n",
                    "message": "ProPoolLib.deposit (ProPoolLib.sol#615-668) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 673,
                    "vulnerability_to_line": 729,
                    "vulnerability_code": "    function withdrawAmount(Pool storage pool, uint amount, uint idx)\n\n        public\n\n        onlyInState(pool, State.Open)\n\n    {\n\n        // Get participant instance.\n\n        Participant storage participant = pool.participantToData[msg.sender];                        \n\n        uint finalAmount;\n\n        \n\n        if(amount == 0) {\n\n            // If withdrawal amount is equal to zero then withdraw entire contribution.\n\n            finalAmount = participant.contribution[idx] + participant.remaining[idx];\n\n        } else {\n\n            // Requested withdrawal amount must be equal or greater than participant \n\n            // remaining balance, but less or equal than his total contribution.\n\n            require(amount >= participant.remaining[idx]);\n\n            require(amount <= participant.contribution[idx] + participant.remaining[idx]);\n\n            finalAmount = amount;\n\n        }\n\n\n\n        require(finalAmount > 0);\n\n        \n\n        // Get group instance.\n\n        Group storage group = pool.groups[idx];\n\n\n\n        // Update group remaining balance.\n\n        group.remaining -= participant.remaining[idx];        \n\n\n\n        // Check if withdrawal amount is greater than remaining balance.\n\n        uint extra = finalAmount - participant.remaining[idx];        \n\n\n\n        // Update participant remaining balance. At this point always zero.\n\n        participant.remaining[idx] = 0;        \n\n\n\n        if(extra > 0) {\n\n            // Update group and participant contribution balance.\n\n            participant.contribution[idx] -= extra;\n\n            group.contribution -= extra;            \n\n\n\n            if(!participant.isAdmin) {\n\n                // Make sure that requested withdrawal amount won't break group settings.\n\n                require(participant.contribution[idx] >= group.minContribution);\n\n            }\n\n        }\n\n\n\n        // Transfer funds.\n\n        addressTransfer(msg.sender, finalAmount);\n\n\n\n        emit Withdrawal(\n\n            msg.sender,\n\n            finalAmount,\n\n            participant.contribution[idx],\n\n            0,\n\n            group.contribution,\n\n            group.remaining,\n\n            idx\n\n        );                        \n",
                    "message": "ProPoolLib.withdrawAmount (ProPoolLib.sol#673-729) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 734,
                    "vulnerability_to_line": 756,
                    "vulnerability_code": "    function withdrawAll(Pool storage pool) public {\n\n\n\n        // Withdraw refund share and tokens share.\n\n        if (pool.state == State.FullRefund || pool.state == State.Distribution) {\n\n            withdrawRefundAndTokens(pool);\n\n            return;\n\n        }\n\n        \n\n        // Withdraw entire contribution balance.\n\n        if(pool.state == State.Canceled || pool.state == State.Open) {\n\n            withdrawAllContribution(pool);\n\n            return;\n\n        }            \n\n        \n\n        // Withdraw remaining balance.\n\n        if (pool.state == State.PaidToPresale) {\n\n            withdrawAllRemaining1(pool);\n\n            return;\n\n        } \n\n\n\n        // Revert transaction.\n\n        revert();\n",
                    "message": "ProPoolLib.withdrawAll (ProPoolLib.sol#734-756) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": 771,
                    "vulnerability_code": "    function tokenFallback(Pool storage pool, address from, uint value, bytes data)\n\n        public \n\n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)\n\n    {\n\n        emit ERC223Fallback(\n\n            msg.sender,\n\n            from,\n\n            value,\n\n            data\n\n        );\n",
                    "message": "ProPoolLib.tokenFallback (ProPoolLib.sol#761-771) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": 787,
                    "vulnerability_code": "    function acceptRefundTransfer(Pool storage pool)\n\n        public \n\n        onlyInStates2(pool, State.Distribution, State.FullRefund)  \n\n    {\n\n        require(msg.value > 0);\n\n        require(msg.sender == pool.refundAddress);\n\n\n\n        emit RefundReceived(\n\n            msg.sender, \n\n            msg.value\n\n        );\n",
                    "message": "ProPoolLib.acceptRefundTransfer (ProPoolLib.sol#776-787) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 792,
                    "vulnerability_to_line": 815,
                    "vulnerability_code": "    function getPoolDetails1(Pool storage pool) \n\n        public view \n\n        returns (     \n\n            uint libVersion,\n\n            uint groupsCount,\n\n            uint currentState,\n\n            uint svcFeePerEther,\n\n            bool feeToTokenMode,            \n\n            address presaleAddress,\n\n            address feeToTokenAddress,            \n\n            address[] participants,\n\n            address[] admins\n\n        )\n\n    {\n\n        libVersion = version();\n\n        currentState = uint(pool.state);\n\n        groupsCount = pool.groups.length;\n\n        svcFeePerEther = pool.svcFeePerEther;\n\n        feeToTokenMode = pool.feeToTokenMode;        \n\n        presaleAddress = pool.presaleAddress;\n\n        feeToTokenAddress = pool.feeToTokenAddress;        \n\n        participants = pool.participants;\n\n        admins = pool.admins;\n",
                    "message": "ProPoolLib.getPoolDetails1 (ProPoolLib.sol#792-815) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": 841,
                    "vulnerability_code": "    function getPoolDetails2(Pool storage pool) \n\n        public view \n\n        returns (      \n\n            uint refundBalance,\n\n            address refundAddress,\n\n            address[] tokenAddresses,\n\n            uint[] tokenBalances\n\n        )\n\n    {                                                \n\n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {                 \n\n            uint poolRemaining;\n\n            (,poolRemaining,) = calcPoolSummary(pool);\n\n            refundBalance = address(this).balance - poolRemaining;\n\n            refundAddress = pool.refundAddress;\n\n            \n\n            tokenAddresses = pool.tokenAddresses;\n\n            tokenBalances = new uint[](tokenAddresses.length);\n\n            for(uint i = 0; i < tokenAddresses.length; i++) {\n\n                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n\n            }\n\n        }\n",
                    "message": "ProPoolLib.getPoolDetails2 (ProPoolLib.sol#820-841) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 846,
                    "vulnerability_to_line": 870,
                    "vulnerability_code": "    function getParticipantDetails(Pool storage pool, address addr)\n\n        public view \n\n        returns (\n\n            uint[] contribution,\n\n            uint[] remaining,\n\n            bool[] whitelist,\n\n            bool isAdmin,\n\n            bool exists\n\n        ) \n\n    {\n\n        Participant storage part = pool.participantToData[addr];\n\n        isAdmin = part.isAdmin;                \n\n        exists = part.exists;\n\n\n\n        uint length = pool.groups.length;\n\n        contribution = new uint[](length);\n\n        remaining = new uint[](length);\n\n        whitelist = new bool[](length);        \n\n\n\n        for(uint i = 0; i < length; i++) {\n\n            contribution[i] = part.contribution[i];\n\n            remaining[i] = part.remaining[i];\n\n            whitelist[i] = part.whitelist[i];\n\n        }                      \n",
                    "message": "ProPoolLib.getParticipantDetails (ProPoolLib.sol#846-870) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 875,
                    "vulnerability_to_line": 910,
                    "vulnerability_code": "    function getParticipantShares(Pool storage pool, address addr) public view returns (uint[] tokenShare, uint refundShare) {       \n\n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {\n\n            uint netPoolContribution;\n\n            uint netPartContribution;\n\n            uint poolRemaining;\n\n            uint poolCtorFee;   \n\n\n\n            (netPoolContribution, netPartContribution, poolRemaining, poolCtorFee) = calcPoolSummary3(pool, addr);\n\n            tokenShare = new uint[](pool.tokenAddresses.length);\n\n\n\n            if(netPartContribution > 0) {\n\n                refundShare = pool.refundQuota.calcShare(\n\n                    addr, \n\n                    address(this).balance - poolRemaining,\n\n                    [netPartContribution, netPoolContribution]\n\n                );        \n\n            }     \n\n\n\n            if(pool.feeToTokenMode) {\n\n                netPoolContribution += poolCtorFee;\n\n                if(pool.feeToTokenAddress == addr) {\n\n                    netPartContribution += poolCtorFee;\n\n                }\n\n            }  \n\n\n\n            if(netPartContribution > 0) {\n\n                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n\n                    tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(\n\n                        addr,\n\n                        IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),\n\n                        [netPartContribution, netPoolContribution]\n\n                    );                \n\n                }      \n\n            }\n\n        }  \n",
                    "message": "ProPoolLib.getParticipantShares (ProPoolLib.sol#875-910) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 915,
                    "vulnerability_to_line": 937,
                    "vulnerability_code": "    function getGroupDetails(Pool storage pool, uint idx)\n\n        public view \n\n        returns (\n\n            uint contributionBalance,\n\n            uint remainingBalance,\n\n            uint maxBalance,\n\n            uint minContribution,                 \n\n            uint maxContribution,\n\n            uint ctorFeePerEther,\n\n            bool isRestricted,\n\n            bool exists\n\n        ) \n\n    {\n\n        Group storage group = pool.groups[idx];                                                \n\n        contributionBalance = group.contribution;\n\n        remainingBalance = group.remaining;\n\n        maxBalance = group.maxBalance;\n\n        minContribution = group.minContribution;\n\n        maxContribution = group.maxContribution;\n\n        ctorFeePerEther = group.ctorFeePerEther;\n\n        isRestricted = group.isRestricted;\n\n        exists = group.exists;\n",
                    "message": "ProPoolLib.getGroupDetails (ProPoolLib.sol#915-937) should be declared external\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 1477,
                    "vulnerability_to_line": 1490,
                    "vulnerability_code": "    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n\n        emit AddressCall(\n\n            destination,\n\n            etherAmount,\n\n            gasAmount > 0 ? gasAmount : gasleft(),\n\n            data\n\n        );\n\n        require(\n\n            destination.call\n\n            .gas(gasAmount > 0 ? gasAmount : gasleft())\n\n            .value(etherAmount)\n\n            (data)            \n\n        );\n",
                    "message": "Low level call in ProPoolLib.addressCall (ProPoolLib.sol#1477-1490):\n\t-require(bool)(destination.call.gas(gasAmount).value(etherAmount)(data)) ProPoolLib.sol#1484-1489\n\t-require(bool)(destination.call.gas(gasleft()()).value(etherAmount)(data)) ProPoolLib.sol#1484-1489\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of Math.max (ProPoolLib.sol#37) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of Math.max (ProPoolLib.sol#37) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of Math.min (ProPoolLib.sol#41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of Math.min (ProPoolLib.sol#41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function average(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of Math.average (ProPoolLib.sol#45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function average(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of Math.average (ProPoolLib.sol#45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.mul (ProPoolLib.sol#65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.mul (ProPoolLib.sol#65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.div (ProPoolLib.sol#82) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.div (ProPoolLib.sol#82) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.sub (ProPoolLib.sol#93) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.sub (ProPoolLib.sol#93) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.add (ProPoolLib.sol#103) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.add (ProPoolLib.sol#103) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 901,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < exclude.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < include.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1642,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1049,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function withdrawAllRemaining2(Pool storage pool) \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calcPoolSummary(Pool storage pool) \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calcPoolSummary2(Pool storage pool, address addr) \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 865,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 901,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1016,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {                        \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < length; i++) {             \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < exclude.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < include.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1583,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1642,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract IFeeService {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns(uint contribution, uint remaining)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] whitelist,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] admins\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tokenFallback(Pool storage pool, address from, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 802,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address[] participants,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address[] admins\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 825,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address[] tokenAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 826,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint[] tokenBalances\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint[] contribution,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint[] remaining,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bool[] whitelist,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 875,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getParticipantShares(Pool storage pool, address addr) public view returns (uint[] tokenShare, uint refundShare) {       \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function modifyWhitelistCore(Pool storage pool, uint idx, address[] include, address[] exclude) private {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function modifyWhitelistCore(Pool storage pool, uint idx, address[] include, address[] exclude) private {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressCall(address destination, uint etherAmount, bytes data) private {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1477,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/library/QuotaLib.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_9"
            ],
            "vulnerability_findings": [
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint share = calcShare(self, addr, currentAmount, fraction);\n",
                    "message": "QuotaLib.claimShare.share (local variable @ QuotaLib.sol#93) shadows:\n\t- QuotaLib.share (function @ QuotaLib.sol#124-126)\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.mul (QuotaLib.sol#15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.mul (QuotaLib.sol#15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.div (QuotaLib.sol#32) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.div (QuotaLib.sol#32) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.sub (QuotaLib.sol#43) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.sub (QuotaLib.sol#43) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.add (QuotaLib.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.add (QuotaLib.sol#53) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint;\n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/common/PoolRegistry.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract HasNoEther is Ownable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Restricted is Ownable {  \n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if(operators[i] == operator) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= lastIndex; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            creatorAddress != address(0) &&\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            creatorAddress != poolAddress\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );        \n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        operators.length--;              \n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= lastIndex; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint deleteIndex;\n",
                    "message": "deleteIndex in Restricted.removeOperator (PoolRegistry.sol#165) is a local variable never initialiazed\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function renounceOwnership() public onlyOwner {        \n\n        emit OwnershipRenounced(owner);\n\n        owner = address(0);\n",
                    "message": "Ownable.renounceOwnership (PoolRegistry.sol#61-64) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        _transferOwnership(newOwner);\n",
                    "message": "Ownable.transferOwnership (PoolRegistry.sol#70-72) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": 191,
                    "vulnerability_code": "    function getOperators() public view returns(address[]) {\n\n        return operators;\n\n    }\n",
                    "message": "Restricted.getOperators (PoolRegistry.sol#188-191) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 82,
                    "vulnerability_code": "    function _transferOwnership(address newOwner) internal {\n\n        require(newOwner != address(0));\n\n        emit OwnershipTransferred(owner, newOwner);\n\n        owner = newOwner;\n",
                    "message": "Function 'Ownable._transferOwnership' (PoolRegistry.sol#78-82) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        operators.length--;              \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getOperators() public view returns(address[]) {\n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/common/CMService.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Pausable is Ownable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract HasNoEther is Ownable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public paused = false;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": 89,
                    "vulnerability_code": "    function renounceOwnership() public onlyOwner {        \n\n        emit OwnershipRenounced(owner);\n\n        owner = address(0);\n",
                    "message": "Ownable.renounceOwnership (CMService.sol#86-89) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": 97,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        _transferOwnership(newOwner);\n",
                    "message": "Ownable.transferOwnership (CMService.sol#95-97) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": 147,
                    "vulnerability_code": "    function pause() onlyOwner whenNotPaused public {\n\n        paused = true;\n\n        emit Pause();\n",
                    "message": "Pausable.pause (CMService.sol#144-147) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": 155,
                    "vulnerability_code": "    function unpause() onlyOwner whenPaused public {\n\n        paused = false;\n\n        emit Unpause();\n",
                    "message": "Pausable.unpause (CMService.sol#152-155) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": 107,
                    "vulnerability_code": "    function _transferOwnership(address newOwner) internal {\n\n        require(newOwner != address(0));\n\n        emit OwnershipTransferred(owner, newOwner);\n\n        owner = newOwner;\n",
                    "message": "Function 'Ownable._transferOwnership' (CMService.sol#103-107) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setFeeService(address newFeeService) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setPoolFactory(address newPoolFactory) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setPoolRegistry(address newPoolRegistry) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/common/Restricted.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Restricted is Ownable {  \n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if(operators[i] == operator) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= lastIndex; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        operators.length--;              \n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= lastIndex; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint deleteIndex;\n",
                    "message": "deleteIndex in Restricted.removeOperator (Restricted.sol#105) is a local variable never initialiazed\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 45,
                    "vulnerability_code": "    function renounceOwnership() public onlyOwner {        \n\n        emit OwnershipRenounced(owner);\n\n        owner = address(0);\n",
                    "message": "Ownable.renounceOwnership (Restricted.sol#42-45) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": 53,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        _transferOwnership(newOwner);\n",
                    "message": "Ownable.transferOwnership (Restricted.sol#51-53) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": 130,
                    "vulnerability_code": "    function getOperators() public view returns(address[]) {\n\n        return operators;\n",
                    "message": "Restricted.getOperators (Restricted.sol#128-130) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": 63,
                    "vulnerability_code": "    function _transferOwnership(address newOwner) internal {\n\n        require(newOwner != address(0));\n\n        emit OwnershipTransferred(owner, newOwner);\n\n        owner = newOwner;\n",
                    "message": "Function 'Ownable._transferOwnership' (Restricted.sol#59-63) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        operators.length--;              \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getOperators() public view returns(address[]) {\n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/common/FeeService.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract FeeService is IFeeService, Ownable {     \n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if(success && sharePerEther > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(sharePerEther <= 1 ether);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                affShare = (msg.value * sharePerEther) / 1 ether;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if(affShare > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    affiliate.sendRevenueShare.value(affShare)(poolCreator);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }            \n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_14"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint affShare;\n",
                    "message": "affShare in FeeService.sendFee (FeeService.sol#187) is a local variable never initialiazed\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 236,
                    "vulnerability_to_line": 238,
                    "vulnerability_code": "    function getFeePerEther() public view returns(uint) {\n\n        return feePerEther;\n",
                    "message": "FeeService.getFeePerEther (FeeService.sol#236-238) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getFeePerEther() public view returns(uint);\n",
                    "message": "IFeeService.getFeePerEther (FeeService.sol#10) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": 140,
                    "vulnerability_code": "    function renounceOwnership() public onlyOwner {        \n\n        emit OwnershipRenounced(owner);\n\n        owner = address(0);\n",
                    "message": "Ownable.renounceOwnership (FeeService.sol#137-140) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": 148,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        _transferOwnership(newOwner);\n",
                    "message": "Ownable.transferOwnership (FeeService.sol#146-148) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.mul (FeeService.sol#41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.mul (FeeService.sol#41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.div (FeeService.sol#58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.div (FeeService.sol#58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.sub (FeeService.sol#69) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.sub (FeeService.sol#69) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.add (FeeService.sol#79) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.add (FeeService.sol#79) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": 158,
                    "vulnerability_code": "    function _transferOwnership(address newOwner) internal {\n\n        require(newOwner != address(0));\n\n        emit OwnershipTransferred(owner, newOwner);\n\n        owner = newOwner;\n",
                    "message": "Function 'Ownable._transferOwnership' (FeeService.sol#154-158) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract IFeeService {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract IAffiliate {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setFeePerEther(uint newFeePerEther) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setAffiliate(address newAffiliate) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/common/PoolFactory.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 2270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract HasNoEther is Ownable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 2304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Restricted is Ownable {  \n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 913,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < exclude.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < include.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1829,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(        \n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1830,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint maxBalance,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1831,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint minContribution,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1832,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint maxContribution,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1833,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint ctorFeePerEther,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1834,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool isRestricted,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1835,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address creatorAddress,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1836,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address presaleAddress,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address feeServiceAddr,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] whitelist,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 2339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if(operators[i] == operator) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 877,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 913,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1028,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1079,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {                        \n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < length; i++) {             \n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 2338,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= lastIndex; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(poolContribution > 0 && poolContribution >= minPoolBalance);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(pool.groups.length > idx && pool.groups[idx].exists);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!participant.exists && !participant.isAdmin);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1642,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1643,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            minContribution > 0 &&\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            minContribution <= maxContribution &&\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            maxContribution <= maxBalance &&\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            maxBalance <= 1e9 ether            \n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if(ctorFee > 0 && !pool.feeToTokenMode) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            addressTransfer(msg.sender, ctorFee);            \n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1532,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if(currentBalance >= maxBalance || (isRestricted && !participant.whitelist[idx])) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            remaining = totalAmount;            \n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1535,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }        \n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 2350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        operators.length--;              \n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 877,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 913,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1028,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1079,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {                        \n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < length; i++) {             \n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < exclude.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < include.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2338,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= lastIndex; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_53"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 1471,
                    "vulnerability_to_line": 1477,
                    "vulnerability_code": "    function addressTransfer(address destination, uint etherAmount) private {\n\n        emit AddressTransfer(\n\n            destination,\n\n            etherAmount\n\n        );\n\n        destination.transfer(etherAmount);        \n",
                    "message": "ProPoolLib.addressTransfer (PoolFactory.sol#1471-1477) sends eth to arbitrary user\n\tDangerous calls:\n\t- destination.transfer(etherAmount) (PoolFactory.sol#1476)\n"
                },
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 1489,
                    "vulnerability_to_line": 1502,
                    "vulnerability_code": "    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n\n        emit AddressCall(\n\n            destination,\n\n            etherAmount,\n\n            gasAmount > 0 ? gasAmount : gasleft(),\n\n            data\n\n        );\n\n        require(\n\n            destination.call\n\n            .gas(gasAmount > 0 ? gasAmount : gasleft())\n\n            .value(etherAmount)\n\n            (data)            \n\n        );\n",
                    "message": "ProPoolLib.addressCall (PoolFactory.sol#1489-1502) sends eth to arbitrary user\n\tDangerous calls:\n\t- require(bool)(destination.call.gas(gasAmount).value(etherAmount)(data)) (PoolFactory.sol#1496-1501)\n\t- require(bool)(destination.call.gas(gasleft()()).value(etherAmount)(data)) (PoolFactory.sol#1496-1501)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1024,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint amount;\n",
                    "message": "amount in ProPoolLib.withdrawAllRemaining1 (PoolFactory.sol#1024) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint sumRemaining; \n",
                    "message": "sumRemaining in ProPoolLib.withdrawAllRemaining2 (PoolFactory.sol#1074) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 969,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint amount;\n",
                    "message": "amount in ProPoolLib.withdrawAllContribution (PoolFactory.sol#969) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 2336,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint deleteIndex;\n",
                    "message": "deleteIndex in Restricted.removeOperator (PoolFactory.sol#2336) is a local variable never initialiazed\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint share = calcShare(self, addr, currentAmount, fraction);\n",
                    "message": "QuotaLib.claimShare.share (local variable @ PoolFactory.sol#155) shadows:\n\t- QuotaLib.share (function @ PoolFactory.sol#186-188)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n",
                    "message": "ProPoolLib.getPoolDetails2 has external calls inside a loop:\n\t- tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this)) (PoolFactory.sol#850)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 914,
                    "vulnerability_to_line": 918,
                    "vulnerability_code": "                    tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(\n\n                        addr,\n\n                        IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),\n\n                        [netPartContribution, netPoolContribution]\n",
                    "message": "ProPoolLib.getParticipantShares has external calls inside a loop:\n\t- tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(addr,IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),(netPartContribution,netPoolContribution)) (PoolFactory.sol#914-918)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 1214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            tokenBalance = tokenContract.balanceOf(address(this));\n",
                    "message": "ProPoolLib.withdrawTokens has external calls inside a loop:\n\t- tokenBalance = tokenContract.balanceOf(address(this)) (PoolFactory.sol#1214)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 1227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    succeeded = tokenContract.transfer(msg.sender, tokenAmount);\n",
                    "message": "ProPoolLib.withdrawTokens has external calls inside a loop:\n\t- succeeded = tokenContract.transfer(msg.sender,tokenAmount) (PoolFactory.sol#1227)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1942,
                    "vulnerability_to_line": 1944,
                    "vulnerability_code": "    function tokenFallback(address from, uint value, bytes data) public {\n\n        pool.tokenFallback(from, value, data);\n",
                    "message": "ProPool.tokenFallback (PoolFactory.sol#1942-1944) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tokenFallback(address from, uint value, bytes data) public;\n",
                    "message": "IERC223Receiver.tokenFallback (PoolFactory.sol#10) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address to, uint value) public returns (bool success);\n",
                    "message": "IERC20Base.transfer (PoolFactory.sol#22) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address owner) public view returns (uint balance);\n",
                    "message": "IERC20Base.balanceOf (PoolFactory.sol#23) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getFeePerEther() public view returns(uint);\n",
                    "message": "IFeeService.getFeePerEther (PoolFactory.sol#35) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": 432,
                    "vulnerability_code": "    function init(\n\n        Pool storage pool,           \n\n        uint maxBalance,\n\n        uint minContribution,\n\n        uint maxContribution,\n\n        uint ctorFeePerEther,\n\n        bool isRestricted,                \n\n        address creatorAddress,        \n\n        address presaleAddress,        \n\n        address feeServiceAddr,\n\n        address[] whitelist,\n\n        address[] admins\n\n    )\n\n        public \n\n    {\n\n\n\n        // Set presale address.\n\n        if(presaleAddress != address(0)) {\n\n            require(presaleAddress != address(this)); \n\n            pool.presaleAddress = presaleAddress;           \n\n            emit PresaleAddressLocked(presaleAddress);            \n\n        }\n\n                \n\n        // Set fee service contract.\n\n        pool.feeService = IFeeService(feeServiceAddr);        \n\n        pool.svcFeePerEther = pool.feeService.getFeePerEther();\n\n        require(pool.svcFeePerEther <= (1 ether / 4));\n\n        emit FeeServiceAttached(\n\n            feeServiceAddr,\n\n            pool.svcFeePerEther\n\n        );  \n\n        \n\n        // Set pool administrators.\n\n        require(creatorAddress != address(0));\n\n        addAdmin(pool, creatorAddress);\n\n        for(uint i = 0; i < admins.length; i++) {\n\n            addAdmin(pool, admins[i]);\n\n        }\n\n        \n\n        // Create first group.\n\n        setGroupSettingsCore(\n\n            pool,\n\n            0,\n\n            maxBalance,\n\n            minContribution,\n\n            maxContribution,\n\n            ctorFeePerEther,\n\n            isRestricted            \n\n        );\n\n        \n\n        // Set whitelist.\n\n        if(whitelist.length > 0) {\n\n            require(isRestricted);\n\n            modifyWhitelistCore(pool, 0, whitelist, new address[](0));\n\n        }\n",
                    "message": "ProPoolLib.init (PoolFactory.sol#377-432) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 438,
                    "vulnerability_to_line": 469,
                    "vulnerability_code": "    function setGroupSettings(\n\n        Pool storage pool,        \n\n        uint idx,\n\n        uint maxBalance,\n\n        uint minContribution,\n\n        uint maxContribution,\n\n        uint ctorFeePerEther,         \n\n        bool isRestricted\n\n    )\n\n        public     \n\n        onlyAdmin(pool)\n\n        onlyInState(pool, State.Open)      \n\n    {\n\n        // Group existence state.\n\n        bool exists = pool.groups[idx].exists;\n\n\n\n        // Set or update group settings.\n\n        setGroupSettingsCore(\n\n            pool,\n\n            idx,\n\n            maxBalance,\n\n            minContribution,\n\n            maxContribution,\n\n            ctorFeePerEther,\n\n            isRestricted            \n\n        );\n\n                \n\n        if(exists) {            \n\n            // Execute rebalancing.\n\n            groupRebalance(pool, idx);\n\n        }\n",
                    "message": "ProPoolLib.setGroupSettings (PoolFactory.sol#438-469) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 474,
                    "vulnerability_to_line": 483,
                    "vulnerability_code": "    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n\n        public \n\n        onlyAdmin(pool)\n\n        onlyInState(pool, State.Open)\n\n    {\n\n        // Modify whitelist (without relabancing).\n\n        modifyWhitelistCore(pool, idx, include, exclude); \n\n        // Execute group rebalancing.\n\n        groupRebalance(pool, idx);\n",
                    "message": "ProPoolLib.modifyWhitelist (PoolFactory.sol#474-483) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": 507,
                    "vulnerability_code": "    function lockPresaleAddress(Pool storage pool, address presaleAddress, bool lock)\n\n        public \n\n        onlyAdmin(pool) \n\n        onlyInState(pool, State.Open) \n\n    {        \n\n        require(presaleAddress != address(0));\n\n        require(presaleAddress != address(this));\n\n        require(pool.presaleAddress == address(0));\n\n        require(!pool.lockPresale);\n\n\n\n        // Set presale address.\n\n        pool.presaleAddress = presaleAddress;\n\n\n\n        // Lock presale address.\n\n        if(lock) {\n\n            pool.lockPresale = true;\n\n        }\n\n\n\n        emit PresaleAddressLocked(presaleAddress);\n",
                    "message": "ProPoolLib.lockPresaleAddress (PoolFactory.sol#488-507) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": 541,
                    "vulnerability_code": "    function confirmTokenAddress(Pool storage pool, address tokenAddress)\n\n        public\n\n        onlyAdmin(pool)\n\n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)         \n\n    {        \n\n        require(tokenAddress != address(0));\n\n        require(pool.tokenAddresses.length <= 4);\n\n        require(!contains(pool.tokenAddresses, tokenAddress));\n\n\n\n        // Get token balance for the pool address.\n\n        IERC20Base ERC20 = IERC20Base(tokenAddress);\n\n        uint balance = ERC20.balanceOf(address(this));  \n\n\n\n        // When confirming the token balance must be greater than zero.      \n\n        require(balance > 0);\n\n\n\n        // Change state of the pool if this is the first token confirmation.\n\n        if(pool.state == State.PaidToPresale) {\n\n            changeState(pool, State.Distribution);            \n\n            sendFees(pool);\n\n        } \n\n                        \n\n        // Save token address.\n\n        pool.tokenAddresses.push(tokenAddress);\n\n\n\n        emit TokenAddressConfirmed(\n\n            tokenAddress,\n\n            balance\n\n        );\n",
                    "message": "ProPoolLib.confirmTokenAddress (PoolFactory.sol#512-541) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 546,
                    "vulnerability_to_line": 562,
                    "vulnerability_code": "    function setRefundAddress(Pool storage pool, address refundAddress)\n\n        public\n\n        onlyAdmin(pool)\n\n        onlyInStates3(pool, State.PaidToPresale, State.Distribution, State.FullRefund)\n\n    {        \n\n        require(refundAddress != address(0));\n\n        require(pool.refundAddress != refundAddress);\n\n\n\n        // Set refund sender address.\n\n        pool.refundAddress = refundAddress;\n\n        emit RefundAddressChanged(refundAddress);\n\n\n\n        // This is full refund scenario.\n\n        if(pool.state == State.PaidToPresale) {\n\n            changeState(pool, State.FullRefund);\n\n        }\n",
                    "message": "ProPoolLib.setRefundAddress (PoolFactory.sol#546-562) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 567,
                    "vulnerability_to_line": 611,
                    "vulnerability_code": "    function payToPresale(\n\n        Pool storage pool,\n\n        address presaleAddress,\n\n        uint minPoolBalance,\n\n        bool feeToToken,\n\n        bytes data\n\n    )\n\n        public\n\n        onlyAdmin(pool) \n\n        onlyInState(pool, State.Open) \n\n    {\n\n        require(presaleAddress != address(0));\n\n                        \n\n        // Check if presale address is locked.\n\n        if(pool.presaleAddress == address(0)) {\n\n            pool.presaleAddress = presaleAddress;\n\n            emit PresaleAddressLocked(presaleAddress);\n\n        } else { \n\n            // If locked then destination address must be same.\n\n            require(pool.presaleAddress == presaleAddress);\n\n        }\n\n        \n\n        uint ctorFee;\n\n        uint poolRemaining;\n\n        uint poolContribution;      \n\n        // Calculate pool summaries.          \n\n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);        \n\n        require(poolContribution > 0 && poolContribution >= minPoolBalance);\n\n\n\n        // Set fee-to-token mode.\n\n        if(feeToToken) {\n\n            pool.feeToTokenMode = true;            \n\n            pool.feeToTokenAddress = msg.sender;\n\n            ctorFee = 0;\n\n        }\n\n\n\n        changeState(pool, State.PaidToPresale);\n\n\n\n        // Transafer funds.\n\n        addressCall(\n\n            pool.presaleAddress,\n\n            poolContribution - ctorFee - calcFee(poolContribution, pool.svcFeePerEther),\n\n            data\n\n        );        \n",
                    "message": "ProPoolLib.payToPresale (PoolFactory.sol#567-611) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": 622,
                    "vulnerability_code": "    function cancel(Pool storage pool)\n\n        public\n\n        onlyAdmin(pool) \n\n        onlyInState(pool, State.Open)\n\n    {\n\n        changeState(pool, State.Canceled);\n",
                    "message": "ProPoolLib.cancel (PoolFactory.sol#616-622) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 627,
                    "vulnerability_to_line": 680,
                    "vulnerability_code": "    function deposit(Pool storage pool, uint idx)\n\n        public        \n\n        onlyInState(pool, State.Open)  \n\n    {\n\n        require(msg.value > 0);\n\n        require(pool.groups.length > idx);\n\n        require(pool.groups[idx].exists);\n\n\n\n        // Get group and participant instances.\n\n        Participant storage participant = pool.participantToData[msg.sender];\n\n        Group storage group = pool.groups[idx];        \n\n\n\n        // Calculate contribution and remaining balance.\n\n        uint remaining;\n\n        uint contribution;                \n\n        (contribution, remaining) = calcContribution(\n\n            idx, \n\n            msg.value, \n\n            group.maxBalance, \n\n            group.contribution - participant.contribution[idx], \n\n            group.minContribution, \n\n            group.maxContribution, \n\n            group.isRestricted,            \n\n            participant\n\n        );\n\n\n\n        // Remaining balance must be equal to zero.\n\n        require(remaining == 0);\n\n\n\n        // Set the participant existence state.\n\n        if (!participant.exists) {\n\n            participant.exists = true;   \n\n            pool.participants.push(msg.sender);\n\n        }        \n\n\n\n        // Mark participant as whitelisted.\n\n        if(!participant.whitelist[idx]) {\n\n            participant.whitelist[idx] = true;         \n\n        }\n\n\n\n        // Update contribution and remaining balance.\n\n        group.contribution = group.contribution - participant.contribution[idx] + contribution;\n\n        group.remaining = group.remaining - participant.remaining[idx] + remaining;\n\n        participant.contribution[idx] = contribution;\n\n        participant.remaining[idx] = remaining;\n\n\n\n        emit Contribution(\n\n            msg.sender,\n\n            idx,\n\n            msg.value,\n\n            contribution,\n\n            group.contribution\n\n        );        \n",
                    "message": "ProPoolLib.deposit (PoolFactory.sol#627-680) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 685,
                    "vulnerability_to_line": 741,
                    "vulnerability_code": "    function withdrawAmount(Pool storage pool, uint amount, uint idx)\n\n        public\n\n        onlyInState(pool, State.Open)\n\n    {\n\n        // Get participant instance.\n\n        Participant storage participant = pool.participantToData[msg.sender];                        \n\n        uint finalAmount;\n\n        \n\n        if(amount == 0) {\n\n            // If withdrawal amount is equal to zero then withdraw entire contribution.\n\n            finalAmount = participant.contribution[idx] + participant.remaining[idx];\n\n        } else {\n\n            // Requested withdrawal amount must be equal or greater than participant \n\n            // remaining balance, but less or equal than his total contribution.\n\n            require(amount >= participant.remaining[idx]);\n\n            require(amount <= participant.contribution[idx] + participant.remaining[idx]);\n\n            finalAmount = amount;\n\n        }\n\n\n\n        require(finalAmount > 0);\n\n        \n\n        // Get group instance.\n\n        Group storage group = pool.groups[idx];\n\n\n\n        // Update group remaining balance.\n\n        group.remaining -= participant.remaining[idx];        \n\n\n\n        // Check if withdrawal amount is greater than remaining balance.\n\n        uint extra = finalAmount - participant.remaining[idx];        \n\n\n\n        // Update participant remaining balance. At this point always zero.\n\n        participant.remaining[idx] = 0;        \n\n\n\n        if(extra > 0) {\n\n            // Update group and participant contribution balance.\n\n            participant.contribution[idx] -= extra;\n\n            group.contribution -= extra;            \n\n\n\n            if(!participant.isAdmin) {\n\n                // Make sure that requested withdrawal amount won't break group settings.\n\n                require(participant.contribution[idx] >= group.minContribution);\n\n            }\n\n        }\n\n\n\n        // Transfer funds.\n\n        addressTransfer(msg.sender, finalAmount);\n\n\n\n        emit Withdrawal(\n\n            msg.sender,\n\n            finalAmount,\n\n            participant.contribution[idx],\n\n            0,\n\n            group.contribution,\n\n            group.remaining,\n\n            idx\n\n        );                        \n",
                    "message": "ProPoolLib.withdrawAmount (PoolFactory.sol#685-741) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 746,
                    "vulnerability_to_line": 768,
                    "vulnerability_code": "    function withdrawAll(Pool storage pool) public {\n\n\n\n        // Withdraw refund share and tokens share.\n\n        if (pool.state == State.FullRefund || pool.state == State.Distribution) {\n\n            withdrawRefundAndTokens(pool);\n\n            return;\n\n        }\n\n        \n\n        // Withdraw entire contribution balance.\n\n        if(pool.state == State.Canceled || pool.state == State.Open) {\n\n            withdrawAllContribution(pool);\n\n            return;\n\n        }            \n\n        \n\n        // Withdraw remaining balance.\n\n        if (pool.state == State.PaidToPresale) {\n\n            withdrawAllRemaining1(pool);\n\n            return;\n\n        } \n\n\n\n        // Revert transaction.\n\n        revert();\n",
                    "message": "ProPoolLib.withdrawAll (PoolFactory.sol#746-768) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 773,
                    "vulnerability_to_line": 783,
                    "vulnerability_code": "    function tokenFallback(Pool storage pool, address from, uint value, bytes data)\n\n        public \n\n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)\n\n    {\n\n        emit ERC223Fallback(\n\n            msg.sender,\n\n            from,\n\n            value,\n\n            data\n\n        );\n",
                    "message": "ProPoolLib.tokenFallback (PoolFactory.sol#773-783) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 788,
                    "vulnerability_to_line": 799,
                    "vulnerability_code": "    function acceptRefundTransfer(Pool storage pool)\n\n        public \n\n        onlyInStates2(pool, State.Distribution, State.FullRefund)  \n\n    {\n\n        require(msg.value > 0);\n\n        require(msg.sender == pool.refundAddress);\n\n\n\n        emit RefundReceived(\n\n            msg.sender, \n\n            msg.value\n\n        );\n",
                    "message": "ProPoolLib.acceptRefundTransfer (PoolFactory.sol#788-799) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": 827,
                    "vulnerability_code": "    function getPoolDetails1(Pool storage pool) \n\n        public view \n\n        returns (     \n\n            uint libVersion,\n\n            uint groupsCount,\n\n            uint currentState,\n\n            uint svcFeePerEther,\n\n            bool feeToTokenMode,            \n\n            address presaleAddress,\n\n            address feeToTokenAddress,            \n\n            address[] participants,\n\n            address[] admins\n\n        )\n\n    {\n\n        libVersion = version();\n\n        currentState = uint(pool.state);\n\n        groupsCount = pool.groups.length;\n\n        svcFeePerEther = pool.svcFeePerEther;\n\n        feeToTokenMode = pool.feeToTokenMode;        \n\n        presaleAddress = pool.presaleAddress;\n\n        feeToTokenAddress = pool.feeToTokenAddress;        \n\n        participants = pool.participants;\n\n        admins = pool.admins;\n",
                    "message": "ProPoolLib.getPoolDetails1 (PoolFactory.sol#804-827) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 832,
                    "vulnerability_to_line": 853,
                    "vulnerability_code": "    function getPoolDetails2(Pool storage pool) \n\n        public view \n\n        returns (      \n\n            uint refundBalance,\n\n            address refundAddress,\n\n            address[] tokenAddresses,\n\n            uint[] tokenBalances\n\n        )\n\n    {                                                \n\n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {                 \n\n            uint poolRemaining;\n\n            (,poolRemaining,) = calcPoolSummary(pool);\n\n            refundBalance = address(this).balance - poolRemaining;\n\n            refundAddress = pool.refundAddress;\n\n            \n\n            tokenAddresses = pool.tokenAddresses;\n\n            tokenBalances = new uint[](tokenAddresses.length);\n\n            for(uint i = 0; i < tokenAddresses.length; i++) {\n\n                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n\n            }\n\n        }\n",
                    "message": "ProPoolLib.getPoolDetails2 (PoolFactory.sol#832-853) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 858,
                    "vulnerability_to_line": 882,
                    "vulnerability_code": "    function getParticipantDetails(Pool storage pool, address addr)\n\n        public view \n\n        returns (\n\n            uint[] contribution,\n\n            uint[] remaining,\n\n            bool[] whitelist,\n\n            bool isAdmin,\n\n            bool exists\n\n        ) \n\n    {\n\n        Participant storage part = pool.participantToData[addr];\n\n        isAdmin = part.isAdmin;                \n\n        exists = part.exists;\n\n\n\n        uint length = pool.groups.length;\n\n        contribution = new uint[](length);\n\n        remaining = new uint[](length);\n\n        whitelist = new bool[](length);        \n\n\n\n        for(uint i = 0; i < length; i++) {\n\n            contribution[i] = part.contribution[i];\n\n            remaining[i] = part.remaining[i];\n\n            whitelist[i] = part.whitelist[i];\n\n        }                      \n",
                    "message": "ProPoolLib.getParticipantDetails (PoolFactory.sol#858-882) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 887,
                    "vulnerability_to_line": 922,
                    "vulnerability_code": "    function getParticipantShares(Pool storage pool, address addr) public view returns (uint[] tokenShare, uint refundShare) {       \n\n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {\n\n            uint netPoolContribution;\n\n            uint netPartContribution;\n\n            uint poolRemaining;\n\n            uint poolCtorFee;   \n\n\n\n            (netPoolContribution, netPartContribution, poolRemaining, poolCtorFee) = calcPoolSummary3(pool, addr);\n\n            tokenShare = new uint[](pool.tokenAddresses.length);\n\n\n\n            if(netPartContribution > 0) {\n\n                refundShare = pool.refundQuota.calcShare(\n\n                    addr, \n\n                    address(this).balance - poolRemaining,\n\n                    [netPartContribution, netPoolContribution]\n\n                );        \n\n            }     \n\n\n\n            if(pool.feeToTokenMode) {\n\n                netPoolContribution += poolCtorFee;\n\n                if(pool.feeToTokenAddress == addr) {\n\n                    netPartContribution += poolCtorFee;\n\n                }\n\n            }  \n\n\n\n            if(netPartContribution > 0) {\n\n                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n\n                    tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(\n\n                        addr,\n\n                        IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),\n\n                        [netPartContribution, netPoolContribution]\n\n                    );                \n\n                }      \n\n            }\n\n        }  \n",
                    "message": "ProPoolLib.getParticipantShares (PoolFactory.sol#887-922) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 927,
                    "vulnerability_to_line": 949,
                    "vulnerability_code": "    function getGroupDetails(Pool storage pool, uint idx)\n\n        public view \n\n        returns (\n\n            uint contributionBalance,\n\n            uint remainingBalance,\n\n            uint maxBalance,\n\n            uint minContribution,                 \n\n            uint maxContribution,\n\n            uint ctorFeePerEther,\n\n            bool isRestricted,\n\n            bool exists\n\n        ) \n\n    {\n\n        Group storage group = pool.groups[idx];                                                \n\n        contributionBalance = group.contribution;\n\n        remainingBalance = group.remaining;\n\n        maxBalance = group.maxBalance;\n\n        minContribution = group.minContribution;\n\n        maxContribution = group.maxContribution;\n\n        ctorFeePerEther = group.ctorFeePerEther;\n\n        isRestricted = group.isRestricted;\n\n        exists = group.exists;\n",
                    "message": "ProPoolLib.getGroupDetails (PoolFactory.sol#927-949) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2232,
                    "vulnerability_to_line": 2235,
                    "vulnerability_code": "    function renounceOwnership() public onlyOwner {        \n\n        emit OwnershipRenounced(owner);\n\n        owner = address(0);\n",
                    "message": "Ownable.renounceOwnership (PoolFactory.sol#2232-2235) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2241,
                    "vulnerability_to_line": 2243,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        _transferOwnership(newOwner);\n",
                    "message": "Ownable.transferOwnership (PoolFactory.sol#2241-2243) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2359,
                    "vulnerability_to_line": 2362,
                    "vulnerability_code": "    function getOperators() public view returns(address[]) {\n\n        return operators;\n\n    }\n",
                    "message": "Restricted.getOperators (PoolFactory.sol#2359-2362) should be declared external\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 1489,
                    "vulnerability_to_line": 1502,
                    "vulnerability_code": "    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n\n        emit AddressCall(\n\n            destination,\n\n            etherAmount,\n\n            gasAmount > 0 ? gasAmount : gasleft(),\n\n            data\n\n        );\n\n        require(\n\n            destination.call\n\n            .gas(gasAmount > 0 ? gasAmount : gasleft())\n\n            .value(etherAmount)\n\n            (data)            \n\n        );\n",
                    "message": "Low level call in ProPoolLib.addressCall (PoolFactory.sol#1489-1502):\n\t-require(bool)(destination.call.gas(gasAmount).value(etherAmount)(data)) PoolFactory.sol#1496-1501\n\t-require(bool)(destination.call.gas(gasleft()()).value(etherAmount)(data)) PoolFactory.sol#1496-1501\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of Math.max (PoolFactory.sol#49) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of Math.max (PoolFactory.sol#49) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of Math.min (PoolFactory.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of Math.min (PoolFactory.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function average(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of Math.average (PoolFactory.sol#57) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function average(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of Math.average (PoolFactory.sol#57) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.mul (PoolFactory.sol#77) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.mul (PoolFactory.sol#77) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.div (PoolFactory.sol#94) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.div (PoolFactory.sol#94) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.sub (PoolFactory.sol#105) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.sub (PoolFactory.sol#105) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_a' of SafeMath.add (PoolFactory.sol#115) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n",
                    "message": "Parameter '_b' of SafeMath.add (PoolFactory.sol#115) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2249,
                    "vulnerability_to_line": 2253,
                    "vulnerability_code": "    function _transferOwnership(address newOwner) internal {\n\n        require(newOwner != address(0));\n\n        emit OwnershipTransferred(owner, newOwner);\n\n        owner = newOwner;\n",
                    "message": "Function 'Ownable._transferOwnership' (PoolFactory.sol#2249-2253) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 2350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        operators.length--;              \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 913,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < exclude.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < include.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function withdrawAllRemaining2(Pool storage pool) \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calcPoolSummary(Pool storage pool) \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1580,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calcPoolSummary2(Pool storage pool, address addr) \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < admins.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for(uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 877,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 913,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1028,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1079,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {                        \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < length; i++) {             \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < exclude.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < include.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < pool.participants.length; i++) {           \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint idx = 0; idx < length; idx++) {            \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < array.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract IFeeService {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 1815,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract ProPool is IERC223Receiver {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1808,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1064,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns(uint contribution, uint remaining)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1556,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1583,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tokenFallback(address from, uint value, bytes data) public;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] whitelist,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] admins\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 474,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 474,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 773,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tokenFallback(Pool storage pool, address from, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address[] participants,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 815,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address[] admins\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address[] tokenAddresses,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint[] tokenBalances\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint[] contribution,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint[] remaining,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 863,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bool[] whitelist,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 887,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getParticipantShares(Pool storage pool, address addr) public view returns (uint[] tokenShare, uint refundShare) {       \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function modifyWhitelistCore(Pool storage pool, uint idx, address[] include, address[] exclude) private {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function modifyWhitelistCore(Pool storage pool, uint idx, address[] include, address[] exclude) private {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressCall(address destination, uint etherAmount, bytes data) private {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1489,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] whitelist,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1839,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] admins\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1942,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tokenFallback(address from, uint value, bytes data) public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getOperators() public view returns(address[]) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1817,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ProPoolLib.Pool pool;    \n",
                    "message": null
                }
            ]
        }
    },
    "EasyPool-master/contracts/common/Affiliate.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Restricted is Ownable {  \n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < levels.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < rules.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint public curModelIndex = 0;   \n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        models[curModelIndex]\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            .push(ShareRule(uint256MaxValue(), 0));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 207,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if(operators[i] == operator) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= lastIndex; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < levels.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < rules.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(levels.length > 0 && levels.length == shares.length);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        operators.length--;              \n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i <= lastIndex; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        curModelIndex++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < levels.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        sData.transfersCount++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < rules.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint deleteIndex;\n",
                    "message": "deleteIndex in Restricted.removeOperator (Affiliate.sol#118) is a local variable never initialiazed\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": 58,
                    "vulnerability_code": "    function renounceOwnership() public onlyOwner {        \n\n        emit OwnershipRenounced(owner);\n\n        owner = address(0);\n",
                    "message": "Ownable.renounceOwnership (Affiliate.sol#55-58) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": 66,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        _transferOwnership(newOwner);\n",
                    "message": "Ownable.transferOwnership (Affiliate.sol#64-66) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": 143,
                    "vulnerability_code": "    function getOperators() public view returns(address[]) {\n\n        return operators;\n",
                    "message": "Restricted.getOperators (Affiliate.sol#141-143) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": 76,
                    "vulnerability_code": "    function _transferOwnership(address newOwner) internal {\n\n        require(newOwner != address(0));\n\n        emit OwnershipTransferred(owner, newOwner);\n\n        owner = newOwner;\n",
                    "message": "Function 'Ownable._transferOwnership' (Affiliate.sol#72-76) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        operators.length--;              \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < levels.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < rules.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < levels.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < rules.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract IAffiliate {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRevenueSharingRules(uint[] levels, uint[] shares) external onlyOwner {    \n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getOperators() public view returns(address[]) {\n",
                    "message": null
                }
            ]
        }
    }
}